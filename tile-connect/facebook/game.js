"use strict";
(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) ||
          desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {},
  __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) :
    target,
    mod
  ));
  var __decorateClass = (decorators, target, key, kind) => {
    var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = (kind ? decorator(target, key, result) : decorator(result)) || result;
    if (kind && result) __defProp(target, key, result);
    return result;
  };

  // phaser/phaser-custom.min.js
  var u, Qt, Ma, qt, lt, Xe, ne, C, Sp, Cp, Rp, Pp, qp, bp, Op, Np, Bp, Up, kp, un, cu, vu, H, pu, Fa,
  rs, Z, $p, em, im, sm, am, hm, lm, dm, vm, mm, xm, Tm, Sm, Cm, Rm, Pm, Ye, B, le, gu, La, xu, ss, Oa,
  km, cn, vi, ns, as, pi, Eu, mi, gi, Tu, xi, Ei, yu, Ti, Su, os, hs, wu, yi, Cu, Au, Ru, _u, Pu, Mu,
  qu, Fu, mg, zt, Eg, yg, wg, Ag, bu, Lu, Ou, qg, Du, Nu, Iu, Bu, Gu, Uu, zu, J, Tr, ki, ae, Da, us,
  ku, Xu, Vu, Na, vn, Qg, jg, i0, s0, a0, Ia, u0, f0, c0, Yu, pn, x0, T0, S0, Ba, Ga, P0, q0, b0, O0,
  N0, Xi, G0, mn, k0, Wu, Ua, Hu, Ku, Q0, $0, ex, ix, sx, Zu, ox, lx, za, Qu, yr, Jt, xx, Tx, Sx, Cx,
  Rx, Px, ds, xn, bx, Tt, Xa, Ix, Gx, kx, Vx, el, En, Tn, Qx, yn, jx, tE, Me, it, aE, uE, dE, pE, xE,
  Ha, SE, AE, PE, FE, OE, IE, UE, XE, WE, KE, il, Ar, Sn, Ka, rl, sl, cs, Za, Qa, Ja, Y, wn, $a, he,
  eo, cT, rt, mT, xT, TT, ST, CT, RT, PT, qT, bT, OT, NT, BT, UT, kT, VT, WT, KT, QT, $T, ey, iy, sy,
  qe, Ne, nl, al, fy, cy, Rr, ps, _r, Ty, An, Cy, _y, My, Fy, Pr, Ny, Gy, zy, io, Lt, ro, Ki, hl, ul,
  $y, tS, Ot, sS, aS, hS, lS, dS, fl, Rn, mS, xS, TS, SS, CS, RS, PS, qS, bS, OS, NS, BS, US, kS, VS,
  WS, KS, QS, xs, ei, Mn, n1, o1, u1, d1, v1, m1, x1, cl, y1, w1, A1, vl, P1, q1, b1, pl, D1, I1, G1,
  ml, k1, V1, W1, gl, Z1, J1, j1, xl, iw, sw, aw, El, uw, Tl, dw, vw, mw, yl, Ew, yw, ww, Sl, Rw, Pw,
  qw, wl, Lw, Dw, Iw, Cl, Uw, Al, On, lo, Zi, Rl, Qw, _l, eC, Pl, rC, nC, Ie, hC, ql, fC, cC, pC, Fl,
  xC, TC, fo, Nn, CC, RC, PC, FC, LC, DC, IC, GC, zC, VC, WC, ZC, JC, jC, iA, sA, aA, hA, lA, dA, pA,
  gA, EA, yA, co, AA, vo, MA, FA, LA, NA, bl, GA, zA, Ll, Ol, Dl, HA, ZA, JA, jA, tR, rR, nR, oR, uR,
  fR, cR, pR, gR, ER, yR, wR, AR, _R, MR, Dt, po, LR, NR, BR, Ai, XR, Il, WR, KR, QR, Bl, go, In, s_,
  o_, l_, c_, m_, E_, Yl, Eo, Bn, __, M_, F_, L_, D_, I_, Ss, X_, Y_, Hl, Kl, Q_, $_, eP, iP, Zl, ws,
  aP, hP, lP, dP, vP, mP, xP, TP, SP, CP, RP, PP, qP, bP, OP, NP, BP, UP, Jl, jl, ef, To, tf, rf, nf,
  af, of, JP, jP, tM, Cs, sM, aM, hf, Un, uf, fM, cM, pM, gM, EM, As, _s, CM, RM, PM, qM, bM, OM, NM,
  BM, UM, kM, df, YM, HM, ZM, JM, jM, tq, rq, nq, oq, uq, cf, pf, Eq, Ao, kn, gf, Pq, Ef, Fq, Lq, Dq,
  Iq, Gq, zq, qs, Vq, Wq, Kq, Qq, $q, eF, iF, sF, Fs, uF, qr, yf, Sf, bs, pF, gF, EF, yF, wF, AF, _F,
  wf, wt, Cf, Vt, Rf, _f, bo, Lo, Ke, VF, Pf, KF, Mf, qf, Ff, eb, bf, sb, Lf, hb, fb, Of, pb, Df, Tb,
  Nf, Cb, If, Pb, Bf, bb, Gf, Nb, Uf, Ub, zf, Vb, No, Io, $b, Wf, Hf, er, Kn, Zn, $f, jf, ed, td, id,
  dL, vL, mL, xL, rd, sd, SL, ad, od, ud, fd, dd, cd, pd, gd, Ed, Td, yd, Yo, Cd, Ad, Rd, Pd, qd, Fd,
  e2, bd, Ld, s2, Jo, Ir, Dd, Bd, Ud, zd, Xd, Yd, b2, O2, I2, G2, z2, X2, Y2, H2, J2, j2, jo, iO, sO,
  eh, oO, uO, fO, cO, pO, gO, EO, yO, wO, AO, _O, MO, FO, LO, DO, IO, GO, zO, XO, YO, HO, ZO, JO, jO,
  tD, rD, nD, oD, uD, fD, cD, pD, gD, ED, yD, wD, AD, _D, MD, FD, LD, DD, ID, GD, zD, XD, Mi, Jn, Qd,
  Jd, jd, ec, tc, Fi, gt, dN, ic, rc, sc, nc, ah, EN, yN, wN, ac, oc, jn, LN, DN, IN, GN, zN, XN, YN,
  HN, ZN, JN, zr, hc, uc, kr, lc, aI, fc, lh, dc, vc, pc, ea, xc, Tc, wI, AI, _I, FI, ta, DI, II, GI,
  zI, XI, YI, JI, jI, tB, nB, yc, wc, cB, pB, gB, EB, yB, wB, AB, _B, MB, FB, LB, DB, IB, GB, zB, XB,
  YB, HB, ZB, JB, jB, tG, rG, nG, hr, sa, na, Ac, Pc, Mc, qc, Fc, bc, Oc, Dc, RG, PG, qG, bG, OG, NG,
  BG, UG, kG, VG, WG, Yr, ZG, JG, jG, tU, rU, nU, oU, uU, fU, cU, Nc, mU, xU, TU, SU, CU, gh, _U, MU,
  FU, LU, DU, IU, GU, zU, XU, YU, HU, Ic, Bc, JU, jU, xh, rz, az, hz, lz, dz, vz, mz, Gc, Eh, Tz, Sz,
  Uc, Az, _z, Mz, Fz, Lz, Dz, Iz, Gz, zc, kz, Th, Zz, Jz, jz, t3, kc, h3, ot, dr, ua, Sh, v3, x3, la,
  wh, Ch, Vc, Yc, P3, q3, b3, Wc, Ah, U3, k3, V3, Z3, _h, fa, Ph, Qc, o5, u5, f5, c5, p5, Jc, Mh, $c,
  tv, iv, rv, sv, nv, va, av, M5, L5, Lh, X5, Y5, H5, Z5, J5, tk, rk, ak, hv, Dh, ck, gk, Nh, wk, _k,
  qk, Ih, Lk, Ok, Dk, Nk, Ik, Bk, Gk, Uk, zk, kk, Xk, Yk, Hk, Zk, Qk, Jk, jk, eX, iX, lv, fv, dv, oX,
  uX, fX, cX, pX, gX, Gh, cv, vv, xa, qX, bX, OX, NX, BX, UX, pv, XX, YX, HX, jX, tV, rV, nV, oV, uV,
  fV, cV, Ea, yv, Sv, wv, Cv, Rv, AV, FV, LV, DV, IV, GV, zV, XV, YV, HV, Kr, Ta, ya, Yh, qv, rn, rY,
  oY, Hh, Dv, Iv, xY, SY, RY, PY, qY, bY, OY, DY, IY, UY, kY, VY, WY, ZY, Wv, e4, i4, Kv, o4, u4, Jh,
  d4, Zv, $h, jh, T4, S4, C4, R4, P4, q4, b4, O4, N4, B4, xr, jr, Qv, Jv, $v, jv, Aa, rp, sp, nu, oW,
  au, cW, mW, xW, TW, SW, CW, RW, PW, qW, bW, OW, NW, BW, UW, kW, VW, Z0e, phaser_custom_min_default;
  var init_phaser_custom_min = __esm({
    "phaser/phaser-custom.min.js"() {
      "use strict";
      u = (e, t) => () => (t || e((t = { exports: {} }).exports, t), t.exports);
      Qt = u((J0e, fp) => {
        fp.exports = { SKIP_CHECK: -1, NORMAL: 0, ADD: 1, MULTIPLY: 2, SCREEN: 3, OVERLAY: 4, DARKEN: 5,
        LIGHTEN: 6, COLOR_DODGE: 7, COLOR_BURN: 8, HARD_LIGHT: 9, SOFT_LIGHT: 10, DIFFERENCE: 11, EXCLUSION: 12,
        HUE: 13, SATURATION: 14, COLOR: 15, LUMINOSITY: 16, ERASE: 17, SOURCE_IN: 18, SOURCE_OUT: 19,
        SOURCE_ATOP: 20, DESTINATION_OVER: 21, DESTINATION_IN: 22, DESTINATION_OUT: 23, DESTINATION_ATOP: 24,
        LIGHTER: 25, COPY: 26, XOR: 27 };
      });
      Ma = u(($0e, dp) => {
        var WW = { DEFAULT: 0, LINEAR: 0, NEAREST: 1 };
        dp.exports = WW;
      });
      qt = u((j0e, cp) => {
        var HW = { VERSION: "3.88.2", LOG_VERSION: "v388", BlendModes: Qt(), ScaleModes: Ma(), AUTO: 0,
        CANVAS: 1, WEBGL: 2, HEADLESS: 3, FOREVER: -1, NONE: 4, UP: 5, DOWN: 6, LEFT: 7, RIGHT: 8 };
        cp.exports = HW;
      });
      lt = u((exe, vp) => {
        var KW = function(e) {
          if (!e || typeof e != "object" || e.nodeType || e === e.window) return false;
          try {
            if (e.constructor && !{}.hasOwnProperty.call(e.constructor.prototype, "isPrototypeOf")) return false;
          } catch (t) {
            return false;
          }
          return true;
        };
        vp.exports = KW;
      });
      Xe = u((txe, gp) => {
        var pp = lt(), mp = function() {
          var e, t, i, r, s, n, a = arguments[0] || {}, o = 1, h = arguments.length, l = false;
          for (typeof a == "boolean" && (l = a, a = arguments[1] || {}, o = 2), h === o && (a = this,
          --o); o < h; o++) if ((e = arguments[o]) != null) for (t in e) i = a[t], r = e[t], a !== r &&
          (l && r && (pp(r) || (s = Array.isArray(r))) ? (s ? (s = false, n = i && Array.isArray(i) ?
          i : []) : n = i && pp(i) ? i : {}, a[t] = mp(l, n, r)) : r !== void 0 && (a[t] = r));
          return a;
        };
        gp.exports = mp;
      });
      ne = u((ixe, xp) => {
        var ZW = function(e, t, i) {
          return Math.max(t, Math.min(i, e));
        };
        xp.exports = ZW;
      });
      C = u((rxe, Tp) => {
        function QW(e) {
          return !!e.get && typeof e.get == "function" || !!e.set && typeof e.set == "function";
        }
        function JW(e, t, i) {
          var r = i ? e[t] : Object.getOwnPropertyDescriptor(e, t);
          return !i && r.value && typeof r.value == "object" && (r = r.value), r && QW(r) ? (typeof r.
          enumerable == "undefined" && (r.enumerable = true), typeof r.configurable == "undefined" &&
          (r.configurable = true), r) : false;
        }
        function $W(e, t) {
          var i = Object.getOwnPropertyDescriptor(e, t);
          return i ? (i.value && typeof i.value == "object" && (i = i.value), i.configurable === false) :
          false;
        }
        function du(e, t, i, r) {
          for (var s in t) if (t.hasOwnProperty(s)) {
            var n = JW(t, s, i);
            if (n !== false) {
              var a = r || e;
              if ($W(a.prototype, s)) {
                if (hn.ignoreFinals) continue;
                throw new Error("cannot override final property '" + s + "', set Class.ignoreFinals \
= true to skip");
              }
              Object.defineProperty(e.prototype, s, n);
            } else e.prototype[s] = t[s];
          }
        }
        function Ep(e, t) {
          if (t) {
            Array.isArray(t) || (t = [t]);
            for (var i = 0; i < t.length; i++) du(e, t[i].prototype || t[i]);
          }
        }
        function hn(e) {
          e || (e = {});
          var t, i;
          if (e.initialize) {
            if (typeof e.initialize != "function") throw new Error("initialize must be a function");
            t = e.initialize, delete e.initialize;
          } else if (e.Extends) {
            var r = e.Extends;
            t = function() {
              r.apply(this, arguments);
            };
          } else t = function() {
          };
          e.Extends ? (t.prototype = Object.create(e.Extends.prototype), t.prototype.constructor = t,
          i = e.Extends, delete e.Extends) : t.prototype.constructor = t;
          var s = null;
          return e.Mixins && (s = e.Mixins, delete e.Mixins), Ep(t, s), du(t, e, true, i), t;
        }
        hn.extend = du;
        hn.mixin = Ep;
        hn.ignoreFinals = false;
        Tp.exports = hn;
      });
      Sp = u((sxe, yp) => {
        yp.exports = "add";
      });
      Cp = u((nxe, wp) => {
        wp.exports = "animationcomplete";
      });
      Rp = u((axe, Ap) => {
        Ap.exports = "animationcomplete-";
      });
      Pp = u((oxe, _p) => {
        _p.exports = "animationrepeat";
      });
      qp = u((hxe, Mp) => {
        Mp.exports = "animationrestart";
      });
      bp = u((uxe, Fp) => {
        Fp.exports = "animationstart";
      });
      Op = u((lxe, Lp) => {
        Lp.exports = "animationstop";
      });
      Np = u((fxe, Dp) => {
        Dp.exports = "animationupdate";
      });
      Bp = u((dxe, Ip) => {
        Ip.exports = "pauseall";
      });
      Up = u((cxe, Gp) => {
        Gp.exports = "remove";
      });
      kp = u((vxe, zp) => {
        zp.exports = "resumeall";
      });
      un = u((pxe, Xp) => {
        Xp.exports = { ADD_ANIMATION: Sp(), ANIMATION_COMPLETE: Cp(), ANIMATION_COMPLETE_KEY: Rp(), ANIMATION_REPEAT: Pp(),
        ANIMATION_RESTART: qp(), ANIMATION_START: bp(), ANIMATION_STOP: Op(), ANIMATION_UPDATE: Np(),
        PAUSE_ALL: Bp(), REMOVE_ANIMATION: Up(), RESUME_ALL: kp() };
      });
      cu = u((mxe, Vp) => {
        var jW = function(e, t, i) {
          if (t.length) {
            if (t.length === 1) return t[0];
          } else return NaN;
          var r = 1, s, n;
          if (i) {
            if (e < t[0][i]) return t[0];
            for (; t[r][i] < e; ) r++;
          } else for (; t[r] < e; ) r++;
          return r > t.length && (r = t.length), i ? (s = t[r - 1][i], n = t[r][i], n - e <= e - s ?
          t[r] : t[r - 1]) : (s = t[r - 1], n = t[r], n - e <= e - s ? n : s);
        };
        Vp.exports = jW;
      });
      vu = u((gxe, Yp) => {
        var eH = C(), tH = new eH({ initialize: function(t, i, r, s, n) {
          n === void 0 && (n = false), this.textureKey = t, this.textureFrame = i, this.index = r, this.
          frame = s, this.isFirst = false, this.isLast = false, this.prevFrame = null, this.nextFrame =
          null, this.duration = 0, this.progress = 0, this.isKeyFrame = n;
        }, toJSON: function() {
          return { key: this.textureKey, frame: this.textureFrame, duration: this.duration, keyframe: this.
          isKeyFrame };
        }, destroy: function() {
          this.frame = void 0;
        } });
        Yp.exports = tH;
      });
      H = u((xxe, Wp) => {
        var iH = function(e, t, i, r) {
          if (!e && !r || typeof e == "number") return i;
          if (e && e.hasOwnProperty(t)) return e[t];
          if (r && r.hasOwnProperty(t)) return r[t];
          if (t.indexOf(".") !== -1) {
            for (var s = t.split("."), n = e, a = r, o = i, h = i, l = true, f = true, d = 0; d < s.
            length; d++) n && n.hasOwnProperty(s[d]) ? (o = n[s[d]], n = n[s[d]]) : l = false, a && a.
            hasOwnProperty(s[d]) ? (h = a[s[d]], a = a[s[d]]) : f = false;
            return l ? o : f ? h : i;
          } else return i;
        };
        Wp.exports = iH;
      });
      pu = u((Exe, Hp) => {
        var rH = function(e) {
          var t = /\D/g;
          return e.sort(function(i, r) {
            return parseInt(i.replace(t, ""), 10) - parseInt(r.replace(t, ""), 10);
          }), e;
        };
        Hp.exports = rH;
      });
      Fa = u((Txe, Kp) => {
        var sH = ne(), nH = C(), qa = un(), aH = cu(), oH = vu(), Oe = H(), hH = pu(), uH = new nH({
        initialize: function(t, i, r) {
          this.manager = t, this.key = i, this.type = "frame", this.frames = this.getFrames(t.textureManager,
          Oe(r, "frames", []), Oe(r, "defaultTextureKey", null), Oe(r, "sortFrames", true)), this.frameRate =
          Oe(r, "frameRate", null), this.duration = Oe(r, "duration", null), this.msPerFrame, this.skipMissedFrames =
          Oe(r, "skipMissedFrames", true), this.delay = Oe(r, "delay", 0), this.repeat = Oe(r, "repe\
at", 0), this.repeatDelay = Oe(r, "repeatDelay", 0), this.yoyo = Oe(r, "yoyo", false), this.showBeforeDelay =
          Oe(r, "showBeforeDelay", false), this.showOnStart = Oe(r, "showOnStart", false), this.hideOnComplete =
          Oe(r, "hideOnComplete", false), this.randomFrame = Oe(r, "randomFrame", false), this.paused =
          false, this.calculateDuration(this, this.getTotalFrames(), this.duration, this.frameRate),
          this.manager.on && (this.manager.on(qa.PAUSE_ALL, this.pause, this), this.manager.on(qa.RESUME_ALL,
          this.resume, this));
        }, getTotalFrames: function() {
          return this.frames.length;
        }, calculateDuration: function(e, t, i, r) {
          i === null && r === null ? (e.frameRate = 24, e.duration = 24 / t * 1e3) : i && r === null ?
          (e.duration = i, e.frameRate = t / (i / 1e3)) : (e.frameRate = r, e.duration = t / r * 1e3),
          e.msPerFrame = 1e3 / e.frameRate;
        }, addFrame: function(e) {
          return this.addFrameAt(this.frames.length, e);
        }, addFrameAt: function(e, t) {
          var i = this.getFrames(this.manager.textureManager, t);
          if (i.length > 0) {
            if (e === 0) this.frames = i.concat(this.frames);
            else if (e === this.frames.length) this.frames = this.frames.concat(i);
            else {
              var r = this.frames.slice(0, e), s = this.frames.slice(e);
              this.frames = r.concat(i, s);
            }
            this.updateFrameSequence();
          }
          return this;
        }, checkFrame: function(e) {
          return e >= 0 && e < this.frames.length;
        }, getFirstTick: function(e) {
          e.accumulator = 0, e.nextTick = e.msPerFrame || e.currentFrame.duration;
        }, getFrameAt: function(e) {
          return this.frames[e];
        }, getFrames: function(e, t, i, r) {
          r === void 0 && (r = true);
          var s = [], n, a, o = 1, h, l;
          if (typeof t == "string") {
            if (l = t, !e.exists(l)) return console.warn('Texture "%s" not found', l), s;
            var f = e.get(l), d = f.getFrameNames();
            r && hH(d), t = [], d.forEach(function(x) {
              t.push({ key: l, frame: x });
            });
          }
          if (!Array.isArray(t) || t.length === 0) return s;
          for (h = 0; h < t.length; h++) {
            var c = t[h], p = Oe(c, "key", i);
            if (p) {
              var v = Oe(c, "frame", 0), m = e.getFrame(p, v);
              if (!m) {
                console.warn('Texture "%s" not found', p);
                continue;
              }
              a = new oH(p, v, o, m), a.duration = Oe(c, "duration", 0), a.isFirst = !n, n && (n.nextFrame =
              a, a.prevFrame = n), s.push(a), n = a, o++;
            }
          }
          if (s.length > 0) {
            a.isLast = true, a.nextFrame = s[0], s[0].prevFrame = a;
            var g = 1 / (s.length - 1);
            for (h = 0; h < s.length; h++) s[h].progress = h * g;
          }
          return s;
        }, getNextTick: function(e) {
          e.accumulator -= e.nextTick, e.nextTick = e.msPerFrame || e.currentFrame.duration;
        }, getFrameByProgress: function(e) {
          return e = sH(e, 0, 1), aH(e, this.frames, "progress");
        }, nextFrame: function(e) {
          var t = e.currentFrame;
          t.isLast ? e.yoyo ? this.handleYoyoFrame(e, false) : e.repeatCounter > 0 ? e.inReverse && e.
          forward ? e.forward = false : this.repeatAnimation(e) : e.complete() : this.updateAndGetNextTick(
          e, t.nextFrame);
        }, handleYoyoFrame: function(e, t) {
          if (t || (t = false), e.inReverse === !t && e.repeatCounter > 0) {
            (e.repeatDelay === 0 || e.pendingRepeat) && (e.forward = t), this.repeatAnimation(e);
            return;
          }
          if (e.inReverse !== t && e.repeatCounter === 0) {
            e.complete();
            return;
          }
          e.forward = t;
          var i = t ? e.currentFrame.nextFrame : e.currentFrame.prevFrame;
          this.updateAndGetNextTick(e, i);
        }, getLastFrame: function() {
          return this.frames[this.frames.length - 1];
        }, previousFrame: function(e) {
          var t = e.currentFrame;
          t.isFirst ? e.yoyo ? this.handleYoyoFrame(e, true) : e.repeatCounter > 0 ? e.inReverse && !e.
          forward ? this.repeatAnimation(e) : (e.forward = true, this.repeatAnimation(e)) : e.complete() :
          this.updateAndGetNextTick(e, t.prevFrame);
        }, updateAndGetNextTick: function(e, t) {
          e.setCurrentFrame(t), this.getNextTick(e);
        }, removeFrame: function(e) {
          var t = this.frames.indexOf(e);
          return t !== -1 && this.removeFrameAt(t), this;
        }, removeFrameAt: function(e) {
          return this.frames.splice(e, 1), this.updateFrameSequence(), this;
        }, repeatAnimation: function(e) {
          if (e._pendingStop === 2) {
            if (e._pendingStopValue === 0) return e.stop();
            e._pendingStopValue--;
          }
          e.repeatDelay > 0 && !e.pendingRepeat ? (e.pendingRepeat = true, e.accumulator -= e.nextTick,
          e.nextTick += e.repeatDelay) : (e.repeatCounter--, e.forward ? e.setCurrentFrame(e.currentFrame.
          nextFrame) : e.setCurrentFrame(e.currentFrame.prevFrame), e.isPlaying && (this.getNextTick(
          e), e.handleRepeat()));
        }, toJSON: function() {
          var e = { key: this.key, type: this.type, frames: [], frameRate: this.frameRate, duration: this.
          duration, skipMissedFrames: this.skipMissedFrames, delay: this.delay, repeat: this.repeat,
          repeatDelay: this.repeatDelay, yoyo: this.yoyo, showBeforeDelay: this.showBeforeDelay, showOnStart: this.
          showOnStart, randomFrame: this.randomFrame, hideOnComplete: this.hideOnComplete };
          return this.frames.forEach(function(t) {
            e.frames.push(t.toJSON());
          }), e;
        }, updateFrameSequence: function() {
          for (var e = this.frames.length, t = 1 / (e - 1), i, r = 0; r < e; r++) i = this.frames[r],
          i.index = r + 1, i.isFirst = false, i.isLast = false, i.progress = r * t, r === 0 ? (i.isFirst =
          true, e === 1 ? (i.isLast = true, i.nextFrame = i, i.prevFrame = i) : (i.isLast = false, i.
          prevFrame = this.frames[e - 1], i.nextFrame = this.frames[r + 1])) : r === e - 1 && e > 1 ?
          (i.isLast = true, i.prevFrame = this.frames[e - 2], i.nextFrame = this.frames[0]) : e > 1 &&
          (i.prevFrame = this.frames[r - 1], i.nextFrame = this.frames[r + 1]);
          return this;
        }, pause: function() {
          return this.paused = true, this;
        }, resume: function() {
          return this.paused = false, this;
        }, destroy: function() {
          this.manager.off && (this.manager.off(qa.PAUSE_ALL, this.pause, this), this.manager.off(qa.
          RESUME_ALL, this.resume, this)), this.manager.remove(this.key);
          for (var e = 0; e < this.frames.length; e++) this.frames[e].destroy();
          this.frames = [], this.manager = null;
        } });
        Kp.exports = uH;
      });
      rs = u((yxe, Zp) => {
        var lH = C(), fH = new lH({ initialize: function(t) {
          this.entries = {}, this.size = 0, this.setAll(t);
        }, setAll: function(e) {
          if (Array.isArray(e)) for (var t = 0; t < e.length; t++) this.set(e[t][0], e[t][1]);
          return this;
        }, set: function(e, t) {
          return this.has(e) || this.size++, this.entries[e] = t, this;
        }, get: function(e) {
          if (this.has(e)) return this.entries[e];
        }, getArray: function() {
          var e = [], t = this.entries;
          for (var i in t) e.push(t[i]);
          return e;
        }, has: function(e) {
          return this.entries.hasOwnProperty(e);
        }, delete: function(e) {
          return this.has(e) && (delete this.entries[e], this.size--), this;
        }, clear: function() {
          return Object.keys(this.entries).forEach(function(e) {
            delete this.entries[e];
          }, this), this.size = 0, this;
        }, keys: function() {
          return Object.keys(this.entries);
        }, values: function() {
          var e = [], t = this.entries;
          for (var i in t) e.push(t[i]);
          return e;
        }, dump: function() {
          var e = this.entries;
          console.group("Map");
          for (var t in e) console.log(t, e[t]);
          console.groupEnd();
        }, each: function(e) {
          var t = this.entries;
          for (var i in t) if (e(i, t[i]) === false) break;
          return this;
        }, contains: function(e) {
          var t = this.entries;
          for (var i in t) if (t[i] === e) return true;
          return false;
        }, merge: function(e, t) {
          t === void 0 && (t = false);
          var i = this.entries, r = e.entries;
          for (var s in r) i.hasOwnProperty(s) && t ? i[s] = r[s] : this.set(s, r[s]);
          return this;
        } });
        Zp.exports = fH;
      });
      Z = u((Sxe, mu) => {
        "use strict";
        var dH = Object.prototype.hasOwnProperty, et = "~";
        function ln() {
        }
        Object.create && (ln.prototype = /* @__PURE__ */ Object.create(null), new ln().__proto__ || (et =
        false));
        function cH(e, t, i) {
          this.fn = e, this.context = t, this.once = i || false;
        }
        function Qp(e, t, i, r, s) {
          if (typeof i != "function") throw new TypeError("The listener must be a function");
          var n = new cH(i, r || e, s), a = et ? et + t : t;
          return e._events[a] ? e._events[a].fn ? e._events[a] = [e._events[a], n] : e._events[a].push(
          n) : (e._events[a] = n, e._eventsCount++), e;
        }
        function ba(e, t) {
          --e._eventsCount === 0 ? e._events = new ln() : delete e._events[t];
        }
        function Ve() {
          this._events = new ln(), this._eventsCount = 0;
        }
        Ve.prototype.eventNames = function() {
          var t = [], i, r;
          if (this._eventsCount === 0) return t;
          for (r in i = this._events) dH.call(i, r) && t.push(et ? r.slice(1) : r);
          return Object.getOwnPropertySymbols ? t.concat(Object.getOwnPropertySymbols(i)) : t;
        };
        Ve.prototype.listeners = function(t) {
          var i = et ? et + t : t, r = this._events[i];
          if (!r) return [];
          if (r.fn) return [r.fn];
          for (var s = 0, n = r.length, a = new Array(n); s < n; s++) a[s] = r[s].fn;
          return a;
        };
        Ve.prototype.listenerCount = function(t) {
          var i = et ? et + t : t, r = this._events[i];
          return r ? r.fn ? 1 : r.length : 0;
        };
        Ve.prototype.emit = function(t, i, r, s, n, a) {
          var o = et ? et + t : t;
          if (!this._events[o]) return false;
          var h = this._events[o], l = arguments.length, f, d;
          if (h.fn) {
            switch (h.once && this.removeListener(t, h.fn, void 0, true), l) {
              case 1:
                return h.fn.call(h.context), true;
              case 2:
                return h.fn.call(h.context, i), true;
              case 3:
                return h.fn.call(h.context, i, r), true;
              case 4:
                return h.fn.call(h.context, i, r, s), true;
              case 5:
                return h.fn.call(h.context, i, r, s, n), true;
              case 6:
                return h.fn.call(h.context, i, r, s, n, a), true;
            }
            for (d = 1, f = new Array(l - 1); d < l; d++) f[d - 1] = arguments[d];
            h.fn.apply(h.context, f);
          } else {
            var c = h.length, p;
            for (d = 0; d < c; d++) switch (h[d].once && this.removeListener(t, h[d].fn, void 0, true),
            l) {
              case 1:
                h[d].fn.call(h[d].context);
                break;
              case 2:
                h[d].fn.call(h[d].context, i);
                break;
              case 3:
                h[d].fn.call(h[d].context, i, r);
                break;
              case 4:
                h[d].fn.call(h[d].context, i, r, s);
                break;
              default:
                if (!f) for (p = 1, f = new Array(l - 1); p < l; p++) f[p - 1] = arguments[p];
                h[d].fn.apply(h[d].context, f);
            }
          }
          return true;
        };
        Ve.prototype.on = function(t, i, r) {
          return Qp(this, t, i, r, false);
        };
        Ve.prototype.once = function(t, i, r) {
          return Qp(this, t, i, r, true);
        };
        Ve.prototype.removeListener = function(t, i, r, s) {
          var n = et ? et + t : t;
          if (!this._events[n]) return this;
          if (!i) return ba(this, n), this;
          var a = this._events[n];
          if (a.fn) a.fn === i && (!s || a.once) && (!r || a.context === r) && ba(this, n);
          else {
            for (var o = 0, h = [], l = a.length; o < l; o++) (a[o].fn !== i || s && !a[o].once || r &&
            a[o].context !== r) && h.push(a[o]);
            h.length ? this._events[n] = h.length === 1 ? h[0] : h : ba(this, n);
          }
          return this;
        };
        Ve.prototype.removeAllListeners = function(t) {
          var i;
          return t ? (i = et ? et + t : t, this._events[i] && ba(this, i)) : (this._events = new ln(),
          this._eventsCount = 0), this;
        };
        Ve.prototype.off = Ve.prototype.removeListener;
        Ve.prototype.addListener = Ve.prototype.on;
        Ve.prefixed = et;
        Ve.EventEmitter = Ve;
        typeof mu != "undefined" && (mu.exports = Ve);
      });
      $p = u((wxe, Jp) => {
        Jp.exports = "blur";
      });
      em = u((Cxe, jp) => {
        jp.exports = "boot";
      });
      im = u((Axe, tm) => {
        tm.exports = "contextlost";
      });
      sm = u((Rxe, rm) => {
        rm.exports = "destroy";
      });
      am = u((_xe, nm) => {
        nm.exports = "focus";
      });
      hm = u((Pxe, om) => {
        om.exports = "hidden";
      });
      lm = u((Mxe, um) => {
        um.exports = "pause";
      });
      dm = u((qxe, fm) => {
        fm.exports = "postrender";
      });
      vm = u((Fxe, cm) => {
        cm.exports = "poststep";
      });
      mm = u((bxe, pm) => {
        pm.exports = "prerender";
      });
      xm = u((Lxe, gm) => {
        gm.exports = "prestep";
      });
      Tm = u((Oxe, Em) => {
        Em.exports = "ready";
      });
      Sm = u((Dxe, ym) => {
        ym.exports = "resume";
      });
      Cm = u((Nxe, wm) => {
        wm.exports = "step";
      });
      Rm = u((Ixe, Am) => {
        Am.exports = "systemready";
      });
      Pm = u((Bxe, _m) => {
        _m.exports = "visible";
      });
      Ye = u((Gxe, Mm) => {
        Mm.exports = { BLUR: $p(), BOOT: em(), CONTEXT_LOST: im(), DESTROY: sm(), FOCUS: am(), HIDDEN: hm(),
        PAUSE: lm(), POST_RENDER: dm(), POST_STEP: vm(), PRE_RENDER: mm(), PRE_STEP: xm(), READY: Tm(),
        RESUME: Sm(), STEP: Cm(), SYSTEM_READY: Rm(), VISIBLE: Pm() };
      });
      B = u((Uxe, qm) => {
        var vH = function(e, t, i) {
          var r = typeof e;
          return !e || r === "number" || r === "string" ? i : e.hasOwnProperty(t) && e[t] !== void 0 ?
          e[t] : i;
        };
        qm.exports = vH;
      });
      le = u((zxe, Fm) => {
        var pH = { PI2: Math.PI * 2, TAU: Math.PI * 0.5, EPSILON: 1e-6, DEG_TO_RAD: Math.PI / 180, RAD_TO_DEG: 180 /
        Math.PI, RND: null, MIN_SAFE_INTEGER: Number.MIN_SAFE_INTEGER || -9007199254740991, MAX_SAFE_INTEGER: Number.
        MAX_SAFE_INTEGER || 9007199254740991 };
        Fm.exports = pH;
      });
      gu = u((kxe, bm) => {
        var mH = function(e, t, i, r) {
          var s = [], n, a = false;
          if ((i || r) && (a = true, i || (i = ""), r || (r = "")), t < e) for (n = e; n >= t; n--) a ?
          s.push(i + n.toString() + r) : s.push(n);
          else for (n = e; n <= t; n++) a ? s.push(i + n.toString() + r) : s.push(n);
          return s;
        };
        bm.exports = mH;
      });
      La = u((Xxe, Lm) => {
        var gH = function(e, t, i, r) {
          t === void 0 && (t = 0), i === void 0 && (i = " "), r === void 0 && (r = 3), e = e.toString();
          var s = 0;
          if (t + 1 >= e.length) switch (r) {
            case 1:
              e = new Array(t + 1 - e.length).join(i) + e;
              break;
            case 3:
              var n = Math.ceil((s = t - e.length) / 2), a = s - n;
              e = new Array(a + 1).join(i) + e + new Array(n + 1).join(i);
              break;
            default:
              e = e + new Array(t + 1 - e.length).join(i);
              break;
          }
          return e;
        };
        Lm.exports = gH;
      });
      xu = u((Vxe, Bm) => {
        var xH = Fa(), EH = C(), Om = rs(), Dm = Z(), fn = un(), Nm = Ye(), dn = B(), tt = H(), TH = le(),
        Im = gu(), yH = La(), SH = new EH({ Extends: Dm, initialize: function(t) {
          Dm.call(this), this.game = t, this.textureManager = null, this.globalTimeScale = 1, this.anims =
          new Om(), this.mixes = new Om(), this.paused = false, this.name = "AnimationManager", t.events.
          once(Nm.BOOT, this.boot, this);
        }, boot: function() {
          this.textureManager = this.game.textures, this.game.events.once(Nm.DESTROY, this.destroy, this);
        }, addMix: function(e, t, i) {
          var r = this.anims, s = this.mixes, n = typeof e == "string" ? e : e.key, a = typeof t == "\
string" ? t : t.key;
          if (r.has(n) && r.has(a)) {
            var o = s.get(n);
            o || (o = {}), o[a] = i, s.set(n, o);
          }
          return this;
        }, removeMix: function(e, t) {
          var i = this.mixes, r = typeof e == "string" ? e : e.key, s = i.get(r);
          if (s) if (t) {
            var n = typeof t == "string" ? t : t.key;
            s.hasOwnProperty(n) && delete s[n];
          } else t || i.delete(r);
          return this;
        }, getMix: function(e, t) {
          var i = this.mixes, r = typeof e == "string" ? e : e.key, s = typeof t == "string" ? t : t.
          key, n = i.get(r);
          return n && n.hasOwnProperty(s) ? n[s] : 0;
        }, add: function(e, t) {
          return this.anims.has(e) ? (console.warn("Animation key exists: " + e), this) : (t.key = e,
          this.anims.set(e, t), this.emit(fn.ADD_ANIMATION, e, t), this);
        }, exists: function(e) {
          return this.anims.has(e);
        }, createFromAseprite: function(e, t, i) {
          var r = [], s = this.game.cache.json.get(e);
          if (!s) return console.warn("No Aseprite data found for: " + e), r;
          var n = this, a = tt(s, "meta", null), o = tt(s, "frames", null);
          if (a && o) {
            var h = tt(a, "frameTags", []);
            h.forEach(function(l) {
              var f = [], d = dn(l, "name", null), c = dn(l, "from", 0), p = dn(l, "to", 0), v = dn(
              l, "direction", "forward");
              if (d && (!t || t && t.indexOf(d) > -1)) {
                for (var m = 0, g = c; g <= p; g++) {
                  var x = g.toString(), E = o[x];
                  if (E) {
                    var T15 = dn(E, "duration", TH.MAX_SAFE_INTEGER);
                    f.push({ key: e, frame: x, duration: T15 }), m += T15;
                  }
                }
                v === "reverse" && (f = f.reverse());
                var w = { key: d, frames: f, duration: m, yoyo: v === "pingpong" }, y;
                i ? i.anims && (y = i.anims.create(w)) : y = n.create(w), y && r.push(y);
              }
            });
          }
          return r;
        }, create: function(e) {
          var t = e.key, i = false;
          return t && (i = this.get(t), i ? console.warn("AnimationManager key already exists: " + t) :
          (i = new xH(this, t, e), this.anims.set(t, i), this.emit(fn.ADD_ANIMATION, t, i))), i;
        }, fromJSON: function(e, t) {
          t === void 0 && (t = false), t && this.anims.clear(), typeof e == "string" && (e = JSON.parse(
          e));
          var i = [];
          if (e.hasOwnProperty("anims") && Array.isArray(e.anims)) {
            for (var r = 0; r < e.anims.length; r++) i.push(this.create(e.anims[r]));
            e.hasOwnProperty("globalTimeScale") && (this.globalTimeScale = e.globalTimeScale);
          } else e.hasOwnProperty("key") && e.type === "frame" && i.push(this.create(e));
          return i;
        }, generateFrameNames: function(e, t) {
          var i = tt(t, "prefix", ""), r = tt(t, "start", 0), s = tt(t, "end", 0), n = tt(t, "suffix",
          ""), a = tt(t, "zeroPad", 0), o = tt(t, "outputArray", []), h = tt(t, "frames", false);
          if (!this.textureManager.exists(e)) return console.warn('Texture "%s" not found', e), o;
          var l = this.textureManager.get(e);
          if (!l) return o;
          var f;
          if (t) for (h || (h = Im(r, s)), f = 0; f < h.length; f++) {
            var d = i + yH(h[f], a, "0", 1) + n;
            l.has(d) ? o.push({ key: e, frame: d }) : console.warn('Frame "%s" not found in texture \
"%s"', d, e);
          }
          else for (h = l.getFrameNames(), f = 0; f < h.length; f++) o.push({ key: e, frame: h[f] });
          return o;
        }, generateFrameNumbers: function(e, t) {
          var i = tt(t, "start", 0), r = tt(t, "end", -1), s = tt(t, "first", false), n = tt(t, "out\
putArray", []), a = tt(t, "frames", false);
          if (!this.textureManager.exists(e)) return console.warn('Texture "%s" not found', e), n;
          var o = this.textureManager.get(e);
          if (!o) return n;
          s && o.has(s) && n.push({ key: e, frame: s }), a || (r === -1 && (r = o.frameTotal - 2), a =
          Im(i, r));
          for (var h = 0; h < a.length; h++) {
            var l = a[h];
            o.has(l) ? n.push({ key: e, frame: l }) : console.warn('Frame "%s" not found in texture \
"%s"', l, e);
          }
          return n;
        }, get: function(e) {
          return this.anims.get(e);
        }, getAnimsFromTexture: function(e) {
          for (var t = this.textureManager.get(e), i = t.key, r = this.anims.getArray(), s = [], n = 0; n <
          r.length; n++) for (var a = r[n], o = a.frames, h = 0; h < o.length; h++) if (o[h].textureKey ===
          i) {
            s.push(a.key);
            break;
          }
          return s;
        }, pauseAll: function() {
          return this.paused || (this.paused = true, this.emit(fn.PAUSE_ALL)), this;
        }, play: function(e, t) {
          Array.isArray(t) || (t = [t]);
          for (var i = 0; i < t.length; i++) t[i].anims.play(e);
          return this;
        }, staggerPlay: function(e, t, i, r) {
          i === void 0 && (i = 0), r === void 0 && (r = true), Array.isArray(t) || (t = [t]);
          var s = t.length;
          r || s--;
          for (var n = 0; n < t.length; n++) {
            var a = i < 0 ? Math.abs(i) * (s - n) : i * n;
            t[n].anims.playAfterDelay(e, a);
          }
          return this;
        }, remove: function(e) {
          var t = this.get(e);
          return t && (this.emit(fn.REMOVE_ANIMATION, e, t), this.anims.delete(e), this.removeMix(e)),
          t;
        }, resumeAll: function() {
          return this.paused && (this.paused = false, this.emit(fn.RESUME_ALL)), this;
        }, toJSON: function(e) {
          var t = { anims: [], globalTimeScale: this.globalTimeScale };
          return e !== void 0 && e !== "" ? t.anims.push(this.anims.get(e).toJSON()) : this.anims.each(
          function(i, r) {
            t.anims.push(r.toJSON());
          }), t;
        }, destroy: function() {
          this.anims.clear(), this.mixes.clear(), this.textureManager = null, this.game = null;
        } });
        Bm.exports = SH;
      });
      ss = u((Yxe, Gm) => {
        var wH = function(e, t) {
          return Math.floor(Math.random() * (t - e + 1) + e);
        };
        Gm.exports = wH;
      });
      Oa = u((Wxe, Um) => {
        var CH = Fa(), AH = ss(), RH = C(), _H = rs(), ci = un(), ft = B(), PH = new RH({ initialize: function(t) {
          this.parent = t, this.animationManager = t.scene.sys.anims, this.animationManager.on(ci.REMOVE_ANIMATION,
          this.globalRemove, this), this.textureManager = this.animationManager.textureManager, this.
          anims = null, this.isPlaying = false, this.hasStarted = false, this.currentAnim = null, this.
          currentFrame = null, this.nextAnim = null, this.nextAnimsQueue = [], this.timeScale = 1, this.
          frameRate = 0, this.duration = 0, this.msPerFrame = 0, this.skipMissedFrames = true, this.
          randomFrame = false, this.delay = 0, this.repeat = 0, this.repeatDelay = 0, this.yoyo = false,
          this.showBeforeDelay = false, this.showOnStart = false, this.hideOnComplete = false, this.
          forward = true, this.inReverse = false, this.accumulator = 0, this.nextTick = 0, this.delayCounter =
          0, this.repeatCounter = 0, this.pendingRepeat = false, this._paused = false, this._wasPlaying =
          false, this._pendingStop = 0, this._pendingStopValue;
        }, chain: function(e) {
          var t = this.parent;
          if (e === void 0) return this.nextAnimsQueue.length = 0, this.nextAnim = null, t;
          Array.isArray(e) || (e = [e]);
          for (var i = 0; i < e.length; i++) {
            var r = e[i];
            this.nextAnim ? this.nextAnimsQueue.push(r) : this.nextAnim = r;
          }
          return this.parent;
        }, getName: function() {
          return this.currentAnim ? this.currentAnim.key : "";
        }, getFrameName: function() {
          return this.currentFrame ? this.currentFrame.textureFrame : "";
        }, load: function(e) {
          this.isPlaying && this.stop();
          var t = this.animationManager, i = typeof e == "string" ? e : ft(e, "key", null), r = this.
          exists(i) ? this.get(i) : t.get(i);
          if (!r) console.warn("Missing animation: " + i);
          else {
            this.currentAnim = r;
            var s = r.getTotalFrames(), n = ft(e, "frameRate", r.frameRate), a = ft(e, "duration", r.
            duration);
            r.calculateDuration(this, s, a, n), this.delay = ft(e, "delay", r.delay), this.repeat = ft(
            e, "repeat", r.repeat), this.repeatDelay = ft(e, "repeatDelay", r.repeatDelay), this.yoyo =
            ft(e, "yoyo", r.yoyo), this.showBeforeDelay = ft(e, "showBeforeDelay", r.showBeforeDelay),
            this.showOnStart = ft(e, "showOnStart", r.showOnStart), this.hideOnComplete = ft(e, "hid\
eOnComplete", r.hideOnComplete), this.skipMissedFrames = ft(e, "skipMissedFrames", r.skipMissedFrames),
            this.randomFrame = ft(e, "randomFrame", r.randomFrame), this.timeScale = ft(e, "timeScal\
e", this.timeScale);
            var o = ft(e, "startFrame", 0);
            o > s && (o = 0), this.randomFrame && (o = AH(0, s - 1));
            var h = r.frames[o];
            o === 0 && !this.forward && (h = r.getLastFrame()), this.currentFrame = h;
          }
          return this.parent;
        }, pause: function(e) {
          return this._paused || (this._paused = true, this._wasPlaying = this.isPlaying, this.isPlaying =
          false), e !== void 0 && this.setCurrentFrame(e), this.parent;
        }, resume: function(e) {
          return this._paused && (this._paused = false, this.isPlaying = this._wasPlaying), e !== void 0 &&
          this.setCurrentFrame(e), this.parent;
        }, playAfterDelay: function(e, t) {
          if (!this.isPlaying) this.delayCounter = t, this.play(e, true);
          else {
            var i = this.nextAnim, r = this.nextAnimsQueue;
            i && r.unshift(i), this.nextAnim = e, this._pendingStop = 1, this._pendingStopValue = t;
          }
          return this.parent;
        }, playAfterRepeat: function(e, t) {
          if (t === void 0 && (t = 1), !this.isPlaying) this.play(e);
          else {
            var i = this.nextAnim, r = this.nextAnimsQueue;
            i && r.unshift(i), this.repeatCounter !== -1 && t > this.repeatCounter && (t = this.repeatCounter),
            this.nextAnim = e, this._pendingStop = 2, this._pendingStopValue = t;
          }
          return this.parent;
        }, play: function(e, t) {
          t === void 0 && (t = false);
          var i = this.currentAnim, r = this.parent, s = typeof e == "string" ? e : e.key;
          if (t && this.isPlaying && i.key === s) return r;
          if (i && this.isPlaying) {
            var n = this.animationManager.getMix(i.key, e);
            if (n > 0) return this.playAfterDelay(e, n);
          }
          return this.forward = true, this.inReverse = false, this._paused = false, this._wasPlaying =
          true, this.startAnimation(e);
        }, playReverse: function(e, t) {
          t === void 0 && (t = false);
          var i = typeof e == "string" ? e : e.key;
          return t && this.isPlaying && this.currentAnim.key === i ? this.parent : (this.forward = false,
          this.inReverse = true, this._paused = false, this._wasPlaying = true, this.startAnimation(
          e));
        }, startAnimation: function(e) {
          this.load(e);
          var t = this.currentAnim, i = this.parent;
          return t && (this.repeatCounter = this.repeat === -1 ? Number.MAX_VALUE : this.repeat, t.getFirstTick(
          this), this.isPlaying = true, this.pendingRepeat = false, this.hasStarted = false, this._pendingStop =
          0, this._pendingStopValue = 0, this._paused = false, this.delayCounter += this.delay, this.
          delayCounter === 0 ? this.handleStart() : this.showBeforeDelay && this.setCurrentFrame(this.
          currentFrame)), i;
        }, handleStart: function() {
          this.showOnStart && this.parent.setVisible(true), this.setCurrentFrame(this.currentFrame),
          this.hasStarted = true, this.emitEvents(ci.ANIMATION_START);
        }, handleRepeat: function() {
          this.pendingRepeat = false, this.emitEvents(ci.ANIMATION_REPEAT);
        }, handleStop: function() {
          this._pendingStop = 0, this.isPlaying = false, this.emitEvents(ci.ANIMATION_STOP);
        }, handleComplete: function() {
          this._pendingStop = 0, this.isPlaying = false, this.hideOnComplete && this.parent.setVisible(
          false), this.emitEvents(ci.ANIMATION_COMPLETE, ci.ANIMATION_COMPLETE_KEY);
        }, emitEvents: function(e, t) {
          var i = this.currentAnim;
          if (i) {
            var r = this.currentFrame, s = this.parent, n = r.textureFrame;
            s.emit(e, i, r, s, n), t && s.emit(t + i.key, i, r, s, n);
          }
        }, reverse: function() {
          return this.isPlaying && (this.inReverse = !this.inReverse, this.forward = !this.forward),
          this.parent;
        }, getProgress: function() {
          var e = this.currentFrame;
          if (!e) return 0;
          var t = e.progress;
          return this.inReverse && (t *= -1), t;
        }, setProgress: function(e) {
          return this.forward || (e = 1 - e), this.setCurrentFrame(this.currentAnim.getFrameByProgress(
          e)), this.parent;
        }, setRepeat: function(e) {
          return this.repeatCounter = e === -1 ? Number.MAX_VALUE : e, this.parent;
        }, globalRemove: function(e, t) {
          t === void 0 && (t = this.currentAnim), this.isPlaying && t.key === this.currentAnim.key &&
          (this.stop(), this.setCurrentFrame(this.currentAnim.frames[0]));
        }, restart: function(e, t) {
          e === void 0 && (e = false), t === void 0 && (t = false);
          var i = this.currentAnim, r = this.parent;
          return i ? (t && (this.repeatCounter = this.repeat === -1 ? Number.MAX_VALUE : this.repeat),
          i.getFirstTick(this), this.emitEvents(ci.ANIMATION_RESTART), this.isPlaying = true, this.pendingRepeat =
          false, this.hasStarted = !e, this._pendingStop = 0, this._pendingStopValue = 0, this._paused =
          false, this.setCurrentFrame(i.frames[0]), this.parent) : r;
        }, complete: function() {
          if (this._pendingStop = 0, this.isPlaying = false, this.currentAnim && this.handleComplete(),
          this.nextAnim) {
            var e = this.nextAnim;
            this.nextAnim = this.nextAnimsQueue.length > 0 ? this.nextAnimsQueue.shift() : null, this.
            play(e);
          }
          return this.parent;
        }, stop: function() {
          if (this._pendingStop = 0, this.isPlaying = false, this.delayCounter = 0, this.currentAnim &&
          this.handleStop(), this.nextAnim) {
            var e = this.nextAnim;
            this.nextAnim = this.nextAnimsQueue.shift(), this.play(e);
          }
          return this.parent;
        }, stopAfterDelay: function(e) {
          return this._pendingStop = 1, this._pendingStopValue = e, this.parent;
        }, stopAfterRepeat: function(e) {
          return e === void 0 && (e = 1), this.repeatCounter !== -1 && e > this.repeatCounter && (e =
          this.repeatCounter), this._pendingStop = 2, this._pendingStopValue = e, this.parent;
        }, stopOnFrame: function(e) {
          return this._pendingStop = 3, this._pendingStopValue = e, this.parent;
        }, getTotalFrames: function() {
          return this.currentAnim ? this.currentAnim.getTotalFrames() : 0;
        }, update: function(e, t) {
          var i = this.currentAnim;
          if (!(!this.isPlaying || !i || i.paused)) {
            if (this.accumulator += t * this.timeScale * this.animationManager.globalTimeScale, this.
            _pendingStop === 1 && (this._pendingStopValue -= t, this._pendingStopValue <= 0)) return this.
            stop();
            if (!this.hasStarted) this.accumulator >= this.delayCounter && (this.accumulator -= this.
            delayCounter, this.handleStart());
            else if (this.accumulator >= this.nextTick && (this.forward ? i.nextFrame(this) : i.previousFrame(
            this), this.isPlaying && this._pendingStop === 0 && this.skipMissedFrames && this.accumulator >
            this.nextTick)) {
              var r = 0;
              do
                this.forward ? i.nextFrame(this) : i.previousFrame(this), r++;
              while (this.isPlaying && this.accumulator > this.nextTick && r < 60);
            }
          }
        }, setCurrentFrame: function(e) {
          var t = this.parent;
          return this.currentFrame = e, t.texture = e.frame.texture, t.frame = e.frame, t.isCropped &&
          t.frame.updateCropUVs(t._crop, t.flipX, t.flipY), e.setAlpha && (t.alpha = e.alpha), t.setSizeToFrame(),
          t._originComponent && (e.frame.customPivot ? t.setOrigin(e.frame.pivotX, e.frame.pivotY) :
          t.updateDisplayOrigin()), this.isPlaying && this.hasStarted && (this.emitEvents(ci.ANIMATION_UPDATE),
          this._pendingStop === 3 && this._pendingStopValue === e && this.stop()), t;
        }, nextFrame: function() {
          return this.currentAnim && this.currentAnim.nextFrame(this), this.parent;
        }, previousFrame: function() {
          return this.currentAnim && this.currentAnim.previousFrame(this), this.parent;
        }, get: function(e) {
          return this.anims ? this.anims.get(e) : null;
        }, exists: function(e) {
          return this.anims ? this.anims.has(e) : false;
        }, create: function(e) {
          var t = e.key, i = false;
          return t && (i = this.get(t), i ? console.warn("Animation key already exists: " + t) : (i =
          new CH(this, t, e), this.anims || (this.anims = new _H()), this.anims.set(t, i))), i;
        }, createFromAseprite: function(e, t) {
          return this.animationManager.createFromAseprite(e, t, this.parent);
        }, generateFrameNames: function(e, t) {
          return this.animationManager.generateFrameNames(e, t);
        }, generateFrameNumbers: function(e, t) {
          return this.animationManager.generateFrameNumbers(e, t);
        }, remove: function(e) {
          var t = this.get(e);
          return t && (this.currentAnim === t && this.stop(), this.anims.delete(e)), t;
        }, destroy: function() {
          this.animationManager.off(ci.REMOVE_ANIMATION, this.globalRemove, this), this.anims && this.
          anims.clear(), this.animationManager = null, this.parent = null, this.nextAnim = null, this.
          nextAnimsQueue.length = 0, this.currentAnim = null, this.currentFrame = null;
        }, isPaused: { get: function() {
          return this._paused;
        } } });
        Um.exports = PH;
      });
      km = u((Hxe, zm) => {
        zm.exports = { Animation: Fa(), AnimationFrame: vu(), AnimationManager: xu(), AnimationState: Oa(),
        Events: un() };
      });
      cn = u((Kxe, Xm) => {
        var MH = { TOP_LEFT: 0, TOP_CENTER: 1, TOP_RIGHT: 2, LEFT_TOP: 3, LEFT_CENTER: 4, LEFT_BOTTOM: 5,
        CENTER: 6, RIGHT_TOP: 7, RIGHT_CENTER: 8, RIGHT_BOTTOM: 9, BOTTOM_LEFT: 10, BOTTOM_CENTER: 11,
        BOTTOM_RIGHT: 12 };
        Xm.exports = MH;
      });
      vi = u((Zxe, Vm) => {
        var qH = function(e) {
          return e.y + e.height - e.height * e.originY;
        };
        Vm.exports = qH;
      });
      ns = u((Qxe, Ym) => {
        var FH = function(e) {
          return e.x - e.width * e.originX + e.width * 0.5;
        };
        Ym.exports = FH;
      });
      as = u((Jxe, Wm) => {
        var bH = function(e, t) {
          var i = e.width * e.originX;
          return e.x = t + i - e.width * 0.5, e;
        };
        Wm.exports = bH;
      });
      pi = u(($xe, Hm) => {
        var LH = function(e, t) {
          return e.y = t + e.height * e.originY, e;
        };
        Hm.exports = LH;
      });
      Eu = u((jxe, Km) => {
        var OH = vi(), DH = ns(), NH = as(), IH = pi(), BH = function(e, t, i, r) {
          return i === void 0 && (i = 0), r === void 0 && (r = 0), NH(e, DH(t) + i), IH(e, OH(t) + r),
          e;
        };
        Km.exports = BH;
      });
      mi = u((eEe, Zm) => {
        var GH = function(e) {
          return e.x - e.width * e.originX;
        };
        Zm.exports = GH;
      });
      gi = u((tEe, Qm) => {
        var UH = function(e, t) {
          return e.x = t + e.width * e.originX, e;
        };
        Qm.exports = UH;
      });
      Tu = u((iEe, Jm) => {
        var zH = vi(), kH = mi(), XH = gi(), VH = pi(), YH = function(e, t, i, r) {
          return i === void 0 && (i = 0), r === void 0 && (r = 0), XH(e, kH(t) - i), VH(e, zH(t) + r),
          e;
        };
        Jm.exports = YH;
      });
      xi = u((rEe, $m) => {
        var WH = function(e) {
          return e.x + e.width - e.width * e.originX;
        };
        $m.exports = WH;
      });
      Ei = u((sEe, jm) => {
        var HH = function(e, t) {
          return e.x = t - e.width + e.width * e.originX, e;
        };
        jm.exports = HH;
      });
      yu = u((nEe, eg) => {
        var KH = vi(), ZH = xi(), QH = Ei(), JH = pi(), $H = function(e, t, i, r) {
          return i === void 0 && (i = 0), r === void 0 && (r = 0), QH(e, ZH(t) + i), JH(e, KH(t) + r),
          e;
        };
        eg.exports = $H;
      });
      Ti = u((aEe, tg) => {
        var jH = function(e, t) {
          return e.y = t - e.height + e.height * e.originY, e;
        };
        tg.exports = jH;
      });
      Su = u((oEe, ig) => {
        var e6 = vi(), t6 = mi(), i6 = Ti(), r6 = Ei(), s6 = function(e, t, i, r) {
          return i === void 0 && (i = 0), r === void 0 && (r = 0), r6(e, t6(t) - i), i6(e, e6(t) + r),
          e;
        };
        ig.exports = s6;
      });
      os = u((hEe, rg) => {
        var n6 = function(e) {
          return e.y - e.height * e.originY + e.height * 0.5;
        };
        rg.exports = n6;
      });
      hs = u((uEe, sg) => {
        var a6 = function(e, t) {
          var i = e.height * e.originY;
          return e.y = t + i - e.height * 0.5, e;
        };
        sg.exports = a6;
      });
      wu = u((lEe, ng) => {
        var o6 = os(), h6 = mi(), u6 = hs(), l6 = Ei(), f6 = function(e, t, i, r) {
          return i === void 0 && (i = 0), r === void 0 && (r = 0), l6(e, h6(t) - i), u6(e, o6(t) + r),
          e;
        };
        ng.exports = f6;
      });
      yi = u((fEe, ag) => {
        var d6 = function(e) {
          return e.y - e.height * e.originY;
        };
        ag.exports = d6;
      });
      Cu = u((dEe, og) => {
        var c6 = mi(), v6 = yi(), p6 = Ei(), m6 = pi(), g6 = function(e, t, i, r) {
          return i === void 0 && (i = 0), r === void 0 && (r = 0), p6(e, c6(t) - i), m6(e, v6(t) - r),
          e;
        };
        og.exports = g6;
      });
      Au = u((cEe, hg) => {
        var x6 = vi(), E6 = xi(), T62 = Ti(), y6 = gi(), S62 = function(e, t, i, r) {
          return i === void 0 && (i = 0), r === void 0 && (r = 0), y6(e, E6(t) + i), T62(e, x6(t) + r),
          e;
        };
        hg.exports = S62;
      });
      Ru = u((vEe, ug) => {
        var w6 = os(), C6 = xi(), A62 = hs(), R6 = gi(), _6 = function(e, t, i, r) {
          return i === void 0 && (i = 0), r === void 0 && (r = 0), R6(e, C6(t) + i), A62(e, w6(t) + r),
          e;
        };
        ug.exports = _6;
      });
      _u = u((pEe, lg) => {
        var P6 = xi(), M6 = yi(), q6 = gi(), F62 = pi(), b6 = function(e, t, i, r) {
          return i === void 0 && (i = 0), r === void 0 && (r = 0), q6(e, P6(t) + i), F62(e, M6(t) - r),
          e;
        };
        lg.exports = b6;
      });
      Pu = u((mEe, fg) => {
        var L6 = ns(), O62 = yi(), D62 = Ti(), N6 = as(), I6 = function(e, t, i, r) {
          return i === void 0 && (i = 0), r === void 0 && (r = 0), N6(e, L6(t) + i), D62(e, O62(t) -
          r), e;
        };
        fg.exports = I6;
      });
      Mu = u((gEe, dg) => {
        var B62 = mi(), G6 = yi(), U6 = Ti(), z6 = gi(), k6 = function(e, t, i, r) {
          return i === void 0 && (i = 0), r === void 0 && (r = 0), z6(e, B62(t) - i), U6(e, G6(t) - r),
          e;
        };
        dg.exports = k6;
      });
      qu = u((xEe, cg) => {
        var X6 = xi(), V62 = yi(), Y6 = Ti(), W6 = Ei(), H6 = function(e, t, i, r) {
          return i === void 0 && (i = 0), r === void 0 && (r = 0), W6(e, X6(t) + i), Y6(e, V62(t) - r),
          e;
        };
        cg.exports = H6;
      });
      Fu = u((EEe, vg) => {
        var Ft = cn(), Et = [];
        Et[Ft.BOTTOM_CENTER] = Eu();
        Et[Ft.BOTTOM_LEFT] = Tu();
        Et[Ft.BOTTOM_RIGHT] = yu();
        Et[Ft.LEFT_BOTTOM] = Su();
        Et[Ft.LEFT_CENTER] = wu();
        Et[Ft.LEFT_TOP] = Cu();
        Et[Ft.RIGHT_BOTTOM] = Au();
        Et[Ft.RIGHT_CENTER] = Ru();
        Et[Ft.RIGHT_TOP] = _u();
        Et[Ft.TOP_CENTER] = Pu();
        Et[Ft.TOP_LEFT] = Mu();
        Et[Ft.TOP_RIGHT] = qu();
        var K6 = function(e, t, i, r, s) {
          return Et[i](e, t, r, s);
        };
        vg.exports = K6;
      });
      mg = u((TEe, pg) => {
        var Z6 = Fu(), Q6 = function(e, t, i, r) {
          for (var s = e[0], n = 1; n < e.length; n++) {
            var a = e[n];
            Z6(a, s, t, i, r), s = a;
          }
          return e;
        };
        pg.exports = Q6;
      });
      zt = u((yEe, gg) => {
        var J6 = function(e, t, i, r, s, n) {
          r === void 0 && (r = 0), s === void 0 && (s = 0), n === void 0 && (n = 1);
          var a, o = 0, h = e.length;
          if (n === 1) for (a = s; a < h; a++) e[a][t] += i + o * r, o++;
          else for (a = s; a >= 0; a--) e[a][t] += i + o * r, o++;
          return e;
        };
        gg.exports = J6;
      });
      Eg = u((SEe, xg) => {
        var $6 = zt(), j6 = function(e, t, i, r, s) {
          return $6(e, "angle", t, i, r, s);
        };
        xg.exports = j6;
      });
      yg = u((wEe, Tg) => {
        var e9 = function(e, t, i) {
          for (var r = 0; r < e.length; r++) {
            var s = e[r];
            t.call(i, s);
          }
          return e;
        };
        Tg.exports = e9;
      });
      wg = u((CEe, Sg) => {
        var t9 = function(e, t, i) {
          i === void 0 && (i = 0);
          for (var r = i; r < e.length; r++) {
            var s = e[r], n = true;
            for (var a in t) s[a] !== t[a] && (n = false);
            if (n) return s;
          }
          return null;
        };
        Sg.exports = t9;
      });
      Ag = u((AEe, Cg) => {
        var i9 = function(e, t, i) {
          i === void 0 && (i = 0);
          for (var r = e.length - 1; r >= i; r--) {
            var s = e[r], n = true;
            for (var a in t) s[a] !== t[a] && (n = false);
            if (n) return s;
          }
          return null;
        };
        Cg.exports = i9;
      });
      bu = u((REe, Rg) => {
        var r9 = vi(), s9 = ns(), n9 = Ti(), a9 = as(), o9 = function(e, t, i, r) {
          return i === void 0 && (i = 0), r === void 0 && (r = 0), a9(e, s9(t) + i), n9(e, r9(t) + r),
          e;
        };
        Rg.exports = o9;
      });
      Lu = u((_Ee, _g) => {
        var h9 = vi(), u9 = mi(), l9 = Ti(), f9 = gi(), d9 = function(e, t, i, r) {
          return i === void 0 && (i = 0), r === void 0 && (r = 0), f9(e, u9(t) - i), l9(e, h9(t) + r),
          e;
        };
        _g.exports = d9;
      });
      Ou = u((PEe, Pg) => {
        var c9 = vi(), v9 = xi(), p9 = Ti(), m9 = Ei(), g9 = function(e, t, i, r) {
          return i === void 0 && (i = 0), r === void 0 && (r = 0), m9(e, v9(t) + i), p9(e, c9(t) + r),
          e;
        };
        Pg.exports = g9;
      });
      qg = u((MEe, Mg) => {
        var x9 = as(), E9 = hs(), T92 = function(e, t, i) {
          return x9(e, t), E9(e, i);
        };
        Mg.exports = T92;
      });
      Du = u((qEe, Fg) => {
        var y9 = qg(), S92 = ns(), w9 = os(), C9 = function(e, t, i, r) {
          return i === void 0 && (i = 0), r === void 0 && (r = 0), y9(e, S92(t) + i, w9(t) + r), e;
        };
        Fg.exports = C9;
      });
      Nu = u((FEe, bg) => {
        var A92 = os(), R9 = mi(), _9 = hs(), P9 = gi(), M9 = function(e, t, i, r) {
          return i === void 0 && (i = 0), r === void 0 && (r = 0), P9(e, R9(t) - i), _9(e, A92(t) + r),
          e;
        };
        bg.exports = M9;
      });
      Iu = u((bEe, Lg) => {
        var q9 = os(), F9 = xi(), b9 = hs(), L9 = Ei(), O92 = function(e, t, i, r) {
          return i === void 0 && (i = 0), r === void 0 && (r = 0), L9(e, F9(t) + i), b9(e, q9(t) + r),
          e;
        };
        Lg.exports = O92;
      });
      Bu = u((LEe, Og) => {
        var D9 = ns(), N9 = yi(), I9 = as(), B9 = pi(), G9 = function(e, t, i, r) {
          return i === void 0 && (i = 0), r === void 0 && (r = 0), I9(e, D9(t) + i), B9(e, N9(t) - r),
          e;
        };
        Og.exports = G9;
      });
      Gu = u((OEe, Dg) => {
        var U9 = mi(), z9 = yi(), k9 = gi(), X9 = pi(), V92 = function(e, t, i, r) {
          return i === void 0 && (i = 0), r === void 0 && (r = 0), k9(e, U9(t) - i), X9(e, z9(t) - r),
          e;
        };
        Dg.exports = V92;
      });
      Uu = u((DEe, Ng) => {
        var Y9 = xi(), W9 = yi(), H9 = Ei(), K9 = pi(), Z9 = function(e, t, i, r) {
          return i === void 0 && (i = 0), r === void 0 && (r = 0), H9(e, Y9(t) + i), K9(e, W9(t) - r),
          e;
        };
        Ng.exports = Z9;
      });
      zu = u((NEe, Ig) => {
        var De = cn(), Pe = [];
        Pe[De.BOTTOM_CENTER] = bu();
        Pe[De.BOTTOM_LEFT] = Lu();
        Pe[De.BOTTOM_RIGHT] = Ou();
        Pe[De.CENTER] = Du();
        Pe[De.LEFT_CENTER] = Nu();
        Pe[De.RIGHT_CENTER] = Iu();
        Pe[De.TOP_CENTER] = Bu();
        Pe[De.TOP_LEFT] = Gu();
        Pe[De.TOP_RIGHT] = Uu();
        Pe[De.LEFT_BOTTOM] = Pe[De.BOTTOM_LEFT];
        Pe[De.LEFT_TOP] = Pe[De.TOP_LEFT];
        Pe[De.RIGHT_BOTTOM] = Pe[De.BOTTOM_RIGHT];
        Pe[De.RIGHT_TOP] = Pe[De.TOP_RIGHT];
        var Q9 = function(e, t, i, r, s) {
          return Pe[i](e, t, r, s);
        };
        Ig.exports = Q9;
      });
      J = u((IEe, Bg) => {
        var J9 = function() {
        };
        Bg.exports = J9;
      });
      Tr = u((BEe, Gg) => {
        var $9 = function(e, t, i) {
          if (e.radius > 0 && t >= e.left && t <= e.right && i >= e.top && i <= e.bottom) {
            var r = (e.x - t) * (e.x - t), s = (e.y - i) * (e.y - i);
            return r + s <= e.radius * e.radius;
          } else return false;
        };
        Gg.exports = $9;
      });
      ki = u((GEe, Ug) => {
        var j9 = { CIRCLE: 0, ELLIPSE: 1, LINE: 2, POINT: 3, POLYGON: 4, RECTANGLE: 5, TRIANGLE: 6 };
        Ug.exports = j9;
      });
      ae = u((UEe, zg) => {
        var e8 = C(), t8 = ki(), i8 = new e8({ initialize: function(t, i) {
          t === void 0 && (t = 0), i === void 0 && (i = t), this.type = t8.POINT, this.x = t, this.y =
          i;
        }, setTo: function(e, t) {
          return e === void 0 && (e = 0), t === void 0 && (t = e), this.x = e, this.y = t, this;
        } });
        zg.exports = i8;
      });
      Da = u((zEe, kg) => {
        var r8 = ae(), s8 = function(e, t, i) {
          return i === void 0 && (i = new r8()), i.x = e.x + e.radius * Math.cos(t), i.y = e.y + e.radius *
          Math.sin(t), i;
        };
        kg.exports = s8;
      });
      us = u((kEe, Xg) => {
        var n8 = ne(), a8 = function(e, t, i) {
          return e = n8(e, 0, 1), (i - t) * e + t;
        };
        Xg.exports = a8;
      });
      ku = u((XEe, Vg) => {
        var o8 = Da(), h8 = us(), u8 = le(), l8 = ae(), f8 = function(e, t, i) {
          i === void 0 && (i = new l8());
          var r = h8(t, 0, u8.PI2);
          return o8(e, r, i);
        };
        Vg.exports = f8;
      });
      Xu = u((VEe, Yg) => {
        var d8 = function(e) {
          return 2 * (Math.PI * e.radius);
        };
        Yg.exports = d8;
      });
      Vu = u((YEe, Wg) => {
        var c8 = Xu(), v8 = Da(), p8 = us(), m8 = le(), g8 = function(e, t, i, r) {
          r === void 0 && (r = []), !t && i > 0 && (t = c8(e) / i);
          for (var s = 0; s < t; s++) {
            var n = p8(s / t, 0, m8.PI2);
            r.push(v8(e, n));
          }
          return r;
        };
        Wg.exports = g8;
      });
      Na = u((WEe, Hg) => {
        var x8 = ae(), E8 = function(e, t) {
          t === void 0 && (t = new x8());
          var i = 2 * Math.PI * Math.random(), r = Math.random() + Math.random(), s = r > 1 ? 2 - r :
          r, n = s * Math.cos(i), a = s * Math.sin(i);
          return t.x = e.x + n * e.radius, t.y = e.y + a * e.radius, t;
        };
        Hg.exports = E8;
      });
      vn = u((HEe, Kg) => {
        var T82 = C(), y8 = Tr(), S82 = ku(), w8 = Vu(), C8 = ki(), A82 = Na(), R8 = new T82({ initialize: function(t, i, r) {
          t === void 0 && (t = 0), i === void 0 && (i = 0), r === void 0 && (r = 0), this.type = C8.
          CIRCLE, this.x = t, this.y = i, this._radius = r, this._diameter = r * 2;
        }, contains: function(e, t) {
          return y8(this, e, t);
        }, getPoint: function(e, t) {
          return S82(this, e, t);
        }, getPoints: function(e, t, i) {
          return w8(this, e, t, i);
        }, getRandomPoint: function(e) {
          return A82(this, e);
        }, setTo: function(e, t, i) {
          return this.x = e, this.y = t, this._radius = i, this._diameter = i * 2, this;
        }, setEmpty: function() {
          return this._radius = 0, this._diameter = 0, this;
        }, setPosition: function(e, t) {
          return t === void 0 && (t = e), this.x = e, this.y = t, this;
        }, isEmpty: function() {
          return this._radius <= 0;
        }, radius: { get: function() {
          return this._radius;
        }, set: function(e) {
          this._radius = e, this._diameter = e * 2;
        } }, diameter: { get: function() {
          return this._diameter;
        }, set: function(e) {
          this._diameter = e, this._radius = e * 0.5;
        } }, left: { get: function() {
          return this.x - this._radius;
        }, set: function(e) {
          this.x = e + this._radius;
        } }, right: { get: function() {
          return this.x + this._radius;
        }, set: function(e) {
          this.x = e - this._radius;
        } }, top: { get: function() {
          return this.y - this._radius;
        }, set: function(e) {
          this.y = e + this._radius;
        } }, bottom: { get: function() {
          return this.y + this._radius;
        }, set: function(e) {
          this.y = e - this._radius;
        } } });
        Kg.exports = R8;
      });
      Qg = u((KEe, Zg) => {
        var Si = ne(), ls = 2, _8 = { _alpha: 1, _alphaTL: 1, _alphaTR: 1, _alphaBL: 1, _alphaBR: 1,
        clearAlpha: function() {
          return this.setAlpha(1);
        }, setAlpha: function(e, t, i, r) {
          return e === void 0 && (e = 1), t === void 0 ? this.alpha = e : (this._alphaTL = Si(e, 0, 1),
          this._alphaTR = Si(t, 0, 1), this._alphaBL = Si(i, 0, 1), this._alphaBR = Si(r, 0, 1)), this;
        }, alpha: { get: function() {
          return this._alpha;
        }, set: function(e) {
          var t = Si(e, 0, 1);
          this._alpha = t, this._alphaTL = t, this._alphaTR = t, this._alphaBL = t, this._alphaBR = t,
          t === 0 ? this.renderFlags &= ~ls : this.renderFlags |= ls;
        } }, alphaTopLeft: { get: function() {
          return this._alphaTL;
        }, set: function(e) {
          var t = Si(e, 0, 1);
          this._alphaTL = t, t !== 0 && (this.renderFlags |= ls);
        } }, alphaTopRight: { get: function() {
          return this._alphaTR;
        }, set: function(e) {
          var t = Si(e, 0, 1);
          this._alphaTR = t, t !== 0 && (this.renderFlags |= ls);
        } }, alphaBottomLeft: { get: function() {
          return this._alphaBL;
        }, set: function(e) {
          var t = Si(e, 0, 1);
          this._alphaBL = t, t !== 0 && (this.renderFlags |= ls);
        } }, alphaBottomRight: { get: function() {
          return this._alphaBR;
        }, set: function(e) {
          var t = Si(e, 0, 1);
          this._alphaBR = t, t !== 0 && (this.renderFlags |= ls);
        } } };
        Zg.exports = _8;
      });
      jg = u((ZEe, $g) => {
        var P8 = ne(), Jg = 2, M8 = { _alpha: 1, clearAlpha: function() {
          return this.setAlpha(1);
        }, setAlpha: function(e) {
          return e === void 0 && (e = 1), this.alpha = e, this;
        }, alpha: { get: function() {
          return this._alpha;
        }, set: function(e) {
          var t = P8(e, 0, 1);
          this._alpha = t, t === 0 ? this.renderFlags &= ~Jg : this.renderFlags |= Jg;
        } } };
        $g.exports = M8;
      });
      i0 = u((QEe, t0) => {
        var e0 = Qt(), q8 = { _blendMode: e0.NORMAL, blendMode: { get: function() {
          return this._blendMode;
        }, set: function(e) {
          typeof e == "string" && (e = e0[e]), e |= 0, e >= -1 && (this._blendMode = e);
        } }, setBlendMode: function(e) {
          return this.blendMode = e, this;
        } };
        t0.exports = q8;
      });
      s0 = u((JEe, r0) => {
        var F8 = { width: 0, height: 0, displayWidth: { get: function() {
          return this.scaleX * this.width;
        }, set: function(e) {
          this.scaleX = e / this.width;
        } }, displayHeight: { get: function() {
          return this.scaleY * this.height;
        }, set: function(e) {
          this.scaleY = e / this.height;
        } }, setSize: function(e, t) {
          return this.width = e, this.height = t, this;
        }, setDisplaySize: function(e, t) {
          return this.displayWidth = e, this.displayHeight = t, this;
        } };
        r0.exports = F8;
      });
      a0 = u(($Ee, n0) => {
        var b8 = { texture: null, frame: null, isCropped: false, setCrop: function(e, t, i, r) {
          if (e === void 0) this.isCropped = false;
          else if (this.frame) {
            if (typeof e == "number") this.frame.setCropUVs(this._crop, e, t, i, r, this.flipX, this.
            flipY);
            else {
              var s = e;
              this.frame.setCropUVs(this._crop, s.x, s.y, s.width, s.height, this.flipX, this.flipY);
            }
            this.isCropped = true;
          }
          return this;
        }, resetCropObject: function() {
          return { u0: 0, v0: 0, u1: 0, v1: 0, width: 0, height: 0, x: 0, y: 0, flipX: false, flipY: false,
          cx: 0, cy: 0, cw: 0, ch: 0 };
        } };
        n0.exports = b8;
      });
      Ia = u((jEe, o0) => {
        var L8 = function(e) {
          if (!Array.isArray(e) || !Array.isArray(e[0])) return false;
          for (var t = e[0].length, i = 1; i < e.length; i++) if (e[i].length !== t) return false;
          return true;
        };
        o0.exports = L8;
      });
      u0 = u((eTe, h0) => {
        var O82 = La(), D8 = Ia(), N8 = function(e) {
          var t = "";
          if (!D8(e)) return t;
          for (var i = 0; i < e.length; i++) {
            for (var r = 0; r < e[i].length; r++) {
              var s = e[i][r].toString();
              s !== "undefined" ? t += O82(s, 2) : t += "?", r < e[i].length - 1 && (t += " |");
            }
            if (i < e.length - 1) {
              t += `
`;
              for (var n = 0; n < e[i].length; n++) t += "---", n < e[i].length - 1 && (t += "+");
              t += `
`;
            }
          }
          return t;
        };
        h0.exports = N8;
      });
      f0 = u((tTe, l0) => {
        var I8 = function(e) {
          return e.reverse();
        };
        l0.exports = I8;
      });
      c0 = u((iTe, d0) => {
        var B8 = function(e) {
          for (var t = 0; t < e.length; t++) e[t].reverse();
          return e;
        };
        d0.exports = B8;
      });
      Yu = u((rTe, v0) => {
        var G8 = function(e) {
          for (var t = e.length, i = e[0].length, r = new Array(i), s = 0; s < i; s++) {
            r[s] = new Array(t);
            for (var n = t - 1; n > -1; n--) r[s][n] = e[n][s];
          }
          return r;
        };
        v0.exports = G8;
      });
      pn = u((sTe, m0) => {
        var U8 = Ia(), p0 = Yu(), z8 = function(e, t) {
          if (t === void 0 && (t = 90), !U8(e)) return null;
          if (typeof t != "string" && (t = (t % 360 + 360) % 360), t === 90 || t === -270 || t === "\
rotateLeft") e = p0(e), e.reverse();
          else if (t === -90 || t === 270 || t === "rotateRight") e.reverse(), e = p0(e);
          else if (Math.abs(t) === 180 || t === "rotate180") {
            for (var i = 0; i < e.length; i++) e[i].reverse();
            e.reverse();
          }
          return e;
        };
        m0.exports = z8;
      });
      x0 = u((nTe, g0) => {
        var k8 = pn(), X8 = function(e) {
          return k8(e, 180);
        };
        g0.exports = X8;
      });
      T0 = u((aTe, E0) => {
        var V82 = pn(), Y8 = function(e, t) {
          t === void 0 && (t = 1);
          for (var i = 0; i < t; i++) e = V82(e, 90);
          return e;
        };
        E0.exports = Y8;
      });
      S0 = u((oTe, y0) => {
        var W8 = pn(), H8 = function(e, t) {
          t === void 0 && (t = 1);
          for (var i = 0; i < t; i++) e = W8(e, -90);
          return e;
        };
        y0.exports = H8;
      });
      Ba = u((hTe, w0) => {
        var K8 = function(e, t) {
          t === void 0 && (t = 1);
          for (var i = null, r = 0; r < t; r++) i = e.shift(), e.push(i);
          return i;
        };
        w0.exports = K8;
      });
      Ga = u((uTe, C0) => {
        var Z8 = function(e, t) {
          t === void 0 && (t = 1);
          for (var i = null, r = 0; r < t; r++) i = e.pop(), e.unshift(i);
          return i;
        };
        C0.exports = Z8;
      });
      P0 = u((lTe, _0) => {
        var A0 = Ba(), R0 = Ga(), Q8 = function(e, t, i) {
          if (t === void 0 && (t = 0), i === void 0 && (i = 0), i !== 0 && (i < 0 ? A0(e, Math.abs(i)) :
          R0(e, i)), t !== 0) for (var r = 0; r < e.length; r++) {
            var s = e[r];
            t < 0 ? A0(s, Math.abs(t)) : R0(s, t);
          }
          return e;
        };
        _0.exports = Q8;
      });
      q0 = u((fTe, M0) => {
        M0.exports = { CheckMatrix: Ia(), MatrixToString: u0(), ReverseColumns: f0(), ReverseRows: c0(),
        Rotate180: x0(), RotateLeft: T0(), RotateMatrix: pn(), RotateRight: S0(), Translate: P0(), TransposeMatrix: Yu() };
      });
      b0 = u((dTe, F0) => {
        var J8 = function(e, t, i, r, s) {
          if (s === void 0 && (s = e), i > 0) {
            var n = i - e.length;
            if (n <= 0) return null;
          }
          if (!Array.isArray(t)) return e.indexOf(t) === -1 ? (e.push(t), r && r.call(s, t), t) : null;
          for (var a = t.length - 1; a >= 0; ) e.indexOf(t[a]) !== -1 && t.splice(a, 1), a--;
          if (a = t.length, a === 0) return null;
          i > 0 && a > n && (t.splice(n), a = n);
          for (var o = 0; o < a; o++) {
            var h = t[o];
            e.push(h), r && r.call(s, h);
          }
          return t;
        };
        F0.exports = J8;
      });
      O0 = u((cTe, L0) => {
        var $8 = function(e, t, i, r, s, n) {
          if (i === void 0 && (i = 0), n === void 0 && (n = e), r > 0) {
            var a = r - e.length;
            if (a <= 0) return null;
          }
          if (!Array.isArray(t)) return e.indexOf(t) === -1 ? (e.splice(i, 0, t), s && s.call(n, t),
          t) : null;
          for (var o = t.length - 1; o >= 0; ) e.indexOf(t[o]) !== -1 && t.pop(), o--;
          if (o = t.length, o === 0) return null;
          r > 0 && o > a && (t.splice(a), o = a);
          for (var h = o - 1; h >= 0; h--) {
            var l = t[h];
            e.splice(i, 0, l), s && s.call(n, l);
          }
          return t;
        };
        L0.exports = $8;
      });
      N0 = u((vTe, D0) => {
        var j8 = function(e, t) {
          var i = e.indexOf(t);
          return i !== -1 && i < e.length && (e.splice(i, 1), e.push(t)), t;
        };
        D0.exports = j8;
      });
      Xi = u((pTe, I0) => {
        var e7 = function(e, t, i, r) {
          var s = e.length;
          if (t < 0 || t >= s || t >= i || i > s) {
            if (r) throw new Error("Range Error: Values outside acceptable range");
            return false;
          } else return true;
        };
        I0.exports = e7;
      });
      G0 = u((mTe, B0) => {
        var t7 = Xi(), i7 = function(e, t, i, r, s) {
          r === void 0 && (r = 0), s === void 0 && (s = e.length);
          var n = 0;
          if (t7(e, r, s)) for (var a = r; a < s; a++) {
            var o = e[a];
            o[t] === i && n++;
          }
          return n;
        };
        B0.exports = i7;
      });
      mn = u((gTe, U0) => {
        var r7 = function(e, t, i) {
          var r, s = [null];
          for (r = 3; r < arguments.length; r++) s.push(arguments[r]);
          for (r = 0; r < e.length; r++) s[0] = e[r], t.apply(i, s);
          return e;
        };
        U0.exports = r7;
      });
      k0 = u((xTe, z0) => {
        var s7 = Xi(), n7 = function(e, t, i, r, s) {
          if (r === void 0 && (r = 0), s === void 0 && (s = e.length), s7(e, r, s)) {
            var n, a = [null];
            for (n = 5; n < arguments.length; n++) a.push(arguments[n]);
            for (n = r; n < s; n++) a[0] = e[n], t.apply(i, a);
          }
          return e;
        };
        z0.exports = n7;
      });
      Wu = u((ETe, V0) => {
        var X0 = function(e, t) {
          t === void 0 && (t = []);
          for (var i = 0; i < e.length; i++) Array.isArray(e[i]) ? X0(e[i], t) : t.push(e[i]);
          return t;
        };
        V0.exports = X0;
      });
      Ua = u((TTe, Y0) => {
        var a7 = Xi(), o7 = function(e, t, i, r, s) {
          r === void 0 && (r = 0), s === void 0 && (s = e.length);
          var n = [];
          if (a7(e, r, s)) for (var a = r; a < s; a++) {
            var o = e[a];
            (!t || t && i === void 0 && o.hasOwnProperty(t) || t && i !== void 0 && o[t] === i) && n.
            push(o);
          }
          return n;
        };
        Y0.exports = o7;
      });
      Hu = u((yTe, H0) => {
        var W0 = Xi(), h7 = function(e, t, i, r, s) {
          if (r === void 0 && (r = 0), s === void 0 && (s = e.length), r !== -1) {
            if (W0(e, r, s)) for (var n = r; n < s; n++) {
              var a = e[n];
              if (!t || t && i === void 0 && a.hasOwnProperty(t) || t && i !== void 0 && a[t] === i)
               return a;
            }
          } else if (W0(e, 0, s)) for (var n = s; n >= 0; n--) {
            var a = e[n];
            if (!t || t && i === void 0 && a.hasOwnProperty(t) || t && i !== void 0 && a[t] === i) return a;
          }
          return null;
        };
        H0.exports = h7;
      });
      Ku = u((STe, K0) => {
        var u7 = function(e, t, i) {
          t === void 0 && (t = 0), i === void 0 && (i = e.length);
          var r = t + Math.floor(Math.random() * i);
          return e[r] === void 0 ? null : e[r];
        };
        K0.exports = u7;
      });
      Q0 = u((wTe, Z0) => {
        var l7 = function(e, t) {
          var i = e.indexOf(t);
          if (i > 0) {
            var r = e[i - 1], s = e.indexOf(r);
            e[i] = r, e[s] = t;
          }
          return e;
        };
        Z0.exports = l7;
      });
      $0 = u((CTe, J0) => {
        var f7 = function(e, t, i) {
          var r = e.indexOf(t);
          if (r === -1 || i < 0 || i >= e.length) throw new Error("Supplied index out of bounds");
          return r !== i && (e.splice(r, 1), e.splice(i, 0, t)), t;
        };
        J0.exports = f7;
      });
      ex = u((ATe, j0) => {
        var d7 = function(e, t) {
          var i = e.indexOf(t);
          if (i !== -1 && i < e.length - 1) {
            var r = e[i + 1], s = e.indexOf(r);
            e[i] = r, e[s] = t;
          }
          return e;
        };
        j0.exports = d7;
      });
      ix = u((RTe, tx) => {
        var c7 = function(e, t, i) {
          if (t === i) return e;
          var r = e.indexOf(t), s = e.indexOf(i);
          if (r < 0 || s < 0) throw new Error("Supplied items must be elements of the same array");
          return r > s || (e.splice(r, 1), s = e.indexOf(i), e.splice(s + 1, 0, t)), e;
        };
        tx.exports = c7;
      });
      sx = u((_Te, rx) => {
        var v7 = function(e, t, i) {
          if (t === i) return e;
          var r = e.indexOf(t), s = e.indexOf(i);
          if (r < 0 || s < 0) throw new Error("Supplied items must be elements of the same array");
          return r < s || (e.splice(r, 1), s === 0 ? e.unshift(t) : e.splice(s, 0, t)), e;
        };
        rx.exports = v7;
      });
      Zu = u((PTe, nx) => {
        var p7 = function(e) {
          return e > 0 ? Math.ceil(e) : Math.floor(e);
        };
        nx.exports = p7;
      });
      ox = u((MTe, ax) => {
        var m7 = Zu(), g7 = function(e, t, i) {
          e === void 0 && (e = 0), t === void 0 && (t = null), i === void 0 && (i = 1), t === null &&
          (t = e, e = 0);
          for (var r = [], s = Math.max(m7((t - e) / (i || 1)), 0), n = 0; n < s; n++) r.push(e), e +=
          i;
          return r;
        };
        ax.exports = g7;
      });
      lx = u((qTe, ux) => {
        function gn(e, t, i) {
          var r = e[t];
          e[t] = e[i], e[i] = r;
        }
        function x7(e, t) {
          return e < t ? -1 : e > t ? 1 : 0;
        }
        var hx = function(e, t, i, r, s) {
          for (i === void 0 && (i = 0), r === void 0 && (r = e.length - 1), s === void 0 && (s = x7); r >
          i; ) {
            if (r - i > 600) {
              var n = r - i + 1, a = t - i + 1, o = Math.log(n), h = 0.5 * Math.exp(2 * o / 3), l = 0.5 *
              Math.sqrt(o * h * (n - h) / n) * (a - n / 2 < 0 ? -1 : 1), f = Math.max(i, Math.floor(
              t - a * h / n + l)), d = Math.min(r, Math.floor(t + (n - a) * h / n + l));
              hx(e, t, f, d, s);
            }
            var c = e[t], p = i, v = r;
            for (gn(e, i, t), s(e[r], c) > 0 && gn(e, i, r); p < v; ) {
              for (gn(e, p, v), p++, v--; s(e[p], c) < 0; ) p++;
              for (; s(e[v], c) > 0; ) v--;
            }
            s(e[i], c) === 0 ? gn(e, i, v) : (v++, gn(e, v, r)), v <= t && (i = v + 1), t <= v && (r =
            v - 1);
          }
        };
        ux.exports = hx;
      });
      za = u((FTe, fx) => {
        var E7 = function(e) {
          for (var t = e.length - 1; t > 0; t--) {
            var i = Math.floor(Math.random() * (t + 1)), r = e[t];
            e[t] = e[i], e[i] = r;
          }
          return e;
        };
        fx.exports = E7;
      });
      Qu = u((bTe, cx) => {
        var fs = H(), dx = za(), T72 = function(e, t, i) {
          for (var r = [], s = 0; s < e.length; s++) for (var n = 0; n < t.length; n++) for (var a = 0; a <
          i; a++) r.push({ a: e[s], b: t[n] });
          return r;
        }, y7 = function(e, t, i) {
          var r = fs(i, "max", 0), s = fs(i, "qty", 1), n = fs(i, "random", false), a = fs(i, "rando\
mB", false), o = fs(i, "repeat", 0), h = fs(i, "yoyo", false), l = [];
          if (a && dx(t), o === -1) if (r === 0) o = 0;
          else {
            var f = e.length * t.length * s;
            h && (f *= 2), o = Math.ceil(r / f);
          }
          for (var d = 0; d <= o; d++) {
            var c = T72(e, t, s);
            n && dx(c), l = l.concat(c), h && (c.reverse(), l = l.concat(c));
          }
          return r && l.splice(r), l;
        };
        cx.exports = y7;
      });
      yr = u((LTe, vx) => {
        var S72 = function(e, t) {
          if (!(t >= e.length)) {
            for (var i = e.length - 1, r = e[t], s = t; s < i; s++) e[s] = e[s + 1];
            return e.length = i, r;
          }
        };
        vx.exports = S72;
      });
      Jt = u((OTe, mx) => {
        var px = yr(), w7 = function(e, t, i, r) {
          r === void 0 && (r = e);
          var s;
          if (!Array.isArray(t)) return s = e.indexOf(t), s !== -1 ? (px(e, s), i && i.call(r, t), t) :
          null;
          for (var n = t.length - 1, a = []; n >= 0; ) {
            var o = t[n];
            s = e.indexOf(o), s !== -1 && (px(e, s), a.push(o), i && i.call(r, o)), n--;
          }
          return a;
        };
        mx.exports = w7;
      });
      xx = u((DTe, gx) => {
        var C7 = yr(), A72 = function(e, t, i, r) {
          if (r === void 0 && (r = e), t < 0 || t > e.length - 1) throw new Error("Index out of boun\
ds");
          var s = C7(e, t);
          return i && i.call(r, s), s;
        };
        gx.exports = A72;
      });
      Tx = u((NTe, Ex) => {
        var R7 = Xi(), _7 = function(e, t, i, r, s) {
          if (t === void 0 && (t = 0), i === void 0 && (i = e.length), s === void 0 && (s = e), R7(e,
          t, i)) {
            var n = i - t, a = e.splice(t, n);
            if (r) for (var o = 0; o < a.length; o++) {
              var h = a[o];
              r.call(s, h);
            }
            return a;
          } else return [];
        };
        Ex.exports = _7;
      });
      Sx = u((ITe, yx) => {
        var P7 = yr(), M7 = function(e, t, i) {
          t === void 0 && (t = 0), i === void 0 && (i = e.length);
          var r = t + Math.floor(Math.random() * i);
          return P7(e, r);
        };
        yx.exports = M7;
      });
      Cx = u((BTe, wx) => {
        var q7 = function(e, t, i) {
          var r = e.indexOf(t), s = e.indexOf(i);
          return r !== -1 && s === -1 ? (e[r] = i, true) : false;
        };
        wx.exports = q7;
      });
      Rx = u((GTe, Ax) => {
        var F72 = function(e, t) {
          var i = e.indexOf(t);
          return i !== -1 && i > 0 && (e.splice(i, 1), e.unshift(t)), t;
        };
        Ax.exports = F72;
      });
      Px = u((UTe, _x) => {
        var b7 = Xi(), L7 = function(e, t, i, r, s) {
          if (r === void 0 && (r = 0), s === void 0 && (s = e.length), b7(e, r, s)) for (var n = r; n <
          s; n++) {
            var a = e[n];
            a.hasOwnProperty(t) && (a[t] = i);
          }
          return e;
        };
        _x.exports = L7;
      });
      ds = u((zTe, Mx) => {
        var k = { android: false, chromeOS: false, cordova: false, crosswalk: false, desktop: false,
        ejecta: false, electron: false, iOS: false, iOSVersion: 0, iPad: false, iPhone: false, kindle: false,
        linux: false, macOS: false, node: false, nodeWebkit: false, pixelRatio: 1, webApp: false, windows: false,
        windowsPhone: false };
        function O72() {
          if (typeof importScripts == "function") return k;
          var e = navigator.userAgent;
          /Windows/.test(e) ? k.windows = true : /Mac OS/.test(e) && !/like Mac OS/.test(e) ? navigator.
          maxTouchPoints && navigator.maxTouchPoints > 2 ? (k.iOS = true, k.iPad = true, navigator.appVersion.
          match(/Version\/(\d+)/), k.iOSVersion = parseInt(RegExp.$1, 10)) : k.macOS = true : /Android/.
          test(e) ? k.android = true : /Linux/.test(e) ? k.linux = true : /iP[ao]d|iPhone/i.test(e) ?
          (k.iOS = true, navigator.appVersion.match(/OS (\d+)/), k.iOSVersion = parseInt(RegExp.$1, 10),
          k.iPhone = e.toLowerCase().indexOf("iphone") !== -1, k.iPad = e.toLowerCase().indexOf("ipa\
d") !== -1) : /Kindle/.test(e) || /\bKF[A-Z][A-Z]+/.test(e) || /Silk.*Mobile Safari/.test(e) ? k.kindle =
          true : /CrOS/.test(e) && (k.chromeOS = true), (/Windows Phone/i.test(e) || /IEMobile/i.test(
          e)) && (k.android = false, k.iOS = false, k.macOS = false, k.windows = true, k.windowsPhone =
          true);
          var t = /Silk/.test(e);
          return (k.windows || k.macOS || k.linux && !t || k.chromeOS) && (k.desktop = true), (k.windowsPhone ||
          /Windows NT/i.test(e) && /Touch/i.test(e)) && (k.desktop = false), navigator.standalone &&
          (k.webApp = true), typeof importScripts != "function" && (window.cordova !== void 0 && (k.
          cordova = true), window.ejecta !== void 0 && (k.ejecta = true)), typeof process != "undefi\
ned" && process.versions && process.versions.node && (k.node = true), k.node && typeof process.versions ==
          "object" && (k.nodeWebkit = !!process.versions["node-webkit"], k.electron = !!process.versions.
          electron), /Crosswalk/.test(e) && (k.crosswalk = true), k.pixelRatio = window.devicePixelRatio ||
          1, k;
        }
        Mx.exports = O72();
      });
      xn = u((kTe, qx) => {
        var Ju = ds(), ee = { chrome: false, chromeVersion: 0, edge: false, firefox: false, firefoxVersion: 0,
        ie: false, ieVersion: 0, mobileSafari: false, opera: false, safari: false, safariVersion: 0,
        silk: false, trident: false, tridentVersion: 0, es2019: false };
        function D72() {
          var e = navigator.userAgent;
          return /Edg\/\d+/.test(e) ? (ee.edge = true, ee.es2019 = true) : /OPR/.test(e) ? (ee.opera =
          true, ee.es2019 = true) : /Chrome\/(\d+)/.test(e) && !Ju.windowsPhone ? (ee.chrome = true,
          ee.chromeVersion = parseInt(RegExp.$1, 10), ee.es2019 = ee.chromeVersion > 69) : /Firefox\D+(\d+)/.
          test(e) ? (ee.firefox = true, ee.firefoxVersion = parseInt(RegExp.$1, 10), ee.es2019 = ee.
          firefoxVersion > 10) : /AppleWebKit\/(?!.*CriOS)/.test(e) && Ju.iOS ? (ee.mobileSafari = true,
          ee.es2019 = true) : /MSIE (\d+\.\d+);/.test(e) ? (ee.ie = true, ee.ieVersion = parseInt(RegExp.
          $1, 10)) : /Version\/(\d+\.\d+(\.\d+)?) Safari/.test(e) && !Ju.windowsPhone ? (ee.safari =
          true, ee.safariVersion = parseInt(RegExp.$1, 10), ee.es2019 = ee.safariVersion > 10) : /Trident\/(\d+\.\d+)(.*)rv:(\d+\.\d+)/.
          test(e) && (ee.ie = true, ee.trident = true, ee.tridentVersion = parseInt(RegExp.$1, 10), ee.
          ieVersion = parseInt(RegExp.$3, 10)), /Silk/.test(e) && (ee.silk = true), ee;
        }
        qx.exports = D72();
      });
      bx = u((XTe, Fx) => {
        var $t = "", N7 = function() {
          var e = function(s) {
            for (var n = ["i", "webkitI", "msI", "mozI", "oI"], a = 0; a < n.length; a++) {
              var o = n[a] + "mageSmoothingEnabled";
              if (o in s) return o;
            }
            return null;
          }, t = function(s) {
            return $t === "" && ($t = e(s)), $t && (s[$t] = true), s;
          }, i = function(s) {
            return $t === "" && ($t = e(s)), $t && (s[$t] = false), s;
          }, r = function(s) {
            return $t !== null ? s[$t] : null;
          };
          return { disable: i, enable: t, getPrefix: e, isEnabled: r };
        };
        Fx.exports = N7();
      });
      Tt = u((VTe, Lx) => {
        var Sr = qt(), I7 = bx(), wr = [], $u = false, B7 = function() {
          var e = function(l, f, d, c, p) {
            f === void 0 && (f = 1), d === void 0 && (d = 1), c === void 0 && (c = Sr.CANVAS), p ===
            void 0 && (p = false);
            var v, m = r(c);
            return m === null ? (m = { parent: l, canvas: document.createElement("canvas"), type: c },
            c === Sr.CANVAS && wr.push(m), v = m.canvas) : (m.parent = l, v = m.canvas), p && (m.parent =
            v), v.width = f, v.height = d, $u && c === Sr.CANVAS && I7.disable(v.getContext("2d", { willReadFrequently: false })),
            v;
          }, t = function(l, f, d) {
            return e(l, f, d, Sr.CANVAS);
          }, i = function(l, f, d) {
            return e(l, f, d, Sr.WEBGL);
          }, r = function(l) {
            if (l === void 0 && (l = Sr.CANVAS), l === Sr.WEBGL) return null;
            for (var f = 0; f < wr.length; f++) {
              var d = wr[f];
              if (!d.parent && d.type === l) return d;
            }
            return null;
          }, s = function(l) {
            var f = l instanceof HTMLCanvasElement;
            wr.forEach(function(d) {
              (f && d.canvas === l || !f && d.parent === l) && (d.parent = null, d.canvas.width = 1,
              d.canvas.height = 1);
            });
          }, n = function() {
            var l = 0;
            return wr.forEach(function(f) {
              f.parent && l++;
            }), l;
          }, a = function() {
            return wr.length - n();
          }, o = function() {
            $u = true;
          }, h = function() {
            $u = false;
          };
          return { create2D: t, create: e, createWebGL: i, disableSmoothing: o, enableSmoothing: h, first: r,
          free: a, pool: wr, remove: s, total: n };
        };
        Lx.exports = B7();
      });
      Xa = u((YTe, Ox) => {
        var G7 = ds(), Cr = xn(), ka = Tt(), ye = { canvas: false, canvasBitBltShift: null, file: false,
        fileSystem: false, getUserMedia: true, littleEndian: false, localStorage: false, pointerLock: false,
        stableSort: false, support32bit: false, vibration: false, webGL: false, worker: false };
        function U7() {
          var e = new ArrayBuffer(4), t = new Uint8Array(e), i = new Uint32Array(e);
          return t[0] = 161, t[1] = 178, t[2] = 195, t[3] = 212, i[0] === 3569595041 ? true : i[0] ===
          2712847316 ? false : null;
        }
        function z7() {
          if (typeof importScripts == "function") return ye;
          ye.canvas = !!window.CanvasRenderingContext2D;
          try {
            ye.localStorage = !!localStorage.getItem;
          } catch (i) {
            ye.localStorage = false;
          }
          ye.file = !!window.File && !!window.FileReader && !!window.FileList && !!window.Blob, ye.fileSystem =
          !!window.requestFileSystem;
          var e = false, t = function() {
            if (window.WebGLRenderingContext) try {
              var i = ka.createWebGL(this), r = i.getContext("webgl") || i.getContext("experimental-\
webgl"), s = ka.create2D(this), n = s.getContext("2d", { willReadFrequently: true }), a = n.createImageData(
              1, 1);
              return e = a.data instanceof Uint8ClampedArray, ka.remove(i), ka.remove(s), !!r;
            } catch (o) {
              return false;
            }
            return false;
          };
          return ye.webGL = t(), ye.worker = !!window.Worker, ye.pointerLock = "pointerLockElement" in
          document || "mozPointerLockElement" in document || "webkitPointerLockElement" in document,
          navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.
          mozGetUserMedia || navigator.msGetUserMedia || navigator.oGetUserMedia, window.URL = window.
          URL || window.webkitURL || window.mozURL || window.msURL, ye.getUserMedia = ye.getUserMedia &&
          !!navigator.getUserMedia && !!window.URL, Cr.firefox && Cr.firefoxVersion < 21 && (ye.getUserMedia =
          false), !G7.iOS && (Cr.ie || Cr.firefox || Cr.chrome) && (ye.canvasBitBltShift = true), (Cr.
          safari || Cr.mobileSafari) && (ye.canvasBitBltShift = false), navigator.vibrate = navigator.
          vibrate || navigator.webkitVibrate || navigator.mozVibrate || navigator.msVibrate, navigator.
          vibrate && (ye.vibration = true), typeof ArrayBuffer != "undefined" && typeof Uint8Array !=
          "undefined" && typeof Uint32Array != "undefined" && (ye.littleEndian = U7()), ye.support32bit =
          typeof ArrayBuffer != "undefined" && typeof Uint8ClampedArray != "undefined" && typeof Int32Array !=
          "undefined" && ye.littleEndian !== null && e, ye;
        }
        Ox.exports = z7();
      });
      Ix = u((WTe, Nx) => {
        var Dx = xn(), Vi = { gamepads: false, mspointer: false, touch: false, wheelEvent: null };
        function k7() {
          return typeof importScripts == "function" || (("ontouchstart" in document.documentElement ||
          navigator.maxTouchPoints && navigator.maxTouchPoints >= 1) && (Vi.touch = true), (navigator.
          msPointerEnabled || navigator.pointerEnabled) && (Vi.mspointer = true), navigator.getGamepads &&
          (Vi.gamepads = true), "onwheel" in window || Dx.ie && "WheelEvent" in window ? Vi.wheelEvent =
          "wheel" : "onmousewheel" in window ? Vi.wheelEvent = "mousewheel" : Dx.firefox && "MouseSc\
rollEvent" in window && (Vi.wheelEvent = "DOMMouseScroll")), Vi;
        }
        Nx.exports = k7();
      });
      Gx = u((HTe, Bx) => {
        var ju = xn(), dt = { flac: false, aac: false, audioData: false, dolby: false, m4a: false, mp3: false,
        ogg: false, opus: false, wav: false, webAudio: false, webm: false };
        function X7() {
          if (typeof importScripts == "function") return dt;
          dt.audioData = !!window.Audio, dt.webAudio = !!(window.AudioContext || window.webkitAudioContext);
          var e = document.createElement("audio"), t = !!e.canPlayType;
          try {
            if (t) {
              var i = function(n, a) {
                var o = e.canPlayType("audio/" + n).replace(/^no$/, "");
                return a ? !!(o || e.canPlayType("audio/" + a).replace(/^no$/, "")) : !!o;
              };
              if (dt.ogg = i('ogg; codecs="vorbis"'), dt.opus = i('ogg; codecs="opus"', "opus"), dt.
              mp3 = i("mpeg"), dt.wav = i("wav"), dt.m4a = i("x-m4a"), dt.aac = i("aac"), dt.flac = i(
              "flac", "x-flac"), dt.webm = i('webm; codecs="vorbis"'), e.canPlayType('audio/mp4; cod\
ecs="ec-3"') !== "") {
                if (ju.edge) dt.dolby = true;
                else if (ju.safari && ju.safariVersion >= 9 && /Mac OS X (\d+)_(\d+)/.test(navigator.
                userAgent)) {
                  var r = parseInt(RegExp.$1, 10), s = parseInt(RegExp.$2, 10);
                  (r === 10 && s >= 11 || r > 10) && (dt.dolby = true);
                }
              }
            }
          } catch (n) {
          }
          return dt;
        }
        Bx.exports = X7();
      });
      kx = u((KTe, zx) => {
        var Ux = B(), kt = { h264: false, hls: false, mp4: false, m4v: false, ogg: false, vp9: false,
        webm: false, hasRequestVideoFrame: false };
        function V72() {
          if (typeof importScripts == "function") return kt;
          var e = document.createElement("video"), t = !!e.canPlayType, i = /^no$/;
          try {
            t && (e.canPlayType('video/ogg; codecs="theora"').replace(i, "") && (kt.ogg = true), e.canPlayType(
            'video/mp4; codecs="avc1.42E01E"').replace(i, "") && (kt.h264 = true, kt.mp4 = true), e.
            canPlayType("video/x-m4v").replace(i, "") && (kt.m4v = true), e.canPlayType('video/webm;\
 codecs="vp8, vorbis"').replace(i, "") && (kt.webm = true), e.canPlayType('video/webm; codecs="vp9"').
            replace(i, "") && (kt.vp9 = true), e.canPlayType('application/x-mpegURL; codecs="avc1.42\
E01E"').replace(i, "") && (kt.hls = true));
          } catch (r) {
          }
          return e.parentNode && e.parentNode.removeChild(e), kt.getVideoURL = function(r) {
            Array.isArray(r) || (r = [r]);
            for (var s = 0; s < r.length; s++) {
              var n = Ux(r[s], "url", r[s]);
              if (n.indexOf("blob:") === 0) return { url: n, type: "" };
              var a;
              if (n.indexOf("data:") === 0 ? a = n.split(",")[0].match(/\/(.*?);/) : a = n.match(/\.([a-zA-Z0-9]+)($|\?)/),
              a = Ux(r[s], "type", a ? a[1] : "").toLowerCase(), kt[a]) return { url: n, type: a };
            }
            return null;
          }, kt;
        }
        zx.exports = V72();
      });
      Vx = u((ZTe, Xx) => {
        var Yi = { available: false, cancel: "", keyboard: false, request: "" };
        function Y7() {
          if (typeof importScripts == "function") return Yi;
          var e, t = "Fullscreen", i = "FullScreen", r = ["request" + t, "request" + i, "webkitReque\
st" + t, "webkitRequest" + i, "msRequest" + t, "msRequest" + i, "mozRequest" + i, "mozRequest" + t];
          for (e = 0; e < r.length; e++) if (document.documentElement[r[e]]) {
            Yi.available = true, Yi.request = r[e];
            break;
          }
          var s = ["cancel" + i, "exit" + t, "webkitCancel" + i, "webkitExit" + t, "msCancel" + i, "\
msExit" + t, "mozCancel" + i, "mozExit" + t];
          if (Yi.available) {
            for (e = 0; e < s.length; e++) if (document[s[e]]) {
              Yi.cancel = s[e];
              break;
            }
          }
          return window.Element && Element.ALLOW_KEYBOARD_INPUT && !/ Version\/5\.1(?:\.\d+)? Safari\//.
          test(navigator.userAgent) && (Yi.keyboard = true), Object.defineProperty(Yi, "active", { get: function() {
            return !!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement ||
            document.msFullscreenElement);
          } }), Yi;
        }
        Xx.exports = Y7();
      });
      el = u((QTe, Yx) => {
        var Ya = Tt(), Va = { supportInverseAlpha: false, supportNewBlendModes: false };
        function W7() {
          var e = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAABAQMAAADD8p2OAAAAA1BMVEX/", t = "\
AAAACklEQVQI12NgAAAAAgAB4iG8MwAAAABJRU5ErkJggg==", i = new Image();
          return i.onload = function() {
            var r = new Image();
            r.onload = function() {
              var s = Ya.create2D(r, 6), n = s.getContext("2d", { willReadFrequently: true });
              if (n.globalCompositeOperation = "multiply", n.drawImage(i, 0, 0), n.drawImage(r, 2, 0),
              !n.getImageData(2, 0, 1, 1)) return false;
              var a = n.getImageData(2, 0, 1, 1).data;
              Ya.remove(r), Va.supportNewBlendModes = a[0] === 255 && a[1] === 0 && a[2] === 0;
            }, r.src = e + "/wCKxvRF" + t;
          }, i.src = e + "AP804Oa6" + t, false;
        }
        function H7() {
          var e = Ya.create2D(this, 2), t = e.getContext("2d", { willReadFrequently: true });
          t.fillStyle = "rgba(10, 20, 30, 0.5)", t.fillRect(0, 0, 1, 1);
          var i = t.getImageData(0, 0, 1, 1);
          if (i === null) return false;
          t.putImageData(i, 1, 0);
          var r = t.getImageData(1, 0, 1, 1), s = r.data[0] === i.data[0] && r.data[1] === i.data[1] &&
          r.data[2] === i.data[2] && r.data[3] === i.data[3];
          return Ya.remove(this), s;
        }
        function K7() {
          return typeof importScripts != "function" && document !== void 0 && (Va.supportNewBlendModes =
          W7(), Va.supportInverseAlpha = H7()), Va;
        }
        Yx.exports = K7();
      });
      En = u((JTe, Wx) => {
        Wx.exports = { os: ds(), browser: xn(), features: Xa(), input: Ix(), audio: Gx(), video: kx(),
        fullscreen: Vx(), canvasFeatures: el() };
      });
      Tn = u(($Te, Kx) => {
        var Z7 = En();
        function Q7(e, t) {
          return String(e).localeCompare(t);
        }
        function J7(e, t) {
          var i = e.length;
          if (i <= 1) return e;
          for (var r = new Array(i), s = 1; s < i; s *= 2) {
            Hx(e, t, s, r);
            var n = e;
            e = r, r = n;
          }
          return e;
        }
        function Hx(e, t, i, r) {
          var s = e.length, n = 0, a = i * 2, o, h, l, f, d;
          for (o = 0; o < s; o += a) for (h = o + i, l = h + i, h > s && (h = s), l > s && (l = s), f =
          o, d = h; ; ) if (f < h && d < l) t(e[f], e[d]) <= 0 ? r[n++] = e[f++] : r[n++] = e[d++];
          else if (f < h) r[n++] = e[f++];
          else if (d < l) r[n++] = e[d++];
          else break;
        }
        var $7 = function(e, t) {
          if (t === void 0 && (t = Q7), !e || e.length < 2) return e;
          if (Z7.features.stableSort) return e.sort(t);
          var i = J7(e, t);
          return i !== e && Hx(i, null, e.length, e), e;
        };
        Kx.exports = $7;
      });
      Qx = u((jTe, Zx) => {
        var j7 = function(e, t, i) {
          if (t === i) return e;
          var r = e.indexOf(t), s = e.indexOf(i);
          if (r < 0 || s < 0) throw new Error("Supplied items must be elements of the same array");
          return e[r] = i, e[s] = t, e;
        };
        Zx.exports = j7;
      });
      yn = u((eye, Jx) => {
        Jx.exports = { Matrix: q0(), Add: b0(), AddAt: O0(), BringToTop: N0(), CountAllMatching: G0(),
        Each: mn(), EachInRange: k0(), FindClosestInSorted: cu(), Flatten: Wu(), GetAll: Ua(), GetFirst: Hu(),
        GetRandom: Ku(), MoveDown: Q0(), MoveTo: $0(), MoveUp: ex(), MoveAbove: ix(), MoveBelow: sx(),
        NumberArray: gu(), NumberArrayStep: ox(), QuickSelect: lx(), Range: Qu(), Remove: Jt(), RemoveAt: xx(),
        RemoveBetween: Tx(), RemoveRandomElement: Sx(), Replace: Cx(), RotateLeft: Ba(), RotateRight: Ga(),
        SafeRange: Xi(), SendToBack: Rx(), SetAll: Px(), Shuffle: za(), SortByDigits: pu(), SpliceOne: yr(),
        StableSort: Tn(), Swap: Qx() };
      });
      jx = u((tye, $x) => {
        var Wa = yn(), eK = { _depth: 0, depth: { get: function() {
          return this._depth;
        }, set: function(e) {
          this.displayList && this.displayList.queueDepthSort(), this._depth = e;
        } }, setDepth: function(e) {
          return e === void 0 && (e = 0), this.depth = e, this;
        }, setToTop: function() {
          var e = this.getDisplayList();
          return e && Wa.BringToTop(e, this), this;
        }, setToBack: function() {
          var e = this.getDisplayList();
          return e && Wa.SendToBack(e, this), this;
        }, setAbove: function(e) {
          var t = this.getDisplayList();
          return t && e && Wa.MoveAbove(t, this, e), this;
        }, setBelow: function(e) {
          var t = this.getDisplayList();
          return t && e && Wa.MoveBelow(t, this, e), this;
        } };
        $x.exports = eK;
      });
      tE = u((iye, eE) => {
        var tK = { flipX: false, flipY: false, toggleFlipX: function() {
          return this.flipX = !this.flipX, this;
        }, toggleFlipY: function() {
          return this.flipY = !this.flipY, this;
        }, setFlipX: function(e) {
          return this.flipX = e, this;
        }, setFlipY: function(e) {
          return this.flipY = e, this;
        }, setFlip: function(e, t) {
          return this.flipX = e, this.flipY = t, this;
        }, resetFlip: function() {
          return this.flipX = false, this.flipY = false, this;
        } };
        eE.exports = tK;
      });
      Me = u((rye, iE) => {
        var iK = { GLOW: 4, SHADOW: 5, PIXELATE: 6, VIGNETTE: 7, SHINE: 8, BLUR: 9, GRADIENT: 12, BLOOM: 13,
        COLOR_MATRIX: 14, CIRCLE: 15, BARREL: 16, DISPLACEMENT: 17, WIPE: 18, BOKEH: 19 };
        iE.exports = iK;
      });
      it = u((sye, rE) => {
        var rK = C(), sK = new rK({ initialize: function(t, i) {
          this.type = t, this.gameObject = i, this.active = true;
        }, setActive: function(e) {
          return this.active = e, this;
        }, destroy: function() {
          this.gameObject = null, this.active = false;
        } });
        rE.exports = sK;
      });
      aE = u((nye, nE) => {
        var nK = C(), sE = it(), aK = Me(), oK = new nK({ Extends: sE, initialize: function(t, i) {
          i === void 0 && (i = 1), sE.call(this, aK.BARREL, t), this.amount = i;
        } });
        nE.exports = oK;
      });
      uE = u((aye, hE) => {
        var hK = C(), oE = it(), uK = Me(), lK = new hK({ Extends: oE, initialize: function(t, i, r, s, n, a, o) {
          r === void 0 && (r = 1), s === void 0 && (s = 1), n === void 0 && (n = 1), a === void 0 &&
          (a = 1), o === void 0 && (o = 4), oE.call(this, uK.BLOOM, t), this.steps = o, this.offsetX =
          r, this.offsetY = s, this.blurStrength = n, this.strength = a, this.glcolor = [1, 1, 1], i !=
          null && (this.color = i);
        }, color: { get: function() {
          var e = this.glcolor;
          return (e[0] * 255 << 16) + (e[1] * 255 << 8) + (e[2] * 255 | 0);
        }, set: function(e) {
          var t = this.glcolor;
          t[0] = (e >> 16 & 255) / 255, t[1] = (e >> 8 & 255) / 255, t[2] = (e & 255) / 255;
        } } });
        hE.exports = lK;
      });
      dE = u((oye, fE) => {
        var fK = C(), lE = it(), dK = Me(), cK = new fK({ Extends: lE, initialize: function(t, i, r, s, n, a, o) {
          i === void 0 && (i = 0), r === void 0 && (r = 2), s === void 0 && (s = 2), n === void 0 &&
          (n = 1), o === void 0 && (o = 4), lE.call(this, dK.BLUR, t), this.quality = i, this.x = r,
          this.y = s, this.steps = o, this.strength = n, this.glcolor = [1, 1, 1], a != null && (this.
          color = a);
        }, color: { get: function() {
          var e = this.glcolor;
          return (e[0] * 255 << 16) + (e[1] * 255 << 8) + (e[2] * 255 | 0);
        }, set: function(e) {
          var t = this.glcolor;
          t[0] = (e >> 16 & 255) / 255, t[1] = (e >> 8 & 255) / 255, t[2] = (e & 255) / 255;
        } } });
        fE.exports = cK;
      });
      pE = u((hye, vE) => {
        var vK = C(), cE = it(), pK = Me(), mK = new vK({ Extends: cE, initialize: function(t, i, r, s, n, a, o, h) {
          i === void 0 && (i = 0.5), r === void 0 && (r = 1), s === void 0 && (s = 0.2), n === void 0 &&
          (n = false), a === void 0 && (a = 1), o === void 0 && (o = 1), h === void 0 && (h = 1), cE.
          call(this, pK.BOKEH, t), this.radius = i, this.amount = r, this.contrast = s, this.isTiltShift =
          n, this.strength = h, this.blurX = a, this.blurY = o;
        } });
        vE.exports = mK;
      });
      xE = u((uye, gE) => {
        var gK = C(), mE = it(), xK = Me(), EK = new gK({ Extends: mE, initialize: function(t, i, r, s, n, a) {
          i === void 0 && (i = 8), n === void 0 && (n = 1), a === void 0 && (a = 5e-3), mE.call(this,
          xK.CIRCLE, t), this.scale = n, this.feather = a, this.thickness = i, this.glcolor = [1, 0.2,
          0.7], this.glcolor2 = [1, 0, 0, 0.4], r != null && (this.color = r), s != null && (this.backgroundColor =
          s);
        }, color: { get: function() {
          var e = this.glcolor;
          return (e[0] * 255 << 16) + (e[1] * 255 << 8) + (e[2] * 255 | 0);
        }, set: function(e) {
          var t = this.glcolor;
          t[0] = (e >> 16 & 255) / 255, t[1] = (e >> 8 & 255) / 255, t[2] = (e & 255) / 255;
        } }, backgroundColor: { get: function() {
          var e = this.glcolor2;
          return (e[0] * 255 << 16) + (e[1] * 255 << 8) + (e[2] * 255 | 0);
        }, set: function(e) {
          var t = this.glcolor2;
          t[0] = (e >> 16 & 255) / 255, t[1] = (e >> 8 & 255) / 255, t[2] = (e & 255) / 255;
        } }, backgroundAlpha: { get: function() {
          return this.glcolor2[3];
        }, set: function(e) {
          this.glcolor2[3] = e;
        } } });
        gE.exports = EK;
      });
      Ha = u((lye, EE) => {
        var TK = C(), yK = new Float32Array(20), oe = new TK({ initialize: function() {
          this._matrix = new Float32Array(20), this.alpha = 1, this._dirty = true, this._data = new Float32Array(
          20), this.reset();
        }, set: function(e) {
          return this._matrix.set(e), this._dirty = true, this;
        }, reset: function() {
          var e = this._matrix;
          return e.fill(0), e[0] = 1, e[6] = 1, e[12] = 1, e[18] = 1, this.alpha = 1, this._dirty = true,
          this;
        }, getData: function() {
          var e = this._data;
          return this._dirty && (e.set(this._matrix), e[4] /= 255, e[9] /= 255, e[14] /= 255, e[19] /=
          255, this._dirty = false), e;
        }, brightness: function(e, t) {
          e === void 0 && (e = 0), t === void 0 && (t = false);
          var i = e;
          return this.multiply([i, 0, 0, 0, 0, 0, i, 0, 0, 0, 0, 0, i, 0, 0, 0, 0, 0, 1, 0], t);
        }, saturate: function(e, t) {
          e === void 0 && (e = 0), t === void 0 && (t = false);
          var i = e * 2 / 3 + 1, r = (i - 1) * -0.5;
          return this.multiply([i, r, r, 0, 0, r, i, r, 0, 0, r, r, i, 0, 0, 0, 0, 0, 1, 0], t);
        }, desaturate: function(e) {
          return e === void 0 && (e = false), this.saturate(-1, e);
        }, hue: function(e, t) {
          e === void 0 && (e = 0), t === void 0 && (t = false), e = e / 180 * Math.PI;
          var i = Math.cos(e), r = Math.sin(e), s = 0.213, n = 0.715, a = 0.072;
          return this.multiply([s + i * (1 - s) + r * -s, n + i * -n + r * -n, a + i * -a + r * (1 -
          a), 0, 0, s + i * -s + r * 0.143, n + i * (1 - n) + r * 0.14, a + i * -a + r * -0.283, 0, 0,
          s + i * -s + r * -(1 - s), n + i * -n + r * n, a + i * (1 - a) + r * a, 0, 0, 0, 0, 0, 1, 0],
          t);
        }, grayscale: function(e, t) {
          return e === void 0 && (e = 1), t === void 0 && (t = false), this.saturate(-e, t);
        }, blackWhite: function(e) {
          return e === void 0 && (e = false), this.multiply(oe.BLACK_WHITE, e);
        }, contrast: function(e, t) {
          e === void 0 && (e = 0), t === void 0 && (t = false);
          var i = e + 1, r = -0.5 * (i - 1);
          return this.multiply([i, 0, 0, 0, r, 0, i, 0, 0, r, 0, 0, i, 0, r, 0, 0, 0, 1, 0], t);
        }, negative: function(e) {
          return e === void 0 && (e = false), this.multiply(oe.NEGATIVE, e);
        }, desaturateLuminance: function(e) {
          return e === void 0 && (e = false), this.multiply(oe.DESATURATE_LUMINANCE, e);
        }, sepia: function(e) {
          return e === void 0 && (e = false), this.multiply(oe.SEPIA, e);
        }, night: function(e, t) {
          return e === void 0 && (e = 0.1), t === void 0 && (t = false), this.multiply([e * -2, -e, 0,
          0, 0, -e, 0, e, 0, 0, 0, e, e * 2, 0, 0, 0, 0, 0, 1, 0], t);
        }, lsd: function(e) {
          return e === void 0 && (e = false), this.multiply(oe.LSD, e);
        }, brown: function(e) {
          return e === void 0 && (e = false), this.multiply(oe.BROWN, e);
        }, vintagePinhole: function(e) {
          return e === void 0 && (e = false), this.multiply(oe.VINTAGE, e);
        }, kodachrome: function(e) {
          return e === void 0 && (e = false), this.multiply(oe.KODACHROME, e);
        }, technicolor: function(e) {
          return e === void 0 && (e = false), this.multiply(oe.TECHNICOLOR, e);
        }, polaroid: function(e) {
          return e === void 0 && (e = false), this.multiply(oe.POLAROID, e);
        }, shiftToBGR: function(e) {
          return e === void 0 && (e = false), this.multiply(oe.SHIFT_BGR, e);
        }, multiply: function(e, t) {
          t === void 0 && (t = false), t || this.reset();
          var i = this._matrix, r = yK;
          return r.set(i), i.set([r[0] * e[0] + r[1] * e[5] + r[2] * e[10] + r[3] * e[15], r[0] * e[1] +
          r[1] * e[6] + r[2] * e[11] + r[3] * e[16], r[0] * e[2] + r[1] * e[7] + r[2] * e[12] + r[3] *
          e[17], r[0] * e[3] + r[1] * e[8] + r[2] * e[13] + r[3] * e[18], r[0] * e[4] + r[1] * e[9] +
          r[2] * e[14] + r[3] * e[19] + r[4], r[5] * e[0] + r[6] * e[5] + r[7] * e[10] + r[8] * e[15],
          r[5] * e[1] + r[6] * e[6] + r[7] * e[11] + r[8] * e[16], r[5] * e[2] + r[6] * e[7] + r[7] *
          e[12] + r[8] * e[17], r[5] * e[3] + r[6] * e[8] + r[7] * e[13] + r[8] * e[18], r[5] * e[4] +
          r[6] * e[9] + r[7] * e[14] + r[8] * e[19] + r[9], r[10] * e[0] + r[11] * e[5] + r[12] * e[10] +
          r[13] * e[15], r[10] * e[1] + r[11] * e[6] + r[12] * e[11] + r[13] * e[16], r[10] * e[2] +
          r[11] * e[7] + r[12] * e[12] + r[13] * e[17], r[10] * e[3] + r[11] * e[8] + r[12] * e[13] +
          r[13] * e[18], r[10] * e[4] + r[11] * e[9] + r[12] * e[14] + r[13] * e[19] + r[14], r[15] *
          e[0] + r[16] * e[5] + r[17] * e[10] + r[18] * e[15], r[15] * e[1] + r[16] * e[6] + r[17] *
          e[11] + r[18] * e[16], r[15] * e[2] + r[16] * e[7] + r[17] * e[12] + r[18] * e[17], r[15] *
          e[3] + r[16] * e[8] + r[17] * e[13] + r[18] * e[18], r[15] * e[4] + r[16] * e[9] + r[17] *
          e[14] + r[18] * e[19] + r[19]]), this._dirty = true, this;
        } });
        oe.BLACK_WHITE = [0.3, 0.6, 0.1, 0, 0, 0.3, 0.6, 0.1, 0, 0, 0.3, 0.6, 0.1, 0, 0, 0, 0, 0, 1,
        0];
        oe.NEGATIVE = [-1, 0, 0, 1, 0, 0, -1, 0, 1, 0, 0, 0, -1, 1, 0, 0, 0, 0, 1, 0];
        oe.DESATURATE_LUMINANCE = [0.2764723, 0.929708, 0.0938197, 0, -37.1, 0.2764723, 0.929708, 0.0938197,
        0, -37.1, 0.2764723, 0.929708, 0.0938197, 0, -37.1, 0, 0, 0, 1, 0];
        oe.SEPIA = [0.393, 0.7689999, 0.18899999, 0, 0, 0.349, 0.6859999, 0.16799999, 0, 0, 0.272, 0.5339999,
        0.13099999, 0, 0, 0, 0, 0, 1, 0];
        oe.LSD = [2, -0.4, 0.5, 0, 0, -0.5, 2, -0.4, 0, 0, -0.4, -0.5, 3, 0, 0, 0, 0, 0, 1, 0];
        oe.BROWN = [0.5997023498159715, 0.34553243048391263, -0.2708298674538042, 0, 47.43192855600873,
        -0.037703249837783157, 0.8609577587992641, 0.15059552388459913, 0, -36.96841498319127, 0.24113635128153335,
        -0.07441037908422492, 0.44972182064877153, 0, -7.562075277591283, 0, 0, 0, 1, 0];
        oe.VINTAGE = [0.6279345635605994, 0.3202183420819367, -0.03965408211312453, 0, 9.651285835294123,
        0.02578397704808868, 0.6441188644374771, 0.03259127616149294, 0, 7.462829176470591, 0.0466055556782719,
        -0.0851232987247891, 0.5241648018700465, 0, 5.159190588235296, 0, 0, 0, 1, 0];
        oe.KODACHROME = [1.1285582396593525, -0.3967382283601348, -0.03992559172921793, 0, 63.72958762196502,
        -0.16404339962244616, 1.0835251566291304, -0.05498805115633132, 0, 24.732407896706203, -0.16786010706155763,
        -0.5603416277695248, 1.6014850761964943, 0, 35.62982807460946, 0, 0, 0, 1, 0];
        oe.TECHNICOLOR = [1.9125277891456083, -0.8545344976951645, -0.09155508482755585, 0, 11.793603434377337,
        -0.3087833385928097, 1.7658908555458428, -0.10601743074722245, 0, -70.35205161461398, -0.231103377548616,
        -0.7501899197440212, 1.847597816108189, 0, 30.950940869491138, 0, 0, 0, 1, 0];
        oe.POLAROID = [1.438, -0.062, -0.062, 0, 0, -0.122, 1.378, -0.122, 0, 0, -0.016, -0.016, 1.483,
        0, 0, 0, 0, 0, 1, 0];
        oe.SHIFT_BGR = [0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0];
        EE.exports = oe;
      });
      SE = u((fye, yE) => {
        var SK = C(), TE = Ha(), wK = Me(), CK = new SK({ Extends: TE, initialize: function(t) {
          TE.call(this), this.type = wK.COLOR_MATRIX, this.gameObject = t, this.active = true;
        }, destroy: function() {
          this.gameObject = null, this._matrix = null, this._data = null;
        } });
        yE.exports = CK;
      });
      AE = u((dye, CE) => {
        var AK = C(), wE = it(), RK = Me(), _K = new AK({ Extends: wE, initialize: function(t, i, r, s) {
          i === void 0 && (i = "__WHITE"), r === void 0 && (r = 5e-3), s === void 0 && (s = 5e-3), wE.
          call(this, RK.DISPLACEMENT, t), this.x = r, this.y = s, this.glTexture, this.setTexture(i);
        }, setTexture: function(e) {
          var t = this.gameObject.scene.sys.textures.getFrame(e);
          return t && (this.glTexture = t.glTexture), this;
        } });
        CE.exports = _K;
      });
      PE = u((cye, _E) => {
        var PK = C(), RE = it(), MK = Me(), qK = new PK({ Extends: RE, initialize: function(t, i, r, s, n) {
          r === void 0 && (r = 4), s === void 0 && (s = 0), n === void 0 && (n = false), RE.call(this,
          MK.GLOW, t), this.outerStrength = r, this.innerStrength = s, this.knockout = n, this.glcolor =
          [1, 1, 1, 1], i !== void 0 && (this.color = i);
        }, color: { get: function() {
          var e = this.glcolor;
          return (e[0] * 255 << 16) + (e[1] * 255 << 8) + (e[2] * 255 | 0);
        }, set: function(e) {
          var t = this.glcolor;
          t[0] = (e >> 16 & 255) / 255, t[1] = (e >> 8 & 255) / 255, t[2] = (e & 255) / 255;
        } } });
        _E.exports = qK;
      });
      FE = u((vye, qE) => {
        var FK = C(), ME = it(), bK = Me(), LK = new FK({ Extends: ME, initialize: function(t, i, r, s, n, a, o, h, l) {
          s === void 0 && (s = 0.2), n === void 0 && (n = 0), a === void 0 && (a = 0), o === void 0 &&
          (o = 0), h === void 0 && (h = 1), l === void 0 && (l = 0), ME.call(this, bK.GRADIENT, t), this.
          alpha = s, this.size = l, this.fromX = n, this.fromY = a, this.toX = o, this.toY = h, this.
          glcolor1 = [255, 0, 0], this.glcolor2 = [0, 255, 0], i != null && (this.color1 = i), r != null &&
          (this.color2 = r);
        }, color1: { get: function() {
          var e = this.glcolor1;
          return (e[0] << 16) + (e[1] << 8) + (e[2] | 0);
        }, set: function(e) {
          var t = this.glcolor1;
          t[0] = e >> 16 & 255, t[1] = e >> 8 & 255, t[2] = e & 255;
        } }, color2: { get: function() {
          var e = this.glcolor2;
          return (e[0] << 16) + (e[1] << 8) + (e[2] | 0);
        }, set: function(e) {
          var t = this.glcolor2;
          t[0] = e >> 16 & 255, t[1] = e >> 8 & 255, t[2] = e & 255;
        } } });
        qE.exports = LK;
      });
      OE = u((pye, LE) => {
        var OK = C(), bE = it(), DK = Me(), NK = new OK({ Extends: bE, initialize: function(t, i) {
          i === void 0 && (i = 1), bE.call(this, DK.PIXELATE, t), this.amount = i;
        } });
        LE.exports = NK;
      });
      IE = u((mye, NE) => {
        var IK = C(), DE = it(), BK = Me(), GK = new IK({ Extends: DE, initialize: function(t, i, r, s, n, a, o, h) {
          i === void 0 && (i = 0), r === void 0 && (r = 0), s === void 0 && (s = 0.1), n === void 0 &&
          (n = 1), o === void 0 && (o = 6), h === void 0 && (h = 1), DE.call(this, BK.SHADOW, t), this.
          x = i, this.y = r, this.decay = s, this.power = n, this.glcolor = [0, 0, 0, 1], this.samples =
          o, this.intensity = h, a !== void 0 && (this.color = a);
        }, color: { get: function() {
          var e = this.glcolor;
          return (e[0] * 255 << 16) + (e[1] * 255 << 8) + (e[2] * 255 | 0);
        }, set: function(e) {
          var t = this.glcolor;
          t[0] = (e >> 16 & 255) / 255, t[1] = (e >> 8 & 255) / 255, t[2] = (e & 255) / 255;
        } } });
        NE.exports = GK;
      });
      UE = u((gye, GE) => {
        var UK = C(), BE = it(), zK = Me(), kK = new UK({ Extends: BE, initialize: function(t, i, r, s, n) {
          i === void 0 && (i = 0.5), r === void 0 && (r = 0.5), s === void 0 && (s = 3), n === void 0 &&
          (n = false), BE.call(this, zK.SHINE, t), this.speed = i, this.lineWidth = r, this.gradient =
          s, this.reveal = n;
        } });
        GE.exports = kK;
      });
      XE = u((xye, kE) => {
        var XK = C(), zE = it(), VK = Me(), YK = new XK({ Extends: zE, initialize: function(t, i, r, s, n) {
          i === void 0 && (i = 0.5), r === void 0 && (r = 0.5), s === void 0 && (s = 0.5), n === void 0 &&
          (n = 0.5), zE.call(this, VK.VIGNETTE, t), this.x = i, this.y = r, this.radius = s, this.strength =
          n;
        } });
        kE.exports = YK;
      });
      WE = u((Eye, YE) => {
        var WK = C(), VE = it(), HK = Me(), KK = new WK({ Extends: VE, initialize: function(t, i, r, s, n) {
          i === void 0 && (i = 0.1), r === void 0 && (r = 0), s === void 0 && (s = 0), n === void 0 &&
          (n = false), VE.call(this, HK.WIPE, t), this.progress = 0, this.wipeWidth = i, this.direction =
          r, this.axis = s, this.reveal = n;
        } });
        YE.exports = KK;
      });
      KE = u((Tye, HE) => {
        var ZK = Xe(), QK = Me(), tl = { Barrel: aE(), Controller: it(), Bloom: uE(), Blur: dE(), Bokeh: pE(),
        Circle: xE(), ColorMatrix: SE(), Displacement: AE(), Glow: PE(), Gradient: FE(), Pixelate: OE(),
        Shadow: IE(), Shine: UE(), Vignette: XE(), Wipe: WE() };
        tl = ZK(false, tl, QK);
        HE.exports = tl;
      });
      il = u((yye, ZE) => {
        var JK = C(), We = KE(), $K = yr(), jK = new JK({ initialize: function(t, i) {
          this.gameObject = t, this.isPost = i, this.enabled = false, this.list = [], this.padding =
          0;
        }, setPadding: function(e) {
          return e === void 0 && (e = 0), this.padding = e, this.gameObject;
        }, onFXCopy: function() {
        }, onFX: function() {
        }, enable: function(e) {
          if (!this.isPost) {
            var t = this.gameObject.scene.sys.renderer;
            t && t.pipelines ? (this.gameObject.pipeline = t.pipelines.FX_PIPELINE, e !== void 0 && (this.
            padding = e), this.enabled = true) : this.enabled = false;
          }
        }, clear: function() {
          if (this.isPost) this.gameObject.resetPostPipeline(true);
          else {
            for (var e = this.list, t = 0; t < e.length; t++) e[t].destroy();
            this.list = [];
          }
          return this.enabled = false, this.gameObject;
        }, remove: function(e) {
          var t;
          if (this.isPost) {
            var i = this.gameObject.getPostPipeline(String(e.type));
            for (Array.isArray(i) || (i = [i]), t = 0; t < i.length; t++) {
              var r = i[t];
              if (r.controller === e) {
                this.gameObject.removePostPipeline(r), e.destroy();
                break;
              }
            }
          } else {
            var s = this.list;
            for (t = 0; t < s.length; t++) s[t] === e && ($K(s, t), e.destroy());
          }
          return this.gameObject;
        }, disable: function(e) {
          return e === void 0 && (e = false), this.isPost || this.gameObject.resetPipeline(), this.enabled =
          false, e && this.clear(), this.gameObject;
        }, add: function(e, t) {
          if (this.isPost) {
            var i = String(e.type);
            this.gameObject.setPostPipeline(i, t);
            var r = this.gameObject.getPostPipeline(i);
            if (r) return Array.isArray(r) && (r = r.pop()), r && (r.controller = e), e;
          } else return this.enabled || this.enable(), this.list.push(e), e;
        }, addGlow: function(e, t, i, r, s, n) {
          return this.add(new We.Glow(this.gameObject, e, t, i, r), { quality: s, distance: n });
        }, addShadow: function(e, t, i, r, s, n, a) {
          return this.add(new We.Shadow(this.gameObject, e, t, i, r, s, n, a));
        }, addPixelate: function(e) {
          return this.add(new We.Pixelate(this.gameObject, e));
        }, addVignette: function(e, t, i, r) {
          return this.add(new We.Vignette(this.gameObject, e, t, i, r));
        }, addShine: function(e, t, i, r) {
          return this.add(new We.Shine(this.gameObject, e, t, i, r));
        }, addBlur: function(e, t, i, r, s, n) {
          return this.add(new We.Blur(this.gameObject, e, t, i, r, s, n));
        }, addGradient: function(e, t, i, r, s, n, a, o) {
          return this.add(new We.Gradient(this.gameObject, e, t, i, r, s, n, a, o));
        }, addBloom: function(e, t, i, r, s, n) {
          return this.add(new We.Bloom(this.gameObject, e, t, i, r, s, n));
        }, addColorMatrix: function() {
          return this.add(new We.ColorMatrix(this.gameObject));
        }, addCircle: function(e, t, i, r, s) {
          return this.add(new We.Circle(this.gameObject, e, t, i, r, s));
        }, addBarrel: function(e) {
          return this.add(new We.Barrel(this.gameObject, e));
        }, addDisplacement: function(e, t, i) {
          return this.add(new We.Displacement(this.gameObject, e, t, i));
        }, addWipe: function(e, t, i) {
          return this.add(new We.Wipe(this.gameObject, e, t, i));
        }, addReveal: function(e, t, i) {
          return this.add(new We.Wipe(this.gameObject, e, t, i, true));
        }, addBokeh: function(e, t, i) {
          return this.add(new We.Bokeh(this.gameObject, e, t, i));
        }, addTiltShift: function(e, t, i, r, s, n) {
          return this.add(new We.Bokeh(this.gameObject, e, t, i, true, r, s, n));
        }, destroy: function() {
          this.clear(), this.gameObject = null;
        } });
        ZE.exports = jK;
      });
      Ar = u((Sye, QE) => {
        var eZ = function(e, t, i) {
          return e.width <= 0 || e.height <= 0 ? false : e.x <= t && e.x + e.width >= t && e.y <= i &&
          e.y + e.height >= i;
        };
        QE.exports = eZ;
      });
      Sn = u((wye, JE) => {
        var tZ = function(e) {
          return 2 * (e.width + e.height);
        };
        JE.exports = tZ;
      });
      Ka = u((Cye, $E) => {
        var iZ = Sn(), rZ = ae(), sZ = function(e, t, i) {
          if (i === void 0 && (i = new rZ()), t <= 0 || t >= 1) return i.x = e.x, i.y = e.y, i;
          var r = iZ(e) * t;
          return t > 0.5 ? (r -= e.width + e.height, r <= e.width ? (i.x = e.right - r, i.y = e.bottom) :
          (i.x = e.x, i.y = e.bottom - (r - e.width))) : r <= e.width ? (i.x = e.x + r, i.y = e.y) :
          (i.x = e.right, i.y = e.y + (r - e.width)), i;
        };
        $E.exports = sZ;
      });
      rl = u((Aye, jE) => {
        var nZ = Ka(), aZ = Sn(), oZ = function(e, t, i, r) {
          r === void 0 && (r = []), !t && i > 0 && (t = aZ(e) / i);
          for (var s = 0; s < t; s++) {
            var n = s / t;
            r.push(nZ(e, n));
          }
          return r;
        };
        jE.exports = oZ;
      });
      sl = u((Rye, eT) => {
        var hZ = ae(), uZ = function(e, t, i) {
          return i === void 0 && (i = new hZ()), i.x = e.x1 + (e.x2 - e.x1) * t, i.y = e.y1 + (e.y2 -
          e.y1) * t, i;
        };
        eT.exports = uZ;
      });
      cs = u((_ye, tT) => {
        var lZ = function(e) {
          return Math.sqrt((e.x2 - e.x1) * (e.x2 - e.x1) + (e.y2 - e.y1) * (e.y2 - e.y1));
        };
        tT.exports = lZ;
      });
      Za = u((Pye, iT) => {
        var fZ = cs(), dZ = ae(), cZ = function(e, t, i, r) {
          r === void 0 && (r = []), !t && i > 0 && (t = fZ(e) / i);
          for (var s = e.x1, n = e.y1, a = e.x2, o = e.y2, h = 0; h < t; h++) {
            var l = h / t, f = s + (a - s) * l, d = n + (o - n) * l;
            r.push(new dZ(f, d));
          }
          return r;
        };
        iT.exports = cZ;
      });
      Qa = u((Mye, rT) => {
        var vZ = ae(), pZ = function(e, t) {
          t === void 0 && (t = new vZ());
          var i = Math.random();
          return t.x = e.x1 + i * (e.x2 - e.x1), t.y = e.y1 + i * (e.y2 - e.y1), t;
        };
        rT.exports = pZ;
      });
      Ja = u((qye, sT) => {
        var mZ = function(e, t, i) {
          return i === void 0 && (i = 1e-4), Math.abs(e - t) < i;
        };
        sT.exports = mZ;
      });
      Y = u((Fye, aT) => {
        var gZ = C(), nT = Ja(), ct = new gZ({ initialize: function(t, i) {
          this.x = 0, this.y = 0, typeof t == "object" ? (this.x = t.x || 0, this.y = t.y || 0) : (i ===
          void 0 && (i = t), this.x = t || 0, this.y = i || 0);
        }, clone: function() {
          return new ct(this.x, this.y);
        }, copy: function(e) {
          return this.x = e.x || 0, this.y = e.y || 0, this;
        }, setFromObject: function(e) {
          return this.x = e.x || 0, this.y = e.y || 0, this;
        }, set: function(e, t) {
          return t === void 0 && (t = e), this.x = e, this.y = t, this;
        }, setTo: function(e, t) {
          return this.set(e, t);
        }, setToPolar: function(e, t) {
          return t == null && (t = 1), this.x = Math.cos(e) * t, this.y = Math.sin(e) * t, this;
        }, equals: function(e) {
          return this.x === e.x && this.y === e.y;
        }, fuzzyEquals: function(e, t) {
          return nT(this.x, e.x, t) && nT(this.y, e.y, t);
        }, angle: function() {
          var e = Math.atan2(this.y, this.x);
          return e < 0 && (e += 2 * Math.PI), e;
        }, setAngle: function(e) {
          return this.setToPolar(e, this.length());
        }, add: function(e) {
          return this.x += e.x, this.y += e.y, this;
        }, subtract: function(e) {
          return this.x -= e.x, this.y -= e.y, this;
        }, multiply: function(e) {
          return this.x *= e.x, this.y *= e.y, this;
        }, scale: function(e) {
          return isFinite(e) ? (this.x *= e, this.y *= e) : (this.x = 0, this.y = 0), this;
        }, divide: function(e) {
          return this.x /= e.x, this.y /= e.y, this;
        }, negate: function() {
          return this.x = -this.x, this.y = -this.y, this;
        }, distance: function(e) {
          var t = e.x - this.x, i = e.y - this.y;
          return Math.sqrt(t * t + i * i);
        }, distanceSq: function(e) {
          var t = e.x - this.x, i = e.y - this.y;
          return t * t + i * i;
        }, length: function() {
          var e = this.x, t = this.y;
          return Math.sqrt(e * e + t * t);
        }, setLength: function(e) {
          return this.normalize().scale(e);
        }, lengthSq: function() {
          var e = this.x, t = this.y;
          return e * e + t * t;
        }, normalize: function() {
          var e = this.x, t = this.y, i = e * e + t * t;
          return i > 0 && (i = 1 / Math.sqrt(i), this.x = e * i, this.y = t * i), this;
        }, normalizeRightHand: function() {
          var e = this.x;
          return this.x = this.y * -1, this.y = e, this;
        }, normalizeLeftHand: function() {
          var e = this.x;
          return this.x = this.y, this.y = e * -1, this;
        }, dot: function(e) {
          return this.x * e.x + this.y * e.y;
        }, cross: function(e) {
          return this.x * e.y - this.y * e.x;
        }, lerp: function(e, t) {
          t === void 0 && (t = 0);
          var i = this.x, r = this.y;
          return this.x = i + t * (e.x - i), this.y = r + t * (e.y - r), this;
        }, transformMat3: function(e) {
          var t = this.x, i = this.y, r = e.val;
          return this.x = r[0] * t + r[3] * i + r[6], this.y = r[1] * t + r[4] * i + r[7], this;
        }, transformMat4: function(e) {
          var t = this.x, i = this.y, r = e.val;
          return this.x = r[0] * t + r[4] * i + r[12], this.y = r[1] * t + r[5] * i + r[13], this;
        }, reset: function() {
          return this.x = 0, this.y = 0, this;
        }, limit: function(e) {
          var t = this.length();
          return t && t > e && this.scale(e / t), this;
        }, reflect: function(e) {
          return e = e.clone().normalize(), this.subtract(e.scale(2 * this.dot(e)));
        }, mirror: function(e) {
          return this.reflect(e).negate();
        }, rotate: function(e) {
          var t = Math.cos(e), i = Math.sin(e);
          return this.set(t * this.x - i * this.y, i * this.x + t * this.y);
        }, project: function(e) {
          var t = this.dot(e) / e.dot(e);
          return this.copy(e).scale(t);
        } });
        ct.ZERO = new ct();
        ct.RIGHT = new ct(1, 0);
        ct.LEFT = new ct(-1, 0);
        ct.UP = new ct(0, -1);
        ct.DOWN = new ct(0, 1);
        ct.ONE = new ct(1, 1);
        aT.exports = ct;
      });
      wn = u((bye, hT) => {
        var xZ = C(), EZ = sl(), TZ = Za(), yZ = ki(), SZ = Qa(), oT = Y(), wZ = new xZ({ initialize: function(t, i, r, s) {
          t === void 0 && (t = 0), i === void 0 && (i = 0), r === void 0 && (r = 0), s === void 0 &&
          (s = 0), this.type = yZ.LINE, this.x1 = t, this.y1 = i, this.x2 = r, this.y2 = s;
        }, getPoint: function(e, t) {
          return EZ(this, e, t);
        }, getPoints: function(e, t, i) {
          return TZ(this, e, t, i);
        }, getRandomPoint: function(e) {
          return SZ(this, e);
        }, setTo: function(e, t, i, r) {
          return e === void 0 && (e = 0), t === void 0 && (t = 0), i === void 0 && (i = 0), r === void 0 &&
          (r = 0), this.x1 = e, this.y1 = t, this.x2 = i, this.y2 = r, this;
        }, setFromObjects: function(e, t) {
          return this.x1 = e.x, this.y1 = e.y, this.x2 = t.x, this.y2 = t.y, this;
        }, getPointA: function(e) {
          return e === void 0 && (e = new oT()), e.set(this.x1, this.y1), e;
        }, getPointB: function(e) {
          return e === void 0 && (e = new oT()), e.set(this.x2, this.y2), e;
        }, left: { get: function() {
          return Math.min(this.x1, this.x2);
        }, set: function(e) {
          this.x1 <= this.x2 ? this.x1 = e : this.x2 = e;
        } }, right: { get: function() {
          return Math.max(this.x1, this.x2);
        }, set: function(e) {
          this.x1 > this.x2 ? this.x1 = e : this.x2 = e;
        } }, top: { get: function() {
          return Math.min(this.y1, this.y2);
        }, set: function(e) {
          this.y1 <= this.y2 ? this.y1 = e : this.y2 = e;
        } }, bottom: { get: function() {
          return Math.max(this.y1, this.y2);
        }, set: function(e) {
          this.y1 > this.y2 ? this.y1 = e : this.y2 = e;
        } } });
        hT.exports = wZ;
      });
      $a = u((Lye, uT) => {
        var CZ = ae(), AZ = function(e, t) {
          return t === void 0 && (t = new CZ()), t.x = e.x + Math.random() * e.width, t.y = e.y + Math.
          random() * e.height, t;
        };
        uT.exports = AZ;
      });
      he = u((Oye, lT) => {
        var RZ = C(), _Z = Ar(), PZ = Ka(), MZ = rl(), qZ = ki(), ja = wn(), FZ = $a(), bZ = new RZ(
        { initialize: function(t, i, r, s) {
          t === void 0 && (t = 0), i === void 0 && (i = 0), r === void 0 && (r = 0), s === void 0 &&
          (s = 0), this.type = qZ.RECTANGLE, this.x = t, this.y = i, this.width = r, this.height = s;
        }, contains: function(e, t) {
          return _Z(this, e, t);
        }, getPoint: function(e, t) {
          return PZ(this, e, t);
        }, getPoints: function(e, t, i) {
          return MZ(this, e, t, i);
        }, getRandomPoint: function(e) {
          return FZ(this, e);
        }, setTo: function(e, t, i, r) {
          return this.x = e, this.y = t, this.width = i, this.height = r, this;
        }, setEmpty: function() {
          return this.setTo(0, 0, 0, 0);
        }, setPosition: function(e, t) {
          return t === void 0 && (t = e), this.x = e, this.y = t, this;
        }, setSize: function(e, t) {
          return t === void 0 && (t = e), this.width = e, this.height = t, this;
        }, isEmpty: function() {
          return this.width <= 0 || this.height <= 0;
        }, getLineA: function(e) {
          return e === void 0 && (e = new ja()), e.setTo(this.x, this.y, this.right, this.y), e;
        }, getLineB: function(e) {
          return e === void 0 && (e = new ja()), e.setTo(this.right, this.y, this.right, this.bottom),
          e;
        }, getLineC: function(e) {
          return e === void 0 && (e = new ja()), e.setTo(this.right, this.bottom, this.x, this.bottom),
          e;
        }, getLineD: function(e) {
          return e === void 0 && (e = new ja()), e.setTo(this.x, this.bottom, this.x, this.y), e;
        }, left: { get: function() {
          return this.x;
        }, set: function(e) {
          e >= this.right ? this.width = 0 : this.width = this.right - e, this.x = e;
        } }, right: { get: function() {
          return this.x + this.width;
        }, set: function(e) {
          e <= this.x ? this.width = 0 : this.width = e - this.x;
        } }, top: { get: function() {
          return this.y;
        }, set: function(e) {
          e >= this.bottom ? this.height = 0 : this.height = this.bottom - e, this.y = e;
        } }, bottom: { get: function() {
          return this.y + this.height;
        }, set: function(e) {
          e <= this.y ? this.height = 0 : this.height = e - this.y;
        } }, centerX: { get: function() {
          return this.x + this.width / 2;
        }, set: function(e) {
          this.x = e - this.width / 2;
        } }, centerY: { get: function() {
          return this.y + this.height / 2;
        }, set: function(e) {
          this.y = e - this.height / 2;
        } } });
        lT.exports = bZ;
      });
      eo = u((Dye, fT) => {
        var LZ = function(e, t, i, r) {
          var s = Math.cos(r), n = Math.sin(r), a = e.x - t, o = e.y - i;
          return e.x = a * s - o * n + t, e.y = a * n + o * s + i, e;
        };
        fT.exports = LZ;
      });
      cT = u((Nye, dT) => {
        var OZ = he(), DZ = eo(), wi = Y(), NZ = { prepareBoundsOutput: function(e, t) {
          if (t === void 0 && (t = false), this.rotation !== 0 && DZ(e, this.x, this.y, this.rotation),
          t && this.parentContainer) {
            var i = this.parentContainer.getBoundsTransformMatrix();
            i.transformPoint(e.x, e.y, e);
          }
          return e;
        }, getCenter: function(e, t) {
          return e === void 0 && (e = new wi()), e.x = this.x - this.displayWidth * this.originX + this.
          displayWidth / 2, e.y = this.y - this.displayHeight * this.originY + this.displayHeight / 2,
          this.prepareBoundsOutput(e, t);
        }, getTopLeft: function(e, t) {
          return e || (e = new wi()), e.x = this.x - this.displayWidth * this.originX, e.y = this.y -
          this.displayHeight * this.originY, this.prepareBoundsOutput(e, t);
        }, getTopCenter: function(e, t) {
          return e || (e = new wi()), e.x = this.x - this.displayWidth * this.originX + this.displayWidth /
          2, e.y = this.y - this.displayHeight * this.originY, this.prepareBoundsOutput(e, t);
        }, getTopRight: function(e, t) {
          return e || (e = new wi()), e.x = this.x - this.displayWidth * this.originX + this.displayWidth,
          e.y = this.y - this.displayHeight * this.originY, this.prepareBoundsOutput(e, t);
        }, getLeftCenter: function(e, t) {
          return e || (e = new wi()), e.x = this.x - this.displayWidth * this.originX, e.y = this.y -
          this.displayHeight * this.originY + this.displayHeight / 2, this.prepareBoundsOutput(e, t);
        }, getRightCenter: function(e, t) {
          return e || (e = new wi()), e.x = this.x - this.displayWidth * this.originX + this.displayWidth,
          e.y = this.y - this.displayHeight * this.originY + this.displayHeight / 2, this.prepareBoundsOutput(
          e, t);
        }, getBottomLeft: function(e, t) {
          return e || (e = new wi()), e.x = this.x - this.displayWidth * this.originX, e.y = this.y -
          this.displayHeight * this.originY + this.displayHeight, this.prepareBoundsOutput(e, t);
        }, getBottomCenter: function(e, t) {
          return e || (e = new wi()), e.x = this.x - this.displayWidth * this.originX + this.displayWidth /
          2, e.y = this.y - this.displayHeight * this.originY + this.displayHeight, this.prepareBoundsOutput(
          e, t);
        }, getBottomRight: function(e, t) {
          return e || (e = new wi()), e.x = this.x - this.displayWidth * this.originX + this.displayWidth,
          e.y = this.y - this.displayHeight * this.originY + this.displayHeight, this.prepareBoundsOutput(
          e, t);
        }, getBounds: function(e) {
          e === void 0 && (e = new OZ());
          var t, i, r, s, n, a, o, h;
          if (this.parentContainer) {
            var l = this.parentContainer.getBoundsTransformMatrix();
            this.getTopLeft(e), l.transformPoint(e.x, e.y, e), t = e.x, i = e.y, this.getTopRight(e),
            l.transformPoint(e.x, e.y, e), r = e.x, s = e.y, this.getBottomLeft(e), l.transformPoint(
            e.x, e.y, e), n = e.x, a = e.y, this.getBottomRight(e), l.transformPoint(e.x, e.y, e), o =
            e.x, h = e.y;
          } else this.getTopLeft(e), t = e.x, i = e.y, this.getTopRight(e), r = e.x, s = e.y, this.getBottomLeft(
          e), n = e.x, a = e.y, this.getBottomRight(e), o = e.x, h = e.y;
          return e.x = Math.min(t, r, n, o), e.y = Math.min(i, s, a, h), e.width = Math.max(t, r, n,
          o) - e.x, e.height = Math.max(i, s, a, h) - e.y, e;
        } };
        dT.exports = NZ;
      });
      rt = u((Iye, vT) => {
        var Wi = {}, jt = {}, bt = {};
        bt.register = function(e, t, i, r) {
          r === void 0 && (r = false), Wi[e] = { plugin: t, mapping: i, custom: r };
        };
        bt.registerCustom = function(e, t, i, r) {
          jt[e] = { plugin: t, mapping: i, data: r };
        };
        bt.hasCore = function(e) {
          return Wi.hasOwnProperty(e);
        };
        bt.hasCustom = function(e) {
          return jt.hasOwnProperty(e);
        };
        bt.getCore = function(e) {
          return Wi[e];
        };
        bt.getCustom = function(e) {
          return jt[e];
        };
        bt.getCustomClass = function(e) {
          return jt.hasOwnProperty(e) ? jt[e].plugin : null;
        };
        bt.remove = function(e) {
          Wi.hasOwnProperty(e) && delete Wi[e];
        };
        bt.removeCustom = function(e) {
          jt.hasOwnProperty(e) && delete jt[e];
        };
        bt.destroyCorePlugins = function() {
          for (var e in Wi) Wi.hasOwnProperty(e) && delete Wi[e];
        };
        bt.destroyCustomPlugins = function() {
          for (var e in jt) jt.hasOwnProperty(e) && delete jt[e];
        };
        vT.exports = bt;
      });
      mT = u((Bye, pT) => {
        pT.exports = "addedtoscene";
      });
      xT = u((Gye, gT) => {
        gT.exports = "boot";
      });
      TT = u((Uye, ET) => {
        ET.exports = "create";
      });
      ST = u((zye, yT) => {
        yT.exports = "destroy";
      });
      CT = u((kye, wT) => {
        wT.exports = "pause";
      });
      RT = u((Xye, AT) => {
        AT.exports = "postupdate";
      });
      PT = u((Vye, _T) => {
        _T.exports = "prerender";
      });
      qT = u((Yye, MT) => {
        MT.exports = "preupdate";
      });
      bT = u((Wye, FT) => {
        FT.exports = "ready";
      });
      OT = u((Hye, LT) => {
        LT.exports = "removedfromscene";
      });
      NT = u((Kye, DT) => {
        DT.exports = "render";
      });
      BT = u((Zye, IT) => {
        IT.exports = "resume";
      });
      UT = u((Qye, GT) => {
        GT.exports = "shutdown";
      });
      kT = u((Jye, zT) => {
        zT.exports = "sleep";
      });
      VT = u(($ye, XT) => {
        XT.exports = "start";
      });
      WT = u((jye, YT) => {
        YT.exports = "transitioncomplete";
      });
      KT = u((eSe, HT) => {
        HT.exports = "transitioninit";
      });
      QT = u((tSe, ZT) => {
        ZT.exports = "transitionout";
      });
      $T = u((iSe, JT) => {
        JT.exports = "transitionstart";
      });
      ey = u((rSe, jT) => {
        jT.exports = "transitionwake";
      });
      iy = u((sSe, ty) => {
        ty.exports = "update";
      });
      sy = u((nSe, ry) => {
        ry.exports = "wake";
      });
      qe = u((aSe, ny) => {
        ny.exports = { ADDED_TO_SCENE: mT(), BOOT: xT(), CREATE: TT(), DESTROY: ST(), PAUSE: CT(), POST_UPDATE: RT(),
        PRE_RENDER: PT(), PRE_UPDATE: qT(), READY: bT(), REMOVED_FROM_SCENE: OT(), RENDER: NT(), RESUME: BT(),
        SHUTDOWN: UT(), SLEEP: kT(), START: VT(), TRANSITION_COMPLETE: WT(), TRANSITION_INIT: KT(), TRANSITION_OUT: QT(),
        TRANSITION_START: $T(), TRANSITION_WAKE: ey(), UPDATE: iy(), WAKE: sy() };
      });
      Ne = u((oSe, ay) => {
        var IZ = C(), BZ = rt(), vs = qe(), Hi = new IZ({ initialize: function(t) {
          this.scene = t, this.systems = t.sys, this.events = t.sys.events, this.displayList, this.updateList,
          this.events.once(vs.BOOT, this.boot, this), this.events.on(vs.START, this.start, this);
        }, boot: function() {
          this.displayList = this.systems.displayList, this.updateList = this.systems.updateList, this.
          events.once(vs.DESTROY, this.destroy, this);
        }, start: function() {
          this.events.once(vs.SHUTDOWN, this.shutdown, this);
        }, existing: function(e) {
          return (e.renderCanvas || e.renderWebGL) && this.displayList.add(e), e.preUpdate && this.updateList.
          add(e), e;
        }, shutdown: function() {
          this.events.off(vs.SHUTDOWN, this.shutdown, this);
        }, destroy: function() {
          this.shutdown(), this.events.off(vs.START, this.start, this), this.scene = null, this.systems =
          null, this.events = null, this.displayList = null, this.updateList = null;
        } });
        Hi.register = function(e, t) {
          Hi.prototype.hasOwnProperty(e) || (Hi.prototype[e] = t);
        };
        Hi.remove = function(e) {
          Hi.prototype.hasOwnProperty(e) && delete Hi.prototype[e];
        };
        BZ.register("GameObjectFactory", Hi, "add");
        ay.exports = Hi;
      });
      nl = u((hSe, hy) => {
        var GZ = C(), UZ = Ne(), oy = new GZ({ initialize: function(t, i, r, s, n, a) {
          i || (i = t.sys.make.image({ x: r, y: s, key: n, frame: a, add: false })), this.bitmapMask =
          i, this.invertAlpha = false, this.isStencil = false;
        }, setBitmap: function(e) {
          this.bitmapMask = e;
        }, preRenderWebGL: function(e, t, i) {
          e.pipelines.BITMAPMASK_PIPELINE.beginMask(this, t, i);
        }, postRenderWebGL: function(e, t, i) {
          e.pipelines.BITMAPMASK_PIPELINE.endMask(this, t, i);
        }, preRenderCanvas: function() {
        }, postRenderCanvas: function() {
        }, destroy: function() {
          this.bitmapMask = null;
        } });
        UZ.register("bitmapMask", function(e, t, i, r, s) {
          return new oy(this.scene, e, t, i, r, s);
        });
        hy.exports = oy;
      });
      al = u((uSe, uy) => {
        var zZ = C(), kZ = new zZ({ initialize: function(t, i) {
          this.geometryMask = i, this.invertAlpha = false, this.isStencil = true, this.level = 0;
        }, setShape: function(e) {
          return this.geometryMask = e, this;
        }, setInvertAlpha: function(e) {
          return e === void 0 && (e = true), this.invertAlpha = e, this;
        }, preRenderWebGL: function(e, t, i) {
          var r = e.gl;
          e.flush(), e.maskStack.length === 0 && (r.enable(r.STENCIL_TEST), r.clear(r.STENCIL_BUFFER_BIT),
          e.maskCount = 0), e.currentCameraMask.mask !== this && (e.currentMask.mask = this), e.maskStack.
          push({ mask: this, camera: i }), this.applyStencil(e, i, true), e.maskCount++;
        }, applyStencil: function(e, t, i) {
          var r = e.gl, s = this.geometryMask, n = e.maskCount, a = 255;
          r.colorMask(false, false, false, false), i ? (r.stencilFunc(r.EQUAL, n, a), r.stencilOp(r.
          KEEP, r.KEEP, r.INCR), n++) : (r.stencilFunc(r.EQUAL, n + 1, a), r.stencilOp(r.KEEP, r.KEEP,
          r.DECR)), this.level = n, s.renderWebGL(e, s, t), e.flush(), r.colorMask(true, true, true,
          true), r.stencilOp(r.KEEP, r.KEEP, r.KEEP), this.invertAlpha ? r.stencilFunc(r.NOTEQUAL, n,
          a) : r.stencilFunc(r.EQUAL, n, a);
        }, postRenderWebGL: function(e) {
          var t = e.gl;
          e.maskStack.pop(), e.maskCount--, e.flush();
          var i = e.currentMask;
          if (e.maskStack.length === 0) i.mask = null, t.disable(t.STENCIL_TEST);
          else {
            var r = e.maskStack[e.maskStack.length - 1];
            r.mask.applyStencil(e, r.camera, false), e.currentCameraMask.mask !== r.mask ? (i.mask =
            r.mask, i.camera = r.camera) : i.mask = null;
          }
        }, preRenderCanvas: function(e, t, i) {
          var r = this.geometryMask;
          e.currentContext.save(), r.renderCanvas(e, r, i, null, null, true), e.currentContext.clip();
        }, postRenderCanvas: function(e) {
          e.currentContext.restore();
        }, destroy: function() {
          this.geometryMask = null;
        } });
        uy.exports = kZ;
      });
      fy = u((lSe, ly) => {
        var XZ = nl(), VZ = al(), YZ = { mask: null, setMask: function(e) {
          return this.mask = e, this;
        }, clearMask: function(e) {
          return e === void 0 && (e = false), e && this.mask && this.mask.destroy(), this.mask = null,
          this;
        }, createBitmapMask: function(e, t, i, r, s) {
          return e === void 0 && (this.texture || this.shader || this.geom) && (e = this), new XZ(this.
          scene, e, t, i, r, s);
        }, createGeometryMask: function(e) {
          return e === void 0 && (this.type === "Graphics" || this.geom) && (e = this), new VZ(this.
          scene, e);
        } };
        ly.exports = YZ;
      });
      cy = u((fSe, dy) => {
        var WZ = { _originComponent: true, originX: 0.5, originY: 0.5, _displayOriginX: 0, _displayOriginY: 0,
        displayOriginX: { get: function() {
          return this._displayOriginX;
        }, set: function(e) {
          this._displayOriginX = e, this.originX = e / this.width;
        } }, displayOriginY: { get: function() {
          return this._displayOriginY;
        }, set: function(e) {
          this._displayOriginY = e, this.originY = e / this.height;
        } }, setOrigin: function(e, t) {
          return e === void 0 && (e = 0.5), t === void 0 && (t = e), this.originX = e, this.originY =
          t, this.updateDisplayOrigin();
        }, setOriginFromFrame: function() {
          return !this.frame || !this.frame.customPivot ? this.setOrigin() : (this.originX = this.frame.
          pivotX, this.originY = this.frame.pivotY, this.updateDisplayOrigin());
        }, setDisplayOrigin: function(e, t) {
          return e === void 0 && (e = 0), t === void 0 && (t = e), this.displayOriginX = e, this.displayOriginY =
          t, this;
        }, updateDisplayOrigin: function() {
          return this._displayOriginX = this.originX * this.width, this._displayOriginY = this.originY *
          this.height, this;
        } };
        dy.exports = WZ;
      });
      Rr = u((dSe, vy) => {
        var HZ = le(), KZ = function(e) {
          return e * HZ.DEG_TO_RAD;
        };
        vy.exports = KZ;
      });
      ps = u((cSe, py) => {
        var ZZ = function(e, t, i) {
          return e && e.hasOwnProperty(t) ? e[t] : i;
        };
        py.exports = ZZ;
      });
      _r = u((vSe, my) => {
        var QZ = { CREATED: 0, DELAY: 2, PENDING_RENDER: 4, PLAYING_FORWARD: 5, PLAYING_BACKWARD: 6,
        HOLD_DELAY: 7, REPEAT_DELAY: 8, COMPLETE: 9, PENDING: 20, ACTIVE: 21, LOOP_DELAY: 22, COMPLETE_DELAY: 23,
        START_DELAY: 24, PENDING_REMOVE: 25, REMOVED: 26, FINISHED: 27, DESTROYED: 28, MAX: 999999999999 };
        my.exports = QZ;
      });
      Ty = u((pSe, Ey) => {
        var gy = Rr(), xy = ps(), to = H(), Cn = _r(), ol = Y(), JZ = { path: null, rotateToPath: false,
        pathRotationOffset: 0, pathOffset: null, pathVector: null, pathDelta: null, pathTween: null,
        pathConfig: null, _prevDirection: Cn.PLAYING_FORWARD, setPath: function(e, t) {
          t === void 0 && (t = this.pathConfig);
          var i = this.pathTween;
          return i && i.isPlaying() && i.stop(), this.path = e, t && this.startFollow(t), this;
        }, setRotateToPath: function(e, t) {
          return t === void 0 && (t = 0), this.rotateToPath = e, this.pathRotationOffset = t, this;
        }, isFollowing: function() {
          var e = this.pathTween;
          return e && e.isPlaying();
        }, startFollow: function(e, t) {
          e === void 0 && (e = {}), t === void 0 && (t = 0);
          var i = this.pathTween;
          i && i.isPlaying() && i.stop(), typeof e == "number" && (e = { duration: e }), e.from = to(
          e, "from", 0), e.to = to(e, "to", 1);
          var r = xy(e, "positionOnPath", false);
          this.rotateToPath = xy(e, "rotateToPath", false), this.pathRotationOffset = to(e, "rotatio\
nOffset", 0);
          var s = to(e, "startAt", t);
          if (s && (e.onStart = function(a) {
            var o = a.data[0];
            o.progress = s, o.elapsed = o.duration * s;
            var h = o.ease(o.progress);
            o.current = o.start + (o.end - o.start) * h, o.setTargetValue();
          }), this.pathOffset || (this.pathOffset = new ol(this.x, this.y)), this.pathVector || (this.
          pathVector = new ol()), this.pathDelta || (this.pathDelta = new ol()), this.pathDelta.reset(),
          e.persist = true, this.pathTween = this.scene.sys.tweens.addCounter(e), this.path.getStartPoint(
          this.pathOffset), r && (this.x = this.pathOffset.x, this.y = this.pathOffset.y), this.pathOffset.
          x = this.x - this.pathOffset.x, this.pathOffset.y = this.y - this.pathOffset.y, this._prevDirection =
          Cn.PLAYING_FORWARD, this.rotateToPath) {
            var n = this.path.getPoint(0.1);
            this.rotation = Math.atan2(n.y - this.y, n.x - this.x) + gy(this.pathRotationOffset);
          }
          return this.pathConfig = e, this;
        }, pauseFollow: function() {
          var e = this.pathTween;
          return e && e.isPlaying() && e.pause(), this;
        }, resumeFollow: function() {
          var e = this.pathTween;
          return e && e.isPaused() && e.resume(), this;
        }, stopFollow: function() {
          var e = this.pathTween;
          return e && e.isPlaying() && e.stop(), this;
        }, pathUpdate: function() {
          var e = this.pathTween;
          if (e && e.data) {
            var t = e.data[0], i = this.pathDelta, r = this.pathVector;
            if (i.copy(r).negate(), t.state === Cn.COMPLETE) {
              this.path.getPoint(t.end, r), i.add(r), r.add(this.pathOffset), this.setPosition(r.x, r.
              y);
              return;
            } else if (t.state !== Cn.PLAYING_FORWARD && t.state !== Cn.PLAYING_BACKWARD) return;
            this.path.getPoint(e.getValue(), r), i.add(r), r.add(this.pathOffset);
            var s = this.x, n = this.y;
            this.setPosition(r.x, r.y);
            var a = this.x - s, o = this.y - n;
            if (a === 0 && o === 0) return;
            if (t.state !== this._prevDirection) {
              this._prevDirection = t.state;
              return;
            }
            this.rotateToPath && (this.rotation = Math.atan2(o, a) + gy(this.pathRotationOffset));
          }
        } };
        Ey.exports = JZ;
      });
      An = u((mSe, Sy) => {
        var yy = function(e) {
          var t, i, r;
          if (typeof e != "object" || e === null) return e;
          t = Array.isArray(e) ? [] : {};
          for (r in e) i = e[r], t[r] = yy(i);
          return t;
        };
        Sy.exports = yy;
      });
      Cy = u((gSe, wy) => {
        var $Z = An(), jZ = { defaultPipeline: null, pipeline: null, pipelineData: null, initPipeline: function(e) {
          this.pipelineData = {};
          var t = this.scene.sys.renderer;
          if (!t) return false;
          var i = t.pipelines;
          if (i) {
            e === void 0 && (e = i.default);
            var r = i.get(e);
            if (r) return this.defaultPipeline = r, this.pipeline = r, true;
          }
          return false;
        }, setPipeline: function(e, t, i) {
          var r = this.scene.sys.renderer;
          if (!r) return this;
          var s = r.pipelines;
          if (s) {
            var n = s.get(e);
            n && (this.pipeline = n), t && (this.pipelineData = i ? $Z(t) : t);
          }
          return this;
        }, setPipelineData: function(e, t) {
          var i = this.pipelineData;
          return t === void 0 ? delete i[e] : i[e] = t, this;
        }, resetPipeline: function(e) {
          return e === void 0 && (e = false), this.pipeline = this.defaultPipeline, e && (this.pipelineData =
          {}), this.pipeline !== null;
        }, getPipelineName: function() {
          return this.pipeline === null ? null : this.pipeline.name;
        } };
        wy.exports = jZ;
      });
      _y = u((xSe, Ry) => {
        var eQ = An(), Ay = il(), tQ = yr(), iQ = { hasPostPipeline: false, postPipelines: null, postPipelineData: null,
        preFX: null, postFX: null, initPostPipeline: function(e) {
          this.postPipelines = [], this.postPipelineData = {}, this.postFX = new Ay(this, true), e &&
          (this.preFX = new Ay(this, false));
        }, setPostPipeline: function(e, t, i) {
          var r = this.scene.sys.renderer;
          if (!r) return this;
          var s = r.pipelines;
          if (s) {
            Array.isArray(e) || (e = [e]);
            for (var n = 0; n < e.length; n++) {
              var a = s.getPostPipeline(e[n], this, t);
              a && this.postPipelines.push(a);
            }
            t && (this.postPipelineData = i ? eQ(t) : t);
          }
          return this.hasPostPipeline = this.postPipelines.length > 0, this;
        }, setPostPipelineData: function(e, t) {
          var i = this.postPipelineData;
          return t === void 0 ? delete i[e] : i[e] = t, this;
        }, getPostPipeline: function(e) {
          for (var t = typeof e == "string", i = this.postPipelines, r = [], s = 0; s < i.length; s++) {
            var n = i[s];
            (t && n.name === e || !t && n instanceof e) && r.push(n);
          }
          return r.length === 1 ? r[0] : r;
        }, resetPostPipeline: function(e) {
          e === void 0 && (e = false);
          for (var t = this.postPipelines, i = 0; i < t.length; i++) t[i].destroy();
          this.postPipelines = [], this.hasPostPipeline = false, e && (this.postPipelineData = {});
        }, removePostPipeline: function(e) {
          for (var t = typeof e == "string", i = this.postPipelines, r = i.length - 1; r >= 0; r--) {
            var s = i[r];
            (t && s.name === e || !t && s === e) && (s.destroy(), tQ(i, r));
          }
          return this.hasPostPipeline = this.postPipelines.length > 0, this;
        }, clearFX: function() {
          return this.preFX && this.preFX.clear(), this.postFX && this.postFX.clear(), this;
        } };
        Ry.exports = iQ;
      });
      My = u((ESe, Py) => {
        var rQ = { scrollFactorX: 1, scrollFactorY: 1, setScrollFactor: function(e, t) {
          return t === void 0 && (t = e), this.scrollFactorX = e, this.scrollFactorY = t, this;
        } };
        Py.exports = rQ;
      });
      Fy = u((TSe, qy) => {
        var sQ = { _sizeComponent: true, width: 0, height: 0, displayWidth: { get: function() {
          return Math.abs(this.scaleX * this.frame.realWidth);
        }, set: function(e) {
          this.scaleX = e / this.frame.realWidth;
        } }, displayHeight: { get: function() {
          return Math.abs(this.scaleY * this.frame.realHeight);
        }, set: function(e) {
          this.scaleY = e / this.frame.realHeight;
        } }, setSizeToFrame: function(e) {
          e || (e = this.frame), this.width = e.realWidth, this.height = e.realHeight;
          var t = this.input;
          return t && !t.customHitArea && (t.hitArea.width = this.width, t.hitArea.height = this.height),
          this;
        }, setSize: function(e, t) {
          return this.width = e, this.height = t, this;
        }, setDisplaySize: function(e, t) {
          return this.displayWidth = e, this.displayHeight = t, this;
        } };
        qy.exports = sQ;
      });
      Pr = u((ySe, Ly) => {
        var nQ = C(), ms = ne(), aQ = Xe(), by = new nQ({ initialize: function(t, i, r, s, n, a, o) {
          this.texture = t, this.name = i, this.source = t.source[r], this.sourceIndex = r, this.cutX,
          this.cutY, this.cutWidth, this.cutHeight, this.x = 0, this.y = 0, this.width, this.height,
          this.halfWidth, this.halfHeight, this.centerX, this.centerY, this.pivotX = 0, this.pivotY =
          0, this.customPivot = false, this.rotated = false, this.autoRound = -1, this.customData = {},
          this.u0 = 0, this.v0 = 0, this.u1 = 0, this.v1 = 0, this.data = { cut: { x: 0, y: 0, w: 0,
          h: 0, r: 0, b: 0 }, trim: false, sourceSize: { w: 0, h: 0 }, spriteSourceSize: { x: 0, y: 0,
          w: 0, h: 0, r: 0, b: 0 }, radius: 0, drawImage: { x: 0, y: 0, width: 0, height: 0 }, is3Slice: false,
          scale9: false, scale9Borders: { x: 0, y: 0, w: 0, h: 0 } }, this.setSize(a, o, s, n);
        }, setCutPosition: function(e, t) {
          return e === void 0 && (e = 0), t === void 0 && (t = 0), this.cutX = e, this.cutY = t, this.
          updateUVs();
        }, setCutSize: function(e, t) {
          return this.cutWidth = e, this.cutHeight = t, this.updateUVs();
        }, setSize: function(e, t, i, r) {
          i === void 0 && (i = 0), r === void 0 && (r = 0), this.setCutPosition(i, r), this.setCutSize(
          e, t), this.width = e, this.height = t, this.halfWidth = Math.floor(e * 0.5), this.halfHeight =
          Math.floor(t * 0.5), this.centerX = Math.floor(e / 2), this.centerY = Math.floor(t / 2);
          var s = this.data, n = s.cut;
          n.x = i, n.y = r, n.w = e, n.h = t, n.r = i + e, n.b = r + t, s.sourceSize.w = e, s.sourceSize.
          h = t, s.spriteSourceSize.w = e, s.spriteSourceSize.h = t, s.radius = 0.5 * Math.sqrt(e * e +
          t * t);
          var a = s.drawImage;
          return a.x = i, a.y = r, a.width = e, a.height = t, this.updateUVs();
        }, setTrim: function(e, t, i, r, s, n) {
          var a = this.data, o = a.spriteSourceSize;
          return a.trim = true, a.sourceSize.w = e, a.sourceSize.h = t, o.x = i, o.y = r, o.w = s, o.
          h = n, o.r = i + s, o.b = r + n, this.x = i, this.y = r, this.width = s, this.height = n, this.
          halfWidth = s * 0.5, this.halfHeight = n * 0.5, this.centerX = Math.floor(s / 2), this.centerY =
          Math.floor(n / 2), this.updateUVs();
        }, setScale9: function(e, t, i, r) {
          var s = this.data;
          return s.scale9 = true, s.is3Slice = t === 0 && r === this.height, s.scale9Borders.x = e, s.
          scale9Borders.y = t, s.scale9Borders.w = i, s.scale9Borders.h = r, this;
        }, setCropUVs: function(e, t, i, r, s, n, a) {
          var o = this.cutX, h = this.cutY, l = this.cutWidth, f = this.cutHeight, d = this.realWidth,
          c = this.realHeight;
          t = ms(t, 0, d), i = ms(i, 0, c), r = ms(r, 0, d - t), s = ms(s, 0, c - i);
          var p = o + t, v = h + i, m = r, g = s, x = this.data;
          if (x.trim) {
            var E = x.spriteSourceSize;
            r = ms(r, 0, E.x + l - t), s = ms(s, 0, E.y + f - i);
            var T15 = t + r, w = i + s, y = !(E.r < t || E.b < i || E.x > T15 || E.y > w);
            if (y) {
              var A10 = Math.max(E.x, t), S14 = Math.max(E.y, i), _ = Math.min(E.r, T15) - A10, q = Math.
              min(E.b, w) - S14;
              m = _, g = q, n ? p = o + (l - (A10 - E.x) - _) : p = o + (A10 - E.x), a ? v = h + (f -
              (S14 - E.y) - q) : v = h + (S14 - E.y), t = A10, i = S14, r = _, s = q;
            } else p = 0, v = 0, m = 0, g = 0;
          } else n && (p = o + (l - t - r)), a && (v = h + (f - i - s));
          var P = this.source.width, L = this.source.height;
          return e.u0 = Math.max(0, p / P), e.v0 = Math.max(0, v / L), e.u1 = Math.min(1, (p + m) / P),
          e.v1 = Math.min(1, (v + g) / L), e.x = t, e.y = i, e.cx = p, e.cy = v, e.cw = m, e.ch = g,
          e.width = r, e.height = s, e.flipX = n, e.flipY = a, e;
        }, updateCropUVs: function(e, t, i) {
          return this.setCropUVs(e, e.x, e.y, e.width, e.height, t, i);
        }, setUVs: function(e, t, i, r, s, n) {
          var a = this.data.drawImage;
          return a.width = e, a.height = t, this.u0 = i, this.v0 = r, this.u1 = s, this.v1 = n, this;
        }, updateUVs: function() {
          var e = this.cutX, t = this.cutY, i = this.cutWidth, r = this.cutHeight, s = this.data.drawImage;
          s.width = i, s.height = r;
          var n = this.source.width, a = this.source.height;
          return this.u0 = e / n, this.v0 = t / a, this.u1 = (e + i) / n, this.v1 = (t + r) / a, this;
        }, updateUVsInverted: function() {
          var e = this.source.width, t = this.source.height;
          return this.u0 = (this.cutX + this.cutHeight) / e, this.v0 = this.cutY / t, this.u1 = this.
          cutX / e, this.v1 = (this.cutY + this.cutWidth) / t, this;
        }, clone: function() {
          var e = new by(this.texture, this.name, this.sourceIndex);
          return e.cutX = this.cutX, e.cutY = this.cutY, e.cutWidth = this.cutWidth, e.cutHeight = this.
          cutHeight, e.x = this.x, e.y = this.y, e.width = this.width, e.height = this.height, e.halfWidth =
          this.halfWidth, e.halfHeight = this.halfHeight, e.centerX = this.centerX, e.centerY = this.
          centerY, e.rotated = this.rotated, e.data = aQ(true, e.data, this.data), e.updateUVs(), e;
        }, destroy: function() {
          this.texture = null, this.source = null, this.customData = null, this.data = null;
        }, glTexture: { get: function() {
          return this.source.glTexture;
        } }, realWidth: { get: function() {
          return this.data.sourceSize.w;
        } }, realHeight: { get: function() {
          return this.data.sourceSize.h;
        } }, radius: { get: function() {
          return this.data.radius;
        } }, trimmed: { get: function() {
          return this.data.trim;
        } }, scale9: { get: function() {
          return this.data.scale9;
        } }, is3Slice: { get: function() {
          return this.data.is3Slice;
        } }, canvasData: { get: function() {
          return this.data.drawImage;
        } } });
        Ly.exports = by;
      });
      Ny = u((SSe, Dy) => {
        var oQ = Pr(), Oy = 8, hQ = { texture: null, frame: null, isCropped: false, setTexture: function(e, t, i, r) {
          return this.texture = this.scene.sys.textures.get(e), this.setFrame(t, i, r);
        }, setFrame: function(e, t, i) {
          return t === void 0 && (t = true), i === void 0 && (i = true), e instanceof oQ ? (this.texture =
          this.scene.sys.textures.get(e.texture.key), this.frame = e) : this.frame = this.texture.get(
          e), !this.frame.cutWidth || !this.frame.cutHeight ? this.renderFlags &= ~Oy : this.renderFlags |=
          Oy, this._sizeComponent && t && this.setSizeToFrame(), this._originComponent && i && (this.
          frame.customPivot ? this.setOrigin(this.frame.pivotX, this.frame.pivotY) : this.updateDisplayOrigin()),
          this;
        } };
        Dy.exports = hQ;
      });
      Gy = u((wSe, By) => {
        var uQ = Pr(), Iy = 8, lQ = { texture: null, frame: null, isCropped: false, setCrop: function(e, t, i, r) {
          if (e === void 0) this.isCropped = false;
          else if (this.frame) {
            if (typeof e == "number") this.frame.setCropUVs(this._crop, e, t, i, r, this.flipX, this.
            flipY);
            else {
              var s = e;
              this.frame.setCropUVs(this._crop, s.x, s.y, s.width, s.height, this.flipX, this.flipY);
            }
            this.isCropped = true;
          }
          return this;
        }, setTexture: function(e, t) {
          return this.texture = this.scene.sys.textures.get(e), this.setFrame(t);
        }, setFrame: function(e, t, i) {
          return t === void 0 && (t = true), i === void 0 && (i = true), e instanceof uQ ? (this.texture =
          this.scene.sys.textures.get(e.texture.key), this.frame = e) : this.frame = this.texture.get(
          e), !this.frame.cutWidth || !this.frame.cutHeight ? this.renderFlags &= ~Iy : this.renderFlags |=
          Iy, this._sizeComponent && t && this.setSizeToFrame(), this._originComponent && i && (this.
          frame.customPivot ? this.setOrigin(this.frame.pivotX, this.frame.pivotY) : this.updateDisplayOrigin()),
          this.isCropped && this.frame.updateCropUVs(this._crop, this.flipX, this.flipY), this;
        }, resetCropObject: function() {
          return { u0: 0, v0: 0, u1: 0, v1: 0, width: 0, height: 0, x: 0, y: 0, flipX: false, flipY: false,
          cx: 0, cy: 0, cw: 0, ch: 0 };
        } };
        By.exports = lQ;
      });
      zy = u((CSe, Uy) => {
        var fQ = { tintTopLeft: 16777215, tintTopRight: 16777215, tintBottomLeft: 16777215, tintBottomRight: 16777215,
        tintFill: false, clearTint: function() {
          return this.setTint(16777215), this;
        }, setTint: function(e, t, i, r) {
          return e === void 0 && (e = 16777215), t === void 0 && (t = e, i = e, r = e), this.tintTopLeft =
          e, this.tintTopRight = t, this.tintBottomLeft = i, this.tintBottomRight = r, this.tintFill =
          false, this;
        }, setTintFill: function(e, t, i, r) {
          return this.setTint(e, t, i, r), this.tintFill = true, this;
        }, tint: { get: function() {
          return this.tintTopLeft;
        }, set: function(e) {
          this.setTint(e, e, e, e);
        } }, isTinted: { get: function() {
          var e = 16777215;
          return this.tintFill || this.tintTopLeft !== e || this.tintTopRight !== e || this.tintBottomLeft !==
          e || this.tintBottomRight !== e;
        } } };
        Uy.exports = fQ;
      });
      io = u((ASe, ky) => {
        var dQ = function(e) {
          var t = { name: e.name, type: e.type, x: e.x, y: e.y, depth: e.depth, scale: { x: e.scaleX,
          y: e.scaleY }, origin: { x: e.originX, y: e.originY }, flipX: e.flipX, flipY: e.flipY, rotation: e.
          rotation, alpha: e.alpha, visible: e.visible, blendMode: e.blendMode, textureKey: "", frameKey: "",
          data: {} };
          return e.texture && (t.textureKey = e.texture.key, t.frameKey = e.frame.name), t;
        };
        ky.exports = dQ;
      });
      Lt = u((RSe, Xy) => {
        var cQ = C(), vQ = le(), pQ = Y(), mQ = new cQ({ initialize: function(t, i, r, s, n, a) {
          t === void 0 && (t = 1), i === void 0 && (i = 0), r === void 0 && (r = 0), s === void 0 &&
          (s = 1), n === void 0 && (n = 0), a === void 0 && (a = 0), this.matrix = new Float32Array(
          [t, i, r, s, n, a, 0, 0, 1]), this.decomposedMatrix = { translateX: 0, translateY: 0, scaleX: 1,
          scaleY: 1, rotation: 0 }, this.quad = new Float32Array(8);
        }, a: { get: function() {
          return this.matrix[0];
        }, set: function(e) {
          this.matrix[0] = e;
        } }, b: { get: function() {
          return this.matrix[1];
        }, set: function(e) {
          this.matrix[1] = e;
        } }, c: { get: function() {
          return this.matrix[2];
        }, set: function(e) {
          this.matrix[2] = e;
        } }, d: { get: function() {
          return this.matrix[3];
        }, set: function(e) {
          this.matrix[3] = e;
        } }, e: { get: function() {
          return this.matrix[4];
        }, set: function(e) {
          this.matrix[4] = e;
        } }, f: { get: function() {
          return this.matrix[5];
        }, set: function(e) {
          this.matrix[5] = e;
        } }, tx: { get: function() {
          return this.matrix[4];
        }, set: function(e) {
          this.matrix[4] = e;
        } }, ty: { get: function() {
          return this.matrix[5];
        }, set: function(e) {
          this.matrix[5] = e;
        } }, rotation: { get: function() {
          return Math.acos(this.a / this.scaleX) * (Math.atan(-this.c / this.a) < 0 ? -1 : 1);
        } }, rotationNormalized: { get: function() {
          var e = this.matrix, t = e[0], i = e[1], r = e[2], s = e[3];
          return t || i ? i > 0 ? Math.acos(t / this.scaleX) : -Math.acos(t / this.scaleX) : r || s ?
          vQ.TAU - (s > 0 ? Math.acos(-r / this.scaleY) : -Math.acos(r / this.scaleY)) : 0;
        } }, scaleX: { get: function() {
          return Math.sqrt(this.a * this.a + this.b * this.b);
        } }, scaleY: { get: function() {
          return Math.sqrt(this.c * this.c + this.d * this.d);
        } }, loadIdentity: function() {
          var e = this.matrix;
          return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 1, e[4] = 0, e[5] = 0, this;
        }, translate: function(e, t) {
          var i = this.matrix;
          return i[4] = i[0] * e + i[2] * t + i[4], i[5] = i[1] * e + i[3] * t + i[5], this;
        }, scale: function(e, t) {
          var i = this.matrix;
          return i[0] *= e, i[1] *= e, i[2] *= t, i[3] *= t, this;
        }, rotate: function(e) {
          var t = Math.sin(e), i = Math.cos(e), r = this.matrix, s = r[0], n = r[1], a = r[2], o = r[3];
          return r[0] = s * i + a * t, r[1] = n * i + o * t, r[2] = s * -t + a * i, r[3] = n * -t + o *
          i, this;
        }, multiply: function(e, t) {
          var i = this.matrix, r = e.matrix, s = i[0], n = i[1], a = i[2], o = i[3], h = i[4], l = i[5],
          f = r[0], d = r[1], c = r[2], p = r[3], v = r[4], m = r[5], g = t === void 0 ? i : t.matrix;
          return g[0] = f * s + d * a, g[1] = f * n + d * o, g[2] = c * s + p * a, g[3] = c * n + p *
          o, g[4] = v * s + m * a + h, g[5] = v * n + m * o + l, g;
        }, multiplyWithOffset: function(e, t, i) {
          var r = this.matrix, s = e.matrix, n = r[0], a = r[1], o = r[2], h = r[3], l = r[4], f = r[5],
          d = t * n + i * o + l, c = t * a + i * h + f, p = s[0], v = s[1], m = s[2], g = s[3], x = s[4],
          E = s[5];
          return r[0] = p * n + v * o, r[1] = p * a + v * h, r[2] = m * n + g * o, r[3] = m * a + g *
          h, r[4] = x * n + E * o + d, r[5] = x * a + E * h + c, this;
        }, transform: function(e, t, i, r, s, n) {
          var a = this.matrix, o = a[0], h = a[1], l = a[2], f = a[3], d = a[4], c = a[5];
          return a[0] = e * o + t * l, a[1] = e * h + t * f, a[2] = i * o + r * l, a[3] = i * h + r *
          f, a[4] = s * o + n * l + d, a[5] = s * h + n * f + c, this;
        }, transformPoint: function(e, t, i) {
          i === void 0 && (i = { x: 0, y: 0 });
          var r = this.matrix, s = r[0], n = r[1], a = r[2], o = r[3], h = r[4], l = r[5];
          return i.x = e * s + t * a + h, i.y = e * n + t * o + l, i;
        }, invert: function() {
          var e = this.matrix, t = e[0], i = e[1], r = e[2], s = e[3], n = e[4], a = e[5], o = t * s -
          i * r;
          return e[0] = s / o, e[1] = -i / o, e[2] = -r / o, e[3] = t / o, e[4] = (r * a - s * n) / o,
          e[5] = -(t * a - i * n) / o, this;
        }, copyFrom: function(e) {
          var t = this.matrix;
          return t[0] = e.a, t[1] = e.b, t[2] = e.c, t[3] = e.d, t[4] = e.e, t[5] = e.f, this;
        }, copyFromArray: function(e) {
          var t = this.matrix;
          return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], this;
        }, copyToContext: function(e) {
          var t = this.matrix;
          return e.transform(t[0], t[1], t[2], t[3], t[4], t[5]), e;
        }, setToContext: function(e) {
          return e.setTransform(this.a, this.b, this.c, this.d, this.e, this.f), e;
        }, copyToArray: function(e) {
          var t = this.matrix;
          return e === void 0 ? e = [t[0], t[1], t[2], t[3], t[4], t[5]] : (e[0] = t[0], e[1] = t[1],
          e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5]), e;
        }, setTransform: function(e, t, i, r, s, n) {
          var a = this.matrix;
          return a[0] = e, a[1] = t, a[2] = i, a[3] = r, a[4] = s, a[5] = n, this;
        }, decomposeMatrix: function() {
          var e = this.decomposedMatrix, t = this.matrix, i = t[0], r = t[1], s = t[2], n = t[3], a = i *
          n - r * s;
          if (e.translateX = t[4], e.translateY = t[5], i || r) {
            var o = Math.sqrt(i * i + r * r);
            e.rotation = r > 0 ? Math.acos(i / o) : -Math.acos(i / o), e.scaleX = o, e.scaleY = a / o;
          } else if (s || n) {
            var h = Math.sqrt(s * s + n * n);
            e.rotation = Math.PI * 0.5 - (n > 0 ? Math.acos(-s / h) : -Math.acos(s / h)), e.scaleX =
            a / h, e.scaleY = h;
          } else e.rotation = 0, e.scaleX = 0, e.scaleY = 0;
          return e;
        }, applyITRS: function(e, t, i, r, s) {
          var n = this.matrix, a = Math.sin(i), o = Math.cos(i);
          return n[4] = e, n[5] = t, n[0] = o * r, n[1] = a * r, n[2] = -a * s, n[3] = o * s, this;
        }, applyInverse: function(e, t, i) {
          i === void 0 && (i = new pQ());
          var r = this.matrix, s = r[0], n = r[1], a = r[2], o = r[3], h = r[4], l = r[5], f = 1 / (s *
          o + a * -n);
          return i.x = o * f * e + -a * f * t + (l * a - h * o) * f, i.y = s * f * t + -n * f * e + (-l *
          s + h * n) * f, i;
        }, setQuad: function(e, t, i, r, s, n) {
          s === void 0 && (s = false), n === void 0 && (n = this.quad);
          var a = this.matrix, o = a[0], h = a[1], l = a[2], f = a[3], d = a[4], c = a[5], p = e * o +
          t * l + d, v = e * h + t * f + c, m = e * o + r * l + d, g = e * h + r * f + c, x = i * o +
          r * l + d, E = i * h + r * f + c, T15 = i * o + t * l + d, w = i * h + t * f + c;
          if (s) {
            var y = Math.floor(p + 0.5), A10 = Math.floor(v + 0.5), S14 = y - p, _ = A10 - v;
            n[0] = y, n[1] = A10, n[2] = m + S14, n[3] = g + _, n[4] = x + S14, n[5] = E + _, n[6] =
            T15 + S14, n[7] = w + _;
          } else n[0] = p, n[1] = v, n[2] = m, n[3] = g, n[4] = x, n[5] = E, n[6] = T15, n[7] = w;
          return n;
        }, getX: function(e, t) {
          return e * this.a + t * this.c + this.e;
        }, getY: function(e, t) {
          return e * this.b + t * this.d + this.f;
        }, getXRound: function(e, t, i) {
          var r = this.getX(e, t);
          return i && (r = Math.floor(r + 0.5)), r;
        }, getYRound: function(e, t, i) {
          var r = this.getY(e, t);
          return i && (r = Math.floor(r + 0.5)), r;
        }, getCSSMatrix: function() {
          var e = this.matrix;
          return "matrix(" + e[0] + "," + e[1] + "," + e[2] + "," + e[3] + "," + e[4] + "," + e[5] +
          ")";
        }, destroy: function() {
          this.matrix = null, this.quad = null, this.decomposedMatrix = null;
        } });
        Xy.exports = mQ;
      });
      ro = u((_Se, Vy) => {
        var gQ = Y(), xQ = function(e, t, i, r, s, n, a, o) {
          o === void 0 && (o = new gQ());
          var h = Math.sin(s), l = Math.cos(s), f = l * n, d = h * n, c = -h * a, p = l * a, v = 1 /
          (f * p + c * -d);
          return o.x = p * v * e + -c * v * t + (r * c - i * p) * v, o.y = f * v * t + -d * v * e + (-r *
          f + i * d) * v, o;
        };
        Vy.exports = xQ;
      });
      Ki = u((PSe, Yy) => {
        var EQ = function(e, t, i) {
          var r = i - t;
          return t + ((e - t) % r + r) % r;
        };
        Yy.exports = EQ;
      });
      hl = u((MSe, Wy) => {
        var TQ = Ki(), yQ = function(e) {
          return TQ(e, -Math.PI, Math.PI);
        };
        Wy.exports = yQ;
      });
      ul = u((qSe, Hy) => {
        var SQ = Ki(), wQ = function(e) {
          return SQ(e, -180, 180);
        };
        Hy.exports = wQ;
      });
      $y = u((FSe, Jy) => {
        var Ky = le(), ll = Lt(), CQ = ro(), AQ = hl(), Zy = ul(), Qy = Y(), gs = 4, RQ = { hasTransformComponent: true,
        _scaleX: 1, _scaleY: 1, _rotation: 0, x: 0, y: 0, z: 0, w: 0, scale: { get: function() {
          return (this._scaleX + this._scaleY) / 2;
        }, set: function(e) {
          this._scaleX = e, this._scaleY = e, e === 0 ? this.renderFlags &= ~gs : this.renderFlags |=
          gs;
        } }, scaleX: { get: function() {
          return this._scaleX;
        }, set: function(e) {
          this._scaleX = e, e === 0 ? this.renderFlags &= ~gs : this._scaleY !== 0 && (this.renderFlags |=
          gs);
        } }, scaleY: { get: function() {
          return this._scaleY;
        }, set: function(e) {
          this._scaleY = e, e === 0 ? this.renderFlags &= ~gs : this._scaleX !== 0 && (this.renderFlags |=
          gs);
        } }, angle: { get: function() {
          return Zy(this._rotation * Ky.RAD_TO_DEG);
        }, set: function(e) {
          this.rotation = Zy(e) * Ky.DEG_TO_RAD;
        } }, rotation: { get: function() {
          return this._rotation;
        }, set: function(e) {
          this._rotation = AQ(e);
        } }, setPosition: function(e, t, i, r) {
          return e === void 0 && (e = 0), t === void 0 && (t = e), i === void 0 && (i = 0), r === void 0 &&
          (r = 0), this.x = e, this.y = t, this.z = i, this.w = r, this;
        }, copyPosition: function(e) {
          return e.x !== void 0 && (this.x = e.x), e.y !== void 0 && (this.y = e.y), e.z !== void 0 &&
          (this.z = e.z), e.w !== void 0 && (this.w = e.w), this;
        }, setRandomPosition: function(e, t, i, r) {
          return e === void 0 && (e = 0), t === void 0 && (t = 0), i === void 0 && (i = this.scene.sys.
          scale.width), r === void 0 && (r = this.scene.sys.scale.height), this.x = e + Math.random() *
          i, this.y = t + Math.random() * r, this;
        }, setRotation: function(e) {
          return e === void 0 && (e = 0), this.rotation = e, this;
        }, setAngle: function(e) {
          return e === void 0 && (e = 0), this.angle = e, this;
        }, setScale: function(e, t) {
          return e === void 0 && (e = 1), t === void 0 && (t = e), this.scaleX = e, this.scaleY = t,
          this;
        }, setX: function(e) {
          return e === void 0 && (e = 0), this.x = e, this;
        }, setY: function(e) {
          return e === void 0 && (e = 0), this.y = e, this;
        }, setZ: function(e) {
          return e === void 0 && (e = 0), this.z = e, this;
        }, setW: function(e) {
          return e === void 0 && (e = 0), this.w = e, this;
        }, getLocalTransformMatrix: function(e) {
          return e === void 0 && (e = new ll()), e.applyITRS(this.x, this.y, this._rotation, this._scaleX,
          this._scaleY);
        }, getWorldTransformMatrix: function(e, t) {
          e === void 0 && (e = new ll());
          var i = this.parentContainer;
          if (!i) return this.getLocalTransformMatrix(e);
          var r = false;
          for (t || (t = new ll(), r = true), e.applyITRS(this.x, this.y, this._rotation, this._scaleX,
          this._scaleY); i; ) t.applyITRS(i.x, i.y, i._rotation, i._scaleX, i._scaleY), t.multiply(e,
          e), i = i.parentContainer;
          return r && t.destroy(), e;
        }, getLocalPoint: function(e, t, i, r) {
          i || (i = new Qy()), r || (r = this.scene.sys.cameras.main);
          var s = r.scrollX, n = r.scrollY, a = e + s * this.scrollFactorX - s, o = t + n * this.scrollFactorY -
          n;
          return this.parentContainer ? this.getWorldTransformMatrix().applyInverse(a, o, i) : CQ(a,
          o, this.x, this.y, this.rotation, this.scaleX, this.scaleY, i), this._originComponent && (i.
          x += this._displayOriginX, i.y += this._displayOriginY), i;
        }, getWorldPoint: function(e, t, i) {
          e === void 0 && (e = new Qy());
          var r = this.parentContainer;
          if (!r) return e.x = this.x, e.y = this.y, e;
          var s = this.getWorldTransformMatrix(t, i);
          return e.x = s.tx, e.y = s.ty, e;
        }, getParentRotation: function() {
          for (var e = 0, t = this.parentContainer; t; ) e += t.rotation, t = t.parentContainer;
          return e;
        } };
        Jy.exports = RQ;
      });
      tS = u((bSe, eS) => {
        var jy = 1, _Q = { _visible: true, visible: { get: function() {
          return this._visible;
        }, set: function(e) {
          e ? (this._visible = true, this.renderFlags |= jy) : (this._visible = false, this.renderFlags &=
          ~jy);
        } }, setVisible: function(e) {
          return this.visible = e, this;
        } };
        eS.exports = _Q;
      });
      Ot = u((LSe, iS) => {
        iS.exports = { Alpha: Qg(), AlphaSingle: jg(), BlendMode: i0(), ComputedSize: s0(), Crop: a0(),
        Depth: jx(), Flip: tE(), FX: il(), GetBounds: cT(), Mask: fy(), Origin: cy(), PathFollower: Ty(),
        Pipeline: Cy(), PostPipeline: _y(), ScrollFactor: My(), Size: Fy(), Texture: Ny(), TextureCrop: Gy(),
        Tint: zy(), ToJSON: io(), Transform: $y(), TransformMatrix: Lt(), Visible: tS() };
      });
      sS = u((OSe, rS) => {
        rS.exports = "changedata";
      });
      aS = u((DSe, nS) => {
        nS.exports = "changedata-";
      });
      hS = u((NSe, oS) => {
        oS.exports = "destroy";
      });
      lS = u((ISe, uS) => {
        uS.exports = "removedata";
      });
      dS = u((BSe, fS) => {
        fS.exports = "setdata";
      });
      fl = u((GSe, cS) => {
        cS.exports = { CHANGE_DATA: sS(), CHANGE_DATA_KEY: aS(), DESTROY: hS(), REMOVE_DATA: lS(), SET_DATA: dS() };
      });
      Rn = u((USe, vS) => {
        var PQ = C(), Ci = fl(), MQ = new PQ({ initialize: function(t, i) {
          this.parent = t, this.events = i, i || (this.events = t.events ? t.events : t), this.list =
          {}, this.values = {}, this._frozen = false, !t.hasOwnProperty("sys") && this.events && this.
          events.once(Ci.DESTROY, this.destroy, this);
        }, get: function(e) {
          var t = this.list;
          if (Array.isArray(e)) {
            for (var i = [], r = 0; r < e.length; r++) i.push(t[e[r]]);
            return i;
          } else return t[e];
        }, getAll: function() {
          var e = {};
          for (var t in this.list) this.list.hasOwnProperty(t) && (e[t] = this.list[t]);
          return e;
        }, query: function(e) {
          var t = {};
          for (var i in this.list) this.list.hasOwnProperty(i) && i.match(e) && (t[i] = this.list[i]);
          return t;
        }, set: function(e, t) {
          if (this._frozen) return this;
          if (typeof e == "string") return this.setValue(e, t);
          for (var i in e) this.setValue(i, e[i]);
          return this;
        }, inc: function(e, t) {
          if (this._frozen) return this;
          t === void 0 && (t = 1);
          var i = this.get(e);
          return i === void 0 && (i = 0), this.set(e, i + t), this;
        }, toggle: function(e) {
          return this._frozen ? this : (this.set(e, !this.get(e)), this);
        }, setValue: function(e, t) {
          if (this._frozen) return this;
          if (this.has(e)) this.values[e] = t;
          else {
            var i = this, r = this.list, s = this.events, n = this.parent;
            Object.defineProperty(this.values, e, { enumerable: true, configurable: true, get: function() {
              return r[e];
            }, set: function(a) {
              if (!i._frozen) {
                var o = r[e];
                r[e] = a, s.emit(Ci.CHANGE_DATA, n, e, a, o), s.emit(Ci.CHANGE_DATA_KEY + e, n, a, o);
              }
            } }), r[e] = t, s.emit(Ci.SET_DATA, n, e, t);
          }
          return this;
        }, each: function(e, t) {
          for (var i = [this.parent, null, void 0], r = 1; r < arguments.length; r++) i.push(arguments[r]);
          for (var s in this.list) i[1] = s, i[2] = this.list[s], e.apply(t, i);
          return this;
        }, merge: function(e, t) {
          t === void 0 && (t = true);
          for (var i in e) e.hasOwnProperty(i) && (t || !t && !this.has(i)) && this.setValue(i, e[i]);
          return this;
        }, remove: function(e) {
          if (this._frozen) return this;
          if (Array.isArray(e)) for (var t = 0; t < e.length; t++) this.removeValue(e[t]);
          else return this.removeValue(e);
          return this;
        }, removeValue: function(e) {
          if (this.has(e)) {
            var t = this.list[e];
            delete this.list[e], delete this.values[e], this.events.emit(Ci.REMOVE_DATA, this.parent,
            e, t);
          }
          return this;
        }, pop: function(e) {
          var t = void 0;
          return !this._frozen && this.has(e) && (t = this.list[e], delete this.list[e], delete this.
          values[e], this.events.emit(Ci.REMOVE_DATA, this.parent, e, t)), t;
        }, has: function(e) {
          return this.list.hasOwnProperty(e);
        }, setFreeze: function(e) {
          return this._frozen = e, this;
        }, reset: function() {
          for (var e in this.list) delete this.list[e], delete this.values[e];
          return this._frozen = false, this;
        }, destroy: function() {
          this.reset(), this.events.off(Ci.CHANGE_DATA), this.events.off(Ci.SET_DATA), this.events.off(
          Ci.REMOVE_DATA), this.parent = null;
        }, freeze: { get: function() {
          return this._frozen;
        }, set: function(e) {
          this._frozen = !!e;
        } }, count: { get: function() {
          var e = 0;
          for (var t in this.list) this.list[t] !== void 0 && e++;
          return e;
        } } });
        vS.exports = MQ;
      });
      mS = u((zSe, pS) => {
        pS.exports = "addedtoscene";
      });
      xS = u((kSe, gS) => {
        gS.exports = "destroy";
      });
      TS = u((XSe, ES) => {
        ES.exports = "removedfromscene";
      });
      SS = u((VSe, yS) => {
        yS.exports = "complete";
      });
      CS = u((YSe, wS) => {
        wS.exports = "created";
      });
      RS = u((WSe, AS) => {
        AS.exports = "error";
      });
      PS = u((HSe, _S) => {
        _S.exports = "locked";
      });
      qS = u((KSe, MS) => {
        MS.exports = "loop";
      });
      bS = u((ZSe, FS) => {
        FS.exports = "metadata";
      });
      OS = u((QSe, LS) => {
        LS.exports = "play";
      });
      NS = u((JSe, DS) => {
        DS.exports = "playing";
      });
      BS = u(($Se, IS) => {
        IS.exports = "seeked";
      });
      US = u((jSe, GS) => {
        GS.exports = "seeking";
      });
      kS = u((e1e, zS) => {
        zS.exports = "stalled";
      });
      VS = u((t1e, XS) => {
        XS.exports = "stop";
      });
      WS = u((i1e, YS) => {
        YS.exports = "textureready";
      });
      KS = u((r1e, HS) => {
        HS.exports = "unlocked";
      });
      QS = u((s1e, ZS) => {
        ZS.exports = "unsupported";
      });
      xs = u((n1e, JS) => {
        JS.exports = { ADDED_TO_SCENE: mS(), DESTROY: xS(), REMOVED_FROM_SCENE: TS(), VIDEO_COMPLETE: SS(),
        VIDEO_CREATED: CS(), VIDEO_ERROR: RS(), VIDEO_LOCKED: PS(), VIDEO_LOOP: qS(), VIDEO_METADATA: bS(),
        VIDEO_PLAY: OS(), VIDEO_PLAYING: NS(), VIDEO_SEEKED: BS(), VIDEO_SEEKING: US(), VIDEO_STALLED: kS(),
        VIDEO_STOP: VS(), VIDEO_TEXTURE: WS(), VIDEO_UNLOCKED: KS(), VIDEO_UNSUPPORTED: QS() };
      });
      ei = u((a1e, e1) => {
        var qQ = C(), FQ = io(), _n = Rn(), $S = Z(), Pn = xs(), jS = qe(), dl = new qQ({ Extends: $S,
        initialize: function(t, i) {
          $S.call(this), this.scene = t, this.displayList = null, this.type = i, this.state = 0, this.
          parentContainer = null, this.name = "", this.active = true, this.tabIndex = -1, this.data =
          null, this.renderFlags = 15, this.cameraFilter = 0, this.input = null, this.body = null, this.
          ignoreDestroy = false, this.on(Pn.ADDED_TO_SCENE, this.addedToScene, this), this.on(Pn.REMOVED_FROM_SCENE,
          this.removedFromScene, this), t.sys.queueDepthSort();
        }, setActive: function(e) {
          return this.active = e, this;
        }, setName: function(e) {
          return this.name = e, this;
        }, setState: function(e) {
          return this.state = e, this;
        }, setDataEnabled: function() {
          return this.data || (this.data = new _n(this)), this;
        }, setData: function(e, t) {
          return this.data || (this.data = new _n(this)), this.data.set(e, t), this;
        }, incData: function(e, t) {
          return this.data || (this.data = new _n(this)), this.data.inc(e, t), this;
        }, toggleData: function(e) {
          return this.data || (this.data = new _n(this)), this.data.toggle(e), this;
        }, getData: function(e) {
          return this.data || (this.data = new _n(this)), this.data.get(e);
        }, setInteractive: function(e, t, i) {
          return this.scene.sys.input.enable(this, e, t, i), this;
        }, disableInteractive: function(e) {
          return e === void 0 && (e = false), this.scene.sys.input.disable(this, e), this;
        }, removeInteractive: function(e) {
          return e === void 0 && (e = false), this.scene.sys.input.clear(this), e && this.scene.sys.
          input.resetCursor(), this.input = void 0, this;
        }, addedToScene: function() {
        }, removedFromScene: function() {
        }, update: function() {
        }, toJSON: function() {
          return FQ(this);
        }, willRender: function(e) {
          var t = this.displayList && this.displayList.active ? this.displayList.willRender(e) : true;
          return !(!t || dl.RENDER_MASK !== this.renderFlags || this.cameraFilter !== 0 && this.cameraFilter &
          e.id);
        }, getIndexList: function() {
          for (var e = this, t = this.parentContainer, i = []; t && (i.unshift(t.getIndex(e)), e = t,
          t.parentContainer); ) t = t.parentContainer;
          return this.displayList ? i.unshift(this.displayList.getIndex(e)) : i.unshift(this.scene.sys.
          displayList.getIndex(e)), i;
        }, addToDisplayList: function(e) {
          return e === void 0 && (e = this.scene.sys.displayList), this.displayList && this.displayList !==
          e && this.removeFromDisplayList(), e.exists(this) || (this.displayList = e, e.add(this, true),
          e.queueDepthSort(), this.emit(Pn.ADDED_TO_SCENE, this, this.scene), e.events.emit(jS.ADDED_TO_SCENE,
          this, this.scene)), this;
        }, addToUpdateList: function() {
          return this.scene && this.preUpdate && this.scene.sys.updateList.add(this), this;
        }, removeFromDisplayList: function() {
          var e = this.displayList || this.scene.sys.displayList;
          return e && e.exists(this) && (e.remove(this, true), e.queueDepthSort(), this.displayList =
          null, this.emit(Pn.REMOVED_FROM_SCENE, this, this.scene), e.events.emit(jS.REMOVED_FROM_SCENE,
          this, this.scene)), this;
        }, removeFromUpdateList: function() {
          return this.scene && this.preUpdate && this.scene.sys.updateList.remove(this), this;
        }, getDisplayList: function() {
          var e = null;
          return this.parentContainer ? e = this.parentContainer.list : this.displayList && (e = this.
          displayList.list), e;
        }, destroy: function(e) {
          !this.scene || this.ignoreDestroy || (e === void 0 && (e = false), this.preDestroy && this.
          preDestroy.call(this), this.emit(Pn.DESTROY, this, e), this.removeAllListeners(), this.postPipelines &&
          this.resetPostPipeline(true), this.removeFromDisplayList(), this.removeFromUpdateList(), this.
          input && (this.scene.sys.input.clear(this), this.input = void 0), this.data && (this.data.
          destroy(), this.data = void 0), this.body && (this.body.destroy(), this.body = void 0), this.
          preFX && (this.preFX.destroy(), this.preFX = void 0), this.postFX && (this.postFX.destroy(),
          this.postFX = void 0), this.active = false, this.visible = false, this.scene = void 0, this.
          parentContainer = void 0);
        } });
        dl.RENDER_MASK = 15;
        e1.exports = dl;
      });
      Mn = u((o1e, i1) => {
        var bQ = Qt(), LQ = vn(), OQ = Tr(), DQ = C(), Es = Ot(), t1 = ei(), NQ = he(), IQ = Ar(), BQ = new DQ(
        { Extends: t1, Mixins: [Es.Depth, Es.GetBounds, Es.Origin, Es.Transform, Es.ScrollFactor, Es.
        Visible], initialize: function(t, i, r, s, n) {
          s === void 0 && (s = 1), n === void 0 && (n = s), t1.call(this, t, "Zone"), this.setPosition(
          i, r), this.width = s, this.height = n, this.blendMode = bQ.NORMAL, this.updateDisplayOrigin();
        }, displayWidth: { get: function() {
          return this.scaleX * this.width;
        }, set: function(e) {
          this.scaleX = e / this.width;
        } }, displayHeight: { get: function() {
          return this.scaleY * this.height;
        }, set: function(e) {
          this.scaleY = e / this.height;
        } }, setSize: function(e, t, i) {
          i === void 0 && (i = true), this.width = e, this.height = t, this.updateDisplayOrigin();
          var r = this.input;
          return i && r && !r.customHitArea && (r.hitArea.width = e, r.hitArea.height = t), this;
        }, setDisplaySize: function(e, t) {
          return this.displayWidth = e, this.displayHeight = t, this;
        }, setCircleDropZone: function(e) {
          return this.setDropZone(new LQ(0, 0, e), OQ);
        }, setRectangleDropZone: function(e, t) {
          return this.setDropZone(new NQ(0, 0, e, t), IQ);
        }, setDropZone: function(e, t) {
          return this.input || this.setInteractive(e, t, true), this;
        }, setAlpha: function() {
        }, setBlendMode: function() {
        }, renderCanvas: function(e, t, i) {
          i.addToRenderList(t);
        }, renderWebGL: function(e, t, i) {
          i.addToRenderList(t);
        } });
        i1.exports = BQ;
      });
      n1 = u((h1e, s1) => {
        var GQ = zu(), UQ = cn(), Mr = B(), r1 = J(), zQ = Mn(), Xt = new zQ({ sys: { queueDepthSort: r1,
        events: { once: r1 } } }, 0, 0, 1, 1).setOrigin(0, 0), kQ = function(e, t) {
          t === void 0 && (t = {});
          var i = t.hasOwnProperty("width"), r = t.hasOwnProperty("height"), s = Mr(t, "width", -1),
          n = Mr(t, "height", -1), a = Mr(t, "cellWidth", 1), o = Mr(t, "cellHeight", a), h = Mr(t, "\
position", UQ.TOP_LEFT), l = Mr(t, "x", 0), f = Mr(t, "y", 0), d = 0, c = 0, p = s * a, v = n * o;
          Xt.setPosition(l, f), Xt.setSize(a, o);
          for (var m = 0; m < e.length; m++) if (GQ(e[m], Xt, h), i && s === -1) Xt.x += a;
          else if (r && n === -1) Xt.y += o;
          else if (r && !i) {
            if (c += o, Xt.y += o, c === v && (c = 0, d += a, Xt.y = f, Xt.x += a, d === p)) break;
          } else if (d += a, Xt.x += a, d === p && (d = 0, c += o, Xt.x = l, Xt.y += o, c === v)) break;
          return e;
        };
        s1.exports = kQ;
      });
      o1 = u((u1e, a1) => {
        var XQ = zt(), VQ = function(e, t, i, r, s) {
          return XQ(e, "alpha", t, i, r, s);
        };
        a1.exports = VQ;
      });
      u1 = u((l1e, h1) => {
        var YQ = zt(), WQ = function(e, t, i, r, s) {
          return YQ(e, "x", t, i, r, s);
        };
        h1.exports = WQ;
      });
      d1 = u((f1e, f1) => {
        var l1 = zt(), HQ = function(e, t, i, r, s, n, a) {
          return i == null && (i = t), l1(e, "x", t, r, n, a), l1(e, "y", i, s, n, a);
        };
        f1.exports = HQ;
      });
      v1 = u((d1e, c1) => {
        var KQ = zt(), ZQ = function(e, t, i, r, s) {
          return KQ(e, "y", t, i, r, s);
        };
        c1.exports = ZQ;
      });
      m1 = u((c1e, p1) => {
        var QQ = function(e, t, i, r) {
          i === void 0 && (i = 0), r === void 0 && (r = 6.28);
          for (var s = i, n = (r - i) / e.length, a = t.x, o = t.y, h = t.radius, l = 0; l < e.length; l++)
           e[l].x = a + h * Math.cos(s), e[l].y = o + h * Math.sin(s), s += n;
          return e;
        };
        p1.exports = QQ;
      });
      x1 = u((v1e, g1) => {
        var JQ = function(e, t, i, r) {
          i === void 0 && (i = 0), r === void 0 && (r = 6.28);
          for (var s = i, n = (r - i) / e.length, a = t.width / 2, o = t.height / 2, h = 0; h < e.length; h++)
           e[h].x = t.x + a * Math.cos(s), e[h].y = t.y + o * Math.sin(s), s += n;
          return e;
        };
        g1.exports = JQ;
      });
      cl = u((p1e, E1) => {
        var $Q = function(e, t) {
          var i = e.x - t.x, r = e.y - t.y;
          return Math.sqrt(i * i + r * r);
        };
        E1.exports = $Q;
      });
      y1 = u((m1e, T1) => {
        var jQ = function(e, t) {
          return t === void 0 && (t = 1.70158), e * e * ((t + 1) * e - t);
        };
        T1.exports = jQ;
      });
      w1 = u((g1e, S1) => {
        var eJ = function(e, t) {
          return t === void 0 && (t = 1.70158), --e * e * ((t + 1) * e + t) + 1;
        };
        S1.exports = eJ;
      });
      A1 = u((x1e, C1) => {
        var tJ = function(e, t) {
          t === void 0 && (t = 1.70158);
          var i = t * 1.525;
          return (e *= 2) < 1 ? 0.5 * (e * e * ((i + 1) * e - i)) : 0.5 * ((e -= 2) * e * ((i + 1) *
          e + i) + 2);
        };
        C1.exports = tJ;
      });
      vl = u((E1e, R1) => {
        R1.exports = { In: y1(), Out: w1(), InOut: A1() };
      });
      P1 = u((T1e, _1) => {
        var iJ = function(e) {
          return e = 1 - e, e < 0.36363636363636365 ? 1 - 7.5625 * e * e : e < 0.7272727272727273 ? 1 -
          (7.5625 * (e -= 0.5454545454545454) * e + 0.75) : e < 0.9090909090909091 ? 1 - (7.5625 * (e -=
          0.8181818181818182) * e + 0.9375) : 1 - (7.5625 * (e -= 0.9545454545454546) * e + 0.984375);
        };
        _1.exports = iJ;
      });
      q1 = u((y1e, M1) => {
        var rJ = function(e) {
          return e < 0.36363636363636365 ? 7.5625 * e * e : e < 0.7272727272727273 ? 7.5625 * (e -= 0.5454545454545454) *
          e + 0.75 : e < 0.9090909090909091 ? 7.5625 * (e -= 0.8181818181818182) * e + 0.9375 : 7.5625 *
          (e -= 0.9545454545454546) * e + 0.984375;
        };
        M1.exports = rJ;
      });
      b1 = u((S1e, F1) => {
        var sJ = function(e) {
          var t = false;
          return e < 0.5 ? (e = 1 - e * 2, t = true) : e = e * 2 - 1, e < 0.36363636363636365 ? e = 7.5625 *
          e * e : e < 0.7272727272727273 ? e = 7.5625 * (e -= 0.5454545454545454) * e + 0.75 : e < 0.9090909090909091 ?
          e = 7.5625 * (e -= 0.8181818181818182) * e + 0.9375 : e = 7.5625 * (e -= 0.9545454545454546) *
          e + 0.984375, t ? (1 - e) * 0.5 : e * 0.5 + 0.5;
        };
        F1.exports = sJ;
      });
      pl = u((w1e, L1) => {
        L1.exports = { In: P1(), Out: q1(), InOut: b1() };
      });
      D1 = u((C1e, O1) => {
        var nJ = function(e) {
          return 1 - Math.sqrt(1 - e * e);
        };
        O1.exports = nJ;
      });
      I1 = u((A1e, N1) => {
        var aJ = function(e) {
          return Math.sqrt(1 - --e * e);
        };
        N1.exports = aJ;
      });
      G1 = u((R1e, B1) => {
        var oJ = function(e) {
          return (e *= 2) < 1 ? -0.5 * (Math.sqrt(1 - e * e) - 1) : 0.5 * (Math.sqrt(1 - (e -= 2) * e) +
          1);
        };
        B1.exports = oJ;
      });
      ml = u((_1e, U1) => {
        U1.exports = { In: D1(), Out: I1(), InOut: G1() };
      });
      k1 = u((P1e, z1) => {
        var hJ = function(e) {
          return e * e * e;
        };
        z1.exports = hJ;
      });
      V1 = u((M1e, X1) => {
        var uJ = function(e) {
          return --e * e * e + 1;
        };
        X1.exports = uJ;
      });
      W1 = u((q1e, Y1) => {
        var lJ = function(e) {
          return (e *= 2) < 1 ? 0.5 * e * e * e : 0.5 * ((e -= 2) * e * e + 2);
        };
        Y1.exports = lJ;
      });
      gl = u((F1e, H1) => {
        H1.exports = { In: k1(), Out: V1(), InOut: W1() };
      });
      Z1 = u((b1e, K1) => {
        var fJ = function(e, t, i) {
          if (t === void 0 && (t = 0.1), i === void 0 && (i = 0.1), e === 0) return 0;
          if (e === 1) return 1;
          var r = i / 4;
          return t < 1 ? t = 1 : r = i * Math.asin(1 / t) / (2 * Math.PI), -(t * Math.pow(2, 10 * (e -=
          1)) * Math.sin((e - r) * (2 * Math.PI) / i));
        };
        K1.exports = fJ;
      });
      J1 = u((L1e, Q1) => {
        var dJ = function(e, t, i) {
          if (t === void 0 && (t = 0.1), i === void 0 && (i = 0.1), e === 0) return 0;
          if (e === 1) return 1;
          var r = i / 4;
          return t < 1 ? t = 1 : r = i * Math.asin(1 / t) / (2 * Math.PI), t * Math.pow(2, -10 * e) *
          Math.sin((e - r) * (2 * Math.PI) / i) + 1;
        };
        Q1.exports = dJ;
      });
      j1 = u((O1e, $1) => {
        var cJ = function(e, t, i) {
          if (t === void 0 && (t = 0.1), i === void 0 && (i = 0.1), e === 0) return 0;
          if (e === 1) return 1;
          var r = i / 4;
          return t < 1 ? t = 1 : r = i * Math.asin(1 / t) / (2 * Math.PI), (e *= 2) < 1 ? -0.5 * (t *
          Math.pow(2, 10 * (e -= 1)) * Math.sin((e - r) * (2 * Math.PI) / i)) : t * Math.pow(2, -10 *
          (e -= 1)) * Math.sin((e - r) * (2 * Math.PI) / i) * 0.5 + 1;
        };
        $1.exports = cJ;
      });
      xl = u((D1e, ew) => {
        ew.exports = { In: Z1(), Out: J1(), InOut: j1() };
      });
      iw = u((N1e, tw) => {
        var vJ = function(e) {
          return Math.pow(2, 10 * (e - 1)) - 1e-3;
        };
        tw.exports = vJ;
      });
      sw = u((I1e, rw) => {
        var pJ = function(e) {
          return 1 - Math.pow(2, -10 * e);
        };
        rw.exports = pJ;
      });
      aw = u((B1e, nw) => {
        var mJ = function(e) {
          return (e *= 2) < 1 ? 0.5 * Math.pow(2, 10 * (e - 1)) : 0.5 * (2 - Math.pow(2, -10 * (e - 1)));
        };
        nw.exports = mJ;
      });
      El = u((G1e, ow) => {
        ow.exports = { In: iw(), Out: sw(), InOut: aw() };
      });
      uw = u((U1e, hw) => {
        var gJ = function(e) {
          return e;
        };
        hw.exports = gJ;
      });
      Tl = u((z1e, lw) => {
        lw.exports = uw();
      });
      dw = u((k1e, fw) => {
        var xJ = function(e) {
          return e * e;
        };
        fw.exports = xJ;
      });
      vw = u((X1e, cw) => {
        var EJ = function(e) {
          return e * (2 - e);
        };
        cw.exports = EJ;
      });
      mw = u((V1e, pw) => {
        var TJ = function(e) {
          return (e *= 2) < 1 ? 0.5 * e * e : -0.5 * (--e * (e - 2) - 1);
        };
        pw.exports = TJ;
      });
      yl = u((Y1e, gw) => {
        gw.exports = { In: dw(), Out: vw(), InOut: mw() };
      });
      Ew = u((W1e, xw) => {
        var yJ = function(e) {
          return e * e * e * e;
        };
        xw.exports = yJ;
      });
      yw = u((H1e, Tw) => {
        var SJ = function(e) {
          return 1 - --e * e * e * e;
        };
        Tw.exports = SJ;
      });
      ww = u((K1e, Sw) => {
        var wJ = function(e) {
          return (e *= 2) < 1 ? 0.5 * e * e * e * e : -0.5 * ((e -= 2) * e * e * e - 2);
        };
        Sw.exports = wJ;
      });
      Sl = u((Z1e, Cw) => {
        Cw.exports = { In: Ew(), Out: yw(), InOut: ww() };
      });
      Rw = u((Q1e, Aw) => {
        var CJ = function(e) {
          return e * e * e * e * e;
        };
        Aw.exports = CJ;
      });
      Pw = u((J1e, _w) => {
        var AJ = function(e) {
          return --e * e * e * e * e + 1;
        };
        _w.exports = AJ;
      });
      qw = u(($1e, Mw) => {
        var RJ = function(e) {
          return (e *= 2) < 1 ? 0.5 * e * e * e * e * e : 0.5 * ((e -= 2) * e * e * e * e + 2);
        };
        Mw.exports = RJ;
      });
      wl = u((j1e, Fw) => {
        Fw.exports = { In: Rw(), Out: Pw(), InOut: qw() };
      });
      Lw = u((ewe, bw) => {
        var _J = function(e) {
          return e === 0 ? 0 : e === 1 ? 1 : 1 - Math.cos(e * Math.PI / 2);
        };
        bw.exports = _J;
      });
      Dw = u((twe, Ow) => {
        var PJ = function(e) {
          return e === 0 ? 0 : e === 1 ? 1 : Math.sin(e * Math.PI / 2);
        };
        Ow.exports = PJ;
      });
      Iw = u((iwe, Nw) => {
        var MJ = function(e) {
          return e === 0 ? 0 : e === 1 ? 1 : 0.5 * (1 - Math.cos(Math.PI * e));
        };
        Nw.exports = MJ;
      });
      Cl = u((rwe, Bw) => {
        Bw.exports = { In: Lw(), Out: Dw(), InOut: Iw() };
      });
      Uw = u((swe, Gw) => {
        var qJ = function(e, t) {
          return t === void 0 && (t = 1), e <= 0 ? 0 : e >= 1 ? 1 : ((t * e | 0) + 1) * (1 / t);
        };
        Gw.exports = qJ;
      });
      Al = u((nwe, zw) => {
        zw.exports = Uw();
      });
      On = u((awe, Xw) => {
        var so = vl(), no = pl(), ao = ml(), qn = gl(), oo = xl(), ho = El(), kw = Tl(), Fn = yl(), bn = Sl(),
        Ln = wl(), uo = Cl(), FJ = Al();
        Xw.exports = { Power0: kw, Power1: Fn.Out, Power2: qn.Out, Power3: bn.Out, Power4: Ln.Out, Linear: kw,
        Quad: Fn.Out, Cubic: qn.Out, Quart: bn.Out, Quint: Ln.Out, Sine: uo.Out, Expo: ho.Out, Circ: ao.
        Out, Elastic: oo.Out, Back: so.Out, Bounce: no.Out, Stepped: FJ, "Quad.easeIn": Fn.In, "Cubi\
c.easeIn": qn.In, "Quart.easeIn": bn.In, "Quint.easeIn": Ln.In, "Sine.easeIn": uo.In, "Expo.easeIn": ho.
        In, "Circ.easeIn": ao.In, "Elastic.easeIn": oo.In, "Back.easeIn": so.In, "Bounce.easeIn": no.
        In, "Quad.easeOut": Fn.Out, "Cubic.easeOut": qn.Out, "Quart.easeOut": bn.Out, "Quint.easeOut": Ln.
        Out, "Sine.easeOut": uo.Out, "Expo.easeOut": ho.Out, "Circ.easeOut": ao.Out, "Elastic.easeOu\
t": oo.Out, "Back.easeOut": so.Out, "Bounce.easeOut": no.Out, "Quad.easeInOut": Fn.InOut, "Cubic.eas\
eInOut": qn.InOut, "Quart.easeInOut": bn.InOut, "Quint.easeInOut": Ln.InOut, "Sine.easeInOut": uo.InOut,
        "Expo.easeInOut": ho.InOut, "Circ.easeInOut": ao.InOut, "Elastic.easeInOut": oo.InOut, "Back\
.easeInOut": so.InOut, "Bounce.easeInOut": no.InOut };
      });
      lo = u((owe, Vw) => {
        var bJ = function(e) {
          return e && e[0].toUpperCase() + e.slice(1);
        };
        Vw.exports = bJ;
      });
      Zi = u((hwe, Yw) => {
        var Dn = On(), LJ = lo(), OJ = function(e, t) {
          var i = Dn.Power0;
          if (typeof e == "string") if (Dn.hasOwnProperty(e)) i = Dn[e];
          else {
            var r = "";
            if (e.indexOf(".")) {
              r = e.substring(e.indexOf(".") + 1);
              var s = r.toLowerCase();
              s === "in" ? r = "easeIn" : s === "out" ? r = "easeOut" : s === "inout" && (r = "easeI\
nOut");
            }
            e = LJ(e.substring(0, e.indexOf(".") + 1) + r), Dn.hasOwnProperty(e) && (i = Dn[e]);
          }
          else typeof e == "function" && (i = e);
          if (!t) return i;
          var n = t.slice(0);
          return n.unshift(0), function(a) {
            return n[0] = a, i.apply(this, n);
          };
        };
        Yw.exports = OJ;
      });
      Rl = u((uwe, Kw) => {
        var Ww = cl(), DJ = Zi(), Hw = ae(), NJ = function(e, t, i, r, s) {
          r === void 0 && (r = 0), s === void 0 && (s = []);
          var n = [], a = e.x1, o = e.y1, h = e.x2 - a, l = e.y2 - o, f = DJ(t, s), d, c, p = i - 1;
          for (d = 0; d < p; d++) c = f(d / p), n.push(new Hw(a + h * c, o + l * c));
          if (c = f(1), n.push(new Hw(a + h * c, o + l * c)), r > 0) {
            var v = n[0], m = [v];
            for (d = 1; d < n.length - 1; d++) {
              var g = n[d];
              Ww(v, g) >= r && (m.push(g), v = g);
            }
            var x = n[n.length - 1];
            return Ww(v, x) < r && m.pop(), m.push(x), m;
          } else return n;
        };
        Kw.exports = NJ;
      });
      Qw = u((lwe, Zw) => {
        var IJ = Za(), BJ = Rl(), GJ = function(e, t, i) {
          var r;
          i ? r = BJ(t, i, e.length) : r = IJ(t, e.length);
          for (var s = 0; s < e.length; s++) {
            var n = e[s], a = r[s];
            n.x = a.x, n.y = a.y;
          }
          return e;
        };
        Zw.exports = GJ;
      });
      _l = u((fwe, $w) => {
        var Jw = Sn(), UJ = ae(), zJ = function(e, t, i, r) {
          if (r === void 0 && (r = []), !t && !i) return r;
          t ? i = Math.round(Jw(e) / t) : t = Jw(e) / i;
          for (var s = e.x, n = e.y, a = 0, o = 0; o < i; o++) switch (r.push(new UJ(s, n)), a) {
            case 0:
              s += t, s >= e.right && (a = 1, n += s - e.right, s = e.right);
              break;
            case 1:
              n += t, n >= e.bottom && (a = 2, s -= n - e.bottom, n = e.bottom);
              break;
            case 2:
              s -= t, s <= e.left && (a = 3, n -= e.left - s, s = e.left);
              break;
            case 3:
              n -= t, n <= e.top && (a = 0, n = e.top);
              break;
          }
          return r;
        };
        $w.exports = zJ;
      });
      eC = u((dwe, jw) => {
        var kJ = _l(), XJ = Ba(), VJ = Ga(), YJ = function(e, t, i) {
          i === void 0 && (i = 0);
          var r = kJ(t, false, e.length);
          i > 0 ? XJ(r, i) : i < 0 && VJ(r, Math.abs(i));
          for (var s = 0; s < e.length; s++) e[s].x = r[s].x, e[s].y = r[s].y;
          return e;
        };
        jw.exports = YJ;
      });
      Pl = u((cwe, tC) => {
        var WJ = function(e, t, i) {
          t === void 0 && (t = 1), i === void 0 && (i = []);
          var r = Math.round(e.x1), s = Math.round(e.y1), n = Math.round(e.x2), a = Math.round(e.y2),
          o = Math.abs(n - r), h = Math.abs(a - s), l = r < n ? 1 : -1, f = s < a ? 1 : -1, d = o - h;
          i.push({ x: r, y: s });
          for (var c = 1; !(r === n && s === a); ) {
            var p = d << 1;
            p > -h && (d -= h, r += l), p < o && (d += o, s += f), c % t === 0 && i.push({ x: r, y: s }),
            c++;
          }
          return i;
        };
        tC.exports = WJ;
      });
      rC = u((vwe, iC) => {
        var Ml = Pl(), HJ = function(e, t, i) {
          var r = Ml({ x1: t.x1, y1: t.y1, x2: t.x2, y2: t.y2 }, i), s = Ml({ x1: t.x2, y1: t.y2, x2: t.
          x3, y2: t.y3 }, i), n = Ml({ x1: t.x3, y1: t.y3, x2: t.x1, y2: t.y1 }, i);
          r.pop(), s.pop(), n.pop(), r = r.concat(s, n);
          for (var a = r.length / e.length, o = 0, h = 0; h < e.length; h++) {
            var l = e[h], f = r[Math.floor(o)];
            l.x = f.x, l.y = f.y, o += a;
          }
          return e;
        };
        iC.exports = HJ;
      });
      nC = u((pwe, sC) => {
        var KJ = function(e, t, i) {
          for (var r = 0; r < e.length; r++) {
            var s = e[r];
            s.anims && s.anims.play(t, i);
          }
          return e;
        };
        sC.exports = KJ;
      });
      Ie = u((mwe, aC) => {
        var ZJ = function(e, t, i, r, s, n) {
          r === void 0 && (r = 0), s === void 0 && (s = 0), n === void 0 && (n = 1);
          var a, o = 0, h = e.length;
          if (n === 1) for (a = s; a < h; a++) e[a][t] = i + o * r, o++;
          else for (a = s; a >= 0; a--) e[a][t] = i + o * r, o++;
          return e;
        };
        aC.exports = ZJ;
      });
      hC = u((gwe, oC) => {
        var QJ = Na(), JJ = function(e, t) {
          for (var i = 0; i < e.length; i++) QJ(t, e[i]);
          return e;
        };
        oC.exports = JJ;
      });
      ql = u((xwe, uC) => {
        var $J = ae(), jJ = function(e, t) {
          t === void 0 && (t = new $J());
          var i = Math.random() * Math.PI * 2, r = Math.sqrt(Math.random());
          return t.x = e.x + r * Math.cos(i) * e.width / 2, t.y = e.y + r * Math.sin(i) * e.height /
          2, t;
        };
        uC.exports = jJ;
      });
      fC = u((Ewe, lC) => {
        var e$ = ql(), t$ = function(e, t) {
          for (var i = 0; i < e.length; i++) e$(t, e[i]);
          return e;
        };
        lC.exports = t$;
      });
      cC = u((Twe, dC) => {
        var i$ = Qa(), r$ = function(e, t) {
          for (var i = 0; i < e.length; i++) i$(t, e[i]);
          return e;
        };
        dC.exports = r$;
      });
      pC = u((ywe, vC) => {
        var s$ = $a(), n$ = function(e, t) {
          for (var i = 0; i < e.length; i++) s$(t, e[i]);
          return e;
        };
        vC.exports = n$;
      });
      Fl = u((Swe, mC) => {
        var a$ = ae(), o$ = function(e, t) {
          t === void 0 && (t = new a$());
          var i = e.x2 - e.x1, r = e.y2 - e.y1, s = e.x3 - e.x1, n = e.y3 - e.y1, a = Math.random(),
          o = Math.random();
          return a + o >= 1 && (a = 1 - a, o = 1 - o), t.x = e.x1 + (i * a + s * o), t.y = e.y1 + (r *
          a + n * o), t;
        };
        mC.exports = o$;
      });
      xC = u((wwe, gC) => {
        var h$ = Fl(), u$ = function(e, t) {
          for (var i = 0; i < e.length; i++) h$(t, e[i]);
          return e;
        };
        gC.exports = u$;
      });
      TC = u((Cwe, EC) => {
        var l$ = zt(), f$ = function(e, t, i, r, s) {
          return l$(e, "rotation", t, i, r, s);
        };
        EC.exports = f$;
      });
      fo = u((Awe, yC) => {
        var d$ = function(e, t, i, r, s) {
          var n = r + Math.atan2(e.y - i, e.x - t);
          return e.x = t + s * Math.cos(n), e.y = i + s * Math.sin(n), e;
        };
        yC.exports = d$;
      });
      Nn = u((Rwe, SC) => {
        var c$ = function(e, t, i, r) {
          var s = e - i, n = t - r;
          return Math.sqrt(s * s + n * n);
        };
        SC.exports = c$;
      });
      CC = u((_we, wC) => {
        var v$ = fo(), p$ = Nn(), m$ = function(e, t, i) {
          for (var r = t.x, s = t.y, n = 0; n < e.length; n++) {
            var a = e[n];
            v$(a, r, s, i, Math.max(1, p$(a.x, a.y, r, s)));
          }
          return e;
        };
        wC.exports = m$;
      });
      RC = u((Pwe, AC) => {
        var g$ = fo(), x$ = function(e, t, i, r) {
          var s = t.x, n = t.y;
          if (r === 0) return e;
          for (var a = 0; a < e.length; a++) g$(e[a], s, n, i, r);
          return e;
        };
        AC.exports = x$;
      });
      PC = u((Mwe, _C) => {
        var E$ = zt(), T$ = function(e, t, i, r, s) {
          return E$(e, "scaleX", t, i, r, s);
        };
        _C.exports = T$;
      });
      FC = u((qwe, qC) => {
        var MC = zt(), y$ = function(e, t, i, r, s, n, a) {
          return i == null && (i = t), MC(e, "scaleX", t, r, n, a), MC(e, "scaleY", i, s, n, a);
        };
        qC.exports = y$;
      });
      LC = u((Fwe, bC) => {
        var S$ = zt(), w$ = function(e, t, i, r, s) {
          return S$(e, "scaleY", t, i, r, s);
        };
        bC.exports = w$;
      });
      DC = u((bwe, OC) => {
        var C$ = Ie(), A$ = function(e, t, i, r, s) {
          return C$(e, "alpha", t, i, r, s);
        };
        OC.exports = A$;
      });
      IC = u((Lwe, NC) => {
        var R$ = Ie(), _$ = function(e, t, i, r) {
          return R$(e, "blendMode", t, 0, i, r);
        };
        NC.exports = _$;
      });
      GC = u((Owe, BC) => {
        var P$ = Ie(), M$ = function(e, t, i, r, s) {
          return P$(e, "depth", t, i, r, s);
        };
        BC.exports = M$;
      });
      zC = u((Dwe, UC) => {
        var q$ = function(e, t, i) {
          for (var r = 0; r < e.length; r++) e[r].setInteractive(t, i);
          return e;
        };
        UC.exports = q$;
      });
      VC = u((Nwe, XC) => {
        var kC = Ie(), F$ = function(e, t, i, r, s, n, a) {
          return i == null && (i = t), kC(e, "originX", t, r, n, a), kC(e, "originY", i, s, n, a), e.
          forEach(function(o) {
            o.updateDisplayOrigin();
          }), e;
        };
        XC.exports = F$;
      });
      WC = u((Iwe, YC) => {
        var b$ = Ie(), L$ = function(e, t, i, r, s) {
          return b$(e, "rotation", t, i, r, s);
        };
        YC.exports = L$;
      });
      ZC = u((Bwe, KC) => {
        var HC = Ie(), O$ = function(e, t, i, r, s, n, a) {
          return i == null && (i = t), HC(e, "scaleX", t, r, n, a), HC(e, "scaleY", i, s, n, a);
        };
        KC.exports = O$;
      });
      JC = u((Gwe, QC) => {
        var D$ = Ie(), N$ = function(e, t, i, r, s) {
          return D$(e, "scaleX", t, i, r, s);
        };
        QC.exports = N$;
      });
      jC = u((Uwe, $C) => {
        var I$ = Ie(), B$ = function(e, t, i, r, s) {
          return I$(e, "scaleY", t, i, r, s);
        };
        $C.exports = B$;
      });
      iA = u((zwe, tA) => {
        var eA = Ie(), G$ = function(e, t, i, r, s, n, a) {
          return i == null && (i = t), eA(e, "scrollFactorX", t, r, n, a), eA(e, "scrollFactorY", i,
          s, n, a);
        };
        tA.exports = G$;
      });
      sA = u((kwe, rA) => {
        var U$ = Ie(), z$ = function(e, t, i, r, s) {
          return U$(e, "scrollFactorX", t, i, r, s);
        };
        rA.exports = z$;
      });
      aA = u((Xwe, nA) => {
        var k$ = Ie(), X$ = function(e, t, i, r, s) {
          return k$(e, "scrollFactorY", t, i, r, s);
        };
        nA.exports = X$;
      });
      hA = u((Vwe, oA) => {
        var V$ = function(e, t, i, r, s) {
          for (var n = 0; n < e.length; n++) e[n].setTint(t, i, r, s);
          return e;
        };
        oA.exports = V$;
      });
      lA = u((Ywe, uA) => {
        var Y$ = Ie(), W$ = function(e, t, i, r) {
          return Y$(e, "visible", t, 0, i, r);
        };
        uA.exports = W$;
      });
      dA = u((Wwe, fA) => {
        var H$ = Ie(), K$ = function(e, t, i, r, s) {
          return H$(e, "x", t, i, r, s);
        };
        fA.exports = K$;
      });
      pA = u((Hwe, vA) => {
        var cA = Ie(), Z$ = function(e, t, i, r, s, n, a) {
          return i == null && (i = t), cA(e, "x", t, r, n, a), cA(e, "y", i, s, n, a);
        };
        vA.exports = Z$;
      });
      gA = u((Kwe, mA) => {
        var Q$ = Ie(), J$ = function(e, t, i, r, s) {
          return Q$(e, "y", t, i, r, s);
        };
        mA.exports = J$;
      });
      EA = u((Zwe, xA) => {
        var $$ = Y(), j$ = function(e, t, i, r, s) {
          r === void 0 && (r = 0), s === void 0 && (s = new $$());
          var n, a, o = e.length;
          if (o === 1) n = e[0].x, a = e[0].y, e[0].x = t, e[0].y = i;
          else {
            var h = 1, l = 0;
            r === 0 && (l = o - 1, h = o - 2), n = e[l].x, a = e[l].y, e[l].x = t, e[l].y = i;
            for (var f = 0; f < o; f++) if (!(h >= o || h === -1)) {
              var d = e[h], c = d.x, p = d.y;
              d.x = n, d.y = a, n = c, a = p, r === 0 ? h-- : h++;
            }
          }
          return s.x = n, s.y = a, s;
        };
        xA.exports = j$;
      });
      yA = u((Qwe, TA) => {
        var ej = za(), tj = function(e) {
          return ej(e);
        };
        TA.exports = tj;
      });
      co = u((Jwe, SA) => {
        var ij = function(e, t, i) {
          return e = Math.max(0, Math.min(1, (e - t) / (i - t))), e * e * e * (e * (e * 6 - 15) + 10);
        };
        SA.exports = ij;
      });
      AA = u(($we, CA) => {
        var wA = co(), rj = function(e, t, i, r, s) {
          s === void 0 && (s = false);
          var n = Math.abs(r - i) / e.length, a;
          if (s) for (a = 0; a < e.length; a++) e[a][t] += wA(a * n, i, r);
          else for (a = 0; a < e.length; a++) e[a][t] = wA(a * n, i, r);
          return e;
        };
        CA.exports = rj;
      });
      vo = u((jwe, RA) => {
        var sj = function(e, t, i) {
          return e <= t ? 0 : e >= i ? 1 : (e = (e - t) / (i - t), e * e * (3 - 2 * e));
        };
        RA.exports = sj;
      });
      MA = u((eCe, PA) => {
        var _A = vo(), nj = function(e, t, i, r, s) {
          s === void 0 && (s = false);
          var n = Math.abs(r - i) / e.length, a;
          if (s) for (a = 0; a < e.length; a++) e[a][t] += _A(a * n, i, r);
          else for (a = 0; a < e.length; a++) e[a][t] = _A(a * n, i, r);
          return e;
        };
        PA.exports = nj;
      });
      FA = u((tCe, qA) => {
        var aj = function(e, t, i, r, s) {
          if (s === void 0 && (s = false), e.length === 0) return e;
          if (e.length === 1) return s ? e[0][t] += (r + i) / 2 : e[0][t] = (r + i) / 2, e;
          var n = Math.abs(r - i) / (e.length - 1), a;
          if (s) for (a = 0; a < e.length; a++) e[a][t] += a * n + i;
          else for (a = 0; a < e.length; a++) e[a][t] = a * n + i;
          return e;
        };
        qA.exports = aj;
      });
      LA = u((iCe, bA) => {
        var oj = function(e) {
          for (var t = 0; t < e.length; t++) e[t].visible = !e[t].visible;
          return e;
        };
        bA.exports = oj;
      });
      NA = u((rCe, DA) => {
        var OA = Ki(), hj = function(e, t, i) {
          i === void 0 && (i = 0);
          for (var r = 0; r < e.length; r++) {
            var s = e[r];
            s.x = OA(s.x, t.left - i, t.right + i), s.y = OA(s.y, t.top - i, t.bottom + i);
          }
          return e;
        };
        DA.exports = hj;
      });
      bl = u((sCe, IA) => {
        IA.exports = { AlignTo: mg(), Angle: Eg(), Call: yg(), GetFirst: wg(), GetLast: Ag(), GridAlign: n1(),
        IncAlpha: o1(), IncX: u1(), IncXY: d1(), IncY: v1(), PlaceOnCircle: m1(), PlaceOnEllipse: x1(),
        PlaceOnLine: Qw(), PlaceOnRectangle: eC(), PlaceOnTriangle: rC(), PlayAnimation: nC(), PropertyValueInc: zt(),
        PropertyValueSet: Ie(), RandomCircle: hC(), RandomEllipse: fC(), RandomLine: cC(), RandomRectangle: pC(),
        RandomTriangle: xC(), Rotate: TC(), RotateAround: CC(), RotateAroundDistance: RC(), ScaleX: PC(),
        ScaleXY: FC(), ScaleY: LC(), SetAlpha: DC(), SetBlendMode: IC(), SetDepth: GC(), SetHitArea: zC(),
        SetOrigin: VC(), SetRotation: WC(), SetScale: ZC(), SetScaleX: JC(), SetScaleY: jC(), SetScrollFactor: iA(),
        SetScrollFactorX: sA(), SetScrollFactorY: aA(), SetTint: hA(), SetVisible: lA(), SetX: dA(),
        SetXY: pA(), SetY: gA(), ShiftPosition: EA(), Shuffle: yA(), SmootherStep: AA(), SmoothStep: MA(),
        Spread: FA(), ToggleVisible: LA(), WrapInRectangle: NA() };
      });
      GA = u((nCe, BA) => {
        BA.exports = "add";
      });
      zA = u((aCe, UA) => {
        UA.exports = "remove";
      });
      Ll = u((oCe, kA) => {
        kA.exports = { ADD: GA(), REMOVE: zA() };
      });
      Ol = u((hCe, VA) => {
        var uj = C(), lj = rs(), fj = Z(), XA = Ll(), dj = new uj({ initialize: function() {
          this.entries = new lj(), this.events = new fj();
        }, add: function(e, t) {
          return this.entries.set(e, t), this.events.emit(XA.ADD, this, e, t), this;
        }, has: function(e) {
          return this.entries.has(e);
        }, exists: function(e) {
          return this.entries.has(e);
        }, get: function(e) {
          return this.entries.get(e);
        }, remove: function(e) {
          var t = this.get(e);
          return t && (this.entries.delete(e), this.events.emit(XA.REMOVE, this, e, t.data)), this;
        }, getKeys: function() {
          return this.entries.keys();
        }, destroy: function() {
          this.entries.clear(), this.events.removeAllListeners(), this.entries = null, this.events =
          null;
        } });
        VA.exports = dj;
      });
      Dl = u((uCe, YA) => {
        var yt = Ol(), cj = C(), vj = Ye(), pj = new cj({ initialize: function(t) {
          this.game = t, this.binary = new yt(), this.bitmapFont = new yt(), this.json = new yt(), this.
          physics = new yt(), this.shader = new yt(), this.audio = new yt(), this.video = new yt(), this.
          text = new yt(), this.html = new yt(), this.obj = new yt(), this.tilemap = new yt(), this.
          xml = new yt(), this.custom = {}, this.game.events.once(vj.DESTROY, this.destroy, this);
        }, addCustom: function(e) {
          return this.custom.hasOwnProperty(e) || (this.custom[e] = new yt()), this.custom[e];
        }, destroy: function() {
          for (var e = ["binary", "bitmapFont", "json", "physics", "shader", "audio", "video", "text",
          "html", "obj", "tilemap", "xml"], t = 0; t < e.length; t++) this[e[t]].destroy(), this[e[t]] =
          null;
          for (var i in this.custom) this.custom[i].destroy();
          this.custom = null, this.game = null;
        } });
        YA.exports = pj;
      });
      HA = u((lCe, WA) => {
        WA.exports = { BaseCache: Ol(), CacheManager: Dl(), Events: Ll() };
      });
      ZA = u((fCe, KA) => {
        KA.exports = "cameradestroy";
      });
      JA = u((dCe, QA) => {
        QA.exports = "camerafadeincomplete";
      });
      jA = u((cCe, $A) => {
        $A.exports = "camerafadeinstart";
      });
      tR = u((vCe, eR) => {
        eR.exports = "camerafadeoutcomplete";
      });
      rR = u((pCe, iR) => {
        iR.exports = "camerafadeoutstart";
      });
      nR = u((mCe, sR) => {
        sR.exports = "cameraflashcomplete";
      });
      oR = u((gCe, aR) => {
        aR.exports = "cameraflashstart";
      });
      uR = u((xCe, hR) => {
        hR.exports = "followupdate";
      });
      fR = u((ECe, lR) => {
        lR.exports = "camerapancomplete";
      });
      cR = u((TCe, dR) => {
        dR.exports = "camerapanstart";
      });
      pR = u((yCe, vR) => {
        vR.exports = "postrender";
      });
      gR = u((SCe, mR) => {
        mR.exports = "prerender";
      });
      ER = u((wCe, xR) => {
        xR.exports = "camerarotatecomplete";
      });
      yR = u((CCe, TR) => {
        TR.exports = "camerarotatestart";
      });
      wR = u((ACe, SR) => {
        SR.exports = "camerashakecomplete";
      });
      AR = u((RCe, CR) => {
        CR.exports = "camerashakestart";
      });
      _R = u((_Ce, RR) => {
        RR.exports = "camerazoomcomplete";
      });
      MR = u((PCe, PR) => {
        PR.exports = "camerazoomstart";
      });
      Dt = u((MCe, qR) => {
        qR.exports = { DESTROY: ZA(), FADE_IN_COMPLETE: JA(), FADE_IN_START: jA(), FADE_OUT_COMPLETE: tR(),
        FADE_OUT_START: rR(), FLASH_COMPLETE: nR(), FLASH_START: oR(), FOLLOW_UPDATE: uR(), PAN_COMPLETE: fR(),
        PAN_START: cR(), POST_RENDER: pR(), PRE_RENDER: gR(), ROTATE_COMPLETE: ER(), ROTATE_START: yR(),
        SHAKE_COMPLETE: wR(), SHAKE_START: AR(), ZOOM_COMPLETE: _R(), ZOOM_START: MR() };
      });
      po = u((qCe, FR) => {
        var mj = function(e, t, i) {
          return e << 16 | t << 8 | i;
        };
        FR.exports = mj;
      });
      LR = u((FCe, bR) => {
        var gj = function(e, t, i, r) {
          return r << 24 | e << 16 | t << 8 | i;
        };
        bR.exports = gj;
      });
      NR = u((bCe, DR) => {
        var OR = po();
        function Nl(e, t, i, r) {
          var s = (e + t * 6) % 6, n = Math.min(s, 4 - s, 1);
          return Math.round(255 * (r - r * i * Math.max(0, n)));
        }
        var xj = function(e, t, i, r) {
          t === void 0 && (t = 1), i === void 0 && (i = 1);
          var s = Nl(5, e, t, i), n = Nl(3, e, t, i), a = Nl(1, e, t, i);
          return r ? r.setTo ? r.setTo(s, n, a, r.alpha, true) : (r.r = s, r.g = n, r.b = a, r.color =
          OR(s, n, a), r) : { r: s, g: n, b: a, color: OR(s, n, a) };
        };
        DR.exports = xj;
      });
      BR = u((LCe, IR) => {
        var Ej = function(e, t, i, r) {
          r === void 0 && (r = { h: 0, s: 0, v: 0 }), e /= 255, t /= 255, i /= 255;
          var s = Math.min(e, t, i), n = Math.max(e, t, i), a = n - s, o = 0, h = n === 0 ? 0 : a / n,
          l = n;
          return n !== s && (n === e ? o = (t - i) / a + (t < i ? 6 : 0) : n === t ? o = (i - e) / a +
          2 : n === i && (o = (e - t) / a + 4), o /= 6), r.hasOwnProperty("_h") ? (r._h = o, r._s = h,
          r._v = l) : (r.h = o, r.s = h, r.v = l), r;
        };
        IR.exports = Ej;
      });
      Ai = u((OCe, zR) => {
        var Tj = C(), yj = po(), Sj = LR(), mo = NR(), GR = BR(), UR = new Tj({ initialize: function(t, i, r, s) {
          t === void 0 && (t = 0), i === void 0 && (i = 0), r === void 0 && (r = 0), s === void 0 &&
          (s = 255), this.r = 0, this.g = 0, this.b = 0, this.a = 255, this._h = 0, this._s = 0, this.
          _v = 0, this._locked = false, this.gl = [0, 0, 0, 1], this._color = 0, this._color32 = 0, this.
          _rgba = "", this.setTo(t, i, r, s);
        }, transparent: function() {
          return this._locked = true, this.red = 0, this.green = 0, this.blue = 0, this.alpha = 0, this.
          _locked = false, this.update(true);
        }, setTo: function(e, t, i, r, s) {
          return r === void 0 && (r = 255), s === void 0 && (s = true), this._locked = true, this.red =
          e, this.green = t, this.blue = i, this.alpha = r, this._locked = false, this.update(s);
        }, setGLTo: function(e, t, i, r) {
          return r === void 0 && (r = 1), this._locked = true, this.redGL = e, this.greenGL = t, this.
          blueGL = i, this.alphaGL = r, this._locked = false, this.update(true);
        }, setFromRGB: function(e) {
          return this._locked = true, this.red = e.r, this.green = e.g, this.blue = e.b, e.hasOwnProperty(
          "a") && (this.alpha = e.a), this._locked = false, this.update(true);
        }, setFromHSV: function(e, t, i) {
          return mo(e, t, i, this);
        }, update: function(e) {
          if (e === void 0 && (e = false), this._locked) return this;
          var t = this.r, i = this.g, r = this.b, s = this.a;
          return this._color = yj(t, i, r), this._color32 = Sj(t, i, r, s), this._rgba = "rgba(" + t +
          "," + i + "," + r + "," + s / 255 + ")", e && GR(t, i, r, this), this;
        }, updateHSV: function() {
          var e = this.r, t = this.g, i = this.b;
          return GR(e, t, i, this), this;
        }, clone: function() {
          return new UR(this.r, this.g, this.b, this.a);
        }, gray: function(e) {
          return this.setTo(e, e, e);
        }, random: function(e, t) {
          e === void 0 && (e = 0), t === void 0 && (t = 255);
          var i = Math.floor(e + Math.random() * (t - e)), r = Math.floor(e + Math.random() * (t - e)),
          s = Math.floor(e + Math.random() * (t - e));
          return this.setTo(i, r, s);
        }, randomGray: function(e, t) {
          e === void 0 && (e = 0), t === void 0 && (t = 255);
          var i = Math.floor(e + Math.random() * (t - e));
          return this.setTo(i, i, i);
        }, saturate: function(e) {
          return this.s += e / 100, this;
        }, desaturate: function(e) {
          return this.s -= e / 100, this;
        }, lighten: function(e) {
          return this.v += e / 100, this;
        }, darken: function(e) {
          return this.v -= e / 100, this;
        }, brighten: function(e) {
          var t = this.r, i = this.g, r = this.b;
          return t = Math.max(0, Math.min(255, t - Math.round(255 * -(e / 100)))), i = Math.max(0, Math.
          min(255, i - Math.round(255 * -(e / 100)))), r = Math.max(0, Math.min(255, r - Math.round(
          255 * -(e / 100)))), this.setTo(t, i, r);
        }, color: { get: function() {
          return this._color;
        } }, color32: { get: function() {
          return this._color32;
        } }, rgba: { get: function() {
          return this._rgba;
        } }, redGL: { get: function() {
          return this.gl[0];
        }, set: function(e) {
          this.gl[0] = Math.min(Math.abs(e), 1), this.r = Math.floor(this.gl[0] * 255), this.update(
          true);
        } }, greenGL: { get: function() {
          return this.gl[1];
        }, set: function(e) {
          this.gl[1] = Math.min(Math.abs(e), 1), this.g = Math.floor(this.gl[1] * 255), this.update(
          true);
        } }, blueGL: { get: function() {
          return this.gl[2];
        }, set: function(e) {
          this.gl[2] = Math.min(Math.abs(e), 1), this.b = Math.floor(this.gl[2] * 255), this.update(
          true);
        } }, alphaGL: { get: function() {
          return this.gl[3];
        }, set: function(e) {
          this.gl[3] = Math.min(Math.abs(e), 1), this.a = Math.floor(this.gl[3] * 255), this.update();
        } }, red: { get: function() {
          return this.r;
        }, set: function(e) {
          e = Math.floor(Math.abs(e)), this.r = Math.min(e, 255), this.gl[0] = e / 255, this.update(
          true);
        } }, green: { get: function() {
          return this.g;
        }, set: function(e) {
          e = Math.floor(Math.abs(e)), this.g = Math.min(e, 255), this.gl[1] = e / 255, this.update(
          true);
        } }, blue: { get: function() {
          return this.b;
        }, set: function(e) {
          e = Math.floor(Math.abs(e)), this.b = Math.min(e, 255), this.gl[2] = e / 255, this.update(
          true);
        } }, alpha: { get: function() {
          return this.a;
        }, set: function(e) {
          e = Math.floor(Math.abs(e)), this.a = Math.min(e, 255), this.gl[3] = e / 255, this.update();
        } }, h: { get: function() {
          return this._h;
        }, set: function(e) {
          this._h = e, mo(e, this._s, this._v, this);
        } }, s: { get: function() {
          return this._s;
        }, set: function(e) {
          this._s = e, mo(this._h, e, this._v, this);
        } }, v: { get: function() {
          return this._v;
        }, set: function(e) {
          this._v = e, mo(this._h, this._s, e, this);
        } } });
        zR.exports = UR;
      });
      XR = u((DCe, kR) => {
        var wj = Ai(), Cj = function(e) {
          var t = new wj();
          e = e.replace(/^(?:#|0x)?([a-f\d])([a-f\d])([a-f\d])$/i, function(a, o, h, l) {
            return o + o + h + h + l + l;
          });
          var i = /^(?:#|0x)?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(e);
          if (i) {
            var r = parseInt(i[1], 16), s = parseInt(i[2], 16), n = parseInt(i[3], 16);
            t.setTo(r, s, n);
          }
          return t;
        };
        kR.exports = Cj;
      });
      Il = u((NCe, VR) => {
        var Aj = function(e) {
          return e > 16777215 ? { a: e >>> 24, r: e >> 16 & 255, g: e >> 8 & 255, b: e & 255 } : { a: 255,
          r: e >> 16 & 255, g: e >> 8 & 255, b: e & 255 };
        };
        VR.exports = Aj;
      });
      WR = u((ICe, YR) => {
        var Rj = Ai(), _j = Il(), Pj = function(e) {
          var t = _j(e);
          return new Rj(t.r, t.g, t.b, t.a);
        };
        YR.exports = Pj;
      });
      KR = u((BCe, HR) => {
        var Mj = Ai(), qj = function(e) {
          return new Mj(e.r, e.g, e.b, e.a);
        };
        HR.exports = qj;
      });
      QR = u((GCe, ZR) => {
        var Fj = Ai(), bj = function(e) {
          var t = new Fj(), i = /^rgba?\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d+(?:\.\d+)?))?\s*\)$/.
          exec(e.toLowerCase());
          if (i) {
            var r = parseInt(i[1], 10), s = parseInt(i[2], 10), n = parseInt(i[3], 10), a = i[4] !==
            void 0 ? parseFloat(i[4]) : 1;
            t.setTo(r, s, n, a * 255);
          }
          return t;
        };
        ZR.exports = bj;
      });
      Bl = u((UCe, JR) => {
        var Lj = XR(), Oj = WR(), Dj = KR(), Nj = QR(), Ij = function(e) {
          var t = typeof e;
          switch (t) {
            case "string":
              return e.substr(0, 3).toLowerCase() === "rgb" ? Nj(e) : Lj(e);
            case "number":
              return Oj(e);
            case "object":
              return Dj(e);
          }
        };
        JR.exports = Ij;
      });
      go = u((zCe, t_) => {
        var Bj = C(), $R = Ot(), Gj = Rr(), jR = Z(), Uj = Dt(), Gl = he(), zj = Lt(), e_ = Bl(), Ul = Y(),
        kj = new Bj({ Extends: jR, Mixins: [$R.AlphaSingle, $R.Visible], initialize: function(t, i, r, s) {
          t === void 0 && (t = 0), i === void 0 && (i = 0), r === void 0 && (r = 0), s === void 0 &&
          (s = 0), jR.call(this), this.scene, this.sceneManager, this.scaleManager, this.cameraManager,
          this.id = 0, this.name = "", this.roundPixels = false, this.useBounds = false, this.worldView =
          new Gl(), this.dirty = true, this._x = t, this._y = i, this._width = r, this._height = s, this.
          _bounds = new Gl(), this._scrollX = 0, this._scrollY = 0, this._zoomX = 1, this._zoomY = 1,
          this._rotation = 0, this.matrix = new zj(), this.transparent = true, this.backgroundColor =
          e_("rgba(0,0,0,0)"), this.disableCull = false, this.culledObjects = [], this.midPoint = new Ul(
          r / 2, s / 2), this.originX = 0.5, this.originY = 0.5, this._customViewport = false, this.
          mask = null, this._maskCamera = null, this.renderList = [], this.isSceneCamera = true, this.
          renderRoundPixels = true;
        }, addToRenderList: function(e) {
          this.renderList.push(e);
        }, setOrigin: function(e, t) {
          return e === void 0 && (e = 0.5), t === void 0 && (t = e), this.originX = e, this.originY =
          t, this;
        }, getScroll: function(e, t, i) {
          i === void 0 && (i = new Ul());
          var r = this.width * 0.5, s = this.height * 0.5;
          return i.x = e - r, i.y = t - s, this.useBounds && (i.x = this.clampX(i.x), i.y = this.clampY(
          i.y)), i;
        }, centerOnX: function(e) {
          var t = this.width * 0.5;
          return this.midPoint.x = e, this.scrollX = e - t, this.useBounds && (this.scrollX = this.clampX(
          this.scrollX)), this;
        }, centerOnY: function(e) {
          var t = this.height * 0.5;
          return this.midPoint.y = e, this.scrollY = e - t, this.useBounds && (this.scrollY = this.clampY(
          this.scrollY)), this;
        }, centerOn: function(e, t) {
          return this.centerOnX(e), this.centerOnY(t), this;
        }, centerToBounds: function() {
          if (this.useBounds) {
            var e = this._bounds, t = this.width * 0.5, i = this.height * 0.5;
            this.midPoint.set(e.centerX, e.centerY), this.scrollX = e.centerX - t, this.scrollY = e.
            centerY - i;
          }
          return this;
        }, centerToSize: function() {
          return this.scrollX = this.width * 0.5, this.scrollY = this.height * 0.5, this;
        }, cull: function(e) {
          if (this.disableCull) return e;
          var t = this.matrix.matrix, i = t[0], r = t[1], s = t[2], n = t[3], a = i * n - r * s;
          if (!a) return e;
          var o = t[4], h = t[5], l = this.scrollX, f = this.scrollY, d = this.width, c = this.height,
          p = this.y, v = p + c, m = this.x, g = m + d, x = this.culledObjects, E = e.length;
          a = 1 / a, x.length = 0;
          for (var T15 = 0; T15 < E; ++T15) {
            var w = e[T15];
            if (!w.hasOwnProperty("width") || w.parentContainer) {
              x.push(w);
              continue;
            }
            var y = w.width, A10 = w.height, S14 = w.x - l * w.scrollFactorX - y * w.originX, _ = w.
            y - f * w.scrollFactorY - A10 * w.originY, q = S14 * i + _ * s + o, P = S14 * r + _ * n +
            h, L = (S14 + y) * i + (_ + A10) * s + o, N5 = (S14 + y) * r + (_ + A10) * n + h;
            L > m && q < g && N5 > p && P < v && x.push(w);
          }
          return x;
        }, getWorldPoint: function(e, t, i) {
          i === void 0 && (i = new Ul());
          var r = this.matrix.matrix, s = r[0], n = r[1], a = r[2], o = r[3], h = r[4], l = r[5], f = s *
          o - n * a;
          if (!f) return i.x = e, i.y = t, i;
          f = 1 / f;
          var d = o * f, c = -n * f, p = -a * f, v = s * f, m = (a * l - o * h) * f, g = (n * h - s *
          l) * f, x = Math.cos(this.rotation), E = Math.sin(this.rotation), T15 = this.zoomX, w = this.
          zoomY, y = this.scrollX, A10 = this.scrollY, S14 = e + (y * x - A10 * E) * T15, _ = t + (y *
          E + A10 * x) * w;
          return i.x = S14 * d + _ * p + m, i.y = S14 * c + _ * v + g, i;
        }, ignore: function(e) {
          var t = this.id;
          Array.isArray(e) || (e = [e]);
          for (var i = 0; i < e.length; i++) {
            var r = e[i];
            Array.isArray(r) ? this.ignore(r) : r.isParent ? this.ignore(r.getChildren()) : r.cameraFilter |=
            t;
          }
          return this;
        }, clampX: function(e) {
          var t = this._bounds, i = this.displayWidth, r = t.x + (i - this.width) / 2, s = Math.max(
          r, r + t.width - i);
          return e < r ? e = r : e > s && (e = s), e;
        }, clampY: function(e) {
          var t = this._bounds, i = this.displayHeight, r = t.y + (i - this.height) / 2, s = Math.max(
          r, r + t.height - i);
          return e < r ? e = r : e > s && (e = s), e;
        }, removeBounds: function() {
          return this.useBounds = false, this.dirty = true, this._bounds.setEmpty(), this;
        }, setAngle: function(e) {
          return e === void 0 && (e = 0), this.rotation = Gj(e), this;
        }, setBackgroundColor: function(e) {
          return e === void 0 && (e = "rgba(0,0,0,0)"), this.backgroundColor = e_(e), this.transparent =
          this.backgroundColor.alpha === 0, this;
        }, setBounds: function(e, t, i, r, s) {
          return s === void 0 && (s = false), this._bounds.setTo(e, t, i, r), this.dirty = true, this.
          useBounds = true, s ? this.centerToBounds() : (this.scrollX = this.clampX(this.scrollX), this.
          scrollY = this.clampY(this.scrollY)), this;
        }, getBounds: function(e) {
          e === void 0 && (e = new Gl());
          var t = this._bounds;
          return e.setTo(t.x, t.y, t.width, t.height), e;
        }, setName: function(e) {
          return e === void 0 && (e = ""), this.name = e, this;
        }, setPosition: function(e, t) {
          return t === void 0 && (t = e), this.x = e, this.y = t, this;
        }, setRotation: function(e) {
          return e === void 0 && (e = 0), this.rotation = e, this;
        }, setRoundPixels: function(e) {
          return this.roundPixels = e, this;
        }, setScene: function(e, t) {
          t === void 0 && (t = true), this.scene && this._customViewport && this.sceneManager.customViewports--,
          this.scene = e, this.isSceneCamera = t;
          var i = e.sys;
          return this.sceneManager = i.game.scene, this.scaleManager = i.scale, this.cameraManager =
          i.cameras, this.updateSystem(), this;
        }, setScroll: function(e, t) {
          return t === void 0 && (t = e), this.scrollX = e, this.scrollY = t, this;
        }, setSize: function(e, t) {
          return t === void 0 && (t = e), this.width = e, this.height = t, this;
        }, setViewport: function(e, t, i, r) {
          return this.x = e, this.y = t, this.width = i, this.height = r, this;
        }, setZoom: function(e, t) {
          return e === void 0 && (e = 1), t === void 0 && (t = e), e === 0 && (e = 1e-3), t === 0 &&
          (t = 1e-3), this.zoomX = e, this.zoomY = t, this;
        }, setMask: function(e, t) {
          return t === void 0 && (t = true), this.mask = e, this._maskCamera = t ? this.cameraManager.
          default : this, this;
        }, clearMask: function(e) {
          return e === void 0 && (e = false), e && this.mask && this.mask.destroy(), this.mask = null,
          this;
        }, toJSON: function() {
          var e = { name: this.name, x: this.x, y: this.y, width: this.width, height: this.height, zoom: this.
          zoom, rotation: this.rotation, roundPixels: this.roundPixels, scrollX: this.scrollX, scrollY: this.
          scrollY, backgroundColor: this.backgroundColor.rgba };
          return this.useBounds && (e.bounds = { x: this._bounds.x, y: this._bounds.y, width: this._bounds.
          width, height: this._bounds.height }), e;
        }, update: function() {
        }, setIsSceneCamera: function(e) {
          return this.isSceneCamera = e, this;
        }, updateSystem: function() {
          if (!(!this.scaleManager || !this.isSceneCamera)) {
            var e = this._x !== 0 || this._y !== 0 || this.scaleManager.width !== this._width || this.
            scaleManager.height !== this._height, t = this.sceneManager;
            e && !this._customViewport ? t.customViewports++ : !e && this._customViewport && t.customViewports--,
            this.dirty = true, this._customViewport = e;
          }
        }, destroy: function() {
          this.emit(Uj.DESTROY, this), this.removeAllListeners(), this.matrix.destroy(), this.culledObjects =
          [], this._customViewport && this.sceneManager.customViewports--, this.renderList = [], this.
          _bounds = null, this.scene = null, this.scaleManager = null, this.sceneManager = null, this.
          cameraManager = null;
        }, x: { get: function() {
          return this._x;
        }, set: function(e) {
          this._x = e, this.updateSystem();
        } }, y: { get: function() {
          return this._y;
        }, set: function(e) {
          this._y = e, this.updateSystem();
        } }, width: { get: function() {
          return this._width;
        }, set: function(e) {
          this._width = e, this.updateSystem();
        } }, height: { get: function() {
          return this._height;
        }, set: function(e) {
          this._height = e, this.updateSystem();
        } }, scrollX: { get: function() {
          return this._scrollX;
        }, set: function(e) {
          e !== this._scrollX && (this._scrollX = e, this.dirty = true);
        } }, scrollY: { get: function() {
          return this._scrollY;
        }, set: function(e) {
          e !== this._scrollY && (this._scrollY = e, this.dirty = true);
        } }, zoom: { get: function() {
          return (this._zoomX + this._zoomY) / 2;
        }, set: function(e) {
          this._zoomX = e, this._zoomY = e, this.dirty = true;
        } }, zoomX: { get: function() {
          return this._zoomX;
        }, set: function(e) {
          this._zoomX = e, this.dirty = true;
        } }, zoomY: { get: function() {
          return this._zoomY;
        }, set: function(e) {
          this._zoomY = e, this.dirty = true;
        } }, rotation: { get: function() {
          return this._rotation;
        }, set: function(e) {
          this._rotation = e, this.dirty = true;
        } }, centerX: { get: function() {
          return this.x + 0.5 * this.width;
        } }, centerY: { get: function() {
          return this.y + 0.5 * this.height;
        } }, displayWidth: { get: function() {
          return this.width / this.zoomX;
        } }, displayHeight: { get: function() {
          return this.height / this.zoomY;
        } } });
        t_.exports = kj;
      });
      In = u((kCe, i_) => {
        var Xj = function(e, t, i) {
          return e.x = t - e.width / 2, e.y = i - e.height / 2, e;
        };
        i_.exports = Xj;
      });
      s_ = u((XCe, r_) => {
        var Vj = ne(), Yj = C(), xo = Dt(), Wj = new Yj({ initialize: function(t) {
          this.camera = t, this.isRunning = false, this.isComplete = false, this.direction = true, this.
          duration = 0, this.red = 0, this.green = 0, this.blue = 0, this.alpha = 0, this.progress =
          0, this._elapsed = 0, this._onUpdate, this._onUpdateScope;
        }, start: function(e, t, i, r, s, n, a, o) {
          if (e === void 0 && (e = true), t === void 0 && (t = 1e3), i === void 0 && (i = 0), r === void 0 &&
          (r = 0), s === void 0 && (s = 0), n === void 0 && (n = false), a === void 0 && (a = null),
          o === void 0 && (o = this.camera.scene), !n && this.isRunning) return this.camera;
          this.isRunning = true, this.isComplete = false, this.duration = t, this.direction = e, this.
          progress = 0, this.red = i, this.green = r, this.blue = s, this.alpha = e ? Number.MIN_VALUE :
          1, this._elapsed = 0, this._onUpdate = a, this._onUpdateScope = o;
          var h = e ? xo.FADE_OUT_START : xo.FADE_IN_START;
          return this.camera.emit(h, this.camera, this, t, i, r, s), this.camera;
        }, update: function(e, t) {
          this.isRunning && (this._elapsed += t, this.progress = Vj(this._elapsed / this.duration, 0,
          1), this._onUpdate && this._onUpdate.call(this._onUpdateScope, this.camera, this.progress),
          this._elapsed < this.duration ? this.alpha = this.direction ? this.progress : 1 - this.progress :
          (this.alpha = this.direction ? 1 : 0, this.effectComplete()));
        }, postRenderCanvas: function(e) {
          if (!this.isRunning && !this.isComplete) return false;
          var t = this.camera;
          return e.fillStyle = "rgba(" + this.red + "," + this.green + "," + this.blue + "," + this.
          alpha + ")", e.fillRect(t.x, t.y, t.width, t.height), true;
        }, postRenderWebGL: function(e, t) {
          if (!this.isRunning && !this.isComplete) return false;
          var i = this.camera, r = this.red / 255, s = this.green / 255, n = this.blue / 255;
          return e.drawFillRect(i.x, i.y, i.width, i.height, t(n, s, r, 1), this.alpha), true;
        }, effectComplete: function() {
          this._onUpdate = null, this._onUpdateScope = null, this.isRunning = false, this.isComplete =
          true;
          var e = this.direction ? xo.FADE_OUT_COMPLETE : xo.FADE_IN_COMPLETE;
          this.camera.emit(e, this.camera, this);
        }, reset: function() {
          this.isRunning = false, this.isComplete = false, this._onUpdate = null, this._onUpdateScope =
          null;
        }, destroy: function() {
          this.reset(), this.camera = null;
        } });
        r_.exports = Wj;
      });
      o_ = u((VCe, a_) => {
        var Hj = ne(), Kj = C(), n_ = Dt(), Zj = new Kj({ initialize: function(t) {
          this.camera = t, this.isRunning = false, this.duration = 0, this.red = 0, this.green = 0, this.
          blue = 0, this.alpha = 1, this.progress = 0, this._elapsed = 0, this._alpha, this._onUpdate,
          this._onUpdateScope;
        }, start: function(e, t, i, r, s, n, a) {
          return e === void 0 && (e = 250), t === void 0 && (t = 255), i === void 0 && (i = 255), r ===
          void 0 && (r = 255), s === void 0 && (s = false), n === void 0 && (n = null), a === void 0 &&
          (a = this.camera.scene), !s && this.isRunning ? this.camera : (this.isRunning = true, this.
          duration = e, this.progress = 0, this.red = t, this.green = i, this.blue = r, this._alpha =
          this.alpha, this._elapsed = 0, this._onUpdate = n, this._onUpdateScope = a, this.camera.emit(
          n_.FLASH_START, this.camera, this, e, t, i, r), this.camera);
        }, update: function(e, t) {
          this.isRunning && (this._elapsed += t, this.progress = Hj(this._elapsed / this.duration, 0,
          1), this._onUpdate && this._onUpdate.call(this._onUpdateScope, this.camera, this.progress),
          this._elapsed < this.duration ? this.alpha = this._alpha * (1 - this.progress) : this.effectComplete());
        }, postRenderCanvas: function(e) {
          if (!this.isRunning) return false;
          var t = this.camera;
          return e.fillStyle = "rgba(" + this.red + "," + this.green + "," + this.blue + "," + this.
          alpha + ")", e.fillRect(t.x, t.y, t.width, t.height), true;
        }, postRenderWebGL: function(e, t) {
          if (!this.isRunning) return false;
          var i = this.camera, r = this.red / 255, s = this.green / 255, n = this.blue / 255;
          return e.drawFillRect(i.x, i.y, i.width, i.height, t(n, s, r, 1), this.alpha), true;
        }, effectComplete: function() {
          this.alpha = this._alpha, this._onUpdate = null, this._onUpdateScope = null, this.isRunning =
          false, this.camera.emit(n_.FLASH_COMPLETE, this.camera, this);
        }, reset: function() {
          this.isRunning = false, this._onUpdate = null, this._onUpdateScope = null;
        }, destroy: function() {
          this.reset(), this.camera = null;
        } });
        a_.exports = Zj;
      });
      l_ = u((YCe, u_) => {
        var Qj = ne(), Jj = C(), zl = On(), h_ = Dt(), kl = Y(), $j = new Jj({ initialize: function(t) {
          this.camera = t, this.isRunning = false, this.duration = 0, this.source = new kl(), this.current =
          new kl(), this.destination = new kl(), this.ease, this.progress = 0, this._elapsed = 0, this.
          _onUpdate, this._onUpdateScope;
        }, start: function(e, t, i, r, s, n, a) {
          i === void 0 && (i = 1e3), r === void 0 && (r = zl.Linear), s === void 0 && (s = false), n ===
          void 0 && (n = null), a === void 0 && (a = this.camera.scene);
          var o = this.camera;
          return !s && this.isRunning || (this.isRunning = true, this.duration = i, this.progress = 0,
          this.source.set(o.scrollX, o.scrollY), this.destination.set(e, t), o.getScroll(e, t, this.
          current), typeof r == "string" && zl.hasOwnProperty(r) ? this.ease = zl[r] : typeof r == "\
function" && (this.ease = r), this._elapsed = 0, this._onUpdate = n, this._onUpdateScope = a, this.camera.
          emit(h_.PAN_START, this.camera, this, i, e, t)), o;
        }, update: function(e, t) {
          if (this.isRunning) {
            this._elapsed += t;
            var i = Qj(this._elapsed / this.duration, 0, 1);
            this.progress = i;
            var r = this.camera;
            if (this._elapsed < this.duration) {
              var s = this.ease(i);
              r.getScroll(this.destination.x, this.destination.y, this.current);
              var n = this.source.x + (this.current.x - this.source.x) * s, a = this.source.y + (this.
              current.y - this.source.y) * s;
              r.setScroll(n, a), this._onUpdate && this._onUpdate.call(this._onUpdateScope, r, i, n,
              a);
            } else r.centerOn(this.destination.x, this.destination.y), this._onUpdate && this._onUpdate.
            call(this._onUpdateScope, r, i, r.scrollX, r.scrollY), this.effectComplete();
          }
        }, effectComplete: function() {
          this._onUpdate = null, this._onUpdateScope = null, this.isRunning = false, this.camera.emit(
          h_.PAN_COMPLETE, this.camera, this);
        }, reset: function() {
          this.isRunning = false, this._onUpdate = null, this._onUpdateScope = null;
        }, destroy: function() {
          this.reset(), this.camera = null, this.source = null, this.destination = null;
        } });
        u_.exports = $j;
      });
      c_ = u((WCe, d_) => {
        var jj = ne(), eee = C(), f_ = Dt(), tee = Y(), iee = new eee({ initialize: function(t) {
          this.camera = t, this.isRunning = false, this.duration = 0, this.intensity = new tee(), this.
          progress = 0, this._elapsed = 0, this._offsetX = 0, this._offsetY = 0, this._onUpdate, this.
          _onUpdateScope;
        }, start: function(e, t, i, r, s) {
          return e === void 0 && (e = 100), t === void 0 && (t = 0.05), i === void 0 && (i = false),
          r === void 0 && (r = null), s === void 0 && (s = this.camera.scene), !i && this.isRunning ?
          this.camera : (this.isRunning = true, this.duration = e, this.progress = 0, typeof t == "n\
umber" ? this.intensity.set(t) : this.intensity.set(t.x, t.y), this._elapsed = 0, this._offsetX = 0,
          this._offsetY = 0, this._onUpdate = r, this._onUpdateScope = s, this.camera.emit(f_.SHAKE_START,
          this.camera, this, e, t), this.camera);
        }, preRender: function() {
          this.isRunning && this.camera.matrix.translate(this._offsetX, this._offsetY);
        }, update: function(e, t) {
          if (this.isRunning) if (this._elapsed += t, this.progress = jj(this._elapsed / this.duration,
          0, 1), this._onUpdate && this._onUpdate.call(this._onUpdateScope, this.camera, this.progress),
          this._elapsed < this.duration) {
            var i = this.intensity, r = this.camera.width, s = this.camera.height, n = this.camera.zoom;
            this._offsetX = (Math.random() * i.x * r * 2 - i.x * r) * n, this._offsetY = (Math.random() *
            i.y * s * 2 - i.y * s) * n, this.camera.roundPixels && (this._offsetX = Math.round(this.
            _offsetX), this._offsetY = Math.round(this._offsetY));
          } else this.effectComplete();
        }, effectComplete: function() {
          this._offsetX = 0, this._offsetY = 0, this._onUpdate = null, this._onUpdateScope = null, this.
          isRunning = false, this.camera.emit(f_.SHAKE_COMPLETE, this.camera, this);
        }, reset: function() {
          this.isRunning = false, this._offsetX = 0, this._offsetY = 0, this._onUpdate = null, this.
          _onUpdateScope = null;
        }, destroy: function() {
          this.reset(), this.camera = null, this.intensity = null;
        } });
        d_.exports = iee;
      });
      m_ = u((HCe, p_) => {
        var ree = ne(), see = C(), v_ = Dt(), Xl = On(), nee = new see({ initialize: function(t) {
          this.camera = t, this.isRunning = false, this.duration = 0, this.source = 0, this.current =
          0, this.destination = 0, this.ease, this.progress = 0, this._elapsed = 0, this._onUpdate, this.
          _onUpdateScope, this.clockwise = true, this.shortestPath = false;
        }, start: function(e, t, i, r, s, n, a) {
          i === void 0 && (i = 1e3), r === void 0 && (r = Xl.Linear), s === void 0 && (s = false), n ===
          void 0 && (n = null), a === void 0 && (a = this.camera.scene), t === void 0 && (t = false),
          this.shortestPath = t;
          var o = e;
          e < 0 ? (o = -1 * e, this.clockwise = false) : this.clockwise = true;
          var h = 360 * Math.PI / 180;
          o = o - Math.floor(o / h) * h;
          var l = this.camera;
          if (!s && this.isRunning) return l;
          if (this.isRunning = true, this.duration = i, this.progress = 0, this.source = l.rotation,
          this.destination = o, typeof r == "string" && Xl.hasOwnProperty(r) ? this.ease = Xl[r] : typeof r ==
          "function" && (this.ease = r), this._elapsed = 0, this._onUpdate = n, this._onUpdateScope =
          a, this.shortestPath) {
            var f = 0, d = 0;
            this.destination > this.source ? f = Math.abs(this.destination - this.source) : f = Math.
            abs(this.destination + h) - this.source, this.source > this.destination ? d = Math.abs(this.
            source - this.destination) : d = Math.abs(this.source + h) - this.destination, f < d ? this.
            clockwise = true : f > d && (this.clockwise = false);
          }
          return this.camera.emit(v_.ROTATE_START, this.camera, this, i, o), l;
        }, update: function(e, t) {
          if (this.isRunning) {
            this._elapsed += t;
            var i = ree(this._elapsed / this.duration, 0, 1);
            this.progress = i;
            var r = this.camera;
            if (this._elapsed < this.duration) {
              var s = this.ease(i);
              this.current = r.rotation;
              var n = 0, a = 360 * Math.PI / 180, o = this.destination, h = this.current;
              this.clockwise === false && (o = this.current, h = this.destination), o >= h ? n = Math.
              abs(o - h) : n = Math.abs(o + a) - h;
              var l = 0;
              this.clockwise ? l = r.rotation + n * s : l = r.rotation - n * s, r.rotation = l, this.
              _onUpdate && this._onUpdate.call(this._onUpdateScope, r, i, l);
            } else r.rotation = this.destination, this._onUpdate && this._onUpdate.call(this._onUpdateScope,
            r, i, this.destination), this.effectComplete();
          }
        }, effectComplete: function() {
          this._onUpdate = null, this._onUpdateScope = null, this.isRunning = false, this.camera.emit(
          v_.ROTATE_COMPLETE, this.camera, this);
        }, reset: function() {
          this.isRunning = false, this._onUpdate = null, this._onUpdateScope = null;
        }, destroy: function() {
          this.reset(), this.camera = null, this.source = null, this.destination = null;
        } });
        p_.exports = nee;
      });
      E_ = u((KCe, x_) => {
        var aee = ne(), oee = C(), Vl = On(), g_ = Dt(), hee = new oee({ initialize: function(t) {
          this.camera = t, this.isRunning = false, this.duration = 0, this.source = 1, this.destination =
          1, this.ease, this.progress = 0, this._elapsed = 0, this._onUpdate, this._onUpdateScope;
        }, start: function(e, t, i, r, s, n) {
          t === void 0 && (t = 1e3), i === void 0 && (i = Vl.Linear), r === void 0 && (r = false), s ===
          void 0 && (s = null), n === void 0 && (n = this.camera.scene);
          var a = this.camera;
          return !r && this.isRunning || (this.isRunning = true, this.duration = t, this.progress = 0,
          this.source = a.zoom, this.destination = e, typeof i == "string" && Vl.hasOwnProperty(i) ?
          this.ease = Vl[i] : typeof i == "function" && (this.ease = i), this._elapsed = 0, this._onUpdate =
          s, this._onUpdateScope = n, this.camera.emit(g_.ZOOM_START, this.camera, this, t, e)), a;
        }, update: function(e, t) {
          this.isRunning && (this._elapsed += t, this.progress = aee(this._elapsed / this.duration, 0,
          1), this._elapsed < this.duration ? (this.camera.zoom = this.source + (this.destination - this.
          source) * this.ease(this.progress), this._onUpdate && this._onUpdate.call(this._onUpdateScope,
          this.camera, this.progress, this.camera.zoom)) : (this.camera.zoom = this.destination, this.
          _onUpdate && this._onUpdate.call(this._onUpdateScope, this.camera, this.progress, this.destination),
          this.effectComplete()));
        }, effectComplete: function() {
          this._onUpdate = null, this._onUpdateScope = null, this.isRunning = false, this.camera.emit(
          g_.ZOOM_COMPLETE, this.camera, this);
        }, reset: function() {
          this.isRunning = false, this._onUpdate = null, this._onUpdateScope = null;
        }, destroy: function() {
          this.reset(), this.camera = null;
        } });
        x_.exports = hee;
      });
      Yl = u((ZCe, T_) => {
        T_.exports = { Fade: s_(), Flash: o_(), Pan: l_(), Shake: c_(), RotateTo: m_(), Zoom: E_() };
      });
      Eo = u((QCe, y_) => {
        var uee = function(e, t, i) {
          return (t - e) * i + e;
        };
        y_.exports = uee;
      });
      Bn = u((JCe, A_) => {
        var Wl = go(), S_ = In(), w_ = ne(), lee = C(), fee = Ot(), Ts = Yl(), dee = Dt(), ys = Eo(),
        cee = he(), C_ = Y(), vee = new lee({ Extends: Wl, Mixins: [fee.PostPipeline], initialize: function(t, i, r, s) {
          Wl.call(this, t, i, r, s), this.initPostPipeline(), this.inputEnabled = true, this.fadeEffect =
          new Ts.Fade(this), this.flashEffect = new Ts.Flash(this), this.shakeEffect = new Ts.Shake(
          this), this.panEffect = new Ts.Pan(this), this.rotateToEffect = new Ts.RotateTo(this), this.
          zoomEffect = new Ts.Zoom(this), this.lerp = new C_(1, 1), this.followOffset = new C_(), this.
          deadzone = null, this._follow = null;
        }, setDeadzone: function(e, t) {
          if (e === void 0) this.deadzone = null;
          else {
            if (this.deadzone ? (this.deadzone.width = e, this.deadzone.height = t) : this.deadzone =
            new cee(0, 0, e, t), this._follow) {
              var i = this.width / 2, r = this.height / 2, s = this._follow.x - this.followOffset.x,
              n = this._follow.y - this.followOffset.y;
              this.midPoint.set(s, n), this.scrollX = s - i, this.scrollY = n - r;
            }
            S_(this.deadzone, this.midPoint.x, this.midPoint.y);
          }
          return this;
        }, fadeIn: function(e, t, i, r, s, n) {
          return this.fadeEffect.start(false, e, t, i, r, true, s, n);
        }, fadeOut: function(e, t, i, r, s, n) {
          return this.fadeEffect.start(true, e, t, i, r, true, s, n);
        }, fadeFrom: function(e, t, i, r, s, n, a) {
          return this.fadeEffect.start(false, e, t, i, r, s, n, a);
        }, fade: function(e, t, i, r, s, n, a) {
          return this.fadeEffect.start(true, e, t, i, r, s, n, a);
        }, flash: function(e, t, i, r, s, n, a) {
          return this.flashEffect.start(e, t, i, r, s, n, a);
        }, shake: function(e, t, i, r, s) {
          return this.shakeEffect.start(e, t, i, r, s);
        }, pan: function(e, t, i, r, s, n, a) {
          return this.panEffect.start(e, t, i, r, s, n, a);
        }, rotateTo: function(e, t, i, r, s, n, a) {
          return this.rotateToEffect.start(e, t, i, r, s, n, a);
        }, zoomTo: function(e, t, i, r, s, n) {
          return this.zoomEffect.start(e, t, i, r, s, n);
        }, preRender: function() {
          this.renderList.length = 0;
          var e = this.width, t = this.height, i = e * 0.5, r = t * 0.5, s = this.zoomX, n = this.zoomY,
          a = this.matrix;
          this.renderRoundPixels = this.roundPixels && Number.isInteger(s) && Number.isInteger(n);
          var o = e * this.originX, h = t * this.originY, l = this._follow, f = this.deadzone, d = this.
          scrollX, c = this.scrollY;
          f && S_(f, this.midPoint.x, this.midPoint.y);
          var p = false;
          if (l && !this.panEffect.isRunning) {
            var v = this.lerp, m = l.x - this.followOffset.x, g = l.y - this.followOffset.y;
            f ? (m < f.x ? d = ys(d, d - (f.x - m), v.x) : m > f.right && (d = ys(d, d + (m - f.right),
            v.x)), g < f.y ? c = ys(c, c - (f.y - g), v.y) : g > f.bottom && (c = ys(c, c + (g - f.bottom),
            v.y))) : (d = ys(d, m - o, v.x), c = ys(c, g - h, v.y)), p = true;
          }
          this.roundPixels && (d = Math.floor(d), c = Math.floor(c)), this.useBounds && (d = this.clampX(
          d), c = this.clampY(c)), this.scrollX = d, this.scrollY = c;
          var x = d + i, E = c + r;
          this.midPoint.set(x, E);
          var T15 = Math.floor(e / s + 0.5), w = Math.floor(t / n + 0.5), y = Math.floor(x - T15 / 2 +
          0.5), A10 = Math.floor(E - w / 2 + 0.5);
          this.worldView.setTo(y, A10, T15, w), a.applyITRS(Math.floor(this.x + o + 0.5), Math.floor(
          this.y + h + 0.5), this.rotation, s, n), a.translate(-o, -h), this.shakeEffect.preRender(),
          p && this.emit(dee.FOLLOW_UPDATE, this, l);
        }, setLerp: function(e, t) {
          return e === void 0 && (e = 1), t === void 0 && (t = e), this.lerp.set(e, t), this;
        }, setFollowOffset: function(e, t) {
          return e === void 0 && (e = 0), t === void 0 && (t = 0), this.followOffset.set(e, t), this;
        }, startFollow: function(e, t, i, r, s, n) {
          t === void 0 && (t = false), i === void 0 && (i = 1), r === void 0 && (r = i), s === void 0 &&
          (s = 0), n === void 0 && (n = s), this._follow = e, this.roundPixels = t, i = w_(i, 0, 1),
          r = w_(r, 0, 1), this.lerp.set(i, r), this.followOffset.set(s, n);
          var a = this.width / 2, o = this.height / 2, h = e.x - s, l = e.y - n;
          return this.midPoint.set(h, l), this.scrollX = h - a, this.scrollY = l - o, this.useBounds &&
          (this.scrollX = this.clampX(this.scrollX), this.scrollY = this.clampY(this.scrollY)), this;
        }, stopFollow: function() {
          return this._follow = null, this;
        }, resetFX: function() {
          return this.rotateToEffect.reset(), this.panEffect.reset(), this.shakeEffect.reset(), this.
          flashEffect.reset(), this.fadeEffect.reset(), this;
        }, update: function(e, t) {
          this.visible && (this.rotateToEffect.update(e, t), this.panEffect.update(e, t), this.zoomEffect.
          update(e, t), this.shakeEffect.update(e, t), this.flashEffect.update(e, t), this.fadeEffect.
          update(e, t));
        }, destroy: function() {
          this.resetFX(), Wl.prototype.destroy.call(this), this._follow = null, this.deadzone = null;
        } });
        A_.exports = vee;
      });
      __ = u(($Ce, R_) => {
        R_.exports = "enterfullscreen";
      });
      M_ = u((jCe, P_) => {
        P_.exports = "fullscreenfailed";
      });
      F_ = u((eAe, q_) => {
        q_.exports = "fullscreenunsupported";
      });
      L_ = u((tAe, b_) => {
        b_.exports = "leavefullscreen";
      });
      D_ = u((iAe, O_) => {
        O_.exports = "orientationchange";
      });
      I_ = u((rAe, N_) => {
        N_.exports = "resize";
      });
      Ss = u((sAe, B_) => {
        B_.exports = { ENTER_FULLSCREEN: __(), FULLSCREEN_FAILED: M_(), FULLSCREEN_UNSUPPORTED: F_(),
        LEAVE_FULLSCREEN: L_(), ORIENTATION_CHANGE: D_(), RESIZE: I_() };
      });
      X_ = u((nAe, k_) => {
        var G_ = Bn(), pee = C(), Be = B(), mee = rt(), gee = Ar(), U_ = Ss(), Ri = qe(), z_ = new pee(
        { initialize: function(t) {
          this.scene = t, this.systems = t.sys, this.roundPixels = t.sys.game.config.roundPixels, this.
          cameras = [], this.main, this.default, t.sys.events.once(Ri.BOOT, this.boot, this), t.sys.
          events.on(Ri.START, this.start, this);
        }, boot: function() {
          var e = this.systems;
          e.settings.cameras ? this.fromJSON(e.settings.cameras) : this.add(), this.main = this.cameras[0],
          this.default = new G_(0, 0, e.scale.width, e.scale.height).setScene(this.scene), e.game.scale.
          on(U_.RESIZE, this.onResize, this), this.systems.events.once(Ri.DESTROY, this.destroy, this);
        }, start: function() {
          if (!this.main) {
            var e = this.systems;
            e.settings.cameras ? this.fromJSON(e.settings.cameras) : this.add(), this.main = this.cameras[0];
          }
          var t = this.systems.events;
          t.on(Ri.UPDATE, this.update, this), t.once(Ri.SHUTDOWN, this.shutdown, this);
        }, add: function(e, t, i, r, s, n) {
          e === void 0 && (e = 0), t === void 0 && (t = 0), i === void 0 && (i = this.scene.sys.scale.
          width), r === void 0 && (r = this.scene.sys.scale.height), s === void 0 && (s = false), n ===
          void 0 && (n = "");
          var a = new G_(e, t, i, r);
          return a.setName(n), a.setScene(this.scene), a.setRoundPixels(this.roundPixels), a.id = this.
          getNextID(), this.cameras.push(a), s && (this.main = a), a;
        }, addExisting: function(e, t) {
          t === void 0 && (t = false);
          var i = this.cameras.indexOf(e);
          return i === -1 ? (e.id = this.getNextID(), e.setRoundPixels(this.roundPixels), this.cameras.
          push(e), t && (this.main = e), e) : null;
        }, getNextID: function() {
          for (var e = this.cameras, t = 1, i = 0; i < 32; i++) {
            for (var r = false, s = 0; s < e.length; s++) {
              var n = e[s];
              if (n && n.id === t) {
                r = true;
                continue;
              }
            }
            if (r) t = t << 1;
            else return t;
          }
          return 0;
        }, getTotal: function(e) {
          e === void 0 && (e = false);
          for (var t = 0, i = this.cameras, r = 0; r < i.length; r++) {
            var s = i[r];
            (!e || e && s.visible) && t++;
          }
          return t;
        }, fromJSON: function(e) {
          Array.isArray(e) || (e = [e]);
          for (var t = this.scene.sys.scale.width, i = this.scene.sys.scale.height, r = 0; r < e.length; r++) {
            var s = e[r], n = Be(s, "x", 0), a = Be(s, "y", 0), o = Be(s, "width", t), h = Be(s, "he\
ight", i), l = this.add(n, a, o, h);
            l.name = Be(s, "name", ""), l.zoom = Be(s, "zoom", 1), l.rotation = Be(s, "rotation", 0),
            l.scrollX = Be(s, "scrollX", 0), l.scrollY = Be(s, "scrollY", 0), l.roundPixels = Be(s, "\
roundPixels", false), l.visible = Be(s, "visible", true);
            var f = Be(s, "backgroundColor", false);
            f && l.setBackgroundColor(f);
            var d = Be(s, "bounds", null);
            if (d) {
              var c = Be(d, "x", 0), p = Be(d, "y", 0), v = Be(d, "width", t), m = Be(d, "height", i);
              l.setBounds(c, p, v, m);
            }
          }
          return this;
        }, getCamera: function(e) {
          for (var t = this.cameras, i = 0; i < t.length; i++) if (t[i].name === e) return t[i];
          return null;
        }, getCamerasBelowPointer: function(e) {
          for (var t = this.cameras, i = e.x, r = e.y, s = [], n = 0; n < t.length; n++) {
            var a = t[n];
            a.visible && a.inputEnabled && gee(a, i, r) && s.unshift(a);
          }
          return s;
        }, remove: function(e, t) {
          t === void 0 && (t = true), Array.isArray(e) || (e = [e]);
          for (var i = 0, r = this.cameras, s = 0; s < e.length; s++) {
            var n = r.indexOf(e[s]);
            n !== -1 && (t ? r[n].destroy() : r[n].renderList = [], r.splice(n, 1), i++);
          }
          return !this.main && r[0] && (this.main = r[0]), i;
        }, render: function(e, t) {
          for (var i = this.scene, r = this.cameras, s = 0; s < r.length; s++) {
            var n = r[s];
            if (n.visible && n.alpha > 0) {
              n.preRender();
              var a = this.getVisibleChildren(t.getChildren(), n);
              e.render(i, a, n);
            }
          }
        }, getVisibleChildren: function(e, t) {
          return e.filter(function(i) {
            return i.willRender(t);
          });
        }, resetAll: function() {
          for (var e = 0; e < this.cameras.length; e++) this.cameras[e].destroy();
          return this.cameras = [], this.main = this.add(), this.main;
        }, update: function(e, t) {
          for (var i = 0; i < this.cameras.length; i++) this.cameras[i].update(e, t);
        }, onResize: function(e, t, i, r, s) {
          for (var n = 0; n < this.cameras.length; n++) {
            var a = this.cameras[n];
            a._x === 0 && a._y === 0 && a._width === r && a._height === s && a.setSize(t.width, t.height);
          }
        }, resize: function(e, t) {
          for (var i = 0; i < this.cameras.length; i++) this.cameras[i].setSize(e, t);
        }, shutdown: function() {
          this.main = void 0;
          for (var e = 0; e < this.cameras.length; e++) this.cameras[e].destroy();
          this.cameras = [];
          var t = this.systems.events;
          t.off(Ri.UPDATE, this.update, this), t.off(Ri.SHUTDOWN, this.shutdown, this);
        }, destroy: function() {
          this.shutdown(), this.default.destroy(), this.systems.events.off(Ri.START, this.start, this),
          this.systems.events.off(Ri.DESTROY, this.destroy, this), this.systems.game.scale.off(U_.RESIZE,
          this.onResize, this), this.scene = null, this.systems = null;
        } });
        mee.register("CameraManager", z_, "cameras");
        k_.exports = z_;
      });
      Y_ = u((aAe, V_) => {
        V_.exports = { Camera: Bn(), BaseCamera: go(), CameraManager: X_(), Effects: Yl(), Events: Dt() };
      });
      Hl = u((oAe, H_) => {
        var W_ = { Global: ["game", "anims", "cache", "plugins", "registry", "scale", "sound", "text\
ures", "renderer"], CoreScene: ["EventEmitter", "CameraManager", "GameObjectCreator", "GameObjectFac\
tory", "ScenePlugin", "DisplayList", "UpdateList"], DefaultScene: ["Clock", "DataManagerPlugin", "In\
putPlugin", "Loader", "TweenManager", "LightsPlugin"] };
        W_.DefaultScene.push("CameraManager3D");
        H_.exports = W_;
      });
      Kl = u((hAe, K_) => {
        var xee = function(e, t, i, r) {
          return Math.atan2(r - t, i - e);
        };
        K_.exports = xee;
      });
      Q_ = u((uAe, Z_) => {
        var Eee = function(e, t) {
          return Math.atan2(t.y - e.y, t.x - e.x);
        };
        Z_.exports = Eee;
      });
      $_ = u((lAe, J_) => {
        var Tee = function(e, t) {
          return Math.atan2(t.x - e.x, t.y - e.y);
        };
        J_.exports = Tee;
      });
      eP = u((fAe, j_) => {
        var yee = function(e, t, i, r) {
          return Math.atan2(i - e, r - t);
        };
        j_.exports = yee;
      });
      iP = u((dAe, tP) => {
        var Gn = le(), See = function(e) {
          return e > Math.PI && (e -= Gn.PI2), Math.abs(((e + Gn.TAU) % Gn.PI2 - Gn.PI2) % Gn.PI2);
        };
        tP.exports = See;
      });
      Zl = u((cAe, rP) => {
        var wee = function(e) {
          return e = e % (2 * Math.PI), e >= 0 ? e : e + 2 * Math.PI;
        };
        rP.exports = wee;
      });
      ws = u((vAe, sP) => {
        var Cee = function(e, t) {
          return Math.random() * (t - e) + e;
        };
        sP.exports = Cee;
      });
      aP = u((pAe, nP) => {
        var Aee = ws(), Ree = function() {
          return Aee(-Math.PI, Math.PI);
        };
        nP.exports = Ree;
      });
      hP = u((mAe, oP) => {
        var _ee = ws(), Pee = function() {
          return _ee(-180, 180);
        };
        oP.exports = Pee;
      });
      lP = u((gAe, uP) => {
        var Mee = Zl(), qee = function(e) {
          return Mee(e + Math.PI);
        };
        uP.exports = qee;
      });
      dP = u((xAe, fP) => {
        var Ql = le(), Fee = function(e, t, i) {
          return i === void 0 && (i = 0.05), e === t || (Math.abs(t - e) <= i || Math.abs(t - e) >= Ql.
          PI2 - i ? e = t : (Math.abs(t - e) > Math.PI && (t < e ? t += Ql.PI2 : t -= Ql.PI2), t > e ?
          e += i : t < e && (e -= i))), e;
        };
        fP.exports = Fee;
      });
      vP = u((EAe, cP) => {
        var bee = function(e, t) {
          var i = t - e;
          if (i === 0) return 0;
          var r = Math.floor((i - -180) / 360);
          return i - r * 360;
        };
        cP.exports = bee;
      });
      mP = u((TAe, pP) => {
        pP.exports = { Between: Kl(), BetweenPoints: Q_(), BetweenPointsY: $_(), BetweenY: eP(), CounterClockwise: iP(),
        Normalize: Zl(), Random: aP(), RandomDegrees: hP(), Reverse: lP(), RotateTo: dP(), ShortestBetween: vP(),
        Wrap: hl(), WrapDegrees: ul() };
      });
      xP = u((yAe, gP) => {
        var Lee = function(e, t) {
          var i = e.x - t.x, r = e.y - t.y;
          return i * i + r * r;
        };
        gP.exports = Lee;
      });
      TP = u((SAe, EP) => {
        var Oee = function(e, t, i, r) {
          return Math.max(Math.abs(e - i), Math.abs(t - r));
        };
        EP.exports = Oee;
      });
      SP = u((wAe, yP) => {
        var Dee = function(e, t, i, r, s) {
          return s === void 0 && (s = 2), Math.sqrt(Math.pow(i - e, s) + Math.pow(r - t, s));
        };
        yP.exports = Dee;
      });
      CP = u((CAe, wP) => {
        var Nee = function(e, t, i, r) {
          return Math.abs(e - i) + Math.abs(t - r);
        };
        wP.exports = Nee;
      });
      RP = u((AAe, AP) => {
        var Iee = function(e, t, i, r) {
          var s = e - i, n = t - r;
          return s * s + n * n;
        };
        AP.exports = Iee;
      });
      PP = u((RAe, _P) => {
        _P.exports = { Between: Nn(), BetweenPoints: cl(), BetweenPointsSquared: xP(), Chebyshev: TP(),
        Power: SP(), Snake: CP(), Squared: RP() };
      });
      qP = u((_Ae, MP) => {
        MP.exports = { Back: vl(), Bounce: pl(), Circular: ml(), Cubic: gl(), Elastic: xl(), Expo: El(),
        Linear: Tl(), Quadratic: yl(), Quartic: Sl(), Quintic: wl(), Sine: Cl(), Stepped: Al() };
      });
      bP = u((PAe, FP) => {
        var Bee = function(e, t) {
          return t === void 0 && (t = 1e-4), Math.ceil(e - t);
        };
        FP.exports = Bee;
      });
      OP = u((MAe, LP) => {
        var Gee = function(e, t) {
          return t === void 0 && (t = 1e-4), Math.floor(e + t);
        };
        LP.exports = Gee;
      });
      NP = u((qAe, DP) => {
        var Uee = function(e, t, i) {
          return i === void 0 && (i = 1e-4), e > t - i;
        };
        DP.exports = Uee;
      });
      BP = u((FAe, IP) => {
        var zee = function(e, t, i) {
          return i === void 0 && (i = 1e-4), e < t + i;
        };
        IP.exports = zee;
      });
      UP = u((bAe, GP) => {
        GP.exports = { Ceil: bP(), Equal: Ja(), Floor: OP(), GreaterThan: NP(), LessThan: BP() };
      });
      Jl = u((LAe, zP) => {
        var kee = function(e) {
          if (e === 0) return 1;
          for (var t = e; --e; ) t *= e;
          return t;
        };
        zP.exports = kee;
      });
      jl = u((OAe, kP) => {
        var $l = Jl(), Xee = function(e, t) {
          return $l(e) / $l(t) / $l(e - t);
        };
        kP.exports = Xee;
      });
      ef = u((DAe, XP) => {
        var Vee = jl(), Yee = function(e, t) {
          for (var i = 0, r = e.length - 1, s = 0; s <= r; s++) i += Math.pow(1 - t, r - s) * Math.pow(
          t, s) * e[s] * Vee(r, s);
          return i;
        };
        XP.exports = Yee;
      });
      To = u((NAe, VP) => {
        var Wee = function(e, t, i, r, s) {
          var n = (r - t) * 0.5, a = (s - i) * 0.5, o = e * e, h = e * o;
          return (2 * i - 2 * r + n + a) * h + (-3 * i + 3 * r - 2 * n - a) * o + n * e + i;
        };
        VP.exports = Wee;
      });
      tf = u((IAe, YP) => {
        var yo = To(), Hee = function(e, t) {
          var i = e.length - 1, r = i * t, s = Math.floor(r);
          return e[0] === e[i] ? (t < 0 && (s = Math.floor(r = i * (1 + t))), yo(r - s, e[(s - 1 + i) %
          i], e[s], e[(s + 1) % i], e[(s + 2) % i])) : t < 0 ? e[0] - (yo(-r, e[0], e[0], e[1], e[1]) -
          e[0]) : t > 1 ? e[i] - (yo(r - i, e[i], e[i], e[i - 1], e[i - 1]) - e[i]) : yo(r - s, e[s ?
          s - 1 : 0], e[s], e[i < s + 1 ? i : s + 1], e[i < s + 2 ? i : s + 2]);
        };
        YP.exports = Hee;
      });
      rf = u((BAe, WP) => {
        function Kee(e, t) {
          var i = 1 - e;
          return i * i * i * t;
        }
        function Zee(e, t) {
          var i = 1 - e;
          return 3 * i * i * e * t;
        }
        function Qee(e, t) {
          return 3 * (1 - e) * e * e * t;
        }
        function Jee(e, t) {
          return e * e * e * t;
        }
        var $ee = function(e, t, i, r, s) {
          return Kee(e, t) + Zee(e, i) + Qee(e, r) + Jee(e, s);
        };
        WP.exports = $ee;
      });
      nf = u((GAe, HP) => {
        var sf = Eo(), jee = function(e, t) {
          var i = e.length - 1, r = i * t, s = Math.floor(r);
          return t < 0 ? sf(e[0], e[1], r) : t > 1 ? sf(e[i], e[i - 1], i - r) : sf(e[s], e[s + 1 > i ?
          i : s + 1], r - s);
        };
        HP.exports = jee;
      });
      af = u((UAe, KP) => {
        function ete(e, t) {
          var i = 1 - e;
          return i * i * t;
        }
        function tte(e, t) {
          return 2 * (1 - e) * e * t;
        }
        function ite(e, t) {
          return e * e * t;
        }
        var rte = function(e, t, i, r) {
          return ete(e, t) + tte(e, i) + ite(e, r);
        };
        KP.exports = rte;
      });
      of = u((zAe, ZP) => {
        var ste = vo(), nte = function(e, t, i) {
          return t + (i - t) * ste(e, 0, 1);
        };
        ZP.exports = nte;
      });
      JP = u((kAe, QP) => {
        var ate = co(), ote = function(e, t, i) {
          return t + (i - t) * ate(e, 0, 1);
        };
        QP.exports = ote;
      });
      jP = u((XAe, $P) => {
        $P.exports = { Bezier: ef(), CatmullRom: tf(), CubicBezier: rf(), Linear: nf(), QuadraticBezier: af(),
        SmoothStep: of(), SmootherStep: JP() };
      });
      tM = u((VAe, eM) => {
        var hte = function(e) {
          var t = Math.log(e) / 0.6931471805599453;
          return 1 << Math.ceil(t);
        };
        eM.exports = hte;
      });
      Cs = u((YAe, iM) => {
        var ute = function(e, t) {
          return e > 0 && (e & e - 1) === 0 && t > 0 && (t & t - 1) === 0;
        };
        iM.exports = ute;
      });
      sM = u((WAe, rM) => {
        var lte = function(e) {
          return e > 0 && (e & e - 1) === 0;
        };
        rM.exports = lte;
      });
      aM = u((HAe, nM) => {
        nM.exports = { GetNext: tM(), IsSize: Cs(), IsValue: sM() };
      });
      hf = u((KAe, oM) => {
        var fte = function(e, t, i, r) {
          return i === void 0 && (i = 0), t === 0 ? e : (e -= i, e = t * Math.ceil(e / t), r ? (i + e) /
          t : i + e);
        };
        oM.exports = fte;
      });
      Un = u((ZAe, hM) => {
        var dte = function(e, t, i, r) {
          return i === void 0 && (i = 0), t === 0 ? e : (e -= i, e = t * Math.floor(e / t), r ? (i +
          e) / t : i + e);
        };
        hM.exports = dte;
      });
      uf = u((QAe, uM) => {
        var cte = function(e, t, i, r) {
          return i === void 0 && (i = 0), t === 0 ? e : (e -= i, e = t * Math.round(e / t), r ? (i +
          e) / t : i + e);
        };
        uM.exports = cte;
      });
      fM = u((JAe, lM) => {
        lM.exports = { Ceil: hf(), Floor: Un(), To: uf() };
      });
      cM = u(($Ae, dM) => {
        var vte = C(), pte = new vte({ initialize: function(t) {
          t === void 0 && (t = [(Date.now() * Math.random()).toString()]), this.c = 1, this.s0 = 0, this.
          s1 = 0, this.s2 = 0, this.n = 0, this.signs = [-1, 1], t && this.init(t);
        }, rnd: function() {
          var e = 2091639 * this.s0 + this.c * 23283064365386963e-26;
          return this.c = e | 0, this.s0 = this.s1, this.s1 = this.s2, this.s2 = e - this.c, this.s2;
        }, hash: function(e) {
          var t, i = this.n;
          e = e.toString();
          for (var r = 0; r < e.length; r++) i += e.charCodeAt(r), t = 0.02519603282416938 * i, i = t >>>
          0, t -= i, t *= i, i = t >>> 0, t -= i, i += t * 4294967296;
          return this.n = i, (i >>> 0) * 23283064365386963e-26;
        }, init: function(e) {
          typeof e == "string" ? this.state(e) : this.sow(e);
        }, sow: function(e) {
          if (this.n = 4022871197, this.s0 = this.hash(" "), this.s1 = this.hash(" "), this.s2 = this.
          hash(" "), this.c = 1, !!e) for (var t = 0; t < e.length && e[t] != null; t++) {
            var i = e[t];
            this.s0 -= this.hash(i), this.s0 += ~~(this.s0 < 0), this.s1 -= this.hash(i), this.s1 +=
            ~~(this.s1 < 0), this.s2 -= this.hash(i), this.s2 += ~~(this.s2 < 0);
          }
        }, integer: function() {
          return this.rnd() * 4294967296;
        }, frac: function() {
          return this.rnd() + (this.rnd() * 2097152 | 0) * 11102230246251565e-32;
        }, real: function() {
          return this.integer() + this.frac();
        }, integerInRange: function(e, t) {
          return Math.floor(this.realInRange(0, t - e + 1) + e);
        }, between: function(e, t) {
          return Math.floor(this.realInRange(0, t - e + 1) + e);
        }, realInRange: function(e, t) {
          return this.frac() * (t - e) + e;
        }, normal: function() {
          return 1 - 2 * this.frac();
        }, uuid: function() {
          var e = "", t = "";
          for (t = e = ""; e++ < 36; t += ~e % 5 | e * 3 & 4 ? (e ^ 15 ? 8 ^ this.frac() * (e ^ 20 ?
          16 : 4) : 4).toString(16) : "-") ;
          return t;
        }, pick: function(e) {
          return e[this.integerInRange(0, e.length - 1)];
        }, sign: function() {
          return this.pick(this.signs);
        }, weightedPick: function(e) {
          return e[~~(Math.pow(this.frac(), 2) * (e.length - 0.5) + 0.5)];
        }, timestamp: function(e, t) {
          return this.realInRange(e || 9466848e5, t || 1577862e6);
        }, angle: function() {
          return this.integerInRange(-180, 180);
        }, rotation: function() {
          return this.realInRange(-3.1415926, 3.1415926);
        }, state: function(e) {
          return typeof e == "string" && e.match(/^!rnd/) && (e = e.split(","), this.c = parseFloat(
          e[1]), this.s0 = parseFloat(e[2]), this.s1 = parseFloat(e[3]), this.s2 = parseFloat(e[4])),
          ["!rnd", this.c, this.s0, this.s1, this.s2].join(",");
        }, shuffle: function(e) {
          for (var t = e.length - 1, i = t; i > 0; i--) {
            var r = Math.floor(this.frac() * (i + 1)), s = e[r];
            e[r] = e[i], e[i] = s;
          }
          return e;
        } });
        dM.exports = pte;
      });
      pM = u((jAe, vM) => {
        var mte = function(e) {
          for (var t = 0, i = 0; i < e.length; i++) t += +e[i];
          return t / e.length;
        };
        vM.exports = mte;
      });
      gM = u((eRe, mM) => {
        var gte = function(e, t, i) {
          t === void 0 && (t = 0), i === void 0 && (i = 10);
          var r = Math.pow(i, -t);
          return Math.ceil(e * r) / r;
        };
        mM.exports = gte;
      });
      EM = u((tRe, xM) => {
        var xte = function(e, t) {
          return Math.abs(e - t);
        };
        xM.exports = xte;
      });
      As = u((iRe, TM) => {
        var Ete = C(), Fe = new Ete({ initialize: function(t, i, r) {
          this.x = 0, this.y = 0, this.z = 0, typeof t == "object" ? (this.x = t.x || 0, this.y = t.
          y || 0, this.z = t.z || 0) : (this.x = t || 0, this.y = i || 0, this.z = r || 0);
        }, up: function() {
          return this.x = 0, this.y = 1, this.z = 0, this;
        }, min: function(e) {
          return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.
          z, e.z), this;
        }, max: function(e) {
          return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.
          z, e.z), this;
        }, clone: function() {
          return new Fe(this.x, this.y, this.z);
        }, addVectors: function(e, t) {
          return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this;
        }, subVectors: function(e, t) {
          return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this;
        }, crossVectors: function(e, t) {
          var i = e.x, r = e.y, s = e.z, n = t.x, a = t.y, o = t.z;
          return this.x = r * o - s * a, this.y = s * n - i * o, this.z = i * a - r * n, this;
        }, equals: function(e) {
          return this.x === e.x && this.y === e.y && this.z === e.z;
        }, copy: function(e) {
          return this.x = e.x, this.y = e.y, this.z = e.z || 0, this;
        }, set: function(e, t, i) {
          return typeof e == "object" ? (this.x = e.x || 0, this.y = e.y || 0, this.z = e.z || 0) : (this.
          x = e || 0, this.y = t || 0, this.z = i || 0), this;
        }, setFromMatrixPosition: function(e) {
          return this.fromArray(e.val, 12);
        }, setFromMatrixColumn: function(e, t) {
          return this.fromArray(e.val, t * 4);
        }, fromArray: function(e, t) {
          return t === void 0 && (t = 0), this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this;
        }, add: function(e) {
          return this.x += e.x, this.y += e.y, this.z += e.z || 0, this;
        }, addScalar: function(e) {
          return this.x += e, this.y += e, this.z += e, this;
        }, addScale: function(e, t) {
          return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t || 0, this;
        }, subtract: function(e) {
          return this.x -= e.x, this.y -= e.y, this.z -= e.z || 0, this;
        }, multiply: function(e) {
          return this.x *= e.x, this.y *= e.y, this.z *= e.z || 1, this;
        }, scale: function(e) {
          return isFinite(e) ? (this.x *= e, this.y *= e, this.z *= e) : (this.x = 0, this.y = 0, this.
          z = 0), this;
        }, divide: function(e) {
          return this.x /= e.x, this.y /= e.y, this.z /= e.z || 1, this;
        }, negate: function() {
          return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
        }, distance: function(e) {
          var t = e.x - this.x, i = e.y - this.y, r = e.z - this.z || 0;
          return Math.sqrt(t * t + i * i + r * r);
        }, distanceSq: function(e) {
          var t = e.x - this.x, i = e.y - this.y, r = e.z - this.z || 0;
          return t * t + i * i + r * r;
        }, length: function() {
          var e = this.x, t = this.y, i = this.z;
          return Math.sqrt(e * e + t * t + i * i);
        }, lengthSq: function() {
          var e = this.x, t = this.y, i = this.z;
          return e * e + t * t + i * i;
        }, normalize: function() {
          var e = this.x, t = this.y, i = this.z, r = e * e + t * t + i * i;
          return r > 0 && (r = 1 / Math.sqrt(r), this.x = e * r, this.y = t * r, this.z = i * r), this;
        }, dot: function(e) {
          return this.x * e.x + this.y * e.y + this.z * e.z;
        }, cross: function(e) {
          var t = this.x, i = this.y, r = this.z, s = e.x, n = e.y, a = e.z;
          return this.x = i * a - r * n, this.y = r * s - t * a, this.z = t * n - i * s, this;
        }, lerp: function(e, t) {
          t === void 0 && (t = 0);
          var i = this.x, r = this.y, s = this.z;
          return this.x = i + t * (e.x - i), this.y = r + t * (e.y - r), this.z = s + t * (e.z - s),
          this;
        }, applyMatrix3: function(e) {
          var t = this.x, i = this.y, r = this.z, s = e.val;
          return this.x = s[0] * t + s[3] * i + s[6] * r, this.y = s[1] * t + s[4] * i + s[7] * r, this.
          z = s[2] * t + s[5] * i + s[8] * r, this;
        }, applyMatrix4: function(e) {
          var t = this.x, i = this.y, r = this.z, s = e.val, n = 1 / (s[3] * t + s[7] * i + s[11] * r +
          s[15]);
          return this.x = (s[0] * t + s[4] * i + s[8] * r + s[12]) * n, this.y = (s[1] * t + s[5] * i +
          s[9] * r + s[13]) * n, this.z = (s[2] * t + s[6] * i + s[10] * r + s[14]) * n, this;
        }, transformMat3: function(e) {
          var t = this.x, i = this.y, r = this.z, s = e.val;
          return this.x = t * s[0] + i * s[3] + r * s[6], this.y = t * s[1] + i * s[4] + r * s[7], this.
          z = t * s[2] + i * s[5] + r * s[8], this;
        }, transformMat4: function(e) {
          var t = this.x, i = this.y, r = this.z, s = e.val;
          return this.x = s[0] * t + s[4] * i + s[8] * r + s[12], this.y = s[1] * t + s[5] * i + s[9] *
          r + s[13], this.z = s[2] * t + s[6] * i + s[10] * r + s[14], this;
        }, transformCoordinates: function(e) {
          var t = this.x, i = this.y, r = this.z, s = e.val, n = t * s[0] + i * s[4] + r * s[8] + s[12],
          a = t * s[1] + i * s[5] + r * s[9] + s[13], o = t * s[2] + i * s[6] + r * s[10] + s[14], h = t *
          s[3] + i * s[7] + r * s[11] + s[15];
          return this.x = n / h, this.y = a / h, this.z = o / h, this;
        }, transformQuat: function(e) {
          var t = this.x, i = this.y, r = this.z, s = e.x, n = e.y, a = e.z, o = e.w, h = o * t + n *
          r - a * i, l = o * i + a * t - s * r, f = o * r + s * i - n * t, d = -s * t - n * i - a * r;
          return this.x = h * o + d * -s + l * -a - f * -n, this.y = l * o + d * -n + f * -s - h * -a,
          this.z = f * o + d * -a + h * -n - l * -s, this;
        }, project: function(e) {
          var t = this.x, i = this.y, r = this.z, s = e.val, n = s[0], a = s[1], o = s[2], h = s[3],
          l = s[4], f = s[5], d = s[6], c = s[7], p = s[8], v = s[9], m = s[10], g = s[11], x = s[12],
          E = s[13], T15 = s[14], w = s[15], y = 1 / (t * h + i * c + r * g + w);
          return this.x = (t * n + i * l + r * p + x) * y, this.y = (t * a + i * f + r * v + E) * y,
          this.z = (t * o + i * d + r * m + T15) * y, this;
        }, projectViewMatrix: function(e, t) {
          return this.applyMatrix4(e).applyMatrix4(t);
        }, unprojectViewMatrix: function(e, t) {
          return this.applyMatrix4(e).applyMatrix4(t);
        }, unproject: function(e, t) {
          var i = e.x, r = e.y, s = e.z, n = e.w, a = this.x - i, o = n - this.y - 1 - r, h = this.z;
          return this.x = 2 * a / s - 1, this.y = 2 * o / n - 1, this.z = 2 * h - 1, this.project(t);
        }, reset: function() {
          return this.x = 0, this.y = 0, this.z = 0, this;
        } });
        Fe.ZERO = new Fe();
        Fe.RIGHT = new Fe(1, 0, 0);
        Fe.LEFT = new Fe(-1, 0, 0);
        Fe.UP = new Fe(0, -1, 0);
        Fe.DOWN = new Fe(0, 1, 0);
        Fe.FORWARD = new Fe(0, 0, 1);
        Fe.BACK = new Fe(0, 0, -1);
        Fe.ONE = new Fe(1, 1, 1);
        TM.exports = Fe;
      });
      _s = u((rRe, yM) => {
        var Tte = C(), lf = As(), So = 1e-6, Co = new Tte({ initialize: function(t) {
          this.val = new Float32Array(16), t ? this.copy(t) : this.identity();
        }, clone: function() {
          return new Co(this);
        }, set: function(e) {
          return this.copy(e);
        }, setValues: function(e, t, i, r, s, n, a, o, h, l, f, d, c, p, v, m) {
          var g = this.val;
          return g[0] = e, g[1] = t, g[2] = i, g[3] = r, g[4] = s, g[5] = n, g[6] = a, g[7] = o, g[8] =
          h, g[9] = l, g[10] = f, g[11] = d, g[12] = c, g[13] = p, g[14] = v, g[15] = m, this;
        }, copy: function(e) {
          var t = e.val;
          return this.setValues(t[0], t[1], t[2], t[3], t[4], t[5], t[6], t[7], t[8], t[9], t[10], t[11],
          t[12], t[13], t[14], t[15]);
        }, fromArray: function(e) {
          return this.setValues(e[0], e[1], e[2], e[3], e[4], e[5], e[6], e[7], e[8], e[9], e[10], e[11],
          e[12], e[13], e[14], e[15]);
        }, zero: function() {
          return this.setValues(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        }, transform: function(e, t, i) {
          var r = Rs.fromQuat(i), s = r.val, n = t.x, a = t.y, o = t.z;
          return this.setValues(s[0] * n, s[1] * n, s[2] * n, 0, s[4] * a, s[5] * a, s[6] * a, 0, s[8] *
          o, s[9] * o, s[10] * o, 0, e.x, e.y, e.z, 1);
        }, xyz: function(e, t, i) {
          this.identity();
          var r = this.val;
          return r[12] = e, r[13] = t, r[14] = i, this;
        }, scaling: function(e, t, i) {
          this.zero();
          var r = this.val;
          return r[0] = e, r[5] = t, r[10] = i, r[15] = 1, this;
        }, identity: function() {
          return this.setValues(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
        }, transpose: function() {
          var e = this.val, t = e[1], i = e[2], r = e[3], s = e[6], n = e[7], a = e[11];
          return e[1] = e[4], e[2] = e[8], e[3] = e[12], e[4] = t, e[6] = e[9], e[7] = e[13], e[8] =
          i, e[9] = s, e[11] = e[14], e[12] = r, e[13] = n, e[14] = a, this;
        }, getInverse: function(e) {
          return this.copy(e), this.invert();
        }, invert: function() {
          var e = this.val, t = e[0], i = e[1], r = e[2], s = e[3], n = e[4], a = e[5], o = e[6], h = e[7],
          l = e[8], f = e[9], d = e[10], c = e[11], p = e[12], v = e[13], m = e[14], g = e[15], x = t *
          a - i * n, E = t * o - r * n, T15 = t * h - s * n, w = i * o - r * a, y = i * h - s * a, A10 = r *
          h - s * o, S14 = l * v - f * p, _ = l * m - d * p, q = l * g - c * p, P = f * m - d * v, L = f *
          g - c * v, N5 = d * g - c * m, O19 = x * N5 - E * L + T15 * P + w * q - y * _ + A10 * S14;
          return O19 ? (O19 = 1 / O19, this.setValues((a * N5 - o * L + h * P) * O19, (r * L - i * N5 -
          s * P) * O19, (v * A10 - m * y + g * w) * O19, (d * y - f * A10 - c * w) * O19, (o * q - n *
          N5 - h * _) * O19, (t * N5 - r * q + s * _) * O19, (m * T15 - p * A10 - g * E) * O19, (l *
          A10 - d * T15 + c * E) * O19, (n * L - a * q + h * S14) * O19, (i * q - t * L - s * S14) *
          O19, (p * y - v * T15 + g * x) * O19, (f * T15 - l * y - c * x) * O19, (a * _ - n * P - o *
          S14) * O19, (t * P - i * _ + r * S14) * O19, (v * E - p * w - m * x) * O19, (l * w - f * E +
          d * x) * O19)) : this;
        }, adjoint: function() {
          var e = this.val, t = e[0], i = e[1], r = e[2], s = e[3], n = e[4], a = e[5], o = e[6], h = e[7],
          l = e[8], f = e[9], d = e[10], c = e[11], p = e[12], v = e[13], m = e[14], g = e[15];
          return this.setValues(a * (d * g - c * m) - f * (o * g - h * m) + v * (o * c - h * d), -(i *
          (d * g - c * m) - f * (r * g - s * m) + v * (r * c - s * d)), i * (o * g - h * m) - a * (r *
          g - s * m) + v * (r * h - s * o), -(i * (o * c - h * d) - a * (r * c - s * d) + f * (r * h -
          s * o)), -(n * (d * g - c * m) - l * (o * g - h * m) + p * (o * c - h * d)), t * (d * g - c *
          m) - l * (r * g - s * m) + p * (r * c - s * d), -(t * (o * g - h * m) - n * (r * g - s * m) +
          p * (r * h - s * o)), t * (o * c - h * d) - n * (r * c - s * d) + l * (r * h - s * o), n *
          (f * g - c * v) - l * (a * g - h * v) + p * (a * c - h * f), -(t * (f * g - c * v) - l * (i *
          g - s * v) + p * (i * c - s * f)), t * (a * g - h * v) - n * (i * g - s * v) + p * (i * h -
          s * a), -(t * (a * c - h * f) - n * (i * c - s * f) + l * (i * h - s * a)), -(n * (f * m -
          d * v) - l * (a * m - o * v) + p * (a * d - o * f)), t * (f * m - d * v) - l * (i * m - r *
          v) + p * (i * d - r * f), -(t * (a * m - o * v) - n * (i * m - r * v) + p * (i * o - r * a)),
          t * (a * d - o * f) - n * (i * d - r * f) + l * (i * o - r * a));
        }, determinant: function() {
          var e = this.val, t = e[0], i = e[1], r = e[2], s = e[3], n = e[4], a = e[5], o = e[6], h = e[7],
          l = e[8], f = e[9], d = e[10], c = e[11], p = e[12], v = e[13], m = e[14], g = e[15], x = t *
          a - i * n, E = t * o - r * n, T15 = t * h - s * n, w = i * o - r * a, y = i * h - s * a, A10 = r *
          h - s * o, S14 = l * v - f * p, _ = l * m - d * p, q = l * g - c * p, P = f * m - d * v, L = f *
          g - c * v, N5 = d * g - c * m;
          return x * N5 - E * L + T15 * P + w * q - y * _ + A10 * S14;
        }, multiply: function(e) {
          var t = this.val, i = t[0], r = t[1], s = t[2], n = t[3], a = t[4], o = t[5], h = t[6], l = t[7],
          f = t[8], d = t[9], c = t[10], p = t[11], v = t[12], m = t[13], g = t[14], x = t[15], E = e.
          val, T15 = E[0], w = E[1], y = E[2], A10 = E[3];
          return t[0] = T15 * i + w * a + y * f + A10 * v, t[1] = T15 * r + w * o + y * d + A10 * m,
          t[2] = T15 * s + w * h + y * c + A10 * g, t[3] = T15 * n + w * l + y * p + A10 * x, T15 = E[4],
          w = E[5], y = E[6], A10 = E[7], t[4] = T15 * i + w * a + y * f + A10 * v, t[5] = T15 * r +
          w * o + y * d + A10 * m, t[6] = T15 * s + w * h + y * c + A10 * g, t[7] = T15 * n + w * l +
          y * p + A10 * x, T15 = E[8], w = E[9], y = E[10], A10 = E[11], t[8] = T15 * i + w * a + y *
          f + A10 * v, t[9] = T15 * r + w * o + y * d + A10 * m, t[10] = T15 * s + w * h + y * c + A10 *
          g, t[11] = T15 * n + w * l + y * p + A10 * x, T15 = E[12], w = E[13], y = E[14], A10 = E[15],
          t[12] = T15 * i + w * a + y * f + A10 * v, t[13] = T15 * r + w * o + y * d + A10 * m, t[14] =
          T15 * s + w * h + y * c + A10 * g, t[15] = T15 * n + w * l + y * p + A10 * x, this;
        }, multiplyLocal: function(e) {
          var t = this.val, i = e.val;
          return this.setValues(t[0] * i[0] + t[1] * i[4] + t[2] * i[8] + t[3] * i[12], t[0] * i[1] +
          t[1] * i[5] + t[2] * i[9] + t[3] * i[13], t[0] * i[2] + t[1] * i[6] + t[2] * i[10] + t[3] *
          i[14], t[0] * i[3] + t[1] * i[7] + t[2] * i[11] + t[3] * i[15], t[4] * i[0] + t[5] * i[4] +
          t[6] * i[8] + t[7] * i[12], t[4] * i[1] + t[5] * i[5] + t[6] * i[9] + t[7] * i[13], t[4] *
          i[2] + t[5] * i[6] + t[6] * i[10] + t[7] * i[14], t[4] * i[3] + t[5] * i[7] + t[6] * i[11] +
          t[7] * i[15], t[8] * i[0] + t[9] * i[4] + t[10] * i[8] + t[11] * i[12], t[8] * i[1] + t[9] *
          i[5] + t[10] * i[9] + t[11] * i[13], t[8] * i[2] + t[9] * i[6] + t[10] * i[10] + t[11] * i[14],
          t[8] * i[3] + t[9] * i[7] + t[10] * i[11] + t[11] * i[15], t[12] * i[0] + t[13] * i[4] + t[14] *
          i[8] + t[15] * i[12], t[12] * i[1] + t[13] * i[5] + t[14] * i[9] + t[15] * i[13], t[12] * i[2] +
          t[13] * i[6] + t[14] * i[10] + t[15] * i[14], t[12] * i[3] + t[13] * i[7] + t[14] * i[11] +
          t[15] * i[15]);
        }, premultiply: function(e) {
          return this.multiplyMatrices(e, this);
        }, multiplyMatrices: function(e, t) {
          var i = e.val, r = t.val, s = i[0], n = i[4], a = i[8], o = i[12], h = i[1], l = i[5], f = i[9],
          d = i[13], c = i[2], p = i[6], v = i[10], m = i[14], g = i[3], x = i[7], E = i[11], T15 = i[15],
          w = r[0], y = r[4], A10 = r[8], S14 = r[12], _ = r[1], q = r[5], P = r[9], L = r[13], N5 = r[2],
          O19 = r[6], M = r[10], F8 = r[14], b = r[3], G = r[7], I = r[11], W = r[15];
          return this.setValues(s * w + n * _ + a * N5 + o * b, h * w + l * _ + f * N5 + d * b, c * w +
          p * _ + v * N5 + m * b, g * w + x * _ + E * N5 + T15 * b, s * y + n * q + a * O19 + o * G,
          h * y + l * q + f * O19 + d * G, c * y + p * q + v * O19 + m * G, g * y + x * q + E * O19 +
          T15 * G, s * A10 + n * P + a * M + o * I, h * A10 + l * P + f * M + d * I, c * A10 + p * P +
          v * M + m * I, g * A10 + x * P + E * M + T15 * I, s * S14 + n * L + a * F8 + o * W, h * S14 +
          l * L + f * F8 + d * W, c * S14 + p * L + v * F8 + m * W, g * S14 + x * L + E * F8 + T15 *
          W);
        }, translate: function(e) {
          return this.translateXYZ(e.x, e.y, e.z);
        }, translateXYZ: function(e, t, i) {
          var r = this.val;
          return r[12] = r[0] * e + r[4] * t + r[8] * i + r[12], r[13] = r[1] * e + r[5] * t + r[9] *
          i + r[13], r[14] = r[2] * e + r[6] * t + r[10] * i + r[14], r[15] = r[3] * e + r[7] * t + r[11] *
          i + r[15], this;
        }, scale: function(e) {
          return this.scaleXYZ(e.x, e.y, e.z);
        }, scaleXYZ: function(e, t, i) {
          var r = this.val;
          return r[0] = r[0] * e, r[1] = r[1] * e, r[2] = r[2] * e, r[3] = r[3] * e, r[4] = r[4] * t,
          r[5] = r[5] * t, r[6] = r[6] * t, r[7] = r[7] * t, r[8] = r[8] * i, r[9] = r[9] * i, r[10] =
          r[10] * i, r[11] = r[11] * i, this;
        }, makeRotationAxis: function(e, t) {
          var i = Math.cos(t), r = Math.sin(t), s = 1 - i, n = e.x, a = e.y, o = e.z, h = s * n, l = s *
          a;
          return this.setValues(h * n + i, h * a - r * o, h * o + r * a, 0, h * a + r * o, l * a + i,
          l * o - r * n, 0, h * o - r * a, l * o + r * n, s * o * o + i, 0, 0, 0, 0, 1);
        }, rotate: function(e, t) {
          var i = this.val, r = t.x, s = t.y, n = t.z, a = Math.sqrt(r * r + s * s + n * n);
          if (Math.abs(a) < So) return this;
          a = 1 / a, r *= a, s *= a, n *= a;
          var o = Math.sin(e), h = Math.cos(e), l = 1 - h, f = i[0], d = i[1], c = i[2], p = i[3], v = i[4],
          m = i[5], g = i[6], x = i[7], E = i[8], T15 = i[9], w = i[10], y = i[11], A10 = i[12], S14 = i[13],
          _ = i[14], q = i[15], P = r * r * l + h, L = s * r * l + n * o, N5 = n * r * l - s * o, O19 = r *
          s * l - n * o, M = s * s * l + h, F8 = n * s * l + r * o, b = r * n * l + s * o, G = s * n *
          l - r * o, I = n * n * l + h;
          return this.setValues(f * P + v * L + E * N5, d * P + m * L + T15 * N5, c * P + g * L + w *
          N5, p * P + x * L + y * N5, f * O19 + v * M + E * F8, d * O19 + m * M + T15 * F8, c * O19 +
          g * M + w * F8, p * O19 + x * M + y * F8, f * b + v * G + E * I, d * b + m * G + T15 * I, c *
          b + g * G + w * I, p * b + x * G + y * I, A10, S14, _, q);
        }, rotateX: function(e) {
          var t = this.val, i = Math.sin(e), r = Math.cos(e), s = t[4], n = t[5], a = t[6], o = t[7],
          h = t[8], l = t[9], f = t[10], d = t[11];
          return t[4] = s * r + h * i, t[5] = n * r + l * i, t[6] = a * r + f * i, t[7] = o * r + d *
          i, t[8] = h * r - s * i, t[9] = l * r - n * i, t[10] = f * r - a * i, t[11] = d * r - o * i,
          this;
        }, rotateY: function(e) {
          var t = this.val, i = Math.sin(e), r = Math.cos(e), s = t[0], n = t[1], a = t[2], o = t[3],
          h = t[8], l = t[9], f = t[10], d = t[11];
          return t[0] = s * r - h * i, t[1] = n * r - l * i, t[2] = a * r - f * i, t[3] = o * r - d *
          i, t[8] = s * i + h * r, t[9] = n * i + l * r, t[10] = a * i + f * r, t[11] = o * i + d * r,
          this;
        }, rotateZ: function(e) {
          var t = this.val, i = Math.sin(e), r = Math.cos(e), s = t[0], n = t[1], a = t[2], o = t[3],
          h = t[4], l = t[5], f = t[6], d = t[7];
          return t[0] = s * r + h * i, t[1] = n * r + l * i, t[2] = a * r + f * i, t[3] = o * r + d *
          i, t[4] = h * r - s * i, t[5] = l * r - n * i, t[6] = f * r - a * i, t[7] = d * r - o * i,
          this;
        }, fromRotationTranslation: function(e, t) {
          var i = e.x, r = e.y, s = e.z, n = e.w, a = i + i, o = r + r, h = s + s, l = i * a, f = i *
          o, d = i * h, c = r * o, p = r * h, v = s * h, m = n * a, g = n * o, x = n * h;
          return this.setValues(1 - (c + v), f + x, d - g, 0, f - x, 1 - (l + v), p + m, 0, d + g, p -
          m, 1 - (l + c), 0, t.x, t.y, t.z, 1);
        }, fromQuat: function(e) {
          var t = e.x, i = e.y, r = e.z, s = e.w, n = t + t, a = i + i, o = r + r, h = t * n, l = t *
          a, f = t * o, d = i * a, c = i * o, p = r * o, v = s * n, m = s * a, g = s * o;
          return this.setValues(1 - (d + p), l + g, f - m, 0, l - g, 1 - (h + p), c + v, 0, f + m, c -
          v, 1 - (h + d), 0, 0, 0, 0, 1);
        }, frustum: function(e, t, i, r, s, n) {
          var a = 1 / (t - e), o = 1 / (r - i), h = 1 / (s - n);
          return this.setValues(s * 2 * a, 0, 0, 0, 0, s * 2 * o, 0, 0, (t + e) * a, (r + i) * o, (n +
          s) * h, -1, 0, 0, n * s * 2 * h, 0);
        }, perspective: function(e, t, i, r) {
          var s = 1 / Math.tan(e / 2), n = 1 / (i - r);
          return this.setValues(s / t, 0, 0, 0, 0, s, 0, 0, 0, 0, (r + i) * n, -1, 0, 0, 2 * r * i *
          n, 0);
        }, perspectiveLH: function(e, t, i, r) {
          return this.setValues(2 * i / e, 0, 0, 0, 0, 2 * i / t, 0, 0, 0, 0, -r / (i - r), 1, 0, 0,
          i * r / (i - r), 0);
        }, ortho: function(e, t, i, r, s, n) {
          var a = e - t, o = i - r, h = s - n;
          return a = a === 0 ? a : 1 / a, o = o === 0 ? o : 1 / o, h = h === 0 ? h : 1 / h, this.setValues(
          -2 * a, 0, 0, 0, 0, -2 * o, 0, 0, 0, 0, 2 * h, 0, (e + t) * a, (r + i) * o, (n + s) * h, 1);
        }, lookAtRH: function(e, t, i) {
          var r = this.val;
          return St.subVectors(e, t), St.lengthSq() === 0 && (St.z = 1), St.normalize(), Qi.crossVectors(
          i, St), Qi.lengthSq() === 0 && (Math.abs(i.z) === 1 ? St.x += 1e-4 : St.z += 1e-4, St.normalize(),
          Qi.crossVectors(i, St)), Qi.normalize(), wo.crossVectors(St, Qi), r[0] = Qi.x, r[1] = Qi.y,
          r[2] = Qi.z, r[4] = wo.x, r[5] = wo.y, r[6] = wo.z, r[8] = St.x, r[9] = St.y, r[10] = St.z,
          this;
        }, lookAt: function(e, t, i) {
          var r = e.x, s = e.y, n = e.z, a = i.x, o = i.y, h = i.z, l = t.x, f = t.y, d = t.z;
          if (Math.abs(r - l) < So && Math.abs(s - f) < So && Math.abs(n - d) < So) return this.identity();
          var c = r - l, p = s - f, v = n - d, m = 1 / Math.sqrt(c * c + p * p + v * v);
          c *= m, p *= m, v *= m;
          var g = o * v - h * p, x = h * c - a * v, E = a * p - o * c;
          m = Math.sqrt(g * g + x * x + E * E), m ? (m = 1 / m, g *= m, x *= m, E *= m) : (g = 0, x =
          0, E = 0);
          var T15 = p * E - v * x, w = v * g - c * E, y = c * x - p * g;
          return m = Math.sqrt(T15 * T15 + w * w + y * y), m ? (m = 1 / m, T15 *= m, w *= m, y *= m) :
          (T15 = 0, w = 0, y = 0), this.setValues(g, T15, c, 0, x, w, p, 0, E, y, v, 0, -(g * r + x *
          s + E * n), -(T15 * r + w * s + y * n), -(c * r + p * s + v * n), 1);
        }, yawPitchRoll: function(e, t, i) {
          this.zero(), Rs.zero(), zn.zero();
          var r = this.val, s = Rs.val, n = zn.val, a = Math.sin(i), o = Math.cos(i);
          return r[10] = 1, r[15] = 1, r[0] = o, r[1] = a, r[4] = -a, r[5] = o, a = Math.sin(t), o =
          Math.cos(t), s[0] = 1, s[15] = 1, s[5] = o, s[10] = o, s[9] = -a, s[6] = a, a = Math.sin(e),
          o = Math.cos(e), n[5] = 1, n[15] = 1, n[0] = o, n[2] = -a, n[8] = a, n[10] = o, this.multiplyLocal(
          Rs), this.multiplyLocal(zn), this;
        }, setWorldMatrix: function(e, t, i, r, s) {
          return this.yawPitchRoll(e.y, e.x, e.z), Rs.scaling(i.x, i.y, i.z), zn.xyz(t.x, t.y, t.z),
          this.multiplyLocal(Rs), this.multiplyLocal(zn), r && this.multiplyLocal(r), s && this.multiplyLocal(
          s), this;
        }, multiplyToMat4: function(e, t) {
          var i = this.val, r = e.val, s = i[0], n = i[1], a = i[2], o = i[3], h = i[4], l = i[5], f = i[6],
          d = i[7], c = i[8], p = i[9], v = i[10], m = i[11], g = i[12], x = i[13], E = i[14], T15 = i[15],
          w = r[0], y = r[1], A10 = r[2], S14 = r[3], _ = r[4], q = r[5], P = r[6], L = r[7], N5 = r[8],
          O19 = r[9], M = r[10], F8 = r[11], b = r[12], G = r[13], I = r[14], W = r[15];
          return t.setValues(w * s + y * h + A10 * c + S14 * g, y * n + y * l + A10 * p + S14 * x, A10 *
          a + y * f + A10 * v + S14 * E, S14 * o + y * d + A10 * m + S14 * T15, _ * s + q * h + P * c +
          L * g, _ * n + q * l + P * p + L * x, _ * a + q * f + P * v + L * E, _ * o + q * d + P * m +
          L * T15, N5 * s + O19 * h + M * c + F8 * g, N5 * n + O19 * l + M * p + F8 * x, N5 * a + O19 *
          f + M * v + F8 * E, N5 * o + O19 * d + M * m + F8 * T15, b * s + G * h + I * c + W * g, b *
          n + G * l + I * p + W * x, b * a + G * f + I * v + W * E, b * o + G * d + I * m + W * T15);
        }, fromRotationXYTranslation: function(e, t, i) {
          var r = t.x, s = t.y, n = t.z, a = Math.sin(e.x), o = Math.cos(e.x), h = Math.sin(e.y), l = Math.
          cos(e.y), f = r, d = s, c = n, p = -a, v = 0 - p * h, m = 0 - o * h, g = p * l, x = o * l;
          return i || (f = l * r + h * n, d = v * r + o * s + g * n, c = m * r + a * s + x * n), this.
          setValues(l, v, m, 0, 0, o, a, 0, h, g, x, 0, f, d, c, 1);
        }, getMaxScaleOnAxis: function() {
          var e = this.val, t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2], i = e[4] * e[4] + e[5] * e[5] +
          e[6] * e[6], r = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
          return Math.sqrt(Math.max(t, i, r));
        } }), Rs = new Co(), zn = new Co(), Qi = new lf(), wo = new lf(), St = new lf();
        yM.exports = Co;
      });
      CM = u((sRe, wM) => {
        var Ps = ne(), yte = C(), Ste = _s(), wte = J(), SM = new Ste(), ff = new yte({ initialize: function e(t, i, r, s) {
          t === void 0 && (t = 0), i === void 0 && (i = 0), r === void 0 && (r = 0), s === void 0 &&
          (s = e.DefaultOrder), this._x = t, this._y = i, this._z = r, this._order = s, this.onChangeCallback =
          wte;
        }, x: { get: function() {
          return this._x;
        }, set: function(e) {
          this._x = e, this.onChangeCallback(this);
        } }, y: { get: function() {
          return this._y;
        }, set: function(e) {
          this._y = e, this.onChangeCallback(this);
        } }, z: { get: function() {
          return this._z;
        }, set: function(e) {
          this._z = e, this.onChangeCallback(this);
        } }, order: { get: function() {
          return this._order;
        }, set: function(e) {
          this._order = e, this.onChangeCallback(this);
        } }, set: function(e, t, i, r) {
          return r === void 0 && (r = this._order), this._x = e, this._y = t, this._z = i, this._order =
          r, this.onChangeCallback(this), this;
        }, copy: function(e) {
          return this.set(e.x, e.y, e.z, e.order);
        }, setFromQuaternion: function(e, t, i) {
          return t === void 0 && (t = this._order), i === void 0 && (i = false), SM.fromQuat(e), this.
          setFromRotationMatrix(SM, t, i);
        }, setFromRotationMatrix: function(e, t, i) {
          t === void 0 && (t = this._order), i === void 0 && (i = false);
          var r = e.val, s = r[0], n = r[4], a = r[8], o = r[1], h = r[5], l = r[9], f = r[2], d = r[6],
          c = r[10], p = 0, v = 0, m = 0, g = 0.99999;
          switch (t) {
            case "XYZ": {
              v = Math.asin(Ps(a, -1, 1)), Math.abs(a) < g ? (p = Math.atan2(-l, c), m = Math.atan2(
              -n, s)) : p = Math.atan2(d, h);
              break;
            }
            case "YXZ": {
              p = Math.asin(-Ps(l, -1, 1)), Math.abs(l) < g ? (v = Math.atan2(a, c), m = Math.atan2(
              o, h)) : v = Math.atan2(-f, s);
              break;
            }
            case "ZXY": {
              p = Math.asin(Ps(d, -1, 1)), Math.abs(d) < g ? (v = Math.atan2(-f, c), m = Math.atan2(
              -n, h)) : m = Math.atan2(o, s);
              break;
            }
            case "ZYX": {
              v = Math.asin(-Ps(f, -1, 1)), Math.abs(f) < g ? (p = Math.atan2(d, c), m = Math.atan2(
              o, s)) : m = Math.atan2(-n, h);
              break;
            }
            case "YZX": {
              m = Math.asin(Ps(o, -1, 1)), Math.abs(o) < g ? (p = Math.atan2(-l, h), v = Math.atan2(
              -f, s)) : v = Math.atan2(a, c);
              break;
            }
            case "XZY": {
              m = Math.asin(-Ps(n, -1, 1)), Math.abs(n) < g ? (p = Math.atan2(d, h), v = Math.atan2(
              a, s)) : p = Math.atan2(-l, c);
              break;
            }
          }
          return this._x = p, this._y = v, this._z = m, this._order = t, i && this.onChangeCallback(
          this), this;
        } });
        ff.RotationOrders = ["XYZ", "YXZ", "ZXY", "ZYX", "YZX", "XZY"];
        ff.DefaultOrder = "XYZ";
        wM.exports = ff;
      });
      RM = u((nRe, AM) => {
        var Cte = function(e, t, i) {
          t === void 0 && (t = 0), i === void 0 && (i = 10);
          var r = Math.pow(i, -t);
          return Math.floor(e * r) / r;
        };
        AM.exports = Cte;
      });
      PM = u((aRe, _M) => {
        var Ate = function(e, t) {
          return e / t / 1e3;
        };
        _M.exports = Ate;
      });
      qM = u((oRe, MM) => {
        var Rte = function(e) {
          return e == parseFloat(e) ? !(e % 2) : void 0;
        };
        MM.exports = Rte;
      });
      bM = u((hRe, FM) => {
        var _te = function(e) {
          return e === parseFloat(e) ? !(e % 2) : void 0;
        };
        FM.exports = _te;
      });
      OM = u((uRe, LM) => {
        var Pte = function(e, t, i) {
          return i === void 0 && (i = 0), e.clone().lerp(t, i);
        };
        LM.exports = Pte;
      });
      NM = u((lRe, DM) => {
        var Mte = function(e, t, i) {
          return Math.min(e + t, i);
        };
        DM.exports = Mte;
      });
      BM = u((fRe, IM) => {
        var qte = function(e) {
          var t = e.length;
          if (t === 0) return 0;
          e.sort(function(r, s) {
            return r - s;
          });
          var i = Math.floor(t / 2);
          return t % 2 === 0 ? (e[i] + e[i - 1]) / 2 : e[i];
        };
        IM.exports = qte;
      });
      UM = u((dRe, GM) => {
        var Fte = function(e, t, i) {
          return Math.max(e - t, i);
        };
        GM.exports = Fte;
      });
      kM = u((cRe, zM) => {
        var bte = function(e, t, i, r) {
          i === void 0 && (i = t + 1);
          var s = (e - t) / (i - t);
          return s > 1 ? r !== void 0 ? (s = (r - e) / (r - i), s < 0 && (s = 0)) : s = 1 : s < 0 &&
          (s = 0), s;
        };
        zM.exports = bte;
      });
      df = u((vRe, XM) => {
        var Lte = le(), Ote = function(e) {
          return e * Lte.RAD_TO_DEG;
        };
        XM.exports = Ote;
      });
      YM = u((pRe, VM) => {
        var Dte = function(e, t) {
          t === void 0 && (t = 1);
          var i = Math.random() * 2 * Math.PI;
          return e.x = Math.cos(i) * t, e.y = Math.sin(i) * t, e;
        };
        VM.exports = Dte;
      });
      HM = u((mRe, WM) => {
        var Nte = function(e, t) {
          t === void 0 && (t = 1);
          var i = Math.random() * 2 * Math.PI, r = Math.random() * 2 - 1, s = Math.sqrt(1 - r * r) *
          t;
          return e.x = Math.cos(i) * s, e.y = Math.sin(i) * s, e.z = r * t, e;
        };
        WM.exports = Nte;
      });
      ZM = u((gRe, KM) => {
        var Ite = function(e, t) {
          return t === void 0 && (t = 1), e.x = (Math.random() * 2 - 1) * t, e.y = (Math.random() * 2 -
          1) * t, e.z = (Math.random() * 2 - 1) * t, e.w = (Math.random() * 2 - 1) * t, e;
        };
        KM.exports = Ite;
      });
      JM = u((xRe, QM) => {
        var Bte = function(e, t) {
          var i = e.x, r = e.y;
          return e.x = i * Math.cos(t) - r * Math.sin(t), e.y = i * Math.sin(t) + r * Math.cos(t), e;
        };
        QM.exports = Bte;
      });
      jM = u((ERe, $M) => {
        var Gte = function(e, t, i, r, s) {
          return e.x = t + s * Math.cos(r), e.y = i + s * Math.sin(r), e;
        };
        $M.exports = Gte;
      });
      tq = u((TRe, eq) => {
        var Ute = function(e, t, i) {
          t === void 0 && (t = 0), i === void 0 && (i = 10);
          var r = Math.pow(i, -t);
          return Math.round(e * r) / r;
        };
        eq.exports = Ute;
      });
      rq = u((yRe, iq) => {
        var zte = function(e, t, i, r) {
          t === void 0 && (t = 1), i === void 0 && (i = 1), r === void 0 && (r = 1), r *= Math.PI / e;
          for (var s = [], n = [], a = 0; a < e; a++) i -= t * r, t += i * r, s[a] = i, n[a] = t;
          return { sin: n, cos: s, length: e };
        };
        iq.exports = zte;
      });
      nq = u((SRe, sq) => {
        var kte = Y(), Xte = function(e, t, i, r) {
          r === void 0 && (r = new kte());
          var s = 0, n = 0, a = t * i;
          return e > 0 && e <= a && (e > t - 1 ? (n = Math.floor(e / t), s = e - n * t) : s = e), r.
          set(s, n);
        };
        sq.exports = Xte;
      });
      oq = u((wRe, aq) => {
        var Vte = function(e, t, i) {
          return Math.abs(e - t) <= i;
        };
        aq.exports = Vte;
      });
      uq = u((CRe, hq) => {
        var Yte = C(), He = new Yte({ initialize: function(t, i, r, s) {
          this.x = 0, this.y = 0, this.z = 0, this.w = 0, typeof t == "object" ? (this.x = t.x || 0,
          this.y = t.y || 0, this.z = t.z || 0, this.w = t.w || 0) : (this.x = t || 0, this.y = i ||
          0, this.z = r || 0, this.w = s || 0);
        }, clone: function() {
          return new He(this.x, this.y, this.z, this.w);
        }, copy: function(e) {
          return this.x = e.x, this.y = e.y, this.z = e.z || 0, this.w = e.w || 0, this;
        }, equals: function(e) {
          return this.x === e.x && this.y === e.y && this.z === e.z && this.w === e.w;
        }, set: function(e, t, i, r) {
          return typeof e == "object" ? (this.x = e.x || 0, this.y = e.y || 0, this.z = e.z || 0, this.
          w = e.w || 0) : (this.x = e || 0, this.y = t || 0, this.z = i || 0, this.w = r || 0), this;
        }, add: function(e) {
          return this.x += e.x, this.y += e.y, this.z += e.z || 0, this.w += e.w || 0, this;
        }, subtract: function(e) {
          return this.x -= e.x, this.y -= e.y, this.z -= e.z || 0, this.w -= e.w || 0, this;
        }, scale: function(e) {
          return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this;
        }, length: function() {
          var e = this.x, t = this.y, i = this.z, r = this.w;
          return Math.sqrt(e * e + t * t + i * i + r * r);
        }, lengthSq: function() {
          var e = this.x, t = this.y, i = this.z, r = this.w;
          return e * e + t * t + i * i + r * r;
        }, normalize: function() {
          var e = this.x, t = this.y, i = this.z, r = this.w, s = e * e + t * t + i * i + r * r;
          return s > 0 && (s = 1 / Math.sqrt(s), this.x = e * s, this.y = t * s, this.z = i * s, this.
          w = r * s), this;
        }, dot: function(e) {
          return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
        }, lerp: function(e, t) {
          t === void 0 && (t = 0);
          var i = this.x, r = this.y, s = this.z, n = this.w;
          return this.x = i + t * (e.x - i), this.y = r + t * (e.y - r), this.z = s + t * (e.z - s),
          this.w = n + t * (e.w - n), this;
        }, multiply: function(e) {
          return this.x *= e.x, this.y *= e.y, this.z *= e.z || 1, this.w *= e.w || 1, this;
        }, divide: function(e) {
          return this.x /= e.x, this.y /= e.y, this.z /= e.z || 1, this.w /= e.w || 1, this;
        }, distance: function(e) {
          var t = e.x - this.x, i = e.y - this.y, r = e.z - this.z || 0, s = e.w - this.w || 0;
          return Math.sqrt(t * t + i * i + r * r + s * s);
        }, distanceSq: function(e) {
          var t = e.x - this.x, i = e.y - this.y, r = e.z - this.z || 0, s = e.w - this.w || 0;
          return t * t + i * i + r * r + s * s;
        }, negate: function() {
          return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
        }, transformMat4: function(e) {
          var t = this.x, i = this.y, r = this.z, s = this.w, n = e.val;
          return this.x = n[0] * t + n[4] * i + n[8] * r + n[12] * s, this.y = n[1] * t + n[5] * i +
          n[9] * r + n[13] * s, this.z = n[2] * t + n[6] * i + n[10] * r + n[14] * s, this.w = n[3] *
          t + n[7] * i + n[11] * r + n[15] * s, this;
        }, transformQuat: function(e) {
          var t = this.x, i = this.y, r = this.z, s = e.x, n = e.y, a = e.z, o = e.w, h = o * t + n *
          r - a * i, l = o * i + a * t - s * r, f = o * r + s * i - n * t, d = -s * t - n * i - a * r;
          return this.x = h * o + d * -s + l * -a - f * -n, this.y = l * o + d * -n + f * -s - h * -a,
          this.z = f * o + d * -a + h * -n - l * -s, this;
        }, reset: function() {
          return this.x = 0, this.y = 0, this.z = 0, this.w = 0, this;
        } });
        He.prototype.sub = He.prototype.subtract;
        He.prototype.mul = He.prototype.multiply;
        He.prototype.div = He.prototype.divide;
        He.prototype.dist = He.prototype.distance;
        He.prototype.distSq = He.prototype.distanceSq;
        He.prototype.len = He.prototype.length;
        He.prototype.lenSq = He.prototype.lengthSq;
        hq.exports = He;
      });
      cf = u((ARe, fq) => {
        var Wte = C(), lq = new Wte({ initialize: function(t) {
          this.val = new Float32Array(9), t ? this.copy(t) : this.identity();
        }, clone: function() {
          return new lq(this);
        }, set: function(e) {
          return this.copy(e);
        }, copy: function(e) {
          var t = this.val, i = e.val;
          return t[0] = i[0], t[1] = i[1], t[2] = i[2], t[3] = i[3], t[4] = i[4], t[5] = i[5], t[6] =
          i[6], t[7] = i[7], t[8] = i[8], this;
        }, fromMat4: function(e) {
          var t = e.val, i = this.val;
          return i[0] = t[0], i[1] = t[1], i[2] = t[2], i[3] = t[4], i[4] = t[5], i[5] = t[6], i[6] =
          t[8], i[7] = t[9], i[8] = t[10], this;
        }, fromArray: function(e) {
          var t = this.val;
          return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t[6] =
          e[6], t[7] = e[7], t[8] = e[8], this;
        }, identity: function() {
          var e = this.val;
          return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 1, e[5] = 0, e[6] = 0, e[7] = 0, e[8] =
          1, this;
        }, transpose: function() {
          var e = this.val, t = e[1], i = e[2], r = e[5];
          return e[1] = e[3], e[2] = e[6], e[3] = t, e[5] = e[7], e[6] = i, e[7] = r, this;
        }, invert: function() {
          var e = this.val, t = e[0], i = e[1], r = e[2], s = e[3], n = e[4], a = e[5], o = e[6], h = e[7],
          l = e[8], f = l * n - a * h, d = -l * s + a * o, c = h * s - n * o, p = t * f + i * d + r *
          c;
          return p ? (p = 1 / p, e[0] = f * p, e[1] = (-l * i + r * h) * p, e[2] = (a * i - r * n) *
          p, e[3] = d * p, e[4] = (l * t - r * o) * p, e[5] = (-a * t + r * s) * p, e[6] = c * p, e[7] =
          (-h * t + i * o) * p, e[8] = (n * t - i * s) * p, this) : null;
        }, adjoint: function() {
          var e = this.val, t = e[0], i = e[1], r = e[2], s = e[3], n = e[4], a = e[5], o = e[6], h = e[7],
          l = e[8];
          return e[0] = n * l - a * h, e[1] = r * h - i * l, e[2] = i * a - r * n, e[3] = a * o - s *
          l, e[4] = t * l - r * o, e[5] = r * s - t * a, e[6] = s * h - n * o, e[7] = i * o - t * h,
          e[8] = t * n - i * s, this;
        }, determinant: function() {
          var e = this.val, t = e[0], i = e[1], r = e[2], s = e[3], n = e[4], a = e[5], o = e[6], h = e[7],
          l = e[8];
          return t * (l * n - a * h) + i * (-l * s + a * o) + r * (h * s - n * o);
        }, multiply: function(e) {
          var t = this.val, i = t[0], r = t[1], s = t[2], n = t[3], a = t[4], o = t[5], h = t[6], l = t[7],
          f = t[8], d = e.val, c = d[0], p = d[1], v = d[2], m = d[3], g = d[4], x = d[5], E = d[6],
          T15 = d[7], w = d[8];
          return t[0] = c * i + p * n + v * h, t[1] = c * r + p * a + v * l, t[2] = c * s + p * o + v *
          f, t[3] = m * i + g * n + x * h, t[4] = m * r + g * a + x * l, t[5] = m * s + g * o + x * f,
          t[6] = E * i + T15 * n + w * h, t[7] = E * r + T15 * a + w * l, t[8] = E * s + T15 * o + w *
          f, this;
        }, translate: function(e) {
          var t = this.val, i = e.x, r = e.y;
          return t[6] = i * t[0] + r * t[3] + t[6], t[7] = i * t[1] + r * t[4] + t[7], t[8] = i * t[2] +
          r * t[5] + t[8], this;
        }, rotate: function(e) {
          var t = this.val, i = t[0], r = t[1], s = t[2], n = t[3], a = t[4], o = t[5], h = Math.sin(
          e), l = Math.cos(e);
          return t[0] = l * i + h * n, t[1] = l * r + h * a, t[2] = l * s + h * o, t[3] = l * n - h *
          i, t[4] = l * a - h * r, t[5] = l * o - h * s, this;
        }, scale: function(e) {
          var t = this.val, i = e.x, r = e.y;
          return t[0] = i * t[0], t[1] = i * t[1], t[2] = i * t[2], t[3] = r * t[3], t[4] = r * t[4],
          t[5] = r * t[5], this;
        }, fromQuat: function(e) {
          var t = e.x, i = e.y, r = e.z, s = e.w, n = t + t, a = i + i, o = r + r, h = t * n, l = t *
          a, f = t * o, d = i * a, c = i * o, p = r * o, v = s * n, m = s * a, g = s * o, x = this.val;
          return x[0] = 1 - (d + p), x[3] = l + g, x[6] = f - m, x[1] = l - g, x[4] = 1 - (h + p), x[7] =
          c + v, x[2] = f + m, x[5] = c - v, x[8] = 1 - (h + d), this;
        }, normalFromMat4: function(e) {
          var t = e.val, i = this.val, r = t[0], s = t[1], n = t[2], a = t[3], o = t[4], h = t[5], l = t[6],
          f = t[7], d = t[8], c = t[9], p = t[10], v = t[11], m = t[12], g = t[13], x = t[14], E = t[15],
          T15 = r * h - s * o, w = r * l - n * o, y = r * f - a * o, A10 = s * l - n * h, S14 = s * f -
          a * h, _ = n * f - a * l, q = d * g - c * m, P = d * x - p * m, L = d * E - v * m, N5 = c *
          x - p * g, O19 = c * E - v * g, M = p * E - v * x, F8 = T15 * M - w * O19 + y * N5 + A10 *
          L - S14 * P + _ * q;
          return F8 ? (F8 = 1 / F8, i[0] = (h * M - l * O19 + f * N5) * F8, i[1] = (l * L - o * M - f *
          P) * F8, i[2] = (o * O19 - h * L + f * q) * F8, i[3] = (n * O19 - s * M - a * N5) * F8, i[4] =
          (r * M - n * L + a * P) * F8, i[5] = (s * L - r * O19 - a * q) * F8, i[6] = (g * _ - x * S14 +
          E * A10) * F8, i[7] = (x * y - m * _ - E * w) * F8, i[8] = (m * S14 - g * y + E * T15) * F8,
          this) : null;
        } });
        fq.exports = lq;
      });
      pf = u((RRe, pq) => {
        var Hte = C(), Kte = cf(), Zte = J(), vf = As(), dq = 1e-6, cq = new Int8Array([1, 2, 0]), Ms = new Float32Array(
        [0, 0, 0]), Qte = new vf(1, 0, 0), Jte = new vf(0, 1, 0), Ji = new vf(), vq = new Kte(), $te = new Hte(
        { initialize: function(t, i, r, s) {
          this.onChangeCallback = Zte, this.set(t, i, r, s);
        }, x: { get: function() {
          return this._x;
        }, set: function(e) {
          this._x = e, this.onChangeCallback(this);
        } }, y: { get: function() {
          return this._y;
        }, set: function(e) {
          this._y = e, this.onChangeCallback(this);
        } }, z: { get: function() {
          return this._z;
        }, set: function(e) {
          this._z = e, this.onChangeCallback(this);
        } }, w: { get: function() {
          return this._w;
        }, set: function(e) {
          this._w = e, this.onChangeCallback(this);
        } }, copy: function(e) {
          return this.set(e);
        }, set: function(e, t, i, r, s) {
          return s === void 0 && (s = true), typeof e == "object" ? (this._x = e.x || 0, this._y = e.
          y || 0, this._z = e.z || 0, this._w = e.w || 0) : (this._x = e || 0, this._y = t || 0, this.
          _z = i || 0, this._w = r || 0), s && this.onChangeCallback(this), this;
        }, add: function(e) {
          return this._x += e.x, this._y += e.y, this._z += e.z, this._w += e.w, this.onChangeCallback(
          this), this;
        }, subtract: function(e) {
          return this._x -= e.x, this._y -= e.y, this._z -= e.z, this._w -= e.w, this.onChangeCallback(
          this), this;
        }, scale: function(e) {
          return this._x *= e, this._y *= e, this._z *= e, this._w *= e, this.onChangeCallback(this),
          this;
        }, length: function() {
          var e = this.x, t = this.y, i = this.z, r = this.w;
          return Math.sqrt(e * e + t * t + i * i + r * r);
        }, lengthSq: function() {
          var e = this.x, t = this.y, i = this.z, r = this.w;
          return e * e + t * t + i * i + r * r;
        }, normalize: function() {
          var e = this.x, t = this.y, i = this.z, r = this.w, s = e * e + t * t + i * i + r * r;
          return s > 0 && (s = 1 / Math.sqrt(s), this._x = e * s, this._y = t * s, this._z = i * s, this.
          _w = r * s), this.onChangeCallback(this), this;
        }, dot: function(e) {
          return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
        }, lerp: function(e, t) {
          t === void 0 && (t = 0);
          var i = this.x, r = this.y, s = this.z, n = this.w;
          return this.set(i + t * (e.x - i), r + t * (e.y - r), s + t * (e.z - s), n + t * (e.w - n));
        }, rotationTo: function(e, t) {
          var i = e.x * t.x + e.y * t.y + e.z * t.z;
          return i < -0.999999 ? (Ji.copy(Qte).cross(e).length() < dq && Ji.copy(Jte).cross(e), Ji.normalize(),
          this.setAxisAngle(Ji, Math.PI)) : i > 0.999999 ? this.set(0, 0, 0, 1) : (Ji.copy(e).cross(
          t), this._x = Ji.x, this._y = Ji.y, this._z = Ji.z, this._w = 1 + i, this.normalize());
        }, setAxes: function(e, t, i) {
          var r = vq.val;
          return r[0] = t.x, r[3] = t.y, r[6] = t.z, r[1] = i.x, r[4] = i.y, r[7] = i.z, r[2] = -e.x,
          r[5] = -e.y, r[8] = -e.z, this.fromMat3(vq).normalize();
        }, identity: function() {
          return this.set(0, 0, 0, 1);
        }, setAxisAngle: function(e, t) {
          t = t * 0.5;
          var i = Math.sin(t);
          return this.set(i * e.x, i * e.y, i * e.z, Math.cos(t));
        }, multiply: function(e) {
          var t = this.x, i = this.y, r = this.z, s = this.w, n = e.x, a = e.y, o = e.z, h = e.w;
          return this.set(t * h + s * n + i * o - r * a, i * h + s * a + r * n - t * o, r * h + s * o +
          t * a - i * n, s * h - t * n - i * a - r * o);
        }, slerp: function(e, t) {
          var i = this.x, r = this.y, s = this.z, n = this.w, a = e.x, o = e.y, h = e.z, l = e.w, f = i *
          a + r * o + s * h + n * l;
          f < 0 && (f = -f, a = -a, o = -o, h = -h, l = -l);
          var d = 1 - t, c = t;
          if (1 - f > dq) {
            var p = Math.acos(f), v = Math.sin(p);
            d = Math.sin((1 - t) * p) / v, c = Math.sin(t * p) / v;
          }
          return this.set(d * i + c * a, d * r + c * o, d * s + c * h, d * n + c * l);
        }, invert: function() {
          var e = this.x, t = this.y, i = this.z, r = this.w, s = e * e + t * t + i * i + r * r, n = s ?
          1 / s : 0;
          return this.set(-e * n, -t * n, -i * n, r * n);
        }, conjugate: function() {
          return this._x = -this.x, this._y = -this.y, this._z = -this.z, this.onChangeCallback(this),
          this;
        }, rotateX: function(e) {
          e *= 0.5;
          var t = this.x, i = this.y, r = this.z, s = this.w, n = Math.sin(e), a = Math.cos(e);
          return this.set(t * a + s * n, i * a + r * n, r * a - i * n, s * a - t * n);
        }, rotateY: function(e) {
          e *= 0.5;
          var t = this.x, i = this.y, r = this.z, s = this.w, n = Math.sin(e), a = Math.cos(e);
          return this.set(t * a - r * n, i * a + s * n, r * a + t * n, s * a - i * n);
        }, rotateZ: function(e) {
          e *= 0.5;
          var t = this.x, i = this.y, r = this.z, s = this.w, n = Math.sin(e), a = Math.cos(e);
          return this.set(t * a + i * n, i * a - t * n, r * a + s * n, s * a - r * n);
        }, calculateW: function() {
          var e = this.x, t = this.y, i = this.z;
          return this.w = -Math.sqrt(1 - e * e - t * t - i * i), this;
        }, setFromEuler: function(e, t) {
          var i = e.x / 2, r = e.y / 2, s = e.z / 2, n = Math.cos(i), a = Math.cos(r), o = Math.cos(
          s), h = Math.sin(i), l = Math.sin(r), f = Math.sin(s);
          switch (e.order) {
            case "XYZ": {
              this.set(h * a * o + n * l * f, n * l * o - h * a * f, n * a * f + h * l * o, n * a * o -
              h * l * f, t);
              break;
            }
            case "YXZ": {
              this.set(h * a * o + n * l * f, n * l * o - h * a * f, n * a * f - h * l * o, n * a * o +
              h * l * f, t);
              break;
            }
            case "ZXY": {
              this.set(h * a * o - n * l * f, n * l * o + h * a * f, n * a * f + h * l * o, n * a * o -
              h * l * f, t);
              break;
            }
            case "ZYX": {
              this.set(h * a * o - n * l * f, n * l * o + h * a * f, n * a * f - h * l * o, n * a * o +
              h * l * f, t);
              break;
            }
            case "YZX": {
              this.set(h * a * o + n * l * f, n * l * o + h * a * f, n * a * f - h * l * o, n * a * o -
              h * l * f, t);
              break;
            }
            case "XZY": {
              this.set(h * a * o - n * l * f, n * l * o - h * a * f, n * a * f + h * l * o, n * a * o +
              h * l * f, t);
              break;
            }
          }
          return this;
        }, setFromRotationMatrix: function(e) {
          var t = e.val, i = t[0], r = t[4], s = t[8], n = t[1], a = t[5], o = t[9], h = t[2], l = t[6],
          f = t[10], d = i + a + f, c;
          return d > 0 ? (c = 0.5 / Math.sqrt(d + 1), this.set((l - o) * c, (s - h) * c, (n - r) * c,
          0.25 / c)) : i > a && i > f ? (c = 2 * Math.sqrt(1 + i - a - f), this.set(0.25 * c, (r + n) /
          c, (s + h) / c, (l - o) / c)) : a > f ? (c = 2 * Math.sqrt(1 + a - i - f), this.set((r + n) /
          c, 0.25 * c, (o + l) / c, (s - h) / c)) : (c = 2 * Math.sqrt(1 + f - i - a), this.set((s +
          h) / c, (o + l) / c, 0.25 * c, (n - r) / c)), this;
        }, fromMat3: function(e) {
          var t = e.val, i = t[0] + t[4] + t[8], r;
          if (i > 0) r = Math.sqrt(i + 1), this.w = 0.5 * r, r = 0.5 / r, this._x = (t[7] - t[5]) * r,
          this._y = (t[2] - t[6]) * r, this._z = (t[3] - t[1]) * r;
          else {
            var s = 0;
            t[4] > t[0] && (s = 1), t[8] > t[s * 3 + s] && (s = 2);
            var n = cq[s], a = cq[n];
            r = Math.sqrt(t[s * 3 + s] - t[n * 3 + n] - t[a * 3 + a] + 1), Ms[s] = 0.5 * r, r = 0.5 /
            r, Ms[n] = (t[n * 3 + s] + t[s * 3 + n]) * r, Ms[a] = (t[a * 3 + s] + t[s * 3 + a]) * r,
            this._x = Ms[0], this._y = Ms[1], this._z = Ms[2], this._w = (t[a * 3 + n] - t[n * 3 + a]) *
            r;
          }
          return this.onChangeCallback(this), this;
        } });
        pq.exports = $te;
      });
      Eq = u((_Re, xq) => {
        var jte = As(), eie = _s(), tie = pf(), mq = new eie(), gq = new tie(), iie = new jte(), rie = function(e, t, i) {
          return gq.setAxisAngle(t, i), mq.fromRotationTranslation(gq, iie.set(0, 0, 0)), e.transformMat4(
          mq);
        };
        xq.exports = rie;
      });
      Ao = u((PRe, Tq) => {
        var sie = le(), nie = Xe(), mf = { Angle: mP(), Distance: PP(), Easing: qP(), Fuzzy: UP(), Interpolation: jP(),
        Pow2: aM(), Snap: fM(), RandomDataGenerator: cM(), Average: pM(), Bernstein: jl(), Between: ss(),
        CatmullRom: To(), CeilTo: gM(), Clamp: ne(), DegToRad: Rr(), Difference: EM(), Euler: CM(), Factorial: Jl(),
        FloatBetween: ws(), FloorTo: RM(), FromPercent: us(), GetSpeed: PM(), IsEven: qM(), IsEvenStrict: bM(),
        Linear: Eo(), LinearXY: OM(), MaxAdd: NM(), Median: BM(), MinSub: UM(), Percent: kM(), RadToDeg: df(),
        RandomXY: YM(), RandomXYZ: HM(), RandomXYZW: ZM(), Rotate: JM(), RotateAround: eo(), RotateAroundDistance: fo(),
        RotateTo: jM(), RoundAwayFromZero: Zu(), RoundTo: tq(), SinCosTableGenerator: rq(), SmootherStep: co(),
        SmoothStep: vo(), ToXY: nq(), TransformXY: ro(), Within: oq(), Wrap: Ki(), Vector2: Y(), Vector3: As(),
        Vector4: uq(), Matrix3: cf(), Matrix4: _s(), Quaternion: pf(), RotateVec3: Eq() };
        mf = nie(false, mf, sie);
        Tq.exports = mf;
      });
      kn = u((MRe, yq) => {
        var aie = { BITMAPMASK_PIPELINE: "BitmapMaskPipeline", LIGHT_PIPELINE: "Light2D", POINTLIGHT_PIPELINE: "\
PointLightPipeline", SINGLE_PIPELINE: "SinglePipeline", MULTI_PIPELINE: "MultiPipeline", ROPE_PIPELINE: "\
RopePipeline", GRAPHICS_PIPELINE: "GraphicsPipeline", POSTFX_PIPELINE: "PostFXPipeline", UTILITY_PIPELINE: "\
UtilityPipeline", MOBILE_PIPELINE: "MobilePipeline", FX_PIPELINE: "FxPipeline" };
        yq.exports = aie;
      });
      gf = u((qRe, Rq) => {
        var oie = C(), Ro = qt(), hie = Hl(), _o = En(), Sq = B(), R = H(), uie = lt(), wq = J(), Cq = Ao(),
        lie = kn(), Aq = Bl(), fie = new oie({ initialize: function(t) {
          t === void 0 && (t = {});
          var i = ["#ff0000", "#ffff00", "#00ff00", "#00ffff", "#000000"], r = "#ffffff", s = R(t, "\
scale", null);
          this.width = R(s, "width", 1024, t), this.height = R(s, "height", 768, t), this.zoom = R(s,
          "zoom", 1, t), this.parent = R(s, "parent", void 0, t), this.scaleMode = R(s, s ? "mode" :
          "scaleMode", 0, t), this.expandParent = R(s, "expandParent", true, t), this.autoRound = R(
          s, "autoRound", false, t), this.autoCenter = R(s, "autoCenter", 0, t), this.resizeInterval =
          R(s, "resizeInterval", 500, t), this.fullscreenTarget = R(s, "fullscreenTarget", null, t),
          this.minWidth = R(s, "min.width", 0, t), this.maxWidth = R(s, "max.width", 0, t), this.minHeight =
          R(s, "min.height", 0, t), this.maxHeight = R(s, "max.height", 0, t), this.snapWidth = R(s,
          "snap.width", 0, t), this.snapHeight = R(s, "snap.height", 0, t), this.renderType = R(t, "\
type", Ro.AUTO), this.canvas = R(t, "canvas", null), this.context = R(t, "context", null), this.canvasStyle =
          R(t, "canvasStyle", null), this.customEnvironment = R(t, "customEnvironment", false), this.
          sceneConfig = R(t, "scene", null), this.seed = R(t, "seed", [(Date.now() * Math.random()).
          toString()]), Cq.RND = new Cq.RandomDataGenerator(this.seed), this.gameTitle = R(t, "title",
          ""), this.gameURL = R(t, "url", "https://phaser.io/" + Ro.LOG_VERSION), this.gameVersion =
          R(t, "version", ""), this.autoFocus = R(t, "autoFocus", true), this.stableSort = R(t, "sta\
bleSort", -1), this.stableSort === -1 && (this.stableSort = _o.browser.es2019 ? 1 : 0), _o.features.
          stableSort = this.stableSort, this.domCreateContainer = R(t, "dom.createContainer", false),
          this.domPointerEvents = R(t, "dom.pointerEvents", "none"), this.inputKeyboard = R(t, "inpu\
t.keyboard", true), this.inputKeyboardEventTarget = R(t, "input.keyboard.target", window), this.inputKeyboardCapture =
          R(t, "input.keyboard.capture", []), this.inputMouse = R(t, "input.mouse", true), this.inputMouseEventTarget =
          R(t, "input.mouse.target", null), this.inputMousePreventDefaultDown = R(t, "input.mouse.pr\
eventDefaultDown", true), this.inputMousePreventDefaultUp = R(t, "input.mouse.preventDefaultUp", true),
          this.inputMousePreventDefaultMove = R(t, "input.mouse.preventDefaultMove", true), this.inputMousePreventDefaultWheel =
          R(t, "input.mouse.preventDefaultWheel", true), this.inputTouch = R(t, "input.touch", _o.input.
          touch), this.inputTouchEventTarget = R(t, "input.touch.target", null), this.inputTouchCapture =
          R(t, "input.touch.capture", true), this.inputActivePointers = R(t, "input.activePointers",
          1), this.inputSmoothFactor = R(t, "input.smoothFactor", 0), this.inputWindowEvents = R(t, "\
input.windowEvents", true), this.inputGamepad = R(t, "input.gamepad", false), this.inputGamepadEventTarget =
          R(t, "input.gamepad.target", window), this.disableContextMenu = R(t, "disableContextMenu",
          false), this.audio = R(t, "audio", {}), this.hideBanner = R(t, "banner", null) === false, this.
          hidePhaser = R(t, "banner.hidePhaser", false), this.bannerTextColor = R(t, "banner.text", r),
          this.bannerBackgroundColor = R(t, "banner.background", i), this.gameTitle === "" && this.hidePhaser &&
          (this.hideBanner = true), this.fps = R(t, "fps", null), this.disablePreFX = R(t, "disableP\
reFX", false), this.disablePostFX = R(t, "disablePostFX", false);
          var n = R(t, "render", null);
          this.pipeline = R(n, "pipeline", null, t), this.autoMobilePipeline = R(n, "autoMobilePipel\
ine", true, t), this.defaultPipeline = R(n, "defaultPipeline", lie.MULTI_PIPELINE, t), this.antialias =
          R(n, "antialias", true, t), this.antialiasGL = R(n, "antialiasGL", true, t), this.mipmapFilter =
          R(n, "mipmapFilter", "", t), this.desynchronized = R(n, "desynchronized", false, t), this.
          roundPixels = R(n, "roundPixels", false, t), this.pixelArt = R(n, "pixelArt", this.zoom !==
          1, t), this.pixelArt && (this.antialias = false, this.antialiasGL = false, this.roundPixels =
          true), this.transparent = R(n, "transparent", false, t), this.clearBeforeRender = R(n, "cl\
earBeforeRender", true, t), this.preserveDrawingBuffer = R(n, "preserveDrawingBuffer", false, t), this.
          premultipliedAlpha = R(n, "premultipliedAlpha", true, t), this.failIfMajorPerformanceCaveat =
          R(n, "failIfMajorPerformanceCaveat", false, t), this.powerPreference = R(n, "powerPreferen\
ce", "default", t), this.batchSize = R(n, "batchSize", 4096, t), this.maxTextures = R(n, "maxTexture\
s", -1, t), this.maxLights = R(n, "maxLights", 10, t);
          var a = R(t, "backgroundColor", 0);
          this.backgroundColor = Aq(a), this.transparent && (this.backgroundColor = Aq(0), this.backgroundColor.
          alpha = 0), this.preBoot = R(t, "callbacks.preBoot", wq), this.postBoot = R(t, "callbacks.\
postBoot", wq), this.physics = R(t, "physics", {}), this.defaultPhysicsSystem = R(this.physics, "def\
ault", false), this.loaderBaseURL = R(t, "loader.baseURL", ""), this.loaderPath = R(t, "loader.path",
          ""), this.loaderMaxParallelDownloads = R(t, "loader.maxParallelDownloads", _o.os.android ?
          6 : 32), this.loaderCrossOrigin = R(t, "loader.crossOrigin", void 0), this.loaderResponseType =
          R(t, "loader.responseType", ""), this.loaderAsync = R(t, "loader.async", true), this.loaderUser =
          R(t, "loader.user", ""), this.loaderPassword = R(t, "loader.password", ""), this.loaderTimeout =
          R(t, "loader.timeout", 0), this.loaderMaxRetries = R(t, "loader.maxRetries", 2), this.loaderWithCredentials =
          R(t, "loader.withCredentials", false), this.loaderImageLoadType = R(t, "loader.imageLoadTy\
pe", "XHR"), this.loaderLocalScheme = R(t, "loader.localScheme", ["file://", "capacitor://"]), this.
          glowFXQuality = R(t, "fx.glow.quality", 0.1), this.glowFXDistance = R(t, "fx.glow.distance",
          10), this.installGlobalPlugins = [], this.installScenePlugins = [];
          var o = R(t, "plugins", null), h = hie.DefaultScene;
          o && (Array.isArray(o) ? this.defaultPlugins = o : uie(o) && (this.installGlobalPlugins = Sq(
          o, "global", []), this.installScenePlugins = Sq(o, "scene", []), Array.isArray(o.default) ?
          h = o.default : Array.isArray(o.defaultMerge) && (h = h.concat(o.defaultMerge)))), this.defaultPlugins =
          h;
          var l = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAg";
          this.defaultImage = R(t, "images.default", l + "AQMAAABJtOi3AAAAA1BMVEX///+nxBvIAAAAAXRSTl\
MAQObYZgAAABVJREFUeF7NwIEAAAAAgKD9qdeocAMAoAABm3DkcAAAAABJRU5ErkJggg=="), this.missingImage = R(t, "\
images.missing", l + "CAIAAAD8GO2jAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJ9JREFUeNq01s\
sOwyAMRFG46v//Mt1ESmgh+DFmE2GPOBARKb2NVjo+17PXLD8a1+pl5+A+wSgFygymWYHBb0FtsKhJDdZlncG2IzJ4ayoMDv20wT\
mSMzClEgbWYNTAkQ0Z+OJ+A/eWnAaR9+oxCF4Os0H8htsMUp+pwcgBBiMNnAwF8GqIgL2hAzaGFFgZauDPKABmowZ4GL369/0rwA\
Cp2yA/ttmvsQAAAABJRU5ErkJggg=="), this.whiteImage = R(t, "images.white", "data:image/png;base64,iVBO\
Rw0KGgoAAAANSUhEUgAAAAQAAAAECAIAAAAmkwkpAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAABdJREFU\
eNpi/P//PwMMMDEgAdwcgAADAJZuAwXJYZOzAAAAAElFTkSuQmCC"), window && (window.FORCE_WEBGL ? this.renderType =
          Ro.WEBGL : window.FORCE_CANVAS && (this.renderType = Ro.CANVAS));
        } });
        Rq.exports = fie;
      });
      Pq = u((FRe, _q) => {
        var die = { setCrisp: function(e) {
          var t = ["optimizeSpeed", "-moz-crisp-edges", "-o-crisp-edges", "-webkit-optimize-contrast",
          "optimize-contrast", "crisp-edges", "pixelated"];
          return t.forEach(function(i) {
            e.style["image-rendering"] = i;
          }), e.style.msInterpolationMode = "nearest-neighbor", e;
        }, setBicubic: function(e) {
          return e.style["image-rendering"] = "auto", e.style.msInterpolationMode = "bicubic", e;
        } };
        _q.exports = die;
      });
      Ef = u((bRe, Mq) => {
        var xf = Tt(), cie = Ai(), $i = B(), vie = function(e, t) {
          var i = $i(t, "callback"), r = $i(t, "type", "image/png"), s = $i(t, "encoder", 0.92), n = Math.
          abs(Math.round($i(t, "x", 0))), a = Math.abs(Math.round($i(t, "y", 0))), o = Math.floor($i(
          t, "width", e.width)), h = Math.floor($i(t, "height", e.height)), l = $i(t, "getPixel", false);
          if (l) {
            var f = e.getContext("2d", { willReadFrequently: false }), d = f.getImageData(n, a, 1, 1),
            c = d.data;
            i.call(null, new cie(c[0], c[1], c[2], c[3]));
          } else if (n !== 0 || a !== 0 || o !== e.width || h !== e.height) {
            var p = xf.createWebGL(this, o, h), v = p.getContext("2d", { willReadFrequently: true });
            o > 0 && h > 0 && v.drawImage(e, n, a, o, h, 0, 0, o, h);
            var m = new Image();
            m.onerror = function() {
              i.call(null), xf.remove(p);
            }, m.onload = function() {
              i.call(null, m), xf.remove(p);
            }, m.src = p.toDataURL(r, s);
          } else {
            var g = new Image();
            g.onerror = function() {
              i.call(null);
            }, g.onload = function() {
              i.call(null, g);
            }, g.src = e.toDataURL(r, s);
          }
        };
        Mq.exports = vie;
      });
      Fq = u((LRe, qq) => {
        qq.exports = "losewebgl";
      });
      Lq = u((ORe, bq) => {
        bq.exports = "postrender";
      });
      Dq = u((DRe, Oq) => {
        Oq.exports = "prerender";
      });
      Iq = u((NRe, Nq) => {
        Nq.exports = "render";
      });
      Gq = u((IRe, Bq) => {
        Bq.exports = "resize";
      });
      zq = u((BRe, Uq) => {
        Uq.exports = "restorewebgl";
      });
      qs = u((GRe, kq) => {
        kq.exports = { LOSE_WEBGL: Fq(), POST_RENDER: Lq(), PRE_RENDER: Dq(), RENDER: Iq(), RESIZE: Gq(),
        RESTORE_WEBGL: zq() };
      });
      Vq = u((URe, Xq) => {
        var Q = Qt(), pie = el(), mie = function() {
          var e = [], t = pie.supportNewBlendModes, i = "source-over";
          return e[Q.NORMAL] = i, e[Q.ADD] = "lighter", e[Q.MULTIPLY] = t ? "multiply" : i, e[Q.SCREEN] =
          t ? "screen" : i, e[Q.OVERLAY] = t ? "overlay" : i, e[Q.DARKEN] = t ? "darken" : i, e[Q.LIGHTEN] =
          t ? "lighten" : i, e[Q.COLOR_DODGE] = t ? "color-dodge" : i, e[Q.COLOR_BURN] = t ? "color-\
burn" : i, e[Q.HARD_LIGHT] = t ? "hard-light" : i, e[Q.SOFT_LIGHT] = t ? "soft-light" : i, e[Q.DIFFERENCE] =
          t ? "difference" : i, e[Q.EXCLUSION] = t ? "exclusion" : i, e[Q.HUE] = t ? "hue" : i, e[Q.
          SATURATION] = t ? "saturation" : i, e[Q.COLOR] = t ? "color" : i, e[Q.LUMINOSITY] = t ? "l\
uminosity" : i, e[Q.ERASE] = "destination-out", e[Q.SOURCE_IN] = "source-in", e[Q.SOURCE_OUT] = "sou\
rce-out", e[Q.SOURCE_ATOP] = "source-atop", e[Q.DESTINATION_OVER] = "destination-over", e[Q.DESTINATION_IN] =
          "destination-in", e[Q.DESTINATION_OUT] = "destination-out", e[Q.DESTINATION_ATOP] = "desti\
nation-atop", e[Q.LIGHTER] = "lighter", e[Q.COPY] = "copy", e[Q.XOR] = "xor", e;
        };
        Xq.exports = mie;
      });
      Wq = u((zRe, Yq) => {
        Yq.exports = "addtexture";
      });
      Kq = u((kRe, Hq) => {
        Hq.exports = "addtexture-";
      });
      Qq = u((XRe, Zq) => {
        Zq.exports = "onerror";
      });
      $q = u((VRe, Jq) => {
        Jq.exports = "onload";
      });
      eF = u((YRe, jq) => {
        jq.exports = "ready";
      });
      iF = u((WRe, tF) => {
        tF.exports = "removetexture";
      });
      sF = u((HRe, rF) => {
        rF.exports = "removetexture-";
      });
      Fs = u((KRe, nF) => {
        nF.exports = { ADD: Wq(), ADD_KEY: Kq(), ERROR: Qq(), LOAD: $q(), READY: eF(), REMOVE: iF(),
        REMOVE_KEY: sF() };
      });
      uF = u((ZRe, hF) => {
        var Po = Dt(), aF = Ef(), gie = C(), xie = qt(), oF = Z(), Xn = qs(), Eie = Vq(), Tie = Ss(),
        yie = Fs(), Sie = Ye(), Tf = Lt(), wie = new gie({ Extends: oF, initialize: function(t) {
          oF.call(this);
          var i = t.config;
          this.config = { clearBeforeRender: i.clearBeforeRender, backgroundColor: i.backgroundColor,
          antialias: i.antialias, roundPixels: i.roundPixels, transparent: i.transparent }, this.game =
          t, this.type = xie.CANVAS, this.drawCount = 0, this.width = 0, this.height = 0, this.gameCanvas =
          t.canvas;
          var r = { alpha: i.transparent, desynchronized: i.desynchronized, willReadFrequently: false };
          this.gameContext = i.context ? i.context : this.gameCanvas.getContext("2d", r), this.currentContext =
          this.gameContext, this.antialias = i.antialias, this.blendModes = Eie(), this.snapshotState =
          { x: 0, y: 0, width: 1, height: 1, getPixel: false, callback: null, type: "image/png", encoder: 0.92 },
          this._tempMatrix1 = new Tf(), this._tempMatrix2 = new Tf(), this._tempMatrix3 = new Tf(), this.
          isBooted = false, this.init();
        }, init: function() {
          var e = this.game;
          e.events.once(Sie.BOOT, function() {
            var t = this.config;
            if (!t.transparent) {
              var i = this.gameContext, r = this.gameCanvas;
              i.fillStyle = t.backgroundColor.rgba, i.fillRect(0, 0, r.width, r.height);
            }
          }, this), e.textures.once(yie.READY, this.boot, this);
        }, boot: function() {
          var e = this.game, t = e.scale.baseSize;
          this.width = t.width, this.height = t.height, this.isBooted = true, e.scale.on(Tie.RESIZE,
          this.onResize, this), this.resize(t.width, t.height);
        }, onResize: function(e, t) {
          (t.width !== this.width || t.height !== this.height) && this.resize(t.width, t.height);
        }, resize: function(e, t) {
          this.width = e, this.height = t, this.emit(Xn.RESIZE, e, t);
        }, resetTransform: function() {
          this.currentContext.setTransform(1, 0, 0, 1, 0, 0);
        }, setBlendMode: function(e) {
          return this.currentContext.globalCompositeOperation = e, this;
        }, setContext: function(e) {
          return this.currentContext = e || this.gameContext, this;
        }, setAlpha: function(e) {
          return this.currentContext.globalAlpha = e, this;
        }, preRender: function() {
          var e = this.gameContext, t = this.config, i = this.width, r = this.height;
          e.globalAlpha = 1, e.globalCompositeOperation = "source-over", e.setTransform(1, 0, 0, 1, 0,
          0), this.emit(Xn.PRE_RENDER_CLEAR), t.clearBeforeRender && (e.clearRect(0, 0, i, r), t.transparent ||
          (e.fillStyle = t.backgroundColor.rgba, e.fillRect(0, 0, i, r))), e.save(), this.drawCount =
          0, this.emit(Xn.PRE_RENDER);
        }, render: function(e, t, i) {
          var r = t.length;
          this.emit(Xn.RENDER, e, i);
          var s = i.x, n = i.y, a = i.width, o = i.height, h = i.renderToTexture ? i.context : e.sys.
          context;
          h.save(), this.game.scene.customViewports && (h.beginPath(), h.rect(s, n, a, o), h.clip()),
          i.emit(Po.PRE_RENDER, i), this.currentContext = h;
          var l = i.mask;
          l && l.preRenderCanvas(this, null, i._maskCamera), i.transparent || (h.fillStyle = i.backgroundColor.
          rgba, h.fillRect(s, n, a, o)), h.globalAlpha = i.alpha, h.globalCompositeOperation = "sour\
ce-over", this.drawCount += r, i.renderToTexture && i.emit(Po.PRE_RENDER, i), i.matrix.copyToContext(
          h);
          for (var f = 0; f < r; f++) {
            var d = t[f];
            d.mask && d.mask.preRenderCanvas(this, d, i), d.renderCanvas(this, d, i), d.mask && d.mask.
            postRenderCanvas(this, d, i);
          }
          h.setTransform(1, 0, 0, 1, 0, 0), h.globalCompositeOperation = "source-over", h.globalAlpha =
          1, i.flashEffect.postRenderCanvas(h), i.fadeEffect.postRenderCanvas(h), i.dirty = false, l &&
          l.postRenderCanvas(this), h.restore(), i.renderToTexture && (i.emit(Po.POST_RENDER, i), i.
          renderToGame && e.sys.context.drawImage(i.canvas, s, n)), i.emit(Po.POST_RENDER, i);
        }, postRender: function() {
          var e = this.gameContext;
          e.restore(), this.emit(Xn.POST_RENDER);
          var t = this.snapshotState;
          t.callback && (aF(this.gameCanvas, t), t.callback = null);
        }, snapshotCanvas: function(e, t, i, r, s, n, a, o, h) {
          i === void 0 && (i = false), this.snapshotArea(r, s, n, a, t, o, h);
          var l = this.snapshotState;
          return l.getPixel = i, aF(e, l), l.callback = null, this;
        }, snapshot: function(e, t, i) {
          return this.snapshotArea(0, 0, this.gameCanvas.width, this.gameCanvas.height, e, t, i);
        }, snapshotArea: function(e, t, i, r, s, n, a) {
          var o = this.snapshotState;
          return o.callback = s, o.type = n, o.encoder = a, o.getPixel = false, o.x = e, o.y = t, o.
          width = Math.min(i, this.gameCanvas.width), o.height = Math.min(r, this.gameCanvas.height),
          this;
        }, snapshotPixel: function(e, t, i) {
          return this.snapshotArea(e, t, 1, 1, i), this.snapshotState.getPixel = true, this;
        }, batchSprite: function(e, t, i, r) {
          var s = i.alpha * e.alpha;
          if (s !== 0) {
            var n = this.currentContext, a = this._tempMatrix1, o = this._tempMatrix2, h = t.canvasData,
            l = h.x, f = h.y, d = t.cutWidth, c = t.cutHeight, p = t.customPivot, v = t.source.resolution,
            m = e.displayOriginX, g = e.displayOriginY, x = -m + t.x, E = -g + t.y;
            if (e.isCropped) {
              var T15 = e._crop;
              (T15.flipX !== e.flipX || T15.flipY !== e.flipY) && t.updateCropUVs(T15, e.flipX, e.flipY),
              d = T15.cw, c = T15.ch, l = T15.cx, f = T15.cy, x = -m + T15.x, E = -g + T15.y, e.flipX &&
              (x >= 0 ? x = -(x + d) : x < 0 && (x = Math.abs(x) - d)), e.flipY && (E >= 0 ? E = -(E +
              c) : E < 0 && (E = Math.abs(E) - c));
            }
            var w = 1, y = 1;
            e.flipX && (p || (x += -t.realWidth + m * 2), w = -1), e.flipY && (p || (E += -t.realHeight +
            g * 2), y = -1);
            var A10 = e.x, S14 = e.y;
            if (i.roundPixels && (A10 = Math.floor(A10), S14 = Math.floor(S14)), o.applyITRS(A10, S14,
            e.rotation, e.scaleX * w, e.scaleY * y), a.copyFrom(i.matrix), r ? (a.multiplyWithOffset(
            r, -i.scrollX * e.scrollFactorX, -i.scrollY * e.scrollFactorY), o.e = A10, o.f = S14) : (o.
            e -= i.scrollX * e.scrollFactorX, o.f -= i.scrollY * e.scrollFactorY), a.multiply(o), i.
            renderRoundPixels && (a.e = Math.floor(a.e + 0.5), a.f = Math.floor(a.f + 0.5)), n.save(),
            a.setToContext(n), n.globalCompositeOperation = this.blendModes[e.blendMode], n.globalAlpha =
            s, n.imageSmoothingEnabled = !t.source.scaleMode, e.mask && e.mask.preRenderCanvas(this,
            e, i), d > 0 && c > 0) {
              var _ = d / v, q = c / v;
              i.roundPixels && (x = Math.floor(x + 0.5), E = Math.floor(E + 0.5), _ += 0.5, q += 0.5),
              n.drawImage(t.source.image, l, f, d, c, x, E, _, q);
            }
            e.mask && e.mask.postRenderCanvas(this, e, i), n.restore();
          }
        }, destroy: function() {
          this.removeAllListeners(), this.game = null, this.gameCanvas = null, this.gameContext = null;
        } });
        hF.exports = wie;
      });
      qr = u((QRe, lF) => {
        var Cie = C(), Mo = qs(), Aie = new Cie({ initialize: function(t, i, r, s, n, a, o, h, l) {
          s === void 0 && (s = 1), n === void 0 && (n = 0), a === void 0 && (a = true), o === void 0 &&
          (o = false), h === void 0 && (h = true), l === void 0 && (l = true), this.renderer = t, this.
          framebuffer = null, this.texture = null, this.width = 0, this.height = 0, this.scale = s, this.
          minFilter = n, this.autoClear = a, this.autoResize = true, this.hasDepthBuffer = h, this.forceClamp =
          l, this.init(i, r), o ? this.renderer.on(Mo.RESIZE, this.resize, this) : this.autoResize =
          false;
        }, init: function(e, t) {
          var i = this.renderer;
          this.texture = i.createTextureFromSource(null, e, t, this.minFilter, this.forceClamp), this.
          framebuffer = i.createFramebuffer(e, t, this.texture, this.hasDepthBuffer), this.width = e,
          this.height = t;
        }, setAutoResize: function(e) {
          return e && !this.autoResize ? (this.renderer.on(Mo.RESIZE, this.resize, this), this.autoResize =
          true) : !e && this.autoResize && (this.renderer.off(Mo.RESIZE, this.resize, this), this.autoResize =
          false), this;
        }, resize: function(e, t) {
          if (this.autoResize && this.willResize(e, t)) {
            var i = this.renderer;
            i.deleteFramebuffer(this.framebuffer), i.deleteTexture(this.texture), this.texture = i.createTextureFromSource(
            null, e, t, this.minFilter, this.forceClamp), this.framebuffer = i.createFramebuffer(e, t,
            this.texture, this.hasDepthBuffer), this.width = e, this.height = t;
          }
          return this;
        }, willResize: function(e, t) {
          return typeof e != "number" || typeof t != "number" ? false : (e = Math.round(e * this.scale),
          t = Math.round(t * this.scale), e = Math.max(e, 1), t = Math.max(t, 1), e !== this.width ||
          t !== this.height);
        }, bind: function(e, t, i) {
          e === void 0 && (e = false);
          var r = this.renderer;
          if (e && r.flush(), t && i && this.resize(t, i), r.pushFramebuffer(this.framebuffer, false,
          false), e && this.adjustViewport(), this.autoClear) {
            var s = this.renderer.gl;
            s.clearColor(0, 0, 0, 0), s.clear(s.COLOR_BUFFER_BIT);
          }
          r.clearStencilMask();
        }, adjustViewport: function() {
          var e = this.renderer.gl;
          e.viewport(0, 0, this.width, this.height), e.disable(e.SCISSOR_TEST);
        }, clear: function(e, t, i, r) {
          var s = this.renderer, n = s.gl;
          s.pushFramebuffer(this.framebuffer), e !== void 0 && t !== void 0 && i !== void 0 && r !==
          void 0 ? (n.enable(n.SCISSOR_TEST), n.scissor(e, t, i, r)) : n.disable(n.SCISSOR_TEST), n.
          clearColor(0, 0, 0, 0), n.clear(n.COLOR_BUFFER_BIT), s.popFramebuffer(), s.resetScissor();
        }, unbind: function(e) {
          e === void 0 && (e = false);
          var t = this.renderer;
          return e && t.flush(), t.popFramebuffer();
        }, destroy: function() {
          var e = this.renderer;
          e.off(Mo.RESIZE, this.resize, this), e.deleteFramebuffer(this.framebuffer), e.deleteTexture(
          this.texture), this.renderer = null, this.framebuffer = null, this.texture = null;
        } });
        lF.exports = Aie;
      });
      yf = u((JRe, fF) => {
        fF.exports = ["#define SHADER_NAME PHASER_BITMAP_MASK_FS", "precision mediump float;", "unif\
orm vec2 uResolution;", "uniform sampler2D uMainSampler;", "uniform sampler2D uMaskSampler;", "unifo\
rm bool uInvertMaskAlpha;", "void main ()", "{", "    vec2 uv = gl_FragCoord.xy / uResolution;", "  \
  vec4 mainColor = texture2D(uMainSampler, uv);", "    vec4 maskColor = texture2D(uMaskSampler, uv);",
        "    if (!uInvertMaskAlpha)", "    {", "        mainColor *= maskColor.a;", "    }", "    el\
se", "    {", "        mainColor *= (1.0 - maskColor.a);", "    }", "    gl_FragColor = mainColor;",
        "}"].join(`
`);
      });
      Sf = u(($Re, dF) => {
        dF.exports = ["#define SHADER_NAME PHASER_BITMAP_MASK_VS", "precision mediump float;", "attr\
ibute vec2 inPosition;", "void main ()", "{", "    gl_Position = vec4(inPosition, 0.0, 1.0);", "}"].
        join(`
`);
      });
      bs = u((jRe, cF) => {
        var Rie = { BYTE: { enum: 5120, size: 1 }, UNSIGNED_BYTE: { enum: 5121, size: 1 }, SHORT: { enum: 5122,
        size: 2 }, UNSIGNED_SHORT: { enum: 5123, size: 2 }, INT: { enum: 5124, size: 4 }, UNSIGNED_INT: {
        enum: 5125, size: 4 }, FLOAT: { enum: 5126, size: 4 } };
        cF.exports = Rie;
      });
      pF = u((e_e, vF) => {
        vF.exports = "pipelineafterflush";
      });
      gF = u((t_e, mF) => {
        mF.exports = "pipelinebeforeflush";
      });
      EF = u((i_e, xF) => {
        xF.exports = "pipelinebind";
      });
      yF = u((r_e, TF) => {
        TF.exports = "pipelineboot";
      });
      wF = u((s_e, SF) => {
        SF.exports = "pipelinedestroy";
      });
      AF = u((n_e, CF) => {
        CF.exports = "pipelinerebind";
      });
      _F = u((a_e, RF) => {
        RF.exports = "pipelineresize";
      });
      wf = u((o_e, PF) => {
        PF.exports = { AFTER_FLUSH: pF(), BEFORE_FLUSH: gF(), BIND: EF(), BOOT: yF(), DESTROY: wF(),
        REBIND: AF(), RESIZE: _F() };
      });
      wt = u((h_e, MF) => {
        MF.exports = { getTintFromFloats: function(e, t, i, r) {
          var s = (e * 255 | 0) & 255, n = (t * 255 | 0) & 255, a = (i * 255 | 0) & 255, o = (r * 255 |
          0) & 255;
          return (o << 24 | s << 16 | n << 8 | a) >>> 0;
        }, getTintAppendFloatAlpha: function(e, t) {
          var i = (t * 255 | 0) & 255;
          return (i << 24 | e) >>> 0;
        }, getTintAppendFloatAlphaAndSwap: function(e, t) {
          var i = (e >> 16 | 0) & 255, r = (e >> 8 | 0) & 255, s = (e | 0) & 255, n = (t * 255 | 0) &
          255;
          return (n << 24 | s << 16 | r << 8 | i) >>> 0;
        }, getFloatsFromUintRGB: function(e) {
          var t = (e >> 16 | 0) & 255, i = (e >> 8 | 0) & 255, r = (e | 0) & 255;
          return [t / 255, i / 255, r / 255];
        }, checkShaderMax: function(e, t) {
          var i = Math.min(16, e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS));
          return !t || t === -1 ? i : Math.min(i, t);
        }, parseFragmentShaderMaxTextures: function(e, t) {
          if (!e) return "";
          for (var i = "", r = 0; r < t; r++) r > 0 && (i += `
	else `), r < t - 1 && (i += "if (outTexId < " + r + ".5)"), i += `
	{`, i += `
		texture = texture2D(uMainSampler[` + r + "], outTexCoord);", i += `
	}`;
          return e = e.replace(/%count%/gi, t.toString()), e.replace(/%forloop%/gi, i);
        }, setGlowQuality: function(e, t, i, r) {
          return i === void 0 && (i = t.config.glowFXQuality), r === void 0 && (r = t.config.glowFXDistance),
          e = e.replace(/__SIZE__/gi, (1 / i / r).toFixed(7)), e = e.replace(/__DIST__/gi, r.toFixed(
          0) + ".0"), e;
        } };
      });
      Cf = u((u_e, bF) => {
        var _ie = C(), qF = mn(), FF = B(), Pie = bs(), Mie = new _ie({ initialize: function(t, i, r, s, n) {
          this.pipeline = t, this.name = i, this.renderer = t.renderer, this.gl = this.renderer.gl, this.
          fragSrc = s, this.vertSrc = r, this.program = this.renderer.createProgram(r, s), this.attributes,
          this.vertexComponentCount = 0, this.vertexSize = 0, this.uniforms = {}, this.createAttributes(
          n), this.createUniforms();
        }, createAttributes: function(e) {
          var t = 0, i = 0, r = [];
          this.vertexComponentCount = 0;
          for (var s = 0; s < e.length; s++) {
            var n = e[s], a = n.name, o = FF(n, "size", 1), h = FF(n, "type", Pie.FLOAT), l = h.enum,
            f = h.size, d = !!n.normalized;
            r.push({ name: a, size: o, type: l, normalized: d, offset: i, enabled: false, location: -1 }),
            f === 4 ? t += o : t++, i += o * f;
          }
          this.vertexSize = i, this.vertexComponentCount = t, this.attributes = r;
        }, bind: function(e, t) {
          return e === void 0 && (e = false), t === void 0 && (t = false), t && this.pipeline.flush(),
          this.renderer.setProgram(this.program), e && this.setAttribPointers(), this;
        }, rebind: function() {
          return this.renderer.setProgram(this.program), this.setAttribPointers(true), this;
        }, setAttribPointers: function(e) {
          e === void 0 && (e = false);
          for (var t = this.gl, i = this.renderer, r = this.vertexSize, s = this.attributes, n = this.
          program, a = 0; a < s.length; a++) {
            var o = s[a], h = o.size, l = o.type, f = o.offset, d = o.enabled, c = o.location, p = !!o.
            normalized;
            if (e) {
              c !== -1 && i.deleteAttribLocation(c);
              var v = this.renderer.createAttribLocation(n, o.name);
              v.webGLAttribLocation >= 0 ? (t.enableVertexAttribArray(v.webGLAttribLocation), t.vertexAttribPointer(
              v.webGLAttribLocation, h, l, p, r, f), o.enabled = true, o.location = v) : v.webGLAttribLocation !==
              -1 && t.disableVertexAttribArray(v.webGLAttribLocation);
            } else d ? t.vertexAttribPointer(c.webGLAttribLocation, h, l, p, r, f) : !d && c !== -1 &&
            c.webGLAttribLocation > -1 && (t.disableVertexAttribArray(c.webGLAttribLocation), o.location =
            -1);
          }
          return this;
        }, createUniforms: function() {
          var e = this.gl, t = this.program, i = this.uniforms, r, s, n, a = e.getProgramParameter(t.
          webGLProgram, e.ACTIVE_UNIFORMS);
          for (r = 0; r < a; r++) {
            var o = e.getActiveUniform(t.webGLProgram, r);
            if (o) {
              s = o.name, n = this.renderer.createUniformLocation(t, s), n !== null && (i[s] = { name: s,
              location: n, setter: null, value1: null, value2: null, value3: null, value4: null });
              var h = s.indexOf("[");
              h > 0 && (s = s.substr(0, h), i.hasOwnProperty(s) || (n = this.renderer.createUniformLocation(
              t, s), n !== null && (i[s] = { name: s, location: n, setter: null, value1: null, value2: null,
              value3: null, value4: null })));
            }
          }
          return this;
        }, syncUniforms: function() {
          var e = this.gl;
          this.renderer.setProgram(this.program);
          for (var t in this.uniforms) {
            var i = this.uniforms[t];
            i.setter && i.setter.call(e, i.location.webGLUniformLocation, i.value1, i.value2, i.value3,
            i.value4);
          }
        }, hasUniform: function(e) {
          return this.uniforms.hasOwnProperty(e);
        }, resetUniform: function(e) {
          var t = this.uniforms[e];
          return t && (t.value1 = null, t.value2 = null, t.value3 = null, t.value4 = null), this;
        }, setUniform1: function(e, t, i, r) {
          var s = this.uniforms[t];
          return s ? ((r || s.value1 !== i) && (s.setter || (s.setter = e), s.value1 = i, this.renderer.
          setProgram(this.program), e.call(this.gl, s.location.webGLUniformLocation, i), this.pipeline.
          currentShader = this), this) : this;
        }, setUniform2: function(e, t, i, r, s) {
          var n = this.uniforms[t];
          return n ? ((s || n.value1 !== i || n.value2 !== r) && (n.setter || (n.setter = e), n.value1 =
          i, n.value2 = r, this.renderer.setProgram(this.program), e.call(this.gl, n.location.webGLUniformLocation,
          i, r), this.pipeline.currentShader = this), this) : this;
        }, setUniform3: function(e, t, i, r, s, n) {
          var a = this.uniforms[t];
          return a ? ((n || a.value1 !== i || a.value2 !== r || a.value3 !== s) && (a.setter || (a.setter =
          e), a.value1 = i, a.value2 = r, a.value3 = s, this.renderer.setProgram(this.program), e.call(
          this.gl, a.location.webGLUniformLocation, i, r, s), this.pipeline.currentShader = this), this) :
          this;
        }, setUniform4: function(e, t, i, r, s, n, a) {
          var o = this.uniforms[t];
          return o ? ((a || o.value1 !== i || o.value2 !== r || o.value3 !== s || o.value4 !== n) &&
          (o.setter || (o.setter = e), o.value1 = i, o.value2 = r, o.value3 = s, o.value4 = n, this.
          renderer.setProgram(this.program), e.call(this.gl, o.location.webGLUniformLocation, i, r, s,
          n), this.pipeline.currentShader = this), this) : this;
        }, setBoolean: function(e, t) {
          return this.setUniform1(this.gl.uniform1i, e, Number(t));
        }, set1f: function(e, t) {
          return this.setUniform1(this.gl.uniform1f, e, t);
        }, set2f: function(e, t, i) {
          return this.setUniform2(this.gl.uniform2f, e, t, i);
        }, set3f: function(e, t, i, r) {
          return this.setUniform3(this.gl.uniform3f, e, t, i, r);
        }, set4f: function(e, t, i, r, s) {
          return this.setUniform4(this.gl.uniform4f, e, t, i, r, s);
        }, set1fv: function(e, t) {
          return this.setUniform1(this.gl.uniform1fv, e, t, true);
        }, set2fv: function(e, t) {
          return this.setUniform1(this.gl.uniform2fv, e, t, true);
        }, set3fv: function(e, t) {
          return this.setUniform1(this.gl.uniform3fv, e, t, true);
        }, set4fv: function(e, t) {
          return this.setUniform1(this.gl.uniform4fv, e, t, true);
        }, set1iv: function(e, t) {
          return this.setUniform1(this.gl.uniform1iv, e, t, true);
        }, set2iv: function(e, t) {
          return this.setUniform1(this.gl.uniform2iv, e, t, true);
        }, set3iv: function(e, t) {
          return this.setUniform1(this.gl.uniform3iv, e, t, true);
        }, set4iv: function(e, t) {
          return this.setUniform1(this.gl.uniform4iv, e, t, true);
        }, set1i: function(e, t) {
          return this.setUniform1(this.gl.uniform1i, e, t);
        }, set2i: function(e, t, i) {
          return this.setUniform2(this.gl.uniform2i, e, t, i);
        }, set3i: function(e, t, i, r) {
          return this.setUniform3(this.gl.uniform3i, e, t, i, r);
        }, set4i: function(e, t, i, r, s) {
          return this.setUniform4(this.gl.uniform4i, e, t, i, r, s);
        }, setMatrix2fv: function(e, t, i) {
          return this.setUniform2(this.gl.uniformMatrix2fv, e, t, i, true);
        }, setMatrix3fv: function(e, t, i) {
          return this.setUniform2(this.gl.uniformMatrix3fv, e, t, i, true);
        }, setMatrix4fv: function(e, t, i) {
          return this.setUniform2(this.gl.uniformMatrix4fv, e, t, i, true);
        }, createProgram: function(e, t) {
          return e === void 0 && (e = this.vertSrc), t === void 0 && (t = this.fragSrc), this.program &&
          this.renderer.deleteProgram(this.program), this.vertSrc = e, this.fragSrc = t, this.program =
          this.renderer.createProgram(e, t), this.createUniforms(), this.rebind();
        }, destroy: function() {
          var e = this.renderer;
          qF(this.uniforms, function(t) {
            e.deleteUniformLocation(t.location);
          }), this.uniforms = null, qF(this.attributes, function(t) {
            e.deleteAttribLocation(t.location);
          }), this.attributes = null, e.deleteProgram(this.program), this.pipeline = null, this.renderer =
          null, this.gl = null, this.program = null;
        } });
        bF.exports = Mie;
      });
      Vt = u((l_e, NF) => {
        var qie = C(), LF = An(), OF = Z(), Fr = wf(), ce = B(), Fie = _s(), ji = qs(), Af = qr(), qo = wt(),
        DF = Cf(), bie = new qie({ Extends: OF, initialize: function(t) {
          OF.call(this);
          var i = t.game, r = i.renderer, s = r.gl;
          this.name = ce(t, "name", "WebGLPipeline"), this.game = i, this.renderer = r, this.manager,
          this.gl = s, this.view = i.canvas, this.width = 0, this.height = 0, this.vertexCount = 0, this.
          vertexCapacity = 0, this.vertexData, this.vertexBuffer, this.activeBuffer, this.topology =
          ce(t, "topology", s.TRIANGLES), this.bytes, this.vertexViewF32, this.vertexViewU32, this.active =
          true, this.forceZero = ce(t, "forceZero", false), this.hasBooted = false, this.isPostFX = false,
          this.isPreFX = false, this.renderTargets = [], this.currentRenderTarget, this.shaders = [],
          this.currentShader, this.projectionMatrix, this.projectionWidth = 0, this.projectionHeight =
          0, this.config = t, this.glReset = false, this.batch = [], this.currentBatch = null, this.
          currentTexture = null, this.currentUnit = 0, this.activeTextures = [], this.resizeUniform =
          ce(t, "resizeUniform", "");
        }, boot: function() {
          var e, t = this.gl, i = this.config, r = this.renderer;
          this.isPostFX || (this.projectionMatrix = new Fie().identity());
          var s = this.renderTargets, n = ce(i, "renderTarget", false);
          typeof n == "boolean" && n && (n = 1);
          var a = r.width, o = r.height;
          if (typeof n == "number") for (e = 0; e < n; e++) s.push(new Af(r, a, o, 1, 0, true));
          else if (Array.isArray(n)) for (e = 0; e < n.length; e++) {
            var h = ce(n[e], "scale", 1), l = ce(n[e], "minFilter", 0), f = ce(n[e], "autoClear", 1),
            d = ce(n[e], "autoResize", false), c = ce(n[e], "width", null), p = ce(n[e], "height", c);
            c ? s.push(new Af(r, c, p, 1, l, f, d)) : s.push(new Af(r, a, o, h, l, f, d));
          }
          s.length && (this.currentRenderTarget = s[0]), this.setShadersFromConfig(i);
          var v = this.shaders, m = 0;
          for (e = 0; e < v.length; e++) v[e].vertexSize > m && (m = v[e].vertexSize);
          var g = ce(i, "batchSize", r.config.batchSize);
          this.vertexCapacity = g * 6;
          var x = new ArrayBuffer(this.vertexCapacity * m);
          this.vertexData = x, this.bytes = new Uint8Array(x), this.vertexViewF32 = new Float32Array(
          x), this.vertexViewU32 = new Uint32Array(x);
          var E = ce(i, "vertices", null);
          for (E ? (this.vertexViewF32.set(E), this.vertexBuffer = r.createVertexBuffer(x, t.STATIC_DRAW)) :
          this.vertexBuffer = r.createVertexBuffer(x.byteLength, t.DYNAMIC_DRAW), this.setVertexBuffer(),
          e = v.length - 1; e >= 0; e--) v[e].rebind();
          this.hasBooted = true, r.on(ji.RESIZE, this.resize, this), r.on(ji.PRE_RENDER, this.onPreRender,
          this), r.on(ji.RENDER, this.onRender, this), r.on(ji.POST_RENDER, this.onPostRender, this),
          this.emit(Fr.BOOT, this), this.onBoot();
        }, onBoot: function() {
        }, onResize: function() {
        }, setShader: function(e, t, i) {
          var r = this.renderer;
          if (e !== this.currentShader || r.currentProgram !== this.currentShader.program) {
            this.flush();
            var s = this.setVertexBuffer(i);
            s && !t && (t = true), e.bind(t, false), this.currentShader = e;
          }
          return this;
        }, getShaderByName: function(e) {
          for (var t = this.shaders, i = 0; i < t.length; i++) if (t[i].name === e) return t[i];
        }, setShadersFromConfig: function(e) {
          var t, i = this.shaders, r = this.renderer;
          for (t = 0; t < i.length; t++) i[t].destroy();
          var s = "vertShader", n = "fragShader", a = "attributes", o = ce(e, s, null), h = qo.parseFragmentShaderMaxTextures(
          ce(e, n, null), r.maxTextures), l = ce(e, a, null), f = ce(e, "shaders", []), d = f.length;
          if (d === 0) o && h && (this.shaders = [new DF(this, "default", o, h, LF(l))]);
          else {
            var c = [];
            for (t = 0; t < d; t++) {
              var p = f[t], v, m, g, x;
              if (typeof p == "string" ? (v = "default", m = o, g = qo.parseFragmentShaderMaxTextures(
              p, r.maxTextures), x = l) : (v = ce(p, "name", "default"), m = ce(p, s, o), g = qo.parseFragmentShaderMaxTextures(
              ce(p, n, h), r.maxTextures), x = ce(p, a, l)), v === "default") {
                var E = g.split(`
`), T15 = E[0].trim();
                T15.indexOf("#define SHADER_NAME") > -1 && (v = T15.substring(20));
              }
              m && g && c.push(new DF(this, v, m, g, LF(x)));
            }
            this.shaders = c;
          }
          return this.shaders.length === 0 ? console.warn("Pipeline: " + this.name + " - Invalid sha\
der config") : this.currentShader = this.shaders[0], this;
        }, createBatch: function(e) {
          return this.currentBatch = { start: this.vertexCount, count: 0, texture: [e], unit: 0, maxUnit: 0 },
          this.currentUnit = 0, this.currentTexture = e, this.batch.push(this.currentBatch), 0;
        }, addTextureToBatch: function(e) {
          var t = this.currentBatch;
          t && (t.texture.push(e), t.unit++, t.maxUnit++);
        }, pushBatch: function(e) {
          if (!this.currentBatch || this.forceZero && e !== this.currentTexture) return this.createBatch(
          e);
          if (e === this.currentTexture) return this.currentUnit;
          var t = this.currentBatch, i = t.texture.indexOf(e);
          return i === -1 ? t.texture.length === this.renderer.maxTextures ? this.createBatch(e) : (t.
          unit++, t.maxUnit++, t.texture.push(e), this.currentUnit = t.unit, this.currentTexture = e,
          t.unit) : (this.currentUnit = i, this.currentTexture = e, i);
        }, setGameObject: function(e, t) {
          return t === void 0 && (t = e.frame), this.pushBatch(t.source.glTexture);
        }, shouldFlush: function(e) {
          return e === void 0 && (e = 0), this.vertexCount + e > this.vertexCapacity;
        }, vertexAvailable: function() {
          return this.vertexCapacity - this.vertexCount;
        }, resize: function(e, t) {
          (e !== this.width || t !== this.height) && this.flush(), this.width = e, this.height = t;
          for (var i = this.renderTargets, r = 0; r < i.length; r++) i[r].resize(e, t);
          return this.setProjectionMatrix(e, t), this.resizeUniform && this.set2f(this.resizeUniform,
          e, t), this.emit(Fr.RESIZE, e, t, this), this.onResize(e, t), this;
        }, setProjectionMatrix: function(e, t) {
          var i = this.projectionMatrix;
          if (!i) return this;
          this.projectionWidth = e, this.projectionHeight = t, i.ortho(0, e, t, 0, -1e3, 1e3);
          for (var r = this.shaders, s = "uProjectionMatrix", n = 0; n < r.length; n++) {
            var a = r[n];
            a.hasUniform(s) && (a.resetUniform(s), a.setMatrix4fv(s, false, i.val, a));
          }
          return this;
        }, flipProjectionMatrix: function(e) {
          e === void 0 && (e = true);
          var t = this.projectionMatrix;
          if (!t) return this;
          var i = this.projectionWidth, r = this.projectionHeight;
          e ? t.ortho(0, i, 0, r, -1e3, 1e3) : t.ortho(0, i, r, 0, -1e3, 1e3), this.setMatrix4fv("uP\
rojectionMatrix", false, t.val);
        }, updateProjectionMatrix: function() {
          if (this.projectionMatrix) {
            var e = this.renderer.projectionWidth, t = this.renderer.projectionHeight;
            (this.projectionWidth !== e || this.projectionHeight !== t) && this.setProjectionMatrix(
            e, t);
          }
        }, bind: function(e) {
          if (e === void 0 && (e = this.currentShader), this.glReset) return this.rebind(e);
          var t = false, i = this.gl;
          return i.getParameter(i.ARRAY_BUFFER_BINDING) !== this.vertexBuffer && (i.bindBuffer(i.ARRAY_BUFFER,
          this.vertexBuffer.webGLBuffer), this.activeBuffer = this.vertexBuffer, t = true), e.bind(t),
          this.currentShader = e, this.activeTextures.length = 0, this.emit(Fr.BIND, this, e), this.
          onActive(e), this;
        }, rebind: function(e) {
          this.activeBuffer = null, this.setVertexBuffer();
          for (var t = this.shaders, i = t.length - 1; i >= 0; i--) {
            var r = t[i].rebind();
            (!e || r === e) && (this.currentShader = r);
          }
          return this.activeTextures.length = 0, this.emit(Fr.REBIND, this.currentShader), this.onActive(
          this.currentShader), this.onRebind(), this.glReset = false, this;
        }, restoreContext: function() {
          var e = this.shaders, t = !!this.vertexBuffer;
          this.activeBuffer = null, this.activeTextures.length = 0, this.batch.length = 0, this.currentBatch =
          null, this.currentTexture = null, this.currentUnit = 0, t && this.setVertexBuffer();
          for (var i = 0; i < e.length; i++) {
            var r = e[i];
            r.syncUniforms(), t && r.rebind();
          }
        }, setVertexBuffer: function(e) {
          if (e === void 0 && (e = this.vertexBuffer), e !== this.activeBuffer) {
            var t = this.gl;
            return this.gl.bindBuffer(t.ARRAY_BUFFER, e.webGLBuffer), this.activeBuffer = e, true;
          }
          return false;
        }, preBatch: function(e) {
          return this.currentRenderTarget && this.currentRenderTarget.bind(), this.onPreBatch(e), this;
        }, postBatch: function(e) {
          return this.onDraw(this.currentRenderTarget), this.onPostBatch(e), this;
        }, onDraw: function() {
        }, unbind: function() {
          this.currentRenderTarget && this.currentRenderTarget.unbind();
        }, flush: function(e) {
          if (e === void 0 && (e = false), this.vertexCount > 0) {
            this.emit(Fr.BEFORE_FLUSH, this, e), this.onBeforeFlush(e);
            var t = this.gl, i = this.vertexCount, r = this.currentShader.vertexSize, s = this.topology;
            if (this.active) {
              this.setVertexBuffer(), i === this.vertexCapacity ? t.bufferData(t.ARRAY_BUFFER, this.
              vertexData, t.DYNAMIC_DRAW) : t.bufferSubData(t.ARRAY_BUFFER, 0, this.bytes.subarray(0,
              i * r));
              var n, a, o, h = this.batch, l = this.activeTextures;
              if (this.forceZero) for (l[0] || t.activeTexture(t.TEXTURE0), n = 0; n < h.length; n++)
               a = h[n], o = a.texture[0], l[0] !== o && (t.bindTexture(t.TEXTURE_2D, o.webGLTexture),
              l[0] = o), t.drawArrays(s, a.start, a.count);
              else for (n = 0; n < h.length; n++) {
                a = h[n];
                for (var f = 0; f <= a.maxUnit; f++) o = a.texture[f], l[f] !== o && (t.activeTexture(
                t.TEXTURE0 + f), t.bindTexture(t.TEXTURE_2D, o.webGLTexture), l[f] = o);
                t.drawArrays(s, a.start, a.count);
              }
            }
            this.vertexCount = 0, this.batch.length = 0, this.currentBatch = null, this.currentTexture =
            null, this.currentUnit = 0, this.emit(Fr.AFTER_FLUSH, this, e), this.onAfterFlush(e);
          }
          return this;
        }, onActive: function() {
        }, onBind: function() {
        }, onRebind: function() {
        }, onBatch: function() {
        }, onPreBatch: function() {
        }, onPostBatch: function() {
        }, onPreRender: function() {
        }, onRender: function() {
        }, onPostRender: function() {
        }, onBeforeFlush: function() {
        }, onAfterFlush: function() {
        }, batchVert: function(e, t, i, r, s, n, a) {
          var o = this.vertexViewF32, h = this.vertexViewU32, l = this.vertexCount * this.currentShader.
          vertexComponentCount - 1;
          o[++l] = e, o[++l] = t, o[++l] = i, o[++l] = r, o[++l] = s, o[++l] = n, h[++l] = a, this.vertexCount++,
          this.currentBatch.count = this.vertexCount - this.currentBatch.start;
        }, batchQuad: function(e, t, i, r, s, n, a, o, h, l, f, d, c, p, v, m, g, x, E, T15) {
          T15 === void 0 && (T15 = this.currentUnit);
          var w = false;
          this.shouldFlush(6) && (this.flush(), w = true), this.currentBatch || (T15 = this.setTexture2D(
          E));
          var y = this.vertexViewF32, A10 = this.vertexViewU32, S14 = this.vertexCount * this.currentShader.
          vertexComponentCount - 1;
          return y[++S14] = t, y[++S14] = i, y[++S14] = l, y[++S14] = f, y[++S14] = T15, y[++S14] = x,
          A10[++S14] = p, y[++S14] = r, y[++S14] = s, y[++S14] = l, y[++S14] = c, y[++S14] = T15, y[++S14] =
          x, A10[++S14] = m, y[++S14] = n, y[++S14] = a, y[++S14] = d, y[++S14] = c, y[++S14] = T15,
          y[++S14] = x, A10[++S14] = g, y[++S14] = t, y[++S14] = i, y[++S14] = l, y[++S14] = f, y[++S14] =
          T15, y[++S14] = x, A10[++S14] = p, y[++S14] = n, y[++S14] = a, y[++S14] = d, y[++S14] = c,
          y[++S14] = T15, y[++S14] = x, A10[++S14] = g, y[++S14] = o, y[++S14] = h, y[++S14] = d, y[++S14] =
          f, y[++S14] = T15, y[++S14] = x, A10[++S14] = v, this.vertexCount += 6, this.currentBatch.
          count = this.vertexCount - this.currentBatch.start, this.onBatch(e), w;
        }, batchTri: function(e, t, i, r, s, n, a, o, h, l, f, d, c, p, v, m, g) {
          g === void 0 && (g = this.currentUnit);
          var x = false;
          this.shouldFlush(3) && (this.flush(), x = true), this.currentBatch || (g = this.setTexture2D(
          m));
          var E = this.vertexViewF32, T15 = this.vertexViewU32, w = this.vertexCount * this.currentShader.
          vertexComponentCount - 1;
          return E[++w] = t, E[++w] = i, E[++w] = o, E[++w] = h, E[++w] = g, E[++w] = v, T15[++w] = d,
          E[++w] = r, E[++w] = s, E[++w] = o, E[++w] = f, E[++w] = g, E[++w] = v, T15[++w] = c, E[++w] =
          n, E[++w] = a, E[++w] = l, E[++w] = f, E[++w] = g, E[++w] = v, T15[++w] = p, this.vertexCount +=
          3, this.currentBatch.count = this.vertexCount - this.currentBatch.start, this.onBatch(e), x;
        }, drawFillRect: function(e, t, i, r, s, n, a, o) {
          a === void 0 && (a = this.renderer.whiteTexture), o === void 0 && (o = true), e = Math.floor(
          e), t = Math.floor(t);
          var h = Math.floor(e + i), l = Math.floor(t + r), f = this.setTexture2D(a), d = qo.getTintAppendFloatAlphaAndSwap(
          s, n), c = 0, p = 0, v = 1, m = 1;
          o && (p = 1, m = 0), this.batchQuad(null, e, t, e, l, h, l, h, t, c, p, v, m, d, d, d, d, 0,
          a, f);
        }, setTexture2D: function(e) {
          return e === void 0 && (e = this.renderer.whiteTexture), this.pushBatch(e);
        }, bindTexture: function(e, t) {
          t === void 0 && (t = 0);
          var i = this.gl;
          return i.activeTexture(i.TEXTURE0 + t), i.bindTexture(i.TEXTURE_2D, e.webGLTexture), this;
        }, bindRenderTarget: function(e, t) {
          return this.bindTexture(e.texture, t);
        }, setTime: function(e, t) {
          return this.set1f(e, this.game.loop.getDuration(), t), this;
        }, setBoolean: function(e, t, i) {
          return i === void 0 && (i = this.currentShader), i.setBoolean(e, t), this;
        }, set1f: function(e, t, i) {
          return i === void 0 && (i = this.currentShader), i.set1f(e, t), this;
        }, set2f: function(e, t, i, r) {
          return r === void 0 && (r = this.currentShader), r.set2f(e, t, i), this;
        }, set3f: function(e, t, i, r, s) {
          return s === void 0 && (s = this.currentShader), s.set3f(e, t, i, r), this;
        }, set4f: function(e, t, i, r, s, n) {
          return n === void 0 && (n = this.currentShader), n.set4f(e, t, i, r, s), this;
        }, set1fv: function(e, t, i) {
          return i === void 0 && (i = this.currentShader), i.set1fv(e, t), this;
        }, set2fv: function(e, t, i) {
          return i === void 0 && (i = this.currentShader), i.set2fv(e, t), this;
        }, set3fv: function(e, t, i) {
          return i === void 0 && (i = this.currentShader), i.set3fv(e, t), this;
        }, set4fv: function(e, t, i) {
          return i === void 0 && (i = this.currentShader), i.set4fv(e, t), this;
        }, set1iv: function(e, t, i) {
          return i === void 0 && (i = this.currentShader), i.set1iv(e, t), this;
        }, set2iv: function(e, t, i) {
          return i === void 0 && (i = this.currentShader), i.set2iv(e, t), this;
        }, set3iv: function(e, t, i) {
          return i === void 0 && (i = this.currentShader), i.set3iv(e, t), this;
        }, set4iv: function(e, t, i) {
          return i === void 0 && (i = this.currentShader), i.set4iv(e, t), this;
        }, set1i: function(e, t, i) {
          return i === void 0 && (i = this.currentShader), i.set1i(e, t), this;
        }, set2i: function(e, t, i, r) {
          return r === void 0 && (r = this.currentShader), r.set2i(e, t, i), this;
        }, set3i: function(e, t, i, r, s) {
          return s === void 0 && (s = this.currentShader), s.set3i(e, t, i, r), this;
        }, set4i: function(e, t, i, r, s, n) {
          return n === void 0 && (n = this.currentShader), n.set4i(e, t, i, r, s), this;
        }, setMatrix2fv: function(e, t, i, r) {
          return r === void 0 && (r = this.currentShader), r.setMatrix2fv(e, t, i), this;
        }, setMatrix3fv: function(e, t, i, r) {
          return r === void 0 && (r = this.currentShader), r.setMatrix3fv(e, t, i), this;
        }, setMatrix4fv: function(e, t, i, r) {
          return r === void 0 && (r = this.currentShader), r.setMatrix4fv(e, t, i), this;
        }, destroy: function() {
          this.emit(Fr.DESTROY, this);
          var e, t = this.shaders;
          for (e = 0; e < t.length; e++) t[e].destroy();
          var i = this.renderTargets;
          for (e = 0; e < i.length; e++) i[e].destroy();
          var r = this.renderer;
          return r.deleteBuffer(this.vertexBuffer), r.off(ji.RESIZE, this.resize, this), r.off(ji.PRE_RENDER,
          this.onPreRender, this), r.off(ji.RENDER, this.onRender, this), r.off(ji.POST_RENDER, this.
          onPostRender, this), this.removeAllListeners(), this.game = null, this.renderer = null, this.
          manager = null, this.gl = null, this.view = null, this.shaders = null, this.renderTargets =
          null, this.bytes = null, this.vertexViewF32 = null, this.vertexViewU32 = null, this.vertexData =
          null, this.vertexBuffer = null, this.currentShader = null, this.currentRenderTarget = null,
          this.activeTextures = null, this;
        } });
        NF.exports = bie;
      });
      Rf = u((f_e, IF) => {
        var Lie = C(), Vn = B(), Oie = yf(), Die = Sf(), Nie = bs(), Fo = Vt(), Iie = new Lie({ Extends: Fo,
        initialize: function(t) {
          t.fragShader = Vn(t, "fragShader", Oie), t.vertShader = Vn(t, "vertShader", Die), t.batchSize =
          Vn(t, "batchSize", 1), t.vertices = Vn(t, "vertices", [-1, 1, -1, -7, 7, 1]), t.attributes =
          Vn(t, "attributes", [{ name: "inPosition", size: 2, type: Nie.FLOAT }]), Fo.call(this, t);
        }, boot: function() {
          Fo.prototype.boot.call(this), this.set1i("uMainSampler", 0), this.set1i("uMaskSampler", 1);
        }, resize: function(e, t) {
          Fo.prototype.resize.call(this, e, t), this.set2f("uResolution", e, t);
        }, beginMask: function(e, t, i) {
          this.renderer.beginBitmapMask(e, i);
        }, endMask: function(e, t, i) {
          var r = this.gl, s = this.renderer, n = e.bitmapMask;
          n && r && (s.drawBitmapMask(n, t, this), i && this.set2f("uResolution", i.width, i.height),
          this.set1i("uInvertMaskAlpha", e.invertAlpha), r.drawArrays(this.topology, 0, 3), i && this.
          set2f("uResolution", this.width, this.height), r.bindTexture(r.TEXTURE_2D, null));
        } });
        IF.exports = Iie;
      });
      _f = u((d_e, BF) => {
        BF.exports = ["#define SHADER_NAME BARREL_FS", "precision mediump float;", "uniform sampler2\
D uMainSampler;", "uniform float amount;", "varying vec2 outTexCoord;", "vec2 Distort(vec2 p)", "{",
        "    float theta  = atan(p.y, p.x);", "    float radius = length(p);", "    radius = pow(rad\
ius, amount);", "    p.x = radius * cos(theta);", "    p.y = radius * sin(theta);", "    return 0.5 \
* (p + 1.0);", "}", "void main()", "{", "    vec2 xy = 2.0 * outTexCoord - 1.0;", "    vec2 texCoord\
 = outTexCoord;", "    if (length(xy) < 1.0)", "    {", "        texCoord = Distort(xy);", "    }", "\
    gl_FragColor = texture2D(uMainSampler, texCoord);", "}"].join(`
`);
      });
      bo = u((c_e, GF) => {
        GF.exports = ["#define SHADER_NAME PHASER_POSTFX_FS", "precision mediump float;", "uniform s\
ampler2D uMainSampler;", "varying vec2 outTexCoord;", "void main ()", "{", "    gl_FragColor = textu\
re2D(uMainSampler, outTexCoord);", "}"].join(`
`);
      });
      Lo = u((v_e, UF) => {
        UF.exports = ["#define SHADER_NAME PHASER_QUAD_VS", "precision mediump float;", "attribute v\
ec2 inPosition;", "attribute vec2 inTexCoord;", "varying vec2 outFragCoord;", "varying vec2 outTexCo\
ord;", "void main ()", "{", "    outFragCoord = inPosition.xy * 0.5 + 0.5;", "    outTexCoord = inTe\
xCoord;", "    gl_Position = vec4(inPosition, 0, 1);", "}"].join(`
`);
      });
      Ke = u((p_e, zF) => {
        var Bie = C(), Gie = Ha(), Oo = B(), Uie = bo(), zie = Lo(), Do = Vt(), kie = new Bie({ Extends: Do,
        initialize: function(t) {
          t.renderTarget = Oo(t, "renderTarget", 1), t.fragShader = Oo(t, "fragShader", Uie), t.vertShader =
          Oo(t, "vertShader", zie), t.attributes = Oo(t, "attributes", [{ name: "inPosition", size: 2 },
          { name: "inTexCoord", size: 2 }]), t.batchSize = 1, t.vertices = [-1, -1, 0, 0, -1, 1, 0, 1,
          1, 1, 1, 1, -1, -1, 0, 0, 1, 1, 1, 1, 1, -1, 1, 0], Do.call(this, t), this.isPostFX = true,
          this.gameObject, this.controller, this.colorMatrix = new Gie(), this.fullFrame1, this.fullFrame2,
          this.halfFrame1, this.halfFrame2, this.renderer.isBooted && (this.manager = this.renderer.
          pipelines);
        }, bootFX: function() {
          Do.prototype.boot.call(this);
          var e = this.manager.UTILITY_PIPELINE;
          this.fullFrame1 = e.fullFrame1, this.fullFrame2 = e.fullFrame2, this.halfFrame1 = e.halfFrame1,
          this.halfFrame2 = e.halfFrame2;
          var t = this.renderer;
          this.set1i("uMainSampler", 0), this.set2f("uResolution", t.width, t.height);
          for (var i = this.renderTargets, r = 0; r < i.length; r++) i[r].autoResize = true;
        }, postBatch: function(e) {
          return this.hasBooted || (this.bootFX(), this.currentRenderTarget && this.currentRenderTarget.
          bind()), this.onDraw(this.currentRenderTarget), this.onPostBatch(e), this;
        }, onDraw: function(e) {
          this.bindAndDraw(e);
        }, getController: function(e) {
          return e !== void 0 ? e : this.controller ? this.controller : this;
        }, copySprite: function(e, t, i) {
          i === void 0 && (i = false);
          var r = this.gl;
          r.activeTexture(r.TEXTURE0), r.bindTexture(r.TEXTURE_2D, e.texture.webGLTexture);
          var s = r.getParameter(r.FRAMEBUFFER_BINDING);
          r.bindFramebuffer(r.FRAMEBUFFER, t.framebuffer.webGLFramebuffer), r.framebufferTexture2D(r.
          FRAMEBUFFER, r.COLOR_ATTACHMENT0, r.TEXTURE_2D, t.texture.webGLTexture, 0), r.clearColor(0,
          0, 0, 0), r.clear(r.COLOR_BUFFER_BIT), r.bufferData(r.ARRAY_BUFFER, this.vertexData, r.STATIC_DRAW),
          r.drawArrays(r.TRIANGLES, 0, 6), i && (r.bindTexture(r.TEXTURE_2D, null), r.bindFramebuffer(
          r.FRAMEBUFFER, s));
        }, copyFrame: function(e, t, i, r, s) {
          this.manager.copyFrame(e, t, i, r, s);
        }, copyToGame: function(e) {
          this.manager.copyToGame(e);
        }, drawFrame: function(e, t, i) {
          this.manager.drawFrame(e, t, i, this.colorMatrix);
        }, blendFrames: function(e, t, i, r, s) {
          this.manager.blendFrames(e, t, i, r, s);
        }, blendFramesAdditive: function(e, t, i, r, s) {
          this.manager.blendFramesAdditive(e, t, i, r, s);
        }, clearFrame: function(e, t) {
          this.manager.clearFrame(e, t);
        }, blitFrame: function(e, t, i, r, s, n) {
          this.manager.blitFrame(e, t, i, r, s, n);
        }, copyFrameRect: function(e, t, i, r, s, n, a, o) {
          this.manager.copyFrameRect(e, t, i, r, s, n, a, o);
        }, bindAndDraw: function(e, t, i, r, s) {
          i === void 0 && (i = true), r === void 0 && (r = true);
          var n = this.gl, a = this.renderer;
          this.bind(s), this.set1i("uMainSampler", 0), t ? (n.viewport(0, 0, t.width, t.height), n.bindFramebuffer(
          n.FRAMEBUFFER, t.framebuffer.webGLFramebuffer), n.framebufferTexture2D(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0,
          n.TEXTURE_2D, t.texture.webGLTexture, 0), i && (r ? n.clearColor(0, 0, 0, 0) : n.clearColor(
          0, 0, 0, 1), n.clear(n.COLOR_BUFFER_BIT))) : (a.popFramebuffer(false, false), a.currentFramebuffer ||
          n.viewport(0, 0, a.width, a.height)), a.restoreStencilMask(), n.activeTexture(n.TEXTURE0),
          n.bindTexture(n.TEXTURE_2D, e.texture.webGLTexture), n.bufferData(n.ARRAY_BUFFER, this.vertexData,
          n.STATIC_DRAW), n.drawArrays(n.TRIANGLES, 0, 6), t && (n.bindTexture(n.TEXTURE_2D, null), n.
          bindFramebuffer(n.FRAMEBUFFER, a.currentFramebuffer.webGLFramebuffer));
        }, destroy: function() {
          return this.controller && this.controller.destroy(), this.gameObject = null, this.controller =
          null, this.colorMatrix = null, this.fullFrame1 = null, this.fullFrame2 = null, this.halfFrame1 =
          null, this.halfFrame2 = null, this.manager.removePostPipeline(this), Do.prototype.destroy.
          call(this), this;
        } });
        zF.exports = kie;
      });
      VF = u((m_e, XF) => {
        var Xie = C(), Vie = _f(), kF = Ke(), Yie = new Xie({ Extends: kF, initialize: function(t) {
          kF.call(this, { game: t, fragShader: Vie }), this.amount = 1;
        }, onPreRender: function(e, t) {
          e = this.getController(e), this.set1f("amount", e.amount, t);
        } });
        XF.exports = Yie;
      });
      Pf = u((g_e, YF) => {
        YF.exports = ["#define SHADER_NAME BLOOM_FS", "precision mediump float;", "uniform sampler2D\
 uMainSampler;", "uniform vec2 offset;", "uniform float strength;", "uniform vec3 color;", "varying \
vec2 outTexCoord;", "void main ()", "{", "    vec4 sum = texture2D(uMainSampler, outTexCoord) * 0.20\
4164 * strength;", "    sum = sum + texture2D(uMainSampler, outTexCoord + offset * 1.407333) * 0.304\
005;", "    sum = sum + texture2D(uMainSampler, outTexCoord - offset * 1.407333) * 0.304005;", "    \
sum = sum + texture2D(uMainSampler, outTexCoord + offset * 3.294215) * 0.093913;", "    gl_FragColor\
 = (sum + texture2D(uMainSampler, outTexCoord - offset * 3.294215) * 0.093913) * vec4(color, 1);", "\
}"].join(`
`);
      });
      KF = u((x_e, HF) => {
        var Wie = C(), Hie = Pf(), WF = Ke(), Kie = new Wie({ Extends: WF, initialize: function(t) {
          WF.call(this, { game: t, fragShader: Hie }), this.steps = 4, this.offsetX = 1, this.offsetY =
          1, this.blurStrength = 1, this.strength = 1, this.glcolor = [1, 1, 1];
        }, onPreRender: function(e) {
          e = this.getController(e), this.set1f("strength", e.blurStrength), this.set3fv("color", e.
          glcolor);
        }, onDraw: function(e) {
          var t = this.getController(), i = this.fullFrame1, r = this.fullFrame2;
          this.copyFrame(e, r);
          for (var s = 2 / e.width * t.offsetX, n = 2 / e.height * t.offsetY, a = 0; a < t.steps; a++)
           this.set2f("offset", s, 0), this.copySprite(e, i), this.set2f("offset", 0, n), this.copySprite(
          i, e);
          this.blendFrames(r, e, i, t.strength), this.copyToGame(i);
        } });
        HF.exports = Kie;
      });
      Mf = u((E_e, ZF) => {
        ZF.exports = ["#define SHADER_NAME BLUR_LOW_FS", "precision mediump float;", "uniform sample\
r2D uMainSampler;", "uniform vec2 resolution;", "uniform vec2 offset;", "uniform float strength;", "\
uniform vec3 color;", "varying vec2 outTexCoord;", "void main ()", "{", "    vec2 uv = outTexCoord;",
        "    vec4 col = vec4(0.0);", "    vec2 offset = vec2(1.333) * offset * strength;", "    col \
+= texture2D(uMainSampler, uv) * 0.29411764705882354;", "    col += texture2D(uMainSampler, uv + (of\
fset / resolution)) * 0.35294117647058826;", "    col += texture2D(uMainSampler, uv - (offset / reso\
lution)) * 0.35294117647058826;", "    gl_FragColor = col * vec4(color, 1.0);", "}"].join(`
`);
      });
      qf = u((T_e, QF) => {
        QF.exports = ["#define SHADER_NAME BLUR_MED_FS", "precision mediump float;", "uniform sample\
r2D uMainSampler;", "uniform vec2 resolution;", "uniform vec2 offset;", "uniform float strength;", "\
uniform vec3 color;", "varying vec2 outTexCoord;", "void main ()", "{", "    vec2 uv = outTexCoord;",
        "    vec4 col = vec4(0.0);", "    vec2 off1 = vec2(1.3846153846) * offset * strength;", "   \
 vec2 off2 = vec2(3.2307692308) * offset * strength;", "    col += texture2D(uMainSampler, uv) * 0.2\
270270270;", "    col += texture2D(uMainSampler, uv + (off1 / resolution)) * 0.3162162162;", "    co\
l += texture2D(uMainSampler, uv - (off1 / resolution)) * 0.3162162162;", "    col += texture2D(uMain\
Sampler, uv + (off2 / resolution)) * 0.0702702703;", "    col += texture2D(uMainSampler, uv - (off2 \
/ resolution)) * 0.0702702703;", "    gl_FragColor = col * vec4(color, 1.0);", "}"].join(`
`);
      });
      Ff = u((y_e, JF) => {
        JF.exports = ["#define SHADER_NAME BLUR_HIGH_FS", "precision mediump float;", "uniform sampl\
er2D uMainSampler;", "uniform vec2 resolution;", "uniform vec2 offset;", "uniform float strength;", "\
uniform vec3 color;", "varying vec2 outTexCoord;", "void main ()", "{", "    vec2 uv = outTexCoord;",
        "    vec4 col = vec4(0.0);", "    vec2 off1 = vec2(1.411764705882353) * offset * strength;",
        "    vec2 off2 = vec2(3.2941176470588234) * offset * strength;", "    vec2 off3 = vec2(5.176\
470588235294) * offset * strength;", "    col += texture2D(uMainSampler, uv) * 0.1964825501511404;",
        "    col += texture2D(uMainSampler, uv + (off1 / resolution)) * 0.2969069646728344;", "    c\
ol += texture2D(uMainSampler, uv - (off1 / resolution)) * 0.2969069646728344;", "    col += texture2\
D(uMainSampler, uv + (off2 / resolution)) * 0.09447039785044732;", "    col += texture2D(uMainSample\
r, uv - (off2 / resolution)) * 0.09447039785044732;", "    col += texture2D(uMainSampler, uv + (off3\
 / resolution)) * 0.010381362401148057;", "    col += texture2D(uMainSampler, uv - (off3 / resolutio\
n)) * 0.010381362401148057;", "    gl_FragColor = col * vec4(color, 1.0);", "}"].join(`
`);
      });
      eb = u((S_e, jF) => {
        var Zie = C(), Qie = Mf(), Jie = qf(), $ie = Ff(), $F = Ke(), jie = new Zie({ Extends: $F, initialize: function(t) {
          $F.call(this, { game: t, shaders: [{ name: "Gaussian5", fragShader: Qie }, { name: "Gaussi\
an9", fragShader: Jie }, { name: "Gaussian13", fragShader: $ie }] }), this.activeShader = this.shaders[0],
          this.x = 2, this.y = 2, this.steps = 4, this.strength = 1, this.glcolor = [1, 1, 1];
        }, setQualityLow: function() {
          return this.activeShader = this.shaders[0], this;
        }, setQualityMedium: function() {
          return this.activeShader = this.shaders[1], this;
        }, setQualityHigh: function() {
          return this.activeShader = this.shaders[2], this;
        }, onDraw: function(e) {
          var t = this.getController(), i = this.gl, r = this.fullFrame1, s = i.getParameter(i.FRAMEBUFFER_BINDING);
          this.bind(this.shaders[t.quality]), i.activeTexture(i.TEXTURE0), i.viewport(0, 0, e.width,
          e.height), this.set1i("uMainSampler", 0), this.set2f("resolution", e.width, e.height), this.
          set1f("strength", t.strength), this.set3fv("color", t.glcolor);
          for (var n = 0; n < t.steps; n++) this.set2f("offset", t.x, 0), this.copySprite(e, r), this.
          set2f("offset", 0, t.y), this.copySprite(r, e);
          i.bindFramebuffer(i.FRAMEBUFFER, s), i.bindTexture(i.TEXTURE_2D, null), this.copyToGame(e);
        } });
        jF.exports = jie;
      });
      bf = u((w_e, tb) => {
        tb.exports = ["#define SHADER_NAME BOKEH_FS", "precision mediump float;", "#define ITERATION\
S 100.0", "#define ONEOVER_ITR 1.0 / ITERATIONS", "#define PI 3.141596", "#define GOLDEN_ANGLE 2.399\
96323", "uniform sampler2D uMainSampler;", "uniform vec2 resolution;", "uniform float radius;", "uni\
form float amount;", "uniform float contrast;", "uniform bool isTiltShift;", "uniform float strength\
;", "uniform vec2 blur;", "varying vec2 outTexCoord;", "vec2 Sample (in float theta, inout float r)",
        "{", "    r += 1.0 / r;", "    return (r - 1.0) * vec2(cos(theta), sin(theta)) * 0.06;", "}",
        "vec3 Bokeh (sampler2D tex, vec2 uv, float radius)", "{", "    vec3 acc = vec3(0.0);", "    \
vec3 div = vec3(0.0);", "    vec2 pixel = vec2(resolution.y / resolution.x, 1.0) * radius * .025;", "\
    float r = 1.0;", "    for (float j = 0.0; j < GOLDEN_ANGLE * ITERATIONS; j += GOLDEN_ANGLE)", " \
   {", "        vec3 col = texture2D(tex, uv + pixel * Sample(j, r)).xyz;", "        col = contrast \
> 0.0 ? col * col * (1.0 + contrast) : col;", "        vec3 bokeh = vec3(0.5) + pow(col, vec3(10.0))\
 * amount;", "        acc += col * bokeh;", "        div += bokeh;", "    }", "    return acc / div;",
        "}", "void main ()", "{", "    float shift = 1.0;", "    if (isTiltShift)", "    {", "      \
  vec2 uv = vec2(gl_FragCoord.xy / resolution + vec2(-0.5, -0.5)) * 2.0;", "        float centerStre\
ngth = 1.0;", "        shift = length(uv * blur * strength) * centerStrength;", "    }", "    gl_Fra\
gColor = vec4(Bokeh(uMainSampler, outTexCoord * vec2(1.0, 1.0), radius * shift), 0.0);", "}"].join(`\

`);
      });
      sb = u((C_e, rb) => {
        var ere = C(), tre = bf(), ib = Ke(), ire = new ere({ Extends: ib, initialize: function(t) {
          ib.call(this, { game: t, fragShader: tre }), this.isTiltShift = false, this.strength = 1, this.
          blurX = 1, this.blurY = 1, this.radius = 0.5, this.amount = 1, this.contrast = 0.2;
        }, onPreRender: function(e, t, i, r) {
          e = this.getController(e), this.set1f("radius", e.radius, t), this.set1f("amount", e.amount,
          t), this.set1f("contrast", e.contrast, t), this.set1f("strength", e.strength, t), this.set2f(
          "blur", e.blurX, e.blurY, t), this.setBoolean("isTiltShift", e.isTiltShift, t), i && r && this.
          set2f("resolution", i, r, t);
        }, onDraw: function(e) {
          this.set2f("resolution", e.width, e.height), this.bindAndDraw(e);
        } });
        rb.exports = ire;
      });
      Lf = u((A_e, nb) => {
        nb.exports = ["#define SHADER_NAME CIRCLE_FS", "precision mediump float;", "uniform sampler2\
D uMainSampler;", "uniform vec2 resolution;", "uniform vec3 color;", "uniform vec4 backgroundColor;",
        "uniform float thickness;", "uniform float scale;", "uniform float feather;", "varying vec2 \
outTexCoord;", "void main ()", "{", "    vec4 texture = texture2D(uMainSampler, outTexCoord);", "   \
 vec2 position = (gl_FragCoord.xy / resolution.xy) * 2.0 - 1.0;", "    float aspectRatio = resolutio\
n.x / resolution.y;", "    position.x *= aspectRatio;", "    float grad = length(position);", "    f\
loat outer = aspectRatio;", "    float inner = outer - (thickness * 2.0 / resolution.y);", "    if (\
aspectRatio >= 1.0)", "    {", "        float f = 2.0 + (resolution.y / resolution.x);", "        ou\
ter = 1.0;", "        inner = 1.0 - (thickness * f / resolution.x);", "    }", "    outer *= scale;",
        "    inner *= scale;", "    float circle = smoothstep(outer, outer - 0.01, grad);", "    flo\
at ring = circle - smoothstep(inner, inner - feather, grad);", "    texture = mix(backgroundColor * \
backgroundColor.a, texture, texture.a);", "    texture = (texture * (circle - ring));", "    gl_Frag\
Color = vec4(texture.rgb + (ring * color), texture.a);", "}"].join(`
`);
      });
      hb = u((R_e, ob) => {
        var rre = C(), sre = Lf(), ab = Ke(), nre = new rre({ Extends: ab, initialize: function(t) {
          ab.call(this, { game: t, fragShader: sre }), this.scale = 1, this.feather = 5e-3, this.thickness =
          8, this.glcolor = [1, 0.2, 0.7], this.glcolor2 = [1, 0, 0, 0.4];
        }, onPreRender: function(e, t, i, r) {
          e = this.getController(e), this.set1f("scale", e.scale, t), this.set1f("feather", e.feather,
          t), this.set1f("thickness", e.thickness, t), this.set3fv("color", e.glcolor, t), this.set4fv(
          "backgroundColor", e.glcolor2, t), i && r && this.set2f("resolution", i, r, t);
        }, onDraw: function(e) {
          this.set2f("resolution", e.width, e.height), this.bindAndDraw(e);
        } });
        ob.exports = nre;
      });
      fb = u((__e, lb) => {
        var are = C(), ub = Ke(), ore = new are({ Extends: ub, initialize: function(t) {
          ub.call(this, { game: t });
        }, onDraw: function(e) {
          var t = this.fullFrame1;
          this.controller ? this.manager.drawFrame(e, t, true, this.controller) : this.drawFrame(e, t),
          this.copyToGame(t);
        } });
        lb.exports = ore;
      });
      Of = u((P_e, db) => {
        db.exports = ["#define SHADER_NAME DISPLACEMENT_FS", "precision mediump float;", "uniform sa\
mpler2D uMainSampler;", "uniform sampler2D uDisplacementSampler;", "uniform vec2 amount;", "varying \
vec2 outTexCoord;", "void main ()", "{", "    vec2 disp = (-vec2(0.5, 0.5) + texture2D(uDisplacement\
Sampler, outTexCoord).rr) * amount;", "    gl_FragColor = texture2D(uMainSampler, outTexCoord + disp\
).rgba;", "}"].join(`
`);
      });
      pb = u((M_e, vb) => {
        var hre = C(), ure = Of(), cb = Ke(), lre = new hre({ Extends: cb, initialize: function(t) {
          cb.call(this, { game: t, fragShader: ure }), this.x = 5e-3, this.y = 5e-3, this.glTexture;
        }, onBoot: function() {
          this.setTexture("__WHITE");
        }, setTexture: function(e) {
          var t = this.game.textures.getFrame(e);
          t && (this.glTexture = t.glTexture);
        }, onDraw: function(e) {
          var t = this.getController(), i = this.fullFrame1;
          this.bind(), this.set1i("uMainSampler", 0), this.set1i("uDisplacementSampler", 1), this.set2f(
          "amount", t.x, t.y), this.bindTexture(t.glTexture, 1), this.copySprite(e, i), this.copyToGame(
          i);
        } });
        vb.exports = lre;
      });
      Df = u((q_e, mb) => {
        mb.exports = ["#define SHADER_NAME GLOW_FS", "precision mediump float;", "uniform sampler2D \
uMainSampler;", "varying vec2 outTexCoord;", "uniform float outerStrength;", "uniform float innerStr\
ength;", "uniform vec2 resolution;", "uniform vec4 glowColor;", "uniform bool knockout;", "const flo\
at PI = 3.14159265358979323846264;", "const float DIST = __DIST__;", "const float SIZE = min(__SIZE_\
_, PI * 2.0);", "const float STEP = ceil(PI * 2.0 / SIZE);", "const float MAX_ALPHA = STEP * DIST * \
(DIST + 1.0) / 2.0;", "void main ()", "{", "    vec2 px = vec2(1.0 / resolution.x, 1.0 / resolution.\
y);", "    float totalAlpha = 0.0;", "    vec2 direction;", "    vec2 displaced;", "    vec4 color;",
        "    for (float angle = 0.0; angle < PI * 2.0; angle += SIZE)", "    {", "        direction \
= vec2(cos(angle), sin(angle)) * px;", "        for (float curDistance = 0.0; curDistance < DIST; cu\
rDistance++)", "        {", "            displaced = outTexCoord + direction * (curDistance + 1.0);",
        "            color = texture2D(uMainSampler, displaced);", "            totalAlpha += (DIST \
- curDistance) * color.a;", "        }", "    }", "    color = texture2D(uMainSampler, outTexCoord);",
        "    float alphaRatio = (totalAlpha / MAX_ALPHA);", "    float innerGlowAlpha = (1.0 - alpha\
Ratio) * innerStrength * color.a;", "    float innerGlowStrength = min(1.0, innerGlowAlpha);", "    \
vec4 innerColor = mix(color, glowColor, innerGlowStrength);", "    float outerGlowAlpha = alphaRatio\
 * outerStrength * (1.0 - color.a);", "    float outerGlowStrength = min(1.0 - innerColor.a, outerGl\
owAlpha);", "    vec4 outerGlowColor = outerGlowStrength * glowColor.rgba;", "    if (knockout)", " \
   {", "        float resultAlpha = outerGlowAlpha + innerGlowAlpha;", "        gl_FragColor = vec4(\
glowColor.rgb * resultAlpha, resultAlpha);", "    }", "    else", "    {", "        gl_FragColor = i\
nnerColor + outerGlowColor;", "    }", "}"].join(`
`);
      });
      Tb = u((F_e, Eb) => {
        var fre = C(), gb = B(), dre = Df(), xb = Ke(), cre = wt(), vre = new fre({ Extends: xb, initialize: function(t, i) {
          var r = gb(i, "quality", 0.1), s = gb(i, "distance", 10);
          xb.call(this, { game: t, fragShader: cre.setGlowQuality(dre, t, r, s) }), this.outerStrength =
          4, this.innerStrength = 0, this.knockout = false, this.glcolor = [1, 1, 1, 1];
        }, onPreRender: function(e, t, i, r) {
          e = this.getController(e), this.set1f("outerStrength", e.outerStrength, t), this.set1f("in\
nerStrength", e.innerStrength, t), this.set4fv("glowColor", e.glcolor, t), this.setBoolean("knockout",
          e.knockout, t), i && r && this.set2f("resolution", i, r, t);
        }, onDraw: function(e) {
          this.set2f("resolution", e.width, e.height), this.bindAndDraw(e);
        } });
        Eb.exports = vre;
      });
      Nf = u((b_e, yb) => {
        yb.exports = ["#define SHADER_NAME GRADIENT_FS", "#define SRGB_TO_LINEAR(c) pow((c), vec3(2.\
2))", "#define LINEAR_TO_SRGB(c) pow((c), vec3(1.0 / 2.2))", "#define SRGB(r, g, b) SRGB_TO_LINEAR(v\
ec3(float(r), float(g), float(b)) / 255.0)", "precision mediump float;", "uniform sampler2D uMainSam\
pler;", "uniform vec2 positionFrom;", "uniform vec2 positionTo;", "uniform vec3 color1;", "uniform v\
ec3 color2;", "uniform float alpha;", "uniform int size;", "varying vec2 outTexCoord;", "float gradi\
entNoise(in vec2 uv)", "{", "    const vec3 magic = vec3(0.06711056, 0.00583715, 52.9829189);", "   \
 return fract(magic.z * fract(dot(uv, magic.xy)));", "}", "float stepped (in float s, in float scale\
, in int steps)", "{", "    return steps > 0 ? floor( s / ((1.0 * scale) / float(steps))) * 1.0 / fl\
oat(steps - 1) : s;", "}", "void main ()", "{", "    vec2 a = positionFrom;", "    vec2 b = position\
To;", "    vec2 ba = b - a;", "    float d = dot(outTexCoord - a, ba) / dot(ba, ba);", "    float t \
= size > 0 ? stepped(d, 1.0, size) : d;", "    t = smoothstep(0.0, 1.0, clamp(t, 0.0, 1.0));", "    \
vec3 color = mix(SRGB(color1.r, color1.g, color1.b), SRGB(color2.r, color2.g, color2.b), t);", "    \
color = LINEAR_TO_SRGB(color);", "    color += (1.0 / 255.0) * gradientNoise(outTexCoord) - (0.5 / 2\
55.0);", "    vec4 texture = texture2D(uMainSampler, outTexCoord);", "    gl_FragColor = vec4(mix(co\
lor.rgb, texture.rgb, alpha), 1.0) * texture.a;", "}"].join(`
`);
      });
      Cb = u((L_e, wb) => {
        var pre = C(), mre = Nf(), Sb = Ke(), gre = new pre({ Extends: Sb, initialize: function(t) {
          Sb.call(this, { game: t, fragShader: mre }), this.alpha = 0.2, this.size = 0, this.fromX =
          0, this.fromY = 0, this.toX = 0, this.toY = 1, this.glcolor1 = [255, 0, 0], this.glcolor2 =
          [0, 255, 0];
        }, onPreRender: function(e, t) {
          e = this.getController(e), this.set1f("alpha", e.alpha, t), this.set1i("size", e.size, t),
          this.set3fv("color1", e.glcolor1, t), this.set3fv("color2", e.glcolor2, t), this.set2f("po\
sitionFrom", e.fromX, e.fromY, t), this.set2f("positionTo", e.toX, e.toY, t);
        } });
        wb.exports = gre;
      });
      If = u((O_e, Ab) => {
        Ab.exports = ["#define SHADER_NAME PIXELATE_FS", "precision mediump float;", "uniform sample\
r2D uMainSampler;", "uniform vec2 resolution;", "uniform float amount;", "varying vec2 outTexCoord;",
        "void main ()", "{", "    float pixelSize = floor(2.0 + amount);", "    vec2 center = pixelS\
ize * floor(outTexCoord * resolution / pixelSize) + pixelSize * vec2(0.5, 0.5);", "    vec2 corner1 \
= center + pixelSize * vec2(-0.5, -0.5);", "    vec2 corner2 = center + pixelSize * vec2(+0.5, -0.5)\
;", "    vec2 corner3 = center + pixelSize * vec2(+0.5, +0.5);", "    vec2 corner4 = center + pixelS\
ize * vec2(-0.5, +0.5);", "    vec4 pixel = 0.4 * texture2D(uMainSampler, center / resolution);", " \
   pixel += 0.15 * texture2D(uMainSampler, corner1 / resolution);", "    pixel += 0.15 * texture2D(u\
MainSampler, corner2 / resolution);", "    pixel += 0.15 * texture2D(uMainSampler, corner3 / resolut\
ion);", "    pixel += 0.15 * texture2D(uMainSampler, corner4 / resolution);", "    gl_FragColor = pi\
xel;", "}"].join(`
`);
      });
      Pb = u((D_e, _b) => {
        var xre = C(), Ere = If(), Rb = Ke(), Tre = new xre({ Extends: Rb, initialize: function(t) {
          Rb.call(this, { game: t, fragShader: Ere }), this.amount = 1;
        }, onPreRender: function(e, t, i, r) {
          e = this.getController(e), this.set1f("amount", e.amount, t), i && r && this.set2f("resolu\
tion", i, r, t);
        }, onDraw: function(e) {
          this.set2f("resolution", e.width, e.height), this.bindAndDraw(e);
        } });
        _b.exports = Tre;
      });
      Bf = u((N_e, Mb) => {
        Mb.exports = ["#define SHADER_NAME SHADOW_FS", "precision mediump float;", "uniform sampler2\
D uMainSampler;", "varying vec2 outTexCoord;", "uniform vec2 lightPosition;", "uniform vec4 color;",
        "uniform float decay;", "uniform float power;", "uniform float intensity;", "uniform int sam\
ples;", "const int MAX = 12;", "void main ()", "{", "    vec4 texture = texture2D(uMainSampler, outT\
exCoord);", "    vec2 pc = (lightPosition - outTexCoord) * intensity;", "    float shadow = 0.0;", "\
    float limit = max(float(MAX), float(samples));", "    for (int i = 0; i < MAX; ++i)", "    {", "\
        if (i >= samples)", "        {", "            break;", "        }", "        shadow += textu\
re2D(uMainSampler, outTexCoord + float(i) * decay / limit * pc).a * power;", "    }", "    float mas\
k = 1.0 - texture.a;", "    gl_FragColor = mix(texture, color, shadow * mask);", "}"].join(`
`);
      });
      bb = u((I_e, Fb) => {
        var yre = C(), Sre = Bf(), qb = Ke(), wre = new yre({ Extends: qb, initialize: function(t) {
          qb.call(this, { game: t, fragShader: Sre }), this.x = 0, this.y = 0, this.decay = 0.1, this.
          power = 1, this.glcolor = [0, 0, 0, 1], this.samples = 6, this.intensity = 1;
        }, onPreRender: function(e, t) {
          e = this.getController(e);
          var i = e.samples;
          this.set1i("samples", i, t), this.set1f("intensity", e.intensity, t), this.set1f("decay", e.
          decay, t), this.set1f("power", e.power / i, t), this.set2f("lightPosition", e.x, e.y, t), this.
          set4fv("color", e.glcolor, t);
        } });
        Fb.exports = wre;
      });
      Gf = u((B_e, Lb) => {
        Lb.exports = ["#define SHADER_NAME SHINE_FS", "precision mediump float;", "uniform sampler2D\
 uMainSampler;", "uniform vec2 resolution;", "uniform bool reveal;", "uniform float speed;", "unifor\
m float time;", "uniform float lineWidth;", "uniform float gradient;", "varying vec2 outTexCoord;", "\
void main ()", "{", "	vec2 uv = gl_FragCoord.xy / resolution.xy;", "    vec4 tex = texture2D(uMainSa\
mpler, outTexCoord);", "    vec4 col1 = vec4(0.3, 0.0, 0.0, 1.0);", "    vec4 col2 = vec4(0.85, 0.85\
, 0.85, 1.0);", "    uv.x = uv.x - mod(time * speed, 2.0) + 0.5;", "    float y = uv.x * gradient;",
        "    float s = smoothstep(y - lineWidth, y, uv.y) - smoothstep(y, y + lineWidth, uv.y);", " \
   gl_FragColor = (((s * col1) + (s * col2)) * tex);", "    if (!reveal)", "    {", "        gl_Frag\
Color += tex;", "    }", "}"].join(`
`);
      });
      Nb = u((G_e, Db) => {
        var Cre = C(), Are = Gf(), Ob = Ke(), Rre = new Cre({ Extends: Ob, initialize: function(t) {
          Ob.call(this, { game: t, fragShader: Are }), this.speed = 0.5, this.lineWidth = 0.5, this.
          gradient = 3, this.reveal = false;
        }, onPreRender: function(e, t, i, r) {
          e = this.getController(e), this.setTime("time", t), this.set1f("speed", e.speed, t), this.
          set1f("lineWidth", e.lineWidth, t), this.set1f("gradient", e.gradient, t), this.setBoolean(
          "reveal", e.reveal, t), i && r && this.set2f("resolution", i, r, t);
        }, onDraw: function(e) {
          this.set2f("resolution", e.width, e.height), this.bindAndDraw(e);
        } });
        Db.exports = Rre;
      });
      Uf = u((U_e, Ib) => {
        Ib.exports = ["#define SHADER_NAME VIGNETTE_FS", "precision mediump float;", "uniform sample\
r2D uMainSampler;", "uniform float radius;", "uniform float strength;", "uniform vec2 position;", "v\
arying vec2 outTexCoord;", "void main ()", "{", "    vec4 col = vec4(1.0);", "    float d = length(o\
utTexCoord - position);", "    if (d <= radius)", "    {", "        float g = d / radius;", "       \
 g = sin(g * 3.14 * strength);", "    	col = vec4(g * g * g);", "    }", "    vec4 texture = texture\
2D(uMainSampler, outTexCoord);", "    gl_FragColor = texture * (1.0 - col);", "}"].join(`
`);
      });
      Ub = u((z_e, Gb) => {
        var _re = C(), Pre = Uf(), Bb = Ke(), Mre = new _re({ Extends: Bb, initialize: function(t) {
          Bb.call(this, { game: t, fragShader: Pre }), this.x = 0.5, this.y = 0.5, this.radius = 0.5,
          this.strength = 0.5;
        }, onPreRender: function(e, t) {
          e = this.getController(e), this.set1f("radius", e.radius, t), this.set1f("strength", e.strength,
          t), this.set2f("position", e.x, e.y, t);
        } });
        Gb.exports = Mre;
      });
      zf = u((k_e, zb) => {
        zb.exports = ["#define SHADER_NAME WIPE_FS", "precision mediump float;", "uniform sampler2D \
uMainSampler;", "uniform vec4 config;", "uniform bool reveal;", "varying vec2 outTexCoord;", "void m\
ain ()", "{", "    vec2 uv = outTexCoord;", "    vec4 color0;", "    vec4 color1;", "    if (reveal)",
        "    {", "        color0 = vec4(0);", "        color1 = texture2D(uMainSampler, uv);", "    \
}", "    else", "    {", "        color0 = texture2D(uMainSampler, uv);", "        color1 = vec4(0);",
        "    }", "    float distance = config.x;", "    float width = config.y;", "    float directi\
on = config.z;", "    float axis = uv.x;", "    if (config.w == 1.0)", "    {", "        axis = uv.y\
;", "    }", "    float adjust = mix(width, -width, distance);", "    float value = smoothstep(dista\
nce - width, distance + width, abs(direction - axis) + adjust);", "    gl_FragColor = mix(color1, co\
lor0, value);", "}"].join(`
`);
      });
      Vb = u((X_e, Xb) => {
        var qre = C(), Fre = zf(), kb = Ke(), bre = new qre({ Extends: kb, initialize: function(t) {
          kb.call(this, { game: t, fragShader: Fre }), this.progress = 0, this.wipeWidth = 0.1, this.
          direction = 0, this.axis = 0, this.reveal = false;
        }, onPreRender: function(e, t) {
          e = this.getController(e);
          var i = e.progress, r = e.wipeWidth, s = e.direction, n = e.axis;
          this.set4f("config", i, r, s, n, t), this.setBoolean("reveal", e.reveal, t);
        } });
        Xb.exports = bre;
      });
      No = u((V_e, Yb) => {
        var Lre = { Barrel: VF(), Bloom: KF(), Blur: eb(), Bokeh: sb(), Circle: hb(), ColorMatrix: fb(),
        Displacement: pb(), Glow: Tb(), Gradient: Cb(), Pixelate: Pb(), Shadow: bb(), Shine: Nb(), Vignette: Ub(),
        Wipe: Vb() };
        Yb.exports = Lre;
      });
      Io = u((Y_e, Wb) => {
        Wb.exports = ["#define SHADER_NAME PHASER_COLORMATRIX_FS", "precision mediump float;", "unif\
orm sampler2D uMainSampler;", "uniform float uColorMatrix[20];", "uniform float uAlpha;", "varying v\
ec2 outTexCoord;", "void main ()", "{", "    vec4 c = texture2D(uMainSampler, outTexCoord);", "    i\
f (uAlpha == 0.0)", "    {", "        gl_FragColor = c;", "        return;", "    }", "    if (c.a >\
 0.0)", "    {", "        c.rgb /= c.a;", "    }", "    vec4 result;", "    result.r = (uColorMatrix\
[0] * c.r) + (uColorMatrix[1] * c.g) + (uColorMatrix[2] * c.b) + (uColorMatrix[3] * c.a) + uColorMat\
rix[4];", "    result.g = (uColorMatrix[5] * c.r) + (uColorMatrix[6] * c.g) + (uColorMatrix[7] * c.b\
) + (uColorMatrix[8] * c.a) + uColorMatrix[9];", "    result.b = (uColorMatrix[10] * c.r) + (uColorM\
atrix[11] * c.g) + (uColorMatrix[12] * c.b) + (uColorMatrix[13] * c.a) + uColorMatrix[14];", "    re\
sult.a = (uColorMatrix[15] * c.r) + (uColorMatrix[16] * c.g) + (uColorMatrix[17] * c.b) + (uColorMat\
rix[18] * c.a) + uColorMatrix[19];", "    vec3 rgb = mix(c.rgb, result.rgb, uAlpha);", "    rgb *= r\
esult.a;", "    gl_FragColor = vec4(rgb, result.a);", "}"].join(`
`);
      });
      $b = u((W_e, Jb) => {
        "use strict";
        function Yf(e, t, i) {
          i = i || 2;
          var r = t && t.length, s = r ? t[0] * i : e.length, n = Kb(e, 0, s, i, true), a = [];
          if (!n || n.next === n.prev) return a;
          var o, h, l, f, d, c, p;
          if (r && (n = Bre(e, t, n, i)), e.length > 80 * i) {
            o = l = e[0], h = f = e[1];
            for (var v = i; v < s; v += i) d = e[v], c = e[v + 1], d < o && (o = d), c < h && (h = c),
            d > l && (l = d), c > f && (f = c);
            p = Math.max(l - o, f - h), p = p !== 0 ? 32767 / p : 0;
          }
          return Yn(n, a, i, o, h, p, 0), a;
        }
        function Kb(e, t, i, r, s) {
          var n, a;
          if (s === Vf(e, t, i, r) > 0) for (n = t; n < i; n += r) a = Hb(n, e[n], e[n + 1], a);
          else for (n = i - r; n >= t; n -= r) a = Hb(n, e[n], e[n + 1], a);
          return a && Uo(a, a.next) && (Hn(a), a = a.next), a;
        }
        function br(e, t) {
          if (!e) return e;
          t || (t = e);
          var i = e, r;
          do
            if (r = false, !i.steiner && (Uo(i, i.next) || ue(i.prev, i, i.next) === 0)) {
              if (Hn(i), i = t = i.prev, i === i.next) break;
              r = true;
            } else i = i.next;
          while (r || i !== t);
          return t;
        }
        function Yn(e, t, i, r, s, n, a) {
          if (e) {
            !a && n && Xre(e, r, s, n);
            for (var o = e, h, l; e.prev !== e.next; ) {
              if (h = e.prev, l = e.next, n ? Dre(e, r, s, n) : Ore(e)) {
                t.push(h.i / i | 0), t.push(e.i / i | 0), t.push(l.i / i | 0), Hn(e), e = l.next, o =
                l.next;
                continue;
              }
              if (e = l, e === o) {
                a ? a === 1 ? (e = Nre(br(e), t, i), Yn(e, t, i, r, s, n, 2)) : a === 2 && Ire(e, t,
                i, r, s, n) : Yn(br(e), t, i, r, s, n, 1);
                break;
              }
            }
          }
        }
        function Ore(e) {
          var t = e.prev, i = e, r = e.next;
          if (ue(t, i, r) >= 0) return false;
          for (var s = t.x, n = i.x, a = r.x, o = t.y, h = i.y, l = r.y, f = s < n ? s < a ? s : a :
          n < a ? n : a, d = o < h ? o < l ? o : l : h < l ? h : l, c = s > n ? s > a ? s : a : n > a ?
          n : a, p = o > h ? o > l ? o : l : h > l ? h : l, v = r.next; v !== t; ) {
            if (v.x >= f && v.x <= c && v.y >= d && v.y <= p && Ls(s, o, n, h, a, l, v.x, v.y) && ue(
            v.prev, v, v.next) >= 0) return false;
            v = v.next;
          }
          return true;
        }
        function Dre(e, t, i, r) {
          var s = e.prev, n = e, a = e.next;
          if (ue(s, n, a) >= 0) return false;
          for (var o = s.x, h = n.x, l = a.x, f = s.y, d = n.y, c = a.y, p = o < h ? o < l ? o : l :
          h < l ? h : l, v = f < d ? f < c ? f : c : d < c ? d : c, m = o > h ? o > l ? o : l : h > l ?
          h : l, g = f > d ? f > c ? f : c : d > c ? d : c, x = kf(p, v, t, i, r), E = kf(m, g, t, i,
          r), T15 = e.prevZ, w = e.nextZ; T15 && T15.z >= x && w && w.z <= E; ) {
            if (T15.x >= p && T15.x <= m && T15.y >= v && T15.y <= g && T15 !== s && T15 !== a && Ls(
            o, f, h, d, l, c, T15.x, T15.y) && ue(T15.prev, T15, T15.next) >= 0 || (T15 = T15.prevZ,
            w.x >= p && w.x <= m && w.y >= v && w.y <= g && w !== s && w !== a && Ls(o, f, h, d, l, c,
            w.x, w.y) && ue(w.prev, w, w.next) >= 0)) return false;
            w = w.nextZ;
          }
          for (; T15 && T15.z >= x; ) {
            if (T15.x >= p && T15.x <= m && T15.y >= v && T15.y <= g && T15 !== s && T15 !== a && Ls(
            o, f, h, d, l, c, T15.x, T15.y) && ue(T15.prev, T15, T15.next) >= 0) return false;
            T15 = T15.prevZ;
          }
          for (; w && w.z <= E; ) {
            if (w.x >= p && w.x <= m && w.y >= v && w.y <= g && w !== s && w !== a && Ls(o, f, h, d,
            l, c, w.x, w.y) && ue(w.prev, w, w.next) >= 0) return false;
            w = w.nextZ;
          }
          return true;
        }
        function Nre(e, t, i) {
          var r = e;
          do {
            var s = r.prev, n = r.next.next;
            !Uo(s, n) && Zb(s, r, r.next, n) && Wn(s, n) && Wn(n, s) && (t.push(s.i / i | 0), t.push(
            r.i / i | 0), t.push(n.i / i | 0), Hn(r), Hn(r.next), r = e = n), r = r.next;
          } while (r !== e);
          return br(r);
        }
        function Ire(e, t, i, r, s, n) {
          var a = e;
          do {
            for (var o = a.next.next; o !== a.prev; ) {
              if (a.i !== o.i && Wre(a, o)) {
                var h = Qb(a, o);
                a = br(a, a.next), h = br(h, h.next), Yn(a, t, i, r, s, n, 0), Yn(h, t, i, r, s, n, 0);
                return;
              }
              o = o.next;
            }
            a = a.next;
          } while (a !== e);
        }
        function Bre(e, t, i, r) {
          var s = [], n, a, o, h, l;
          for (n = 0, a = t.length; n < a; n++) o = t[n] * r, h = n < a - 1 ? t[n + 1] * r : e.length,
          l = Kb(e, o, h, r, false), l === l.next && (l.steiner = true), s.push(Yre(l));
          for (s.sort(Gre), n = 0; n < s.length; n++) i = Ure(s[n], i);
          return i;
        }
        function Gre(e, t) {
          return e.x - t.x;
        }
        function Ure(e, t) {
          var i = zre(e, t);
          if (!i) return t;
          var r = Qb(i, e);
          return br(r, r.next), br(i, i.next);
        }
        function zre(e, t) {
          var i = t, r = e.x, s = e.y, n = -1 / 0, a;
          do {
            if (s <= i.y && s >= i.next.y && i.next.y !== i.y) {
              var o = i.x + (s - i.y) * (i.next.x - i.x) / (i.next.y - i.y);
              if (o <= r && o > n && (n = o, a = i.x < i.next.x ? i : i.next, o === r)) return a;
            }
            i = i.next;
          } while (i !== t);
          if (!a) return null;
          var h = a, l = a.x, f = a.y, d = 1 / 0, c;
          i = a;
          do
            r >= i.x && i.x >= l && r !== i.x && Ls(s < f ? r : n, s, l, f, s < f ? n : r, s, i.x, i.
            y) && (c = Math.abs(s - i.y) / (r - i.x), Wn(i, e) && (c < d || c === d && (i.x > a.x ||
            i.x === a.x && kre(a, i))) && (a = i, d = c)), i = i.next;
          while (i !== h);
          return a;
        }
        function kre(e, t) {
          return ue(e.prev, e, t.prev) < 0 && ue(t.next, e, e.next) < 0;
        }
        function Xre(e, t, i, r) {
          var s = e;
          do
            s.z === 0 && (s.z = kf(s.x, s.y, t, i, r)), s.prevZ = s.prev, s.nextZ = s.next, s = s.next;
          while (s !== e);
          s.prevZ.nextZ = null, s.prevZ = null, Vre(s);
        }
        function Vre(e) {
          var t, i, r, s, n, a, o, h, l = 1;
          do {
            for (i = e, e = null, n = null, a = 0; i; ) {
              for (a++, r = i, o = 0, t = 0; t < l && (o++, r = r.nextZ, !!r); t++) ;
              for (h = l; o > 0 || h > 0 && r; ) o !== 0 && (h === 0 || !r || i.z <= r.z) ? (s = i, i =
              i.nextZ, o--) : (s = r, r = r.nextZ, h--), n ? n.nextZ = s : e = s, s.prevZ = n, n = s;
              i = r;
            }
            n.nextZ = null, l *= 2;
          } while (a > 1);
          return e;
        }
        function kf(e, t, i, r, s) {
          return e = (e - i) * s | 0, t = (t - r) * s | 0, e = (e | e << 8) & 16711935, e = (e | e <<
          4) & 252645135, e = (e | e << 2) & 858993459, e = (e | e << 1) & 1431655765, t = (t | t <<
          8) & 16711935, t = (t | t << 4) & 252645135, t = (t | t << 2) & 858993459, t = (t | t << 1) &
          1431655765, e | t << 1;
        }
        function Yre(e) {
          var t = e, i = e;
          do
            (t.x < i.x || t.x === i.x && t.y < i.y) && (i = t), t = t.next;
          while (t !== e);
          return i;
        }
        function Ls(e, t, i, r, s, n, a, o) {
          return (s - a) * (t - o) >= (e - a) * (n - o) && (e - a) * (r - o) >= (i - a) * (t - o) &&
          (i - a) * (n - o) >= (s - a) * (r - o);
        }
        function Wre(e, t) {
          return e.next.i !== t.i && e.prev.i !== t.i && !Hre(e, t) && (Wn(e, t) && Wn(t, e) && Kre(
          e, t) && (ue(e.prev, e, t.prev) || ue(e, t.prev, t)) || Uo(e, t) && ue(e.prev, e, e.next) >
          0 && ue(t.prev, t, t.next) > 0);
        }
        function ue(e, t, i) {
          return (t.y - e.y) * (i.x - t.x) - (t.x - e.x) * (i.y - t.y);
        }
        function Uo(e, t) {
          return e.x === t.x && e.y === t.y;
        }
        function Zb(e, t, i, r) {
          var s = Go(ue(e, t, i)), n = Go(ue(e, t, r)), a = Go(ue(i, r, e)), o = Go(ue(i, r, t));
          return !!(s !== n && a !== o || s === 0 && Bo(e, i, t) || n === 0 && Bo(e, r, t) || a === 0 &&
          Bo(i, e, r) || o === 0 && Bo(i, t, r));
        }
        function Bo(e, t, i) {
          return t.x <= Math.max(e.x, i.x) && t.x >= Math.min(e.x, i.x) && t.y <= Math.max(e.y, i.y) &&
          t.y >= Math.min(e.y, i.y);
        }
        function Go(e) {
          return e > 0 ? 1 : e < 0 ? -1 : 0;
        }
        function Hre(e, t) {
          var i = e;
          do {
            if (i.i !== e.i && i.next.i !== e.i && i.i !== t.i && i.next.i !== t.i && Zb(i, i.next, e,
            t)) return true;
            i = i.next;
          } while (i !== e);
          return false;
        }
        function Wn(e, t) {
          return ue(e.prev, e, e.next) < 0 ? ue(e, t, e.next) >= 0 && ue(e, e.prev, t) >= 0 : ue(e, t,
          e.prev) < 0 || ue(e, e.next, t) < 0;
        }
        function Kre(e, t) {
          var i = e, r = false, s = (e.x + t.x) / 2, n = (e.y + t.y) / 2;
          do
            i.y > n != i.next.y > n && i.next.y !== i.y && s < (i.next.x - i.x) * (n - i.y) / (i.next.
            y - i.y) + i.x && (r = !r), i = i.next;
          while (i !== e);
          return r;
        }
        function Qb(e, t) {
          var i = new Xf(e.i, e.x, e.y), r = new Xf(t.i, t.x, t.y), s = e.next, n = t.prev;
          return e.next = t, t.prev = e, i.next = s, s.prev = i, r.next = i, i.prev = r, n.next = r,
          r.prev = n, r;
        }
        function Hb(e, t, i, r) {
          var s = new Xf(e, t, i);
          return r ? (s.next = r.next, s.prev = r, r.next.prev = s, r.next = s) : (s.prev = s, s.next =
          s), s;
        }
        function Hn(e) {
          e.next.prev = e.prev, e.prev.next = e.next, e.prevZ && (e.prevZ.nextZ = e.nextZ), e.nextZ &&
          (e.nextZ.prevZ = e.prevZ);
        }
        function Xf(e, t, i) {
          this.i = e, this.x = t, this.y = i, this.prev = null, this.next = null, this.z = 0, this.prevZ =
          null, this.nextZ = null, this.steiner = false;
        }
        Yf.deviation = function(e, t, i, r) {
          var s = t && t.length, n = s ? t[0] * i : e.length, a = Math.abs(Vf(e, 0, n, i));
          if (s) for (var o = 0, h = t.length; o < h; o++) {
            var l = t[o] * i, f = o < h - 1 ? t[o + 1] * i : e.length;
            a -= Math.abs(Vf(e, l, f, i));
          }
          var d = 0;
          for (o = 0; o < r.length; o += 3) {
            var c = r[o] * i, p = r[o + 1] * i, v = r[o + 2] * i;
            d += Math.abs((e[c] - e[v]) * (e[p + 1] - e[c + 1]) - (e[c] - e[p]) * (e[v + 1] - e[c + 1]));
          }
          return a === 0 && d === 0 ? 0 : Math.abs((d - a) / a);
        };
        function Vf(e, t, i, r) {
          for (var s = 0, n = t, a = i - r; n < i; n += r) s += (e[a] - e[n]) * (e[n + 1] + e[a + 1]),
          a = n;
          return s;
        }
        Yf.flatten = function(e) {
          for (var t = e[0][0].length, i = { vertices: [], holes: [], dimensions: t }, r = 0, s = 0; s <
          e.length; s++) {
            for (var n = 0; n < e[s].length; n++) for (var a = 0; a < t; a++) i.vertices.push(e[s][n][a]);
            s > 0 && (r += e[s - 1].length, i.holes.push(r));
          }
          return i;
        };
        Jb.exports = Yf;
      });
      Wf = u((H_e, jb) => {
        jb.exports = ["#define SHADER_NAME PHASER_MULTI_FS", "#ifdef GL_FRAGMENT_PRECISION_HIGH", "p\
recision highp float;", "#else", "precision mediump float;", "#endif", "uniform sampler2D uMainSampl\
er[%count%];", "varying vec2 outTexCoord;", "varying float outTexId;", "varying float outTintEffect;",
        "varying vec4 outTint;", "void main ()", "{", "    vec4 texture;", "    %forloop%", "    vec\
4 texel = vec4(outTint.bgr * outTint.a, outTint.a);", "    vec4 color = texture * texel;", "    if (\
outTintEffect == 1.0)", "    {", "        color.rgb = mix(texture.rgb, outTint.bgr * outTint.a, text\
ure.a);", "    }", "    else if (outTintEffect == 2.0)", "    {", "        color = texel;", "    }",
        "    gl_FragColor = color;", "}"].join(`
`);
      });
      Hf = u((K_e, eL) => {
        eL.exports = ["#define SHADER_NAME PHASER_MULTI_VS", "precision mediump float;", "uniform ma\
t4 uProjectionMatrix;", "uniform vec2 uResolution;", "attribute vec2 inPosition;", "attribute vec2 i\
nTexCoord;", "attribute float inTexId;", "attribute float inTintEffect;", "attribute vec4 inTint;", "\
varying vec2 outTexCoord;", "varying float outTexId;", "varying float outTintEffect;", "varying vec4\
 outTint;", "void main ()", "{", "    gl_Position = uProjectionMatrix * vec4(inPosition, 1.0, 1.0);",
        "    outTexCoord = inTexCoord;", "    outTexId = inTexId;", "    outTint = inTint;", "    ou\
tTintEffect = inTintEffect;", "}"].join(`
`);
      });
      er = u((Z_e, tL) => {
        var Zre = C(), Qre = $b(), Kf = B(), Jre = Wf(), $re = Hf(), zo = Lt(), Zf = wt(), jre = bs(),
        ko = Vt(), ese = new Zre({ Extends: ko, initialize: function(t) {
          var i = t.game.renderer, r = Kf(t, "fragShader", Jre);
          t.fragShader = Zf.parseFragmentShaderMaxTextures(r, i.maxTextures), t.vertShader = Kf(t, "\
vertShader", $re), t.attributes = Kf(t, "attributes", [{ name: "inPosition", size: 2 }, { name: "inT\
exCoord", size: 2 }, { name: "inTexId" }, { name: "inTintEffect" }, { name: "inTint", size: 4, type: jre.
          UNSIGNED_BYTE, normalized: true }]), t.resizeUniform = "uResolution", ko.call(this, t), this.
          _tempMatrix1 = new zo(), this._tempMatrix2 = new zo(), this._tempMatrix3 = new zo(), this.
          calcMatrix = new zo(), this.tempTriangle = [{ x: 0, y: 0, width: 0 }, { x: 0, y: 0, width: 0 },
          { x: 0, y: 0, width: 0 }, { x: 0, y: 0, width: 0 }], this.strokeTint = { TL: 0, TR: 0, BL: 0,
          BR: 0 }, this.fillTint = { TL: 0, TR: 0, BL: 0, BR: 0 }, this.currentFrame = { u0: 0, v0: 0,
          u1: 1, v1: 1 }, this.firstQuad = [0, 0, 0, 0, 0], this.prevQuad = [0, 0, 0, 0, 0], this.polygonCache =
          [];
        }, boot: function() {
          ko.prototype.boot.call(this);
          var e = this.renderer;
          this.set1iv("uMainSampler", e.textureIndexes), this.set2f("uResolution", e.width, e.height);
        }, batchSprite: function(e, t, i) {
          this.manager.set(this, e);
          var r = this._tempMatrix1, s = this._tempMatrix2, n = this._tempMatrix3, a = e.frame, o = a.
          glTexture, h = a.u0, l = a.v0, f = a.u1, d = a.v1, c = a.x, p = a.y, v = a.cutWidth, m = a.
          cutHeight, g = a.customPivot, x = e.displayOriginX, E = e.displayOriginY, T15 = -x + c, w = -E +
          p;
          if (e.isCropped) {
            var y = e._crop;
            (y.flipX !== e.flipX || y.flipY !== e.flipY) && a.updateCropUVs(y, e.flipX, e.flipY), h =
            y.u0, l = y.v0, f = y.u1, d = y.v1, v = y.width, m = y.height, c = y.x, p = y.y, T15 = -x +
            c, w = -E + p;
          }
          var A10 = 1, S14 = 1;
          e.flipX && (g || (T15 += -a.realWidth + x * 2), A10 = -1), e.flipY && (g || (w += -a.realHeight +
          E * 2), S14 = -1);
          var _ = e.x, q = e.y;
          t.roundPixels && (_ = Math.floor(_), q = Math.floor(q)), s.applyITRS(_, q, e.rotation, e.scaleX *
          A10, e.scaleY * S14), r.copyFrom(t.matrix), i ? (r.multiplyWithOffset(i, -t.scrollX * e.scrollFactorX,
          -t.scrollY * e.scrollFactorY), s.e = _, s.f = q) : (s.e -= t.scrollX * e.scrollFactorX, s.
          f -= t.scrollY * e.scrollFactorY), r.multiply(s, n);
          var P = n.setQuad(T15, w, T15 + v, w + m, t.renderRoundPixels), L = Zf.getTintAppendFloatAlpha,
          N5 = t.alpha, O19 = L(e.tintTopLeft, N5 * e._alphaTL), M = L(e.tintTopRight, N5 * e._alphaTR),
          F8 = L(e.tintBottomLeft, N5 * e._alphaBL), b = L(e.tintBottomRight, N5 * e._alphaBR);
          this.shouldFlush(6) && this.flush();
          var G = this.setGameObject(e, a);
          this.manager.preBatch(e), this.batchQuad(e, P[0], P[1], P[2], P[3], P[4], P[5], P[6], P[7],
          h, l, f, d, O19, M, F8, b, e.tintFill, o, G), this.manager.postBatch(e);
        }, batchTexture: function(e, t, i, r, s, n, a, o, h, l, f, d, c, p, v, m, g, x, E, T15, w, y, A10, S14, _, q, P, L, N5, O19, M, F8, b) {
          b === void 0 && (b = false), this.manager.set(this, e);
          var G = this._tempMatrix1, I = this._tempMatrix2, W = this._tempMatrix3, Ae = x / i + P, Re = E /
          r + L, ge = (x + T15) / i + P, _e = (E + w) / r + L, V24 = a, Te = o, ts = -m, Ra = -g;
          if (e.isCropped) {
            var is = e._crop, _a = is.width, Pa = is.height;
            V24 = _a, Te = Pa, a = _a, o = Pa, x = is.x, E = is.y;
            var lu = x, fu = E;
            d && (lu = T15 - is.x - _a), c && (fu = w - is.y - Pa), Ae = lu / i + P, Re = fu / r + L,
            ge = (lu + _a) / i + P, _e = (fu + Pa) / r + L, ts = -m + x, Ra = -g + E;
          }
          c = c ^ (!M && t.isRenderTexture ? 1 : 0), d && (V24 *= -1, ts += a), c && (Te *= -1, Ra +=
          o), N5.roundPixels && (s = Math.floor(s), n = Math.floor(n)), I.applyITRS(s, n, f, h, l), G.
          copyFrom(N5.matrix), O19 ? (G.multiplyWithOffset(O19, -N5.scrollX * p, -N5.scrollY * v), I.
          e = s, I.f = n) : (I.e -= N5.scrollX * p, I.f -= N5.scrollY * v), G.multiply(I, W);
          var zi = W.setQuad(ts, Ra, ts + V24, Ra + Te, N5.renderRoundPixels);
          F8 == null && (F8 = this.setTexture2D(t)), e && !b && this.manager.preBatch(e), this.batchQuad(
          e, zi[0], zi[1], zi[2], zi[3], zi[4], zi[5], zi[6], zi[7], Ae, Re, ge, _e, y, A10, S14, _,
          q, t, F8), e && !b && this.manager.postBatch(e);
        }, batchTextureFrame: function(e, t, i, r, s, n, a) {
          this.manager.set(this);
          var o = this._tempMatrix1.copyFrom(n), h = this._tempMatrix2;
          a ? o.multiply(a, h) : h = o;
          var l = h.setQuad(t, i, t + e.width, i + e.height), f = this.setTexture2D(e.source.glTexture);
          r = Zf.getTintAppendFloatAlpha(r, s), this.batchQuad(null, l[0], l[1], l[2], l[3], l[4], l[5],
          l[6], l[7], e.u0, e.v0, e.u1, e.v1, r, r, r, r, 0, e.glTexture, f);
        }, batchFillRect: function(e, t, i, r, s, n) {
          this.renderer.pipelines.set(this);
          var a = this.calcMatrix;
          n && n.multiply(s, a);
          var o = a.setQuad(e, t, e + i, t + r), h = this.fillTint;
          this.batchQuad(null, o[0], o[1], o[2], o[3], o[4], o[5], o[6], o[7], 0, 0, 1, 1, h.TL, h.TR,
          h.BL, h.BR, 2);
        }, batchFillTriangle: function(e, t, i, r, s, n, a, o) {
          this.renderer.pipelines.set(this);
          var h = this.calcMatrix;
          o && o.multiply(a, h);
          var l = h.getX(e, t), f = h.getY(e, t), d = h.getX(i, r), c = h.getY(i, r), p = h.getX(s, n),
          v = h.getY(s, n), m = this.fillTint;
          this.batchTri(null, l, f, d, c, p, v, 0, 0, 1, 1, m.TL, m.TR, m.BL, 2);
        }, batchStrokeTriangle: function(e, t, i, r, s, n, a, o, h) {
          var l = this.tempTriangle;
          l[0].x = e, l[0].y = t, l[0].width = a, l[1].x = i, l[1].y = r, l[1].width = a, l[2].x = s,
          l[2].y = n, l[2].width = a, l[3].x = e, l[3].y = t, l[3].width = a, this.batchStrokePath(l,
          a, false, o, h);
        }, batchFillPath: function(e, t, i) {
          this.renderer.pipelines.set(this);
          var r = this.calcMatrix;
          i && i.multiply(t, r);
          for (var s = e.length, n = this.polygonCache, a, o, h = this.fillTint.TL, l = this.fillTint.
          TR, f = this.fillTint.BL, d = 0; d < s; ++d) o = e[d], n.push(o.x, o.y);
          a = Qre(n), s = a.length;
          for (var c = 0; c < s; c += 3) {
            var p = a[c + 0] * 2, v = a[c + 1] * 2, m = a[c + 2] * 2, g = n[p + 0], x = n[p + 1], E = n[v +
            0], T15 = n[v + 1], w = n[m + 0], y = n[m + 1], A10 = r.getX(g, x), S14 = r.getY(g, x), _ = r.
            getX(E, T15), q = r.getY(E, T15), P = r.getX(w, y), L = r.getY(w, y);
            this.batchTri(null, A10, S14, _, q, P, L, 0, 0, 1, 1, h, l, f, 2);
          }
          n.length = 0;
        }, batchStrokePath: function(e, t, i, r, s) {
          this.renderer.pipelines.set(this), this.prevQuad[4] = 0, this.firstQuad[4] = 0;
          for (var n = e.length - 1, a = 0; a < n; a++) {
            var o = e[a], h = e[a + 1];
            this.batchLine(o.x, o.y, h.x, h.y, o.width / 2, h.width / 2, t, a, !i && a === n - 1, r,
            s);
          }
        }, batchLine: function(e, t, i, r, s, n, a, o, h, l, f) {
          this.renderer.pipelines.set(this);
          var d = this.calcMatrix;
          f && f.multiply(l, d);
          var c = i - e, p = r - t, v = Math.sqrt(c * c + p * p);
          if (v !== 0) {
            var m = s * (r - t) / v, g = s * (e - i) / v, x = n * (r - t) / v, E = n * (e - i) / v, T15 = i -
            x, w = r - E, y = e - m, A10 = t - g, S14 = i + x, _ = r + E, q = e + m, P = t + g, L = d.
            getX(T15, w), N5 = d.getY(T15, w), O19 = d.getX(y, A10), M = d.getY(y, A10), F8 = d.getX(
            S14, _), b = d.getY(S14, _), G = d.getX(q, P), I = d.getY(q, P), W = this.strokeTint, Ae = W.
            TL, Re = W.TR, ge = W.BL, _e = W.BR;
            if (this.batchQuad(null, G, I, O19, M, L, N5, F8, b, 0, 0, 1, 1, Ae, Re, ge, _e, 2), !(a <=
            2)) {
              var V24 = this.prevQuad, Te = this.firstQuad;
              o > 0 && V24[4] ? this.batchQuad(null, G, I, O19, M, V24[0], V24[1], V24[2], V24[3], 0,
              0, 1, 1, Ae, Re, ge, _e, 2) : (Te[0] = G, Te[1] = I, Te[2] = O19, Te[3] = M, Te[4] = 1),
              h && Te[4] ? this.batchQuad(null, L, N5, F8, b, Te[0], Te[1], Te[2], Te[3], 0, 0, 1, 1,
              Ae, Re, ge, _e, 2) : (V24[0] = L, V24[1] = N5, V24[2] = F8, V24[3] = b, V24[4] = 1);
            }
          }
        }, destroy: function() {
          return this._tempMatrix1.destroy(), this._tempMatrix2.destroy(), this._tempMatrix3.destroy(),
          this._tempMatrix1 = null, this._tempMatrix1 = null, this._tempMatrix1 = null, ko.prototype.
          destroy.call(this), this;
        } });
        tL.exports = ese;
      });
      Kn = u((Q_e, iL) => {
        iL.exports = ["#define SHADER_NAME PHASER_SINGLE_FS", "#ifdef GL_FRAGMENT_PRECISION_HIGH", "\
precision highp float;", "#else", "precision mediump float;", "#endif", "uniform sampler2D uMainSamp\
ler;", "varying vec2 outTexCoord;", "varying float outTintEffect;", "varying vec4 outTint;", "void m\
ain ()", "{", "    vec4 texture = texture2D(uMainSampler, outTexCoord);", "    vec4 texel = vec4(out\
Tint.bgr * outTint.a, outTint.a);", "    vec4 color = texture * texel;", "    if (outTintEffect == 1\
.0)", "    {", "        color.rgb = mix(texture.rgb, outTint.bgr * outTint.a, texture.a);", "    }",
        "    else if (outTintEffect == 2.0)", "    {", "        color = texel;", "    }", "    gl_Fr\
agColor = color;", "}"].join(`
`);
      });
      Zn = u((J_e, rL) => {
        rL.exports = ["#define SHADER_NAME PHASER_SINGLE_VS", "precision mediump float;", "uniform m\
at4 uProjectionMatrix;", "uniform vec2 uResolution;", "attribute vec2 inPosition;", "attribute vec2 \
inTexCoord;", "attribute float inTexId;", "attribute float inTintEffect;", "attribute vec4 inTint;",
        "varying vec2 outTexCoord;", "varying float outTintEffect;", "varying vec4 outTint;", "void \
main ()", "{", "    gl_Position = uProjectionMatrix * vec4(inPosition, 1.0, 1.0);", "    outTexCoord\
 = inTexCoord;", "    outTint = inTint;", "    outTintEffect = inTintEffect;", "}"].join(`
`);
      });
      $f = u(($_e, aL) => {
        var tse = Qt(), ise = In(), rse = C(), sse = Io(), Xo = B(), Qf = er(), sL = bo(), nL = he(),
        nse = qr(), ase = Kn(), Jf = Zn(), ose = Vt(), hse = new rse({ Extends: Qf, initialize: function(t) {
          var i = Xo(t, "fragShader", sL), r = Xo(t, "vertShader", Jf), s = Xo(t, "drawShader", sL),
          n = [{ name: "DrawSprite", fragShader: ase, vertShader: Jf }, { name: "CopySprite", fragShader: i,
          vertShader: r }, { name: "DrawGame", fragShader: s, vertShader: Jf }, { name: "ColorMatrix",
          fragShader: sse }], a = Xo(t, "shaders", []);
          t.shaders = n.concat(a), t.vertShader || (t.vertShader = r), t.batchSize = 1, Qf.call(this,
          t), this.isPreFX = true, this.customMainSampler = null, this.drawSpriteShader, this.copyShader,
          this.gameShader, this.colorMatrixShader, this.quadVertexData, this.quadVertexBuffer, this.
          quadVertexViewF32, this.spriteBounds = new nL(), this.targetBounds = new nL(), this.fsTarget,
          this.tempSprite, this.renderer.isBooted && (this.manager = this.renderer.pipelines, this.boot());
        }, boot: function() {
          ose.prototype.boot.call(this);
          var e = this.shaders, t = this.renderer;
          this.drawSpriteShader = e[0], this.copyShader = e[1], this.gameShader = e[2], this.colorMatrixShader =
          e[3], this.fsTarget = new nse(t, t.width, t.height, 1, 0, true, true), this.renderTargets =
          this.manager.renderTargets.concat(this.fsTarget);
          var i = new ArrayBuffer(168);
          this.quadVertexData = i, this.quadVertexViewF32 = new Float32Array(i), this.quadVertexBuffer =
          t.createVertexBuffer(i, this.gl.STATIC_DRAW), this.onResize(t.width, t.height), this.currentShader =
          this.copyShader, this.set2f("uResolution", t.width, t.height);
        }, onResize: function(e, t) {
          var i = this.quadVertexViewF32;
          i[1] = t, i[22] = t, i[14] = e, i[28] = e, i[35] = e, i[36] = t;
        }, batchQuad: function(e, t, i, r, s, n, a, o, h, l, f, d, c, p, v, m, g, x, E) {
          var T15 = Math.min(t, r, n, o), w = Math.min(i, s, a, h), y = Math.max(t, r, n, o), A10 = Math.
          max(i, s, a, h), S14 = y - T15, _ = A10 - w, q = this.spriteBounds.setTo(T15, w, S14, _), P = e ?
          e.preFX.padding : 0, L = S14 + P * 2, N5 = _ + P * 2, O19 = Math.abs(Math.max(L, N5)), M = this.
          manager.getRenderTarget(O19), F8 = this.targetBounds.setTo(0, 0, M.width, M.height);
          ise(F8, Math.round(q.centerX), Math.round(q.centerY)), this.tempSprite = e;
          var b = this.gl, G = this.renderer;
          G.clearStencilMask(), this.setShader(this.drawSpriteShader), this.set1i("uMainSampler", 0),
          this.set2f("uResolution", G.width, G.height), this.flipProjectionMatrix(true), e && (this.
          onDrawSprite(e, M), e.preFX.onFX(this));
          var I = this.fsTarget;
          return this.flush(), b.viewport(0, 0, G.width, G.height), b.bindFramebuffer(b.FRAMEBUFFER,
          I.framebuffer.webGLFramebuffer), b.framebufferTexture2D(b.FRAMEBUFFER, b.COLOR_ATTACHMENT0,
          b.TEXTURE_2D, I.texture.webGLTexture, 0), b.clearColor(0, 0, 0, 0), b.clear(b.COLOR_BUFFER_BIT),
          this.setTexture2D(E), this.batchVert(t, i, l, f, 0, x, p), this.batchVert(r, s, l, c, 0, x,
          m), this.batchVert(n, a, d, c, 0, x, g), this.batchVert(t, i, l, f, 0, x, p), this.batchVert(
          n, a, d, c, 0, x, g), this.batchVert(o, h, d, f, 0, x, v), this.flush(), this.flipProjectionMatrix(
          false), b.activeTexture(b.TEXTURE0), b.bindTexture(b.TEXTURE_2D, M.texture.webGLTexture), b.
          copyTexSubImage2D(b.TEXTURE_2D, 0, 0, 0, F8.x, F8.y, F8.width, F8.height), b.bindFramebuffer(
          b.FRAMEBUFFER, null), b.bindTexture(b.TEXTURE_2D, null), this.onBatch(e), this.currentShader =
          this.copyShader, this.onDraw(M, this.manager.getSwapRenderTarget(), this.manager.getAltSwapRenderTarget()),
          true;
        }, onDrawSprite: function() {
        }, onCopySprite: function() {
        }, copySprite: function(e, t, i, r, s, n, a) {
          i === void 0 && (i = true), r === void 0 && (r = true), s === void 0 && (s = false), a ===
          void 0 && (a = this.copyShader);
          var o = this.gl, h = this.tempSprite;
          n && (a = this.colorMatrixShader), this.currentShader = a;
          var l = this.setVertexBuffer(this.quadVertexBuffer);
          a.bind(l, false);
          var f = this.renderer;
          if (this.set1i("uMainSampler", 0), this.set2f("uResolution", f.width, f.height), h.preFX.onFXCopy(
          this), this.onCopySprite(e, t, h), n && (this.set1fv("uColorMatrix", n.getData()), this.set1f(
          "uAlpha", n.alpha)), o.activeTexture(o.TEXTURE0), o.bindTexture(o.TEXTURE_2D, e.texture.webGLTexture),
          e.height > t.height) o.viewport(0, 0, e.width, e.height), this.setTargetUVs(e, t);
          else {
            var d = t.height - e.height;
            o.viewport(0, d, e.width, e.height), this.resetUVs();
          }
          if (o.bindFramebuffer(o.FRAMEBUFFER, t.framebuffer.webGLFramebuffer), o.framebufferTexture2D(
          o.FRAMEBUFFER, o.COLOR_ATTACHMENT0, o.TEXTURE_2D, t.texture.webGLTexture, 0), i && (o.clearColor(
          0, 0, 0, +!r), o.clear(o.COLOR_BUFFER_BIT)), s) {
            var c = this.renderer.currentBlendMode;
            this.renderer.setBlendMode(tse.ERASE);
          }
          o.bufferData(o.ARRAY_BUFFER, this.quadVertexData, o.STATIC_DRAW), o.drawArrays(o.TRIANGLES,
          0, 6), s && this.renderer.setBlendMode(c), o.bindFramebuffer(o.FRAMEBUFFER, null);
        }, copy: function(e, t) {
          var i = this.gl;
          this.set1i("uMainSampler", 0), i.activeTexture(i.TEXTURE0), i.bindTexture(i.TEXTURE_2D, e.
          texture.webGLTexture), i.viewport(0, 0, e.width, e.height), this.setUVs(0, 0, 0, 1, 1, 1, 1,
          0), i.bindFramebuffer(i.FRAMEBUFFER, t.framebuffer.webGLFramebuffer), i.framebufferTexture2D(
          i.FRAMEBUFFER, i.COLOR_ATTACHMENT0, i.TEXTURE_2D, t.texture.webGLTexture, 0), i.clearColor(
          0, 0, 0, 0), i.clear(i.COLOR_BUFFER_BIT), i.bufferData(i.ARRAY_BUFFER, this.quadVertexData,
          i.STATIC_DRAW), i.drawArrays(i.TRIANGLES, 0, 6), i.bindFramebuffer(i.FRAMEBUFFER, null);
        }, blendFrames: function(e, t, i, r, s) {
          this.manager.blendFrames(e, t, i, r, s);
        }, blendFramesAdditive: function(e, t, i, r, s) {
          this.manager.blendFramesAdditive(e, t, i, r, s);
        }, drawToGame: function(e) {
          this.currentShader = null, this.setShader(this.copyShader), this.bindAndDraw(e);
        }, copyToGame: function(e) {
          this.currentShader = null, this.setShader(this.gameShader), this.bindAndDraw(e);
        }, bindAndDraw: function(e) {
          var t = this.gl, i = this.renderer;
          this.set1i("uMainSampler", 0), this.customMainSampler ? this.setTexture2D(this.customMainSampler) :
          this.setTexture2D(e.texture);
          var r = this._tempMatrix1.loadIdentity(), s = this.targetBounds.x, n = this.targetBounds.y,
          a = s + e.width, o = n + e.height, h = r.getX(s, n), l = r.getX(s, o), f = r.getX(a, o), d = r.
          getX(a, n), c = r.getY(s, n), p = r.getY(s, o), v = r.getY(a, o), m = r.getY(a, n), g = 16777215;
          this.batchVert(h, c, 0, 0, 0, 0, g), this.batchVert(l, p, 0, 1, 0, 0, g), this.batchVert(f,
          v, 1, 1, 0, 0, g), this.batchVert(h, c, 0, 0, 0, 0, g), this.batchVert(f, v, 1, 1, 0, 0, g),
          this.batchVert(d, m, 1, 0, 0, 0, g), i.restoreFramebuffer(false, true), i.currentFramebuffer ||
          t.viewport(0, 0, i.width, i.height), i.restoreStencilMask(), this.flush(), this.tempSprite =
          null;
        }, onDraw: function(e) {
          this.drawToGame(e);
        }, setUVs: function(e, t, i, r, s, n, a, o) {
          var h = this.quadVertexViewF32;
          h[2] = e, h[3] = t, h[9] = i, h[10] = r, h[16] = s, h[17] = n, h[23] = e, h[24] = t, h[30] =
          s, h[31] = n, h[37] = a, h[38] = o;
        }, setTargetUVs: function(e, t) {
          var i = t.height / e.height;
          i > 0.5 ? i = 0.5 - (i - 0.5) : i = 0.5 + (0.5 - i), this.setUVs(0, i, 0, 1 + i, 1, 1 + i,
          1, i);
        }, resetUVs: function() {
          this.setUVs(0, 0, 0, 1, 1, 1, 1, 0);
        }, destroy: function() {
          return this.renderer.deleteBuffer(this.quadVertexBuffer), this.drawSpriteShader = null, this.
          copyShader = null, this.gameShader = null, this.colorMatrixShader = null, this.quadVertexData =
          null, this.quadVertexBuffer = null, this.quadVertexViewF32 = null, this.fsTarget = null, this.
          tempSprite = null, Qf.prototype.destroy.call(this), this;
        } });
        aL.exports = hse;
      });
      jf = u((j_e, oL) => {
        oL.exports = ["#define SHADER_NAME PHASER_ADD_BLEND_FS", "precision mediump float;", "unifor\
m sampler2D uMainSampler1;", "uniform sampler2D uMainSampler2;", "uniform float uStrength;", "varyin\
g vec2 outTexCoord;", "void main ()", "{", "    vec4 frame1 = texture2D(uMainSampler1, outTexCoord);",
        "    vec4 frame2 = texture2D(uMainSampler2, outTexCoord);", "    gl_FragColor = frame1 + fra\
me2 * uStrength;", "}"].join(`
`);
      });
      ed = u((ePe, hL) => {
        hL.exports = ["#define SHADER_NAME PHASER_COPY_FS", "precision mediump float;", "uniform sam\
pler2D uMainSampler;", "uniform float uBrightness;", "varying vec2 outTexCoord;", "void main ()", "{",
        "    gl_FragColor = texture2D(uMainSampler, outTexCoord) * uBrightness;", "}"].join(`
`);
      });
      td = u((tPe, uL) => {
        uL.exports = ["#define SHADER_NAME PHASER_LIGHT_FS", "precision mediump float;", "struct Lig\
ht", "{", "    vec2 position;", "    vec3 color;", "    float intensity;", "    float radius;", "};",
        "const int kMaxLights = %LIGHT_COUNT%;", "uniform vec4 uCamera; /* x, y, rotation, zoom */",
        "uniform vec2 uResolution;", "uniform sampler2D uMainSampler;", "uniform sampler2D uNormSamp\
ler;", "uniform vec3 uAmbientLightColor;", "uniform Light uLights[kMaxLights];", "uniform mat3 uInve\
rseRotationMatrix;", "uniform int uLightCount;", "varying vec2 outTexCoord;", "varying float outTexI\
d;", "varying float outTintEffect;", "varying vec4 outTint;", "void main ()", "{", "    vec3 finalCo\
lor = vec3(0.0, 0.0, 0.0);", "    vec4 texel = vec4(outTint.bgr * outTint.a, outTint.a);", "    vec4\
 texture = texture2D(uMainSampler, outTexCoord);", "    vec4 color = texture * texel;", "    if (out\
TintEffect == 1.0)", "    {", "        color.rgb = mix(texture.rgb, outTint.bgr * outTint.a, texture\
.a);", "    }", "    else if (outTintEffect == 2.0)", "    {", "        color = texel;", "    }", " \
   vec3 normalMap = texture2D(uNormSampler, outTexCoord).rgb;", "    vec3 normal = normalize(uInvers\
eRotationMatrix * vec3(normalMap * 2.0 - 1.0));", "    vec2 res = vec2(min(uResolution.x, uResolutio\
n.y)) * uCamera.w;", "    for (int index = 0; index < kMaxLights; ++index)", "    {", "        if (i\
ndex < uLightCount)", "        {", "            Light light = uLights[index];", "            vec3 li\
ghtDir = vec3((light.position.xy / res) - (gl_FragCoord.xy / res), 0.1);", "            vec3 lightNo\
rmal = normalize(lightDir);", "            float distToSurf = length(lightDir) * uCamera.w;", "     \
       float diffuseFactor = max(dot(normal, lightNormal), 0.0);", "            float radius = (ligh\
t.radius / res.x * uCamera.w) * uCamera.w;", "            float attenuation = clamp(1.0 - distToSurf\
 * distToSurf / (radius * radius), 0.0, 1.0);", "            vec3 diffuse = light.color * diffuseFac\
tor;", "            finalColor += (attenuation * diffuse) * light.intensity;", "        }", "    }",
        "    vec4 colorOutput = vec4(uAmbientLightColor + finalColor, 1.0);", "    gl_FragColor = co\
lor * vec4(colorOutput.rgb * colorOutput.a, colorOutput.a);", "}"].join(`
`);
      });
      id = u((iPe, lL) => {
        lL.exports = ["#define SHADER_NAME PHASER_LINEAR_BLEND_FS", "precision mediump float;", "uni\
form sampler2D uMainSampler1;", "uniform sampler2D uMainSampler2;", "uniform float uStrength;", "var\
ying vec2 outTexCoord;", "void main ()", "{", "    vec4 frame1 = texture2D(uMainSampler1, outTexCoor\
d);", "    vec4 frame2 = texture2D(uMainSampler2, outTexCoord);", "    gl_FragColor = mix(frame1, fr\
ame2 * uStrength, 0.5);", "}"].join(`
`);
      });
      dL = u((rPe, fL) => {
        fL.exports = ["#define SHADER_NAME PHASER_MESH_FS", "precision mediump float;", "uniform vec\
3 uLightPosition;", "uniform vec3 uLightAmbient;", "uniform vec3 uLightDiffuse;", "uniform vec3 uLig\
htSpecular;", "uniform vec3 uFogColor;", "uniform float uFogNear;", "uniform float uFogFar;", "unifo\
rm vec3 uMaterialAmbient;", "uniform vec3 uMaterialDiffuse;", "uniform vec3 uMaterialSpecular;", "un\
iform float uMaterialShine;", "uniform vec3 uCameraPosition;", "uniform sampler2D uTexture;", "varyi\
ng vec2 vTextureCoord;", "varying vec3 vNormal;", "varying vec3 vPosition;", "void main (void)", "{",
        "    vec4 color = texture2D(uTexture, vTextureCoord);", "    vec3 ambient = uLightAmbient * \
uMaterialAmbient;", "    vec3 norm = normalize(vNormal);", "    vec3 lightDir = normalize(uLightPosi\
tion - vPosition);", "    float diff = max(dot(norm, lightDir), 0.0);", "    vec3 diffuse = uLightDi\
ffuse * (diff * uMaterialDiffuse);", "    vec3 viewDir = normalize(uCameraPosition - vPosition);", "\
    vec3 reflectDir = reflect(-lightDir, norm);", "    float spec = pow(max(dot(viewDir, reflectDir)\
, 0.0), uMaterialShine);", "    vec3 specular = uLightSpecular * (spec * uMaterialSpecular);", "    \
vec3 result = (ambient + diffuse + specular) * color.rgb;", "    float depth = gl_FragCoord.z / gl_F\
ragCoord.w;", "    float fogFactor = smoothstep(uFogNear, uFogFar, depth);", "    gl_FragColor.rgb =\
 mix(result.rgb, uFogColor, fogFactor);", "    gl_FragColor.a = color.a;", "}"].join(`
`);
      });
      vL = u((sPe, cL) => {
        cL.exports = ["#define SHADER_NAME PHASER_MESH_VS", "precision mediump float;", "attribute v\
ec3 aVertexPosition;", "attribute vec3 aVertexNormal;", "attribute vec2 aTextureCoord;", "uniform ma\
t4 uViewProjectionMatrix;", "uniform mat4 uModelMatrix;", "uniform mat4 uNormalMatrix;", "varying ve\
c2 vTextureCoord;", "varying vec3 vNormal;", "varying vec3 vPosition;", "void main ()", "{", "    vT\
extureCoord = aTextureCoord;", "    vPosition = vec3(uModelMatrix * vec4(aVertexPosition, 1.0));", "\
    vNormal = vec3(uNormalMatrix * vec4(aVertexNormal, 1.0));", "    gl_Position = uViewProjectionMa\
trix * uModelMatrix * vec4(aVertexPosition, 1.0);", "}"].join(`
`);
      });
      mL = u((nPe, pL) => {
        pL.exports = ["#define SHADER_NAME PHASER_MOBILE_FS", "#ifdef GL_FRAGMENT_PRECISION_HIGH", "\
precision highp float;", "#else", "precision mediump float;", "#endif", "uniform sampler2D uMainSamp\
ler;", "varying vec2 outTexCoord;", "varying float outTintEffect;", "varying vec4 outTint;", "void m\
ain ()", "{", "    vec4 texel = vec4(outTint.bgr * outTint.a, outTint.a);", "    vec4 texture = text\
ure2D(uMainSampler, outTexCoord);", "    vec4 color = texture * texel;", "    if (outTintEffect == 1\
.0)", "    {", "        color.rgb = mix(texture.rgb, outTint.bgr * outTint.a, texture.a);", "    }",
        "    else if (outTintEffect == 2.0)", "    {", "        color = texel;", "    }", "    gl_Fr\
agColor = color;", "}"].join(`
`);
      });
      xL = u((aPe, gL) => {
        gL.exports = ["#define SHADER_NAME PHASER_MOBILE_VS", "precision mediump float;", "uniform m\
at4 uProjectionMatrix;", "uniform vec2 uResolution;", "attribute vec2 inPosition;", "attribute vec2 \
inTexCoord;", "attribute float inTexId;", "attribute float inTintEffect;", "attribute vec4 inTint;",
        "varying vec2 outTexCoord;", "varying float outTintEffect;", "varying vec4 outTint;", "void \
main ()", "{", "    gl_Position = uProjectionMatrix * vec4(inPosition, 1.0, 1.0);", "    outTexCoord\
 = inTexCoord;", "    outTint = inTint;", "    outTintEffect = inTintEffect;", "}"].join(`
`);
      });
      rd = u((oPe, EL) => {
        EL.exports = ["#define SHADER_NAME PHASER_POINTLIGHT_FS", "precision mediump float;", "unifo\
rm vec2 uResolution;", "uniform float uCameraZoom;", "varying vec4 lightPosition;", "varying vec4 li\
ghtColor;", "varying float lightRadius;", "varying float lightAttenuation;", "void main ()", "{", " \
   vec2 center = (lightPosition.xy + 1.0) * (uResolution.xy * 0.5);", "    float distToSurf = length\
(center - gl_FragCoord.xy);", "    float radius = 1.0 - distToSurf / (lightRadius * uCameraZoom);", "\
    float intensity = smoothstep(0.0, 1.0, radius * lightAttenuation);", "    vec4 color = vec4(inte\
nsity, intensity, intensity, 0.0) * lightColor;", "    gl_FragColor = vec4(color.rgb * lightColor.a,\
 color.a);", "}"].join(`
`);
      });
      sd = u((hPe, TL) => {
        TL.exports = ["#define SHADER_NAME PHASER_POINTLIGHT_VS", "precision mediump float;", "unifo\
rm mat4 uProjectionMatrix;", "attribute vec2 inPosition;", "attribute vec2 inLightPosition;", "attri\
bute vec4 inLightColor;", "attribute float inLightRadius;", "attribute float inLightAttenuation;", "\
varying vec4 lightPosition;", "varying vec4 lightColor;", "varying float lightRadius;", "varying flo\
at lightAttenuation;", "void main ()", "{", "    lightColor = inLightColor;", "    lightRadius = inL\
ightRadius;", "    lightAttenuation = inLightAttenuation;", "    lightPosition = uProjectionMatrix *\
 vec4(inLightPosition, 1.0, 1.0);", "    gl_Position = uProjectionMatrix * vec4(inPosition, 1.0, 1.0\
);", "}"].join(`
`);
      });
      SL = u((uPe, yL) => {
        yL.exports = { AddBlendFrag: jf(), BitmapMaskFrag: yf(), BitmapMaskVert: Sf(), ColorMatrixFrag: Io(),
        CopyFrag: ed(), FXBarrelFrag: _f(), FXBloomFrag: Pf(), FXBlurHighFrag: Ff(), FXBlurLowFrag: Mf(),
        FXBlurMedFrag: qf(), FXBokehFrag: bf(), FXCircleFrag: Lf(), FXDisplacementFrag: Of(), FXGlowFrag: Df(),
        FXGradientFrag: Nf(), FXPixelateFrag: If(), FXShadowFrag: Bf(), FXShineFrag: Gf(), FXVignetteFrag: Uf(),
        FXWipeFrag: zf(), LightFrag: td(), LinearBlendFrag: id(), MeshFrag: dL(), MeshVert: vL(), MobileFrag: mL(),
        MobileVert: xL(), MultiFrag: Wf(), MultiVert: Hf(), PointLightFrag: rd(), PointLightVert: sd(),
        PostFXFrag: bo(), QuadVert: Lo(), SingleFrag: Kn(), SingleVert: Zn() };
      });
      ad = u((lPe, wL) => {
        var use = C(), ti = No(), $ = Me(), Nt = B(), nd = $f(), Ze = SL(), lse = wt(), fse = new use(
        { Extends: nd, initialize: function(t) {
          t.shaders = [lse.setGlowQuality(Ze.FXGlowFrag, t.game), Ze.FXShadowFrag, Ze.FXPixelateFrag,
          Ze.FXVignetteFrag, Ze.FXShineFrag, Ze.FXBlurLowFrag, Ze.FXBlurMedFrag, Ze.FXBlurHighFrag, Ze.
          FXGradientFrag, Ze.FXBloomFrag, Ze.ColorMatrixFrag, Ze.FXCircleFrag, Ze.FXBarrelFrag, Ze.FXDisplacementFrag,
          Ze.FXWipeFrag, Ze.FXBokehFrag], nd.call(this, t);
          var i = this.game;
          this.glow = new ti.Glow(i), this.shadow = new ti.Shadow(i), this.pixelate = new ti.Pixelate(
          i), this.vignette = new ti.Vignette(i), this.shine = new ti.Shine(i), this.gradient = new ti.
          Gradient(i), this.circle = new ti.Circle(i), this.barrel = new ti.Barrel(i), this.wipe = new ti.
          Wipe(i), this.bokeh = new ti.Bokeh(i);
          var r = [];
          r[$.GLOW] = this.onGlow, r[$.SHADOW] = this.onShadow, r[$.PIXELATE] = this.onPixelate, r[$.
          VIGNETTE] = this.onVignette, r[$.SHINE] = this.onShine, r[$.BLUR] = this.onBlur, r[$.GRADIENT] =
          this.onGradient, r[$.BLOOM] = this.onBloom, r[$.COLOR_MATRIX] = this.onColorMatrix, r[$.CIRCLE] =
          this.onCircle, r[$.BARREL] = this.onBarrel, r[$.DISPLACEMENT] = this.onDisplacement, r[$.WIPE] =
          this.onWipe, r[$.BOKEH] = this.onBokeh, this.fxHandlers = r, this.source, this.target, this.
          swap;
        }, onDraw: function(e, t, i) {
          this.source = e, this.target = t, this.swap = i;
          var r = e.width, s = e.height, n = this.tempSprite, a = this.fxHandlers;
          if (n && n.preFX) for (var o = n.preFX.list, h = 0; h < o.length; h++) {
            var l = o[h];
            l.active && a[l.type].call(this, l, r, s);
          }
          this.drawToGame(this.source);
        }, runDraw: function() {
          var e = this.source, t = this.target;
          this.copy(e, t), this.source = t, this.target = e;
        }, onGlow: function(e, t, i) {
          var r = this.shaders[$.GLOW];
          this.setShader(r), this.glow.onPreRender(e, r, t, i), this.runDraw();
        }, onShadow: function(e) {
          var t = this.shaders[$.SHADOW];
          this.setShader(t), this.shadow.onPreRender(e, t), this.runDraw();
        }, onPixelate: function(e, t, i) {
          var r = this.shaders[$.PIXELATE];
          this.setShader(r), this.pixelate.onPreRender(e, r, t, i), this.runDraw();
        }, onVignette: function(e) {
          var t = this.shaders[$.VIGNETTE];
          this.setShader(t), this.vignette.onPreRender(e, t), this.runDraw();
        }, onShine: function(e, t, i) {
          var r = this.shaders[$.SHINE];
          this.setShader(r), this.shine.onPreRender(e, r, t, i), this.runDraw();
        }, onBlur: function(e, t, i) {
          var r = Nt(e, "quality"), s = this.shaders[$.BLUR + r];
          this.setShader(s), this.set1i("uMainSampler", 0), this.set2f("resolution", t, i), this.set1f(
          "strength", Nt(e, "strength")), this.set3fv("color", Nt(e, "glcolor"));
          for (var n = Nt(e, "x"), a = Nt(e, "y"), o = Nt(e, "steps"), h = 0; h < o; h++) this.set2f(
          "offset", n, 0), this.runDraw(), this.set2f("offset", 0, a), this.runDraw();
        }, onGradient: function(e) {
          var t = this.shaders[$.GRADIENT];
          this.setShader(t), this.gradient.onPreRender(e, t), this.runDraw();
        }, onBloom: function(e, t, i) {
          var r = this.shaders[$.BLOOM];
          this.copySprite(this.source, this.swap), this.setShader(r), this.set1i("uMainSampler", 0),
          this.set1f("strength", Nt(e, "blurStrength")), this.set3fv("color", Nt(e, "glcolor"));
          for (var s = 2 / t * Nt(e, "offsetX"), n = 2 / i * Nt(e, "offsetY"), a = Nt(e, "steps"), o = 0; o <
          a; o++) this.set2f("offset", s, 0), this.runDraw(), this.set2f("offset", 0, n), this.runDraw();
          this.blendFrames(this.swap, this.source, this.target, Nt(e, "strength")), this.copySprite(
          this.target, this.source);
        }, onColorMatrix: function(e) {
          this.setShader(this.colorMatrixShader), this.set1fv("uColorMatrix", e.getData()), this.set1f(
          "uAlpha", e.alpha), this.runDraw();
        }, onCircle: function(e, t, i) {
          var r = this.shaders[$.CIRCLE];
          this.setShader(r), this.circle.onPreRender(e, r, t, i), this.runDraw();
        }, onBarrel: function(e) {
          var t = this.shaders[$.BARREL];
          this.setShader(t), this.barrel.onPreRender(e, t), this.runDraw();
        }, onDisplacement: function(e) {
          this.setShader(this.shaders[$.DISPLACEMENT]), this.set1i("uDisplacementSampler", 1), this.
          set2f("amount", e.x, e.y), this.bindTexture(e.glTexture, 1), this.runDraw();
        }, onWipe: function(e) {
          var t = this.shaders[$.WIPE];
          this.setShader(t), this.wipe.onPreRender(e, t), this.runDraw();
        }, onBokeh: function(e, t, i) {
          var r = this.shaders[$.BOKEH];
          this.setShader(r), this.bokeh.onPreRender(e, r, t, i), this.runDraw();
        }, destroy: function() {
          return this.glow.destroy(), this.shadow.destroy(), this.pixelate.destroy(), this.vignette.
          destroy(), this.shine.destroy(), this.gradient.destroy(), this.circle.destroy(), this.barrel.
          destroy(), this.wipe.destroy(), this.bokeh.destroy(), this.fxHandlers = null, this.source =
          null, this.target = null, this.swap = null, nd.prototype.destroy.call(this), this;
        } });
        wL.exports = fse;
      });
      od = u((fPe, AL) => {
        var dse = C(), cse = B(), vse = td(), Qn = er(), CL = Lt(), pse = Y(), mse = Vt(), gse = new dse(
        { Extends: Qn, initialize: function(t) {
          var i = cse(t, "fragShader", vse);
          t.fragShader = i.replace("%LIGHT_COUNT%", t.game.renderer.config.maxLights), Qn.call(this,
          t), this.inverseRotationMatrix = new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]), this.currentNormalMap,
          this.lightsActive = true, this.tempVec2 = new pse(), this._tempMatrix = new CL(), this._tempMatrix2 =
          new CL();
        }, boot: function() {
          mse.prototype.boot.call(this);
        }, onRender: function(e, t) {
          var i = e.sys.lights;
          if (this.lightsActive = false, !(!i || !i.active)) {
            var r = i.getLights(t), s = r.length;
            this.lightsActive = true;
            var n, a = this.renderer, o = a.height, h = t.matrix, l = this.tempVec2;
            for (this.set1i("uMainSampler", 0), this.set1i("uNormSampler", 1), this.set2f("uResoluti\
on", this.width / 2, this.height / 2), this.set4f("uCamera", t.x, t.y, t.rotation, t.zoom), this.set3f(
            "uAmbientLightColor", i.ambientColor.r, i.ambientColor.g, i.ambientColor.b), this.set1i(
            "uLightCount", s), n = 0; n < s; n++) {
              var f = r[n].light, d = f.color, c = "uLights[" + n + "].";
              h.transformPoint(f.x, f.y, l), this.set2f(c + "position", l.x - t.scrollX * f.scrollFactorX *
              t.zoom, o - (l.y - t.scrollY * f.scrollFactorY * t.zoom)), this.set3f(c + "color", d.r,
              d.g, d.b), this.set1f(c + "intensity", f.intensity), this.set1f(c + "radius", f.radius);
            }
            this.currentNormalMapRotation = null;
          }
        }, setNormalMapRotation: function(e) {
          if (e !== this.currentNormalMapRotation || this.vertexCount === 0) {
            this.vertexCount > 0 && this.flush();
            var t = this.inverseRotationMatrix;
            if (e) {
              var i = -e, r = Math.cos(i), s = Math.sin(i);
              t[1] = s, t[3] = -s, t[0] = t[4] = r;
            } else t[0] = t[4] = 1, t[1] = t[3] = 0;
            this.setMatrix3fv("uInverseRotationMatrix", false, t), this.currentNormalMapRotation = e;
          }
        }, setTexture2D: function(e, t) {
          var i = this.renderer;
          e === void 0 && (e = i.whiteTexture);
          var r = this.getNormalMap(t);
          this.isNewNormalMap(e, r) && (this.flush(), this.createBatch(e), this.addTextureToBatch(r),
          this.currentNormalMap = r);
          var s = 0;
          if (t && t.parentContainer) {
            var n = t.getWorldTransformMatrix(this._tempMatrix, this._tempMatrix2);
            s = n.rotationNormalized;
          } else t && (s = t.rotation);
          return this.currentBatch === null && (this.createBatch(e), this.addTextureToBatch(r)), this.
          setNormalMapRotation(s), 0;
        }, setGameObject: function(e, t) {
          t === void 0 && (t = e.frame);
          var i = t.glTexture, r = this.getNormalMap(e);
          if (this.isNewNormalMap(i, r) && (this.flush(), this.createBatch(i), this.addTextureToBatch(
          r), this.currentNormalMap = r), e.parentContainer) {
            var s = e.getWorldTransformMatrix(this._tempMatrix, this._tempMatrix2);
            this.setNormalMapRotation(s.rotationNormalized);
          } else this.setNormalMapRotation(e.rotation);
          return this.currentBatch === null && (this.createBatch(i), this.addTextureToBatch(r)), 0;
        }, isNewNormalMap: function(e, t) {
          return this.currentTexture !== e || this.currentNormalMap !== t;
        }, getNormalMap: function(e) {
          var t;
          if (e) e.displayTexture ? t = e.displayTexture.dataSource[e.displayFrame.sourceIndex] : e.
          texture ? t = e.texture.dataSource[e.frame.sourceIndex] : e.tileset && (Array.isArray(e.tileset) ?
          t = e.tileset[0].image.dataSource[0] : t = e.tileset.image.dataSource[0]);
          else return this.renderer.normalTexture;
          return t ? t.glTexture : this.renderer.normalTexture;
        }, batchSprite: function(e, t, i) {
          this.lightsActive && Qn.prototype.batchSprite.call(this, e, t, i);
        }, batchTexture: function(e, t, i, r, s, n, a, o, h, l, f, d, c, p, v, m, g, x, E, T15, w, y, A10, S14, _, q, P, L, N5, O19, M, F8) {
          this.lightsActive && Qn.prototype.batchTexture.call(this, e, t, i, r, s, n, a, o, h, l, f,
          d, c, p, v, m, g, x, E, T15, w, y, A10, S14, _, q, P, L, N5, O19, M, F8);
        }, batchTextureFrame: function(e, t, i, r, s, n, a) {
          this.lightsActive && Qn.prototype.batchTextureFrame.call(this, e, t, i, r, s, n, a);
        } });
        AL.exports = gse;
      });
      ud = u((dPe, _L) => {
        var xse = C(), hd = B(), RL = er(), Ese = Kn(), Tse = Zn(), yse = bs(), Sse = Vt(), wse = new xse(
        { Extends: RL, initialize: function(t) {
          t.fragShader = hd(t, "fragShader", Ese), t.vertShader = hd(t, "vertShader", Tse), t.attributes =
          hd(t, "attributes", [{ name: "inPosition", size: 2 }, { name: "inTexCoord", size: 2 }, { name: "\
inTexId" }, { name: "inTintEffect" }, { name: "inTint", size: 4, type: yse.UNSIGNED_BYTE, normalized: true }]),
          t.forceZero = true, t.resizeUniform = "uResolution", RL.call(this, t);
        }, boot: function() {
          Sse.prototype.boot.call(this);
          var e = this.renderer;
          this.set1i("uMainSampler", 0), this.set2f("uResolution", e.width, e.height);
        } });
        _L.exports = wse;
      });
      fd = u((cPe, ML) => {
        var Cse = C(), ld = B(), Ase = rd(), Rse = sd(), PL = Vt(), _se = new Cse({ Extends: PL, initialize: function(t) {
          t.vertShader = ld(t, "vertShader", Rse), t.fragShader = ld(t, "fragShader", Ase), t.attributes =
          ld(t, "attributes", [{ name: "inPosition", size: 2 }, { name: "inLightPosition", size: 2 },
          { name: "inLightRadius" }, { name: "inLightAttenuation" }, { name: "inLightColor", size: 4 }]),
          PL.call(this, t);
        }, onRender: function(e, t) {
          this.set2f("uResolution", this.width, this.height), this.set1f("uCameraZoom", t.zoom);
        }, batchPointLight: function(e, t, i, r, s, n, a, o, h, l, f, d) {
          var c = e.color, p = e.intensity, v = e.radius, m = e.attenuation, g = c.r * p, x = c.g * p,
          E = c.b * p, T15 = t.alpha * e.alpha;
          this.shouldFlush(6) && this.flush(), this.currentBatch || this.setTexture2D(), this.batchLightVert(
          i, r, f, d, v, m, g, x, E, T15), this.batchLightVert(s, n, f, d, v, m, g, x, E, T15), this.
          batchLightVert(a, o, f, d, v, m, g, x, E, T15), this.batchLightVert(i, r, f, d, v, m, g, x,
          E, T15), this.batchLightVert(a, o, f, d, v, m, g, x, E, T15), this.batchLightVert(h, l, f,
          d, v, m, g, x, E, T15), this.currentBatch.count = this.vertexCount - this.currentBatch.start;
        }, batchLightVert: function(e, t, i, r, s, n, a, o, h, l) {
          var f = this.vertexViewF32, d = this.vertexCount * this.currentShader.vertexComponentCount -
          1;
          f[++d] = e, f[++d] = t, f[++d] = i, f[++d] = r, f[++d] = s, f[++d] = n, f[++d] = a, f[++d] =
          o, f[++d] = h, f[++d] = l, this.vertexCount++;
        } });
        ML.exports = _se;
      });
      dd = u((vPe, FL) => {
        var Pse = C(), Mse = B(), qL = er(), qse = new Pse({ Extends: qL, initialize: function(t) {
          t.topology = 5, t.batchSize = Mse(t, "batchSize", 256), qL.call(this, t);
        } });
        FL.exports = qse;
      });
      cd = u((pPe, OL) => {
        var Fse = C(), bL = B(), LL = er(), bse = Kn(), Lse = Zn(), Ose = Vt(), Dse = new Fse({ Extends: LL,
        initialize: function(t) {
          t.fragShader = bL(t, "fragShader", bse), t.vertShader = bL(t, "vertShader", Lse), t.forceZero =
          true, LL.call(this, t);
        }, boot: function() {
          Ose.prototype.boot.call(this);
          var e = this.renderer;
          this.set1i("uMainSampler", 0), this.set2f("uResolution", e.width, e.height);
        } });
        OL.exports = Dse;
      });
      pd = u((mPe, DL) => {
        var Nse = jf(), Ise = Qt(), Bse = C(), Gse = Ha(), Use = Io(), zse = ed(), Vo = B(), kse = id(),
        Xse = Lo(), vd = Vt(), Vse = new Bse({ Extends: vd, initialize: function(t) {
          t.renderTarget = Vo(t, "renderTarget", [{ scale: 1, autoResize: true }, { scale: 1, autoResize: true },
          { scale: 0.5, autoResize: true }, { scale: 0.5, autoResize: true }]), t.vertShader = Vo(t,
          "vertShader", Xse), t.shaders = Vo(t, "shaders", [{ name: "Copy", fragShader: zse }, { name: "\
AddBlend", fragShader: Nse }, { name: "LinearBlend", fragShader: kse }, { name: "ColorMatrix", fragShader: Use }]),
          t.attributes = Vo(t, "attributes", [{ name: "inPosition", size: 2 }, { name: "inTexCoord",
          size: 2 }]), t.vertices = [-1, -1, 0, 0, -1, 1, 0, 1, 1, 1, 1, 1, -1, -1, 0, 0, 1, 1, 1, 1,
          1, -1, 1, 0], t.batchSize = 1, vd.call(this, t), this.colorMatrix = new Gse(), this.copyShader,
          this.addShader, this.linearShader, this.colorMatrixShader, this.fullFrame1, this.fullFrame2,
          this.halfFrame1, this.halfFrame2;
        }, boot: function() {
          vd.prototype.boot.call(this);
          var e = this.shaders, t = this.renderTargets;
          this.copyShader = e[0], this.addShader = e[1], this.linearShader = e[2], this.colorMatrixShader =
          e[3], this.fullFrame1 = t[0], this.fullFrame2 = t[1], this.halfFrame1 = t[2], this.halfFrame2 =
          t[3];
        }, copyFrame: function(e, t, i, r, s) {
          i === void 0 && (i = 1), r === void 0 && (r = true), s === void 0 && (s = true);
          var n = this.gl;
          this.setShader(this.copyShader), this.set1i("uMainSampler", 0), this.set1f("uBrightness", i),
          n.activeTexture(n.TEXTURE0), n.bindTexture(n.TEXTURE_2D, e.texture.webGLTexture), t ? (n.viewport(
          0, 0, t.width, t.height), n.bindFramebuffer(n.FRAMEBUFFER, t.framebuffer.webGLFramebuffer),
          n.framebufferTexture2D(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0, n.TEXTURE_2D, t.texture.webGLTexture,
          0)) : n.viewport(0, 0, e.width, e.height), r && (s ? n.clearColor(0, 0, 0, 0) : n.clearColor(
          0, 0, 0, 1), n.clear(n.COLOR_BUFFER_BIT)), n.bufferData(n.ARRAY_BUFFER, this.vertexData, n.
          STATIC_DRAW), n.drawArrays(n.TRIANGLES, 0, 6), n.bindFramebuffer(n.FRAMEBUFFER, null), n.bindTexture(
          n.TEXTURE_2D, null);
        }, blitFrame: function(e, t, i, r, s, n, a) {
          i === void 0 && (i = 1), r === void 0 && (r = true), s === void 0 && (s = true), n === void 0 &&
          (n = false), a === void 0 && (a = false);
          var o = this.gl;
          if (this.setShader(this.copyShader), this.set1i("uMainSampler", 0), this.set1f("uBrightnes\
s", i), o.activeTexture(o.TEXTURE0), o.bindTexture(o.TEXTURE_2D, e.texture.webGLTexture), e.height >
          t.height) o.viewport(0, 0, e.width, e.height), this.setTargetUVs(e, t);
          else {
            var h = t.height - e.height;
            o.viewport(0, h, e.width, e.height);
          }
          if (o.bindFramebuffer(o.FRAMEBUFFER, t.framebuffer.webGLFramebuffer), o.framebufferTexture2D(
          o.FRAMEBUFFER, o.COLOR_ATTACHMENT0, o.TEXTURE_2D, t.texture.webGLTexture, 0), r && (s ? o.
          clearColor(0, 0, 0, 0) : o.clearColor(0, 0, 0, 1), o.clear(o.COLOR_BUFFER_BIT)), n) {
            var l = this.renderer.currentBlendMode;
            this.renderer.setBlendMode(Ise.ERASE);
          }
          a && this.flipY(), o.bufferData(o.ARRAY_BUFFER, this.vertexData, o.STATIC_DRAW), o.drawArrays(
          o.TRIANGLES, 0, 6), n && this.renderer.setBlendMode(l), o.bindFramebuffer(o.FRAMEBUFFER, null),
          o.bindTexture(o.TEXTURE_2D, null), this.resetUVs();
        }, copyFrameRect: function(e, t, i, r, s, n, a, o) {
          a === void 0 && (a = true), o === void 0 && (o = true);
          var h = this.gl;
          h.bindFramebuffer(h.FRAMEBUFFER, e.framebuffer.webGLFramebuffer), h.framebufferTexture2D(h.
          FRAMEBUFFER, h.COLOR_ATTACHMENT0, h.TEXTURE_2D, e.texture.webGLTexture, 0), a && (o ? h.clearColor(
          0, 0, 0, 0) : h.clearColor(0, 0, 0, 1), h.clear(h.COLOR_BUFFER_BIT)), h.activeTexture(h.TEXTURE0),
          h.bindTexture(h.TEXTURE_2D, t.texture.webGLTexture), h.copyTexSubImage2D(h.TEXTURE_2D, 0, 0,
          0, i, r, s, n), h.bindFramebuffer(h.FRAMEBUFFER, null), h.bindTexture(h.TEXTURE_2D, null);
        }, copyToGame: function(e) {
          var t = this.gl;
          this.setShader(this.copyShader), this.set1i("uMainSampler", 0), this.set1f("uBrightness", 1),
          this.renderer.popFramebuffer(), t.activeTexture(t.TEXTURE0), t.bindTexture(t.TEXTURE_2D, e.
          texture.webGLTexture), t.bufferData(t.ARRAY_BUFFER, this.vertexData, t.STATIC_DRAW), t.drawArrays(
          t.TRIANGLES, 0, 6);
        }, drawFrame: function(e, t, i, r) {
          i === void 0 && (i = true), r === void 0 && (r = this.colorMatrix);
          var s = this.gl;
          this.setShader(this.colorMatrixShader), this.set1i("uMainSampler", 0), this.set1fv("uColor\
Matrix", r.getData()), this.set1f("uAlpha", r.alpha), s.activeTexture(s.TEXTURE0), s.bindTexture(s.TEXTURE_2D,
          e.texture.webGLTexture), t ? (s.viewport(0, 0, t.width, t.height), s.bindFramebuffer(s.FRAMEBUFFER,
          t.framebuffer.webGLFramebuffer), s.framebufferTexture2D(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0,
          s.TEXTURE_2D, t.texture.webGLTexture, 0)) : s.viewport(0, 0, e.width, e.height), i ? s.clearColor(
          0, 0, 0, 0) : s.clearColor(0, 0, 0, 1), s.clear(s.COLOR_BUFFER_BIT), s.bufferData(s.ARRAY_BUFFER,
          this.vertexData, s.STATIC_DRAW), s.drawArrays(s.TRIANGLES, 0, 6), s.bindFramebuffer(s.FRAMEBUFFER,
          null), s.bindTexture(s.TEXTURE_2D, null);
        }, blendFrames: function(e, t, i, r, s, n) {
          r === void 0 && (r = 1), s === void 0 && (s = true), n === void 0 && (n = this.linearShader);
          var a = this.gl;
          this.setShader(n), this.set1i("uMainSampler1", 0), this.set1i("uMainSampler2", 1), this.set1f(
          "uStrength", r), a.activeTexture(a.TEXTURE0), a.bindTexture(a.TEXTURE_2D, e.texture.webGLTexture),
          a.activeTexture(a.TEXTURE1), a.bindTexture(a.TEXTURE_2D, t.texture.webGLTexture), i ? (a.bindFramebuffer(
          a.FRAMEBUFFER, i.framebuffer.webGLFramebuffer), a.framebufferTexture2D(a.FRAMEBUFFER, a.COLOR_ATTACHMENT0,
          a.TEXTURE_2D, i.texture.webGLTexture, 0), a.viewport(0, 0, i.width, i.height)) : a.viewport(
          0, 0, e.width, e.height), s ? a.clearColor(0, 0, 0, 0) : a.clearColor(0, 0, 0, 1), a.clear(
          a.COLOR_BUFFER_BIT), a.bufferData(a.ARRAY_BUFFER, this.vertexData, a.STATIC_DRAW), a.drawArrays(
          a.TRIANGLES, 0, 6), a.bindFramebuffer(a.FRAMEBUFFER, null), a.bindTexture(a.TEXTURE_2D, null);
        }, blendFramesAdditive: function(e, t, i, r, s) {
          this.blendFrames(e, t, i, r, s, this.addShader);
        }, clearFrame: function(e, t) {
          t === void 0 && (t = true);
          var i = this.gl;
          i.viewport(0, 0, e.width, e.height), i.bindFramebuffer(i.FRAMEBUFFER, e.framebuffer.webGLFramebuffer),
          t ? i.clearColor(0, 0, 0, 0) : i.clearColor(0, 0, 0, 1), i.clear(i.COLOR_BUFFER_BIT);
          var r = this.renderer.currentFramebuffer;
          i.bindFramebuffer(i.FRAMEBUFFER, r.webGLFramebuffer);
        }, setUVs: function(e, t, i, r, s, n, a, o) {
          var h = this.vertexViewF32;
          h[2] = e, h[3] = t, h[6] = i, h[7] = r, h[10] = s, h[11] = n, h[14] = e, h[15] = t, h[18] =
          s, h[19] = n, h[22] = a, h[23] = o;
        }, setTargetUVs: function(e, t) {
          var i = t.height / e.height;
          i > 0.5 ? i = 0.5 - (i - 0.5) : i = 0.5 + (0.5 - i), this.setUVs(0, i, 0, 1 + i, 1, 1 + i,
          1, i);
        }, flipX: function() {
          this.setUVs(1, 0, 1, 1, 0, 1, 0, 0);
        }, flipY: function() {
          this.setUVs(0, 1, 0, 0, 1, 0, 1, 1);
        }, resetUVs: function() {
          this.setUVs(0, 0, 0, 1, 1, 1, 1, 0);
        } });
        DL.exports = Vse;
      });
      gd = u((gPe, NL) => {
        var Yse = C(), vt = kn(), md = rs(), Wse = En(), Hse = B(), Os = qr(), Kse = hf(), Zse = Rf(),
        pt = No(), mt = Me(), Qse = ad(), Jse = od(), $se = ud(), jse = er(), ene = fd(), tne = dd(),
        ine = cd(), rne = pd(), sne = mn(), nne = Jt(), ane = new Yse({ initialize: function(t) {
          this.game = t.game, this.renderer = t, this.classes = new md([[vt.UTILITY_PIPELINE, rne], [
          vt.MULTI_PIPELINE, jse], [vt.BITMAPMASK_PIPELINE, Zse], [vt.SINGLE_PIPELINE, ine], [vt.ROPE_PIPELINE,
          tne], [vt.LIGHT_PIPELINE, Jse], [vt.POINTLIGHT_PIPELINE, ene], [vt.MOBILE_PIPELINE, $se]]),
          this.postPipelineClasses = new md(), this.pipelines = new md(), this.postPipelineInstances =
          [], this.default = null, this.current = null, this.previous = null, this.MULTI_PIPELINE = null,
          this.BITMAPMASK_PIPELINE = null, this.UTILITY_PIPELINE = null, this.MOBILE_PIPELINE = null,
          this.FX_PIPELINE = null, this.fullFrame1, this.fullFrame2, this.halfFrame1, this.halfFrame2,
          this.renderTargets = [], this.maxDimension = 0, this.frameInc = 32, this.targetIndex = 0;
        }, boot: function(e, t, i) {
          var r = this.renderer, s = this.renderTargets;
          this.frameInc = Math.floor(Hse(e, "frameInc", 32));
          var n = r.width, a = r.height, o = this.game.config.disablePreFX, h = this.game.config.disablePostFX;
          if (h || this.postPipelineClasses.setAll([[String(mt.BARREL), pt.Barrel], [String(mt.BLOOM),
          pt.Bloom], [String(mt.BLUR), pt.Blur], [String(mt.BOKEH), pt.Bokeh], [String(mt.CIRCLE), pt.
          Circle], [String(mt.COLOR_MATRIX), pt.ColorMatrix], [String(mt.DISPLACEMENT), pt.Displacement],
          [String(mt.GLOW), pt.Glow], [String(mt.GRADIENT), pt.Gradient], [String(mt.PIXELATE), pt.Pixelate],
          [String(mt.SHADOW), pt.Shadow], [String(mt.SHINE), pt.Shine], [String(mt.VIGNETTE), pt.Vignette],
          [String(mt.WIPE), pt.Wipe]]), !o) {
            this.classes.set(vt.FX_PIPELINE, Qse);
            for (var l = Math.min(n, a), f = Math.ceil(l / this.frameInc), d = 1; d < f; d++) {
              var c = d * this.frameInc;
              s.push(new Os(r, c, c)), s.push(new Os(r, c, c)), s.push(new Os(r, c, c)), this.maxDimension =
              c;
            }
            s.push(new Os(r, n, a, 1, 0, true, true)), s.push(new Os(r, n, a, 1, 0, true, true)), s.
            push(new Os(r, n, a, 1, 0, true, true));
          }
          var p, v, m = this, g = this.game;
          if (this.classes.each(function(E, T15) {
            p = m.add(E, new T15({ game: g })), E === vt.UTILITY_PIPELINE && (m.UTILITY_PIPELINE = p,
            m.fullFrame1 = p.fullFrame1, m.fullFrame2 = p.fullFrame2, m.halfFrame1 = p.halfFrame1, m.
            halfFrame2 = p.halfFrame2);
          }), this.MULTI_PIPELINE = this.get(vt.MULTI_PIPELINE), this.BITMAPMASK_PIPELINE = this.get(
          vt.BITMAPMASK_PIPELINE), this.MOBILE_PIPELINE = this.get(vt.MOBILE_PIPELINE), o || (this.FX_PIPELINE =
          this.get(vt.FX_PIPELINE)), e) for (v in e) {
            var x = e[v];
            p = new x(g), p.name = v, p.isPostFX ? this.postPipelineClasses.set(v, x) : this.has(v) ||
            (this.classes.set(v, x), this.add(v, p));
          }
          this.default = this.get(t), i && !Wse.os.desktop && (this.default = this.MOBILE_PIPELINE);
        }, setDefaultPipeline: function(e) {
          var t = this.get(e);
          return t && (this.default = t), t;
        }, add: function(e, t) {
          if (t.isPostFX) {
            console.warn(e + " is a Post Pipeline. Use `addPostPipeline` instead");
            return;
          }
          var i = this.pipelines, r = this.renderer;
          return i.has(e) ? console.warn("Pipeline exists: " + e) : (t.name = e, t.manager = this, i.
          set(e, t)), t.hasBooted || t.boot(), r.width !== 0 && r.height !== 0 && !t.isPreFX && t.resize(
          r.width, r.height), t;
        }, addPostPipeline: function(e, t) {
          this.postPipelineClasses.has(e) || this.postPipelineClasses.set(e, t);
        }, flush: function() {
          this.current && this.current.flush();
        }, has: function(e) {
          var t = this.pipelines;
          return typeof e == "string" ? t.has(e) : !!t.contains(e);
        }, get: function(e) {
          var t = this.pipelines;
          if (typeof e == "string") return t.get(e);
          if (t.contains(e)) return e;
        }, getPostPipeline: function(e, t, i) {
          var r = this.postPipelineClasses, s, n = "", a = typeof e;
          if (a === "string" || a === "number" ? (s = r.get(e), n = e) : a === "function" ? (r.contains(
          e) && (s = e), n = e.name) : a === "object" && (s = r.get(e.name), n = e.name), s) {
            var o = new s(this.game, i);
            return o.name = n, t && (o.gameObject = t), this.postPipelineInstances.push(o), o;
          }
        }, removePostPipeline: function(e) {
          nne(this.postPipelineInstances, e);
        }, remove: function(e, t, i) {
          t === void 0 && (t = true), i === void 0 && (i = true), this.pipelines.delete(e), t && this.
          classes.delete(e), i && this.postPipelineClasses.delete(e);
        }, set: function(e, t, i) {
          if (!e.isPostFX) return this.isCurrent(e, i) || (this.flush(), this.current && this.current.
          unbind(), this.current = e, e.bind(i)), e.updateProjectionMatrix(), e.onBind(t), e;
        }, preBatch: function(e) {
          if (e.hasPostPipeline) {
            this.flush();
            for (var t = e.postPipelines, i = t.length - 1; i >= 0; i--) {
              var r = t[i];
              r.active && r.preBatch(e);
            }
          }
        }, postBatch: function(e) {
          if (e.hasPostPipeline) {
            this.flush();
            for (var t = e.postPipelines, i = 0; i < t.length; i++) {
              var r = t[i];
              r.active && r.postBatch(e);
            }
          }
        }, preBatchCamera: function(e) {
          if (e.hasPostPipeline) {
            this.flush();
            for (var t = e.postPipelines, i = t.length - 1; i >= 0; i--) {
              var r = t[i];
              r.active && r.preBatch(e);
            }
          }
        }, postBatchCamera: function(e) {
          if (e.hasPostPipeline) {
            this.flush();
            for (var t = e.postPipelines, i = 0; i < t.length; i++) {
              var r = t[i];
              r.active && r.postBatch(e);
            }
          }
        }, isCurrent: function(e, t) {
          var i = this.renderer, r = this.current;
          return r && !t && (t = r.currentShader), !(r !== e || t.program !== i.currentProgram);
        }, copyFrame: function(e, t, i, r, s) {
          return this.setUtility(this.UTILITY_PIPELINE.copyShader).copyFrame(e, t, i, r, s), this;
        }, copyToGame: function(e) {
          return this.setUtility(this.UTILITY_PIPELINE.copyShader).copyToGame(e), this;
        }, drawFrame: function(e, t, i, r) {
          return this.setUtility(this.UTILITY_PIPELINE.colorMatrixShader).drawFrame(e, t, i, r), this;
        }, blendFrames: function(e, t, i, r, s) {
          return this.setUtility(this.UTILITY_PIPELINE.linearShader).blendFrames(e, t, i, r, s), this;
        }, blendFramesAdditive: function(e, t, i, r, s) {
          return this.setUtility(this.UTILITY_PIPELINE.addShader).blendFramesAdditive(e, t, i, r, s),
          this;
        }, clearFrame: function(e, t) {
          return this.UTILITY_PIPELINE.clearFrame(e, t), this;
        }, blitFrame: function(e, t, i, r, s, n) {
          return this.setUtility(this.UTILITY_PIPELINE.copyShader).blitFrame(e, t, i, r, s, n), this;
        }, copyFrameRect: function(e, t, i, r, s, n, a, o) {
          return this.UTILITY_PIPELINE.copyFrameRect(e, t, i, r, s, n, a, o), this;
        }, forceZero: function() {
          return this.current && this.current.forceZero;
        }, setMulti: function() {
          return this.set(this.MULTI_PIPELINE);
        }, setUtility: function(e) {
          return this.UTILITY_PIPELINE.bind(e);
        }, setFX: function() {
          return this.set(this.FX_PIPELINE);
        }, restoreContext: function() {
          this.rebind(), this.pipelines.each(function(e, t) {
            t.restoreContext();
          }), sne(this.postPipelineInstances, function(e) {
            e.restoreContext();
          });
        }, rebind: function(e) {
          e === void 0 && this.previous && (e = this.previous);
          var t = this.renderer, i = t.gl;
          i.disable(i.DEPTH_TEST), i.disable(i.CULL_FACE), t.hasActiveStencilMask() ? i.clear(i.DEPTH_BUFFER_BIT) :
          (i.disable(i.STENCIL_TEST), i.clear(i.DEPTH_BUFFER_BIT | i.STENCIL_BUFFER_BIT)), i.viewport(
          0, 0, t.width, t.height), t.currentProgram = null, t.setBlendMode(0, true);
          var r = t.vaoExtension;
          r && r.bindVertexArrayOES(null);
          var s = this.pipelines.entries;
          for (var n in s) s[n].glReset = true;
          e && (this.current = e, e.rebind());
        }, clear: function() {
          var e = this.renderer;
          this.flush(), this.current ? (this.current.unbind(), this.previous = this.current, this.current =
          null) : this.previous = null, e.currentProgram = null, e.setBlendMode(0, true);
          var t = e.vaoExtension;
          t && t.bindVertexArrayOES(null);
        }, getRenderTarget: function(e) {
          var t = this.renderTargets, i = 3;
          if (e > this.maxDimension) return this.targetIndex = t.length - i, t[this.targetIndex];
          var r = (Kse(e, this.frameInc, 0, true) - 1) * i;
          return this.targetIndex = r, t[r];
        }, getSwapRenderTarget: function() {
          return this.renderTargets[this.targetIndex + 1];
        }, getAltSwapRenderTarget: function() {
          return this.renderTargets[this.targetIndex + 2];
        }, destroy: function() {
          this.flush(), this.classes.clear(), this.postPipelineClasses.clear(), this.pipelines.clear(),
          this.renderer = null, this.game = null, this.classes = null, this.postPipelineClasses = null,
          this.pipelines = null, this.default = null, this.current = null, this.previous = null;
        } });
        NL.exports = ane;
      });
      Ed = u((xPe, IL) => {
        var xd = Tt(), one = Ai(), Yt = B(), hne = function(e, t) {
          var i = e, r = Yt(t, "callback"), s = Yt(t, "type", "image/png"), n = Yt(t, "encoder", 0.92),
          a = Math.abs(Math.round(Yt(t, "x", 0))), o = Math.abs(Math.round(Yt(t, "y", 0))), h = Yt(t,
          "getPixel", false), l = Yt(t, "isFramebuffer", false), f = l ? Yt(t, "bufferWidth", 1) : i.
          drawingBufferWidth, d = l ? Yt(t, "bufferHeight", 1) : i.drawingBufferHeight;
          if (h) {
            var c = new Uint8Array(4), p = l ? o : d - o;
            i.readPixels(a, p, 1, 1, i.RGBA, i.UNSIGNED_BYTE, c), r.call(null, new one(c[0], c[1], c[2],
            c[3]));
          } else {
            var v = Math.floor(Yt(t, "width", f)), m = Math.floor(Yt(t, "height", d)), g = v * m * 4,
            x = new Uint8Array(g);
            i.readPixels(a, d - o - m, v, m, i.RGBA, i.UNSIGNED_BYTE, x);
            for (var E = xd.createWebGL(this, v, m), T15 = E.getContext("2d", { willReadFrequently: true }),
            w = T15.getImageData(0, 0, v, m), y = w.data, A10 = 0; A10 < m; A10++) for (var S14 = 0; S14 <
            v; S14++) {
              var _ = ((m - A10 - 1) * v + S14) * 4, q = l ? g - (A10 * v + (v - S14)) * 4 : (A10 * v +
              S14) * 4;
              y[q + 0] = x[_ + 0], y[q + 1] = x[_ + 1], y[q + 2] = x[_ + 2], y[q + 3] = x[_ + 3];
            }
            T15.putImageData(w, 0, 0);
            var P = new Image();
            P.onerror = function() {
              r.call(null), xd.remove(E);
            }, P.onload = function() {
              r.call(null, P), xd.remove(E);
            }, P.src = E.toDataURL(s, n);
          }
        };
        IL.exports = hne;
      });
      Td = u((EPe, BL) => {
        var une = C(), lne = new une({ initialize: function(t, i, r, s) {
          this.webGLBuffer = null, this.gl = t, this.initialDataOrSize = i, this.bufferType = r, this.
          bufferUsage = s, this.createResource();
        }, createResource: function() {
          if (this.initialDataOrSize !== null) {
            var e = this.gl;
            if (!e.isContextLost()) {
              var t = this.bufferType, i = e.createBuffer();
              this.webGLBuffer = i, e.bindBuffer(t, this.webGLBuffer), e.bufferData(t, this.initialDataOrSize,
              this.bufferUsage), e.bindBuffer(t, null);
            }
          }
        }, destroy: function() {
          var e = this.gl;
          e.isContextLost() || e.deleteBuffer(this.webGLBuffer), this.webGLBuffer = null, this.initialDataOrSize =
          null, this.gl = null;
        } });
        BL.exports = lne;
      });
      yd = u((TPe, GL) => {
        var fne = C(), dne = new fne({ initialize: function(t, i, r) {
          this.webGLProgram = null, this.gl = t, this.vertexSource = i, this.fragmentSource = r, this.
          createResource();
        }, createResource: function() {
          var e = this.gl;
          if (!e.isContextLost()) {
            var t = e.createProgram(), i = e.createShader(e.VERTEX_SHADER), r = e.createShader(e.FRAGMENT_SHADER);
            e.shaderSource(i, this.vertexSource), e.shaderSource(r, this.fragmentSource), e.compileShader(
            i), e.compileShader(r);
            var s = `Shader failed:
`;
            if (!e.getShaderParameter(i, e.COMPILE_STATUS)) throw new Error("Vertex " + s + e.getShaderInfoLog(
            i));
            if (!e.getShaderParameter(r, e.COMPILE_STATUS)) throw new Error("Fragment " + s + e.getShaderInfoLog(
            r));
            if (e.attachShader(t, i), e.attachShader(t, r), e.linkProgram(t), !e.getProgramParameter(
            t, e.LINK_STATUS)) throw new Error("Link " + s + e.getProgramInfoLog(t));
            e.useProgram(t), this.webGLProgram = t;
          }
        }, destroy: function() {
          this.webGLProgram && (this.gl.isContextLost() || this.gl.deleteProgram(this.webGLProgram),
          this.webGLProgram = null, this.gl = null);
        } });
        GL.exports = dne;
      });
      Yo = u((yPe, UL) => {
        var cne = C(), Sd = Cs(), wd = new cne({ initialize: function(t, i, r, s, n, a, o, h, l, f, d, c, p) {
          this.webGLTexture = null, this.isRenderTexture = false, this.gl = t, this.mipLevel = i, this.
          minFilter = r, this.magFilter = s, this.wrapT = n, this.wrapS = a, this.format = o, this.pixels =
          h, this.width = l, this.height = f, this.pma = d == null ? true : d, this.forceSize = !!c,
          this.flipY = !!p, this.__SPECTOR_Metadata = {}, this.createResource();
        }, createResource: function() {
          var e = this.gl;
          if (!e.isContextLost()) {
            if (this.pixels instanceof wd) {
              this.webGLTexture = this.pixels.webGLTexture;
              return;
            }
            var t = e.createTexture();
            t.__SPECTOR_Metadata = this.__SPECTOR_Metadata, this.webGLTexture = t, this._processTexture();
          }
        }, update: function(e, t, i, r, s, n, a, o, h) {
          if (!(t === 0 || i === 0)) {
            this.pixels = e, this.width = t, this.height = i, this.flipY = r, this.wrapS = s, this.wrapT =
            n, this.minFilter = a, this.magFilter = o, this.format = h;
            var l = this.gl;
            l.isContextLost() || this._processTexture();
          }
        }, _processTexture: function() {
          var e = this.gl;
          e.activeTexture(e.TEXTURE0);
          var t = e.getParameter(e.TEXTURE_BINDING_2D);
          e.bindTexture(e.TEXTURE_2D, this.webGLTexture), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER,
          this.minFilter), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, this.magFilter), e.texParameteri(
          e.TEXTURE_2D, e.TEXTURE_WRAP_S, this.wrapS), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T,
          this.wrapT), e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this.pma), e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL,
          this.flipY);
          var i = this.pixels, r = this.mipLevel, s = this.width, n = this.height, a = this.format, o = false;
          if (i == null) e.texImage2D(e.TEXTURE_2D, r, a, s, n, 0, a, e.UNSIGNED_BYTE, null), o = Sd(
          s, n);
          else if (i.compressed) {
            s = i.width, n = i.height, o = i.generateMipmap;
            for (var h = 0; h < i.mipmaps.length; h++) e.compressedTexImage2D(e.TEXTURE_2D, h, i.internalFormat,
            i.mipmaps[h].width, i.mipmaps[h].height, 0, i.mipmaps[h].data);
          } else i instanceof Uint8Array ? (e.texImage2D(e.TEXTURE_2D, r, a, s, n, 0, a, e.UNSIGNED_BYTE,
          i), o = Sd(s, n)) : (this.forceSize || (s = i.width, n = i.height), e.texImage2D(e.TEXTURE_2D,
          r, a, a, e.UNSIGNED_BYTE, i), o = Sd(s, n));
          o && e.generateMipmap(e.TEXTURE_2D), t ? e.bindTexture(e.TEXTURE_2D, t) : e.bindTexture(e.
          TEXTURE_2D, null);
        }, spectorMetadata: { get: function() {
          return this.__SPECTOR_Metadata;
        }, set: function(e) {
          this.__SPECTOR_Metadata = e, this.gl.isContextLost() || (this.webGLTexture.__SPECTOR_Metadata =
          e);
        } }, destroy: function() {
          this.webGLTexture !== null && (this.gl.isContextLost() || this.pixels instanceof wd || this.
          gl.deleteTexture(this.webGLTexture), this.pixels = null, this.webGLTexture = null, this.gl =
          null);
        } });
        UL.exports = wd;
      });
      Cd = u((SPe, zL) => {
        var vne = C(), pne = { 36054: "Incomplete Attachment", 36055: "Missing Attachment", 36057: "\
Incomplete Dimensions", 36061: "Framebuffer Unsupported" }, mne = new vne({ initialize: function(t, i, r, s, n) {
          this.webGLFramebuffer = null, this.gl = t, this.width = i, this.height = r, this.renderTexture =
          s, this.addDepthStencilBuffer = !!n, this.createResource();
        }, createResource: function() {
          var e = this.gl;
          if (!e.isContextLost()) {
            var t = this.renderTexture, i = 0, r = e.createFramebuffer();
            if (this.webGLFramebuffer = r, e.bindFramebuffer(e.FRAMEBUFFER, r), t.isRenderTexture = true,
            t.isAlphaPremultiplied = false, e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0,
            e.TEXTURE_2D, t.webGLTexture, 0), i = e.checkFramebufferStatus(e.FRAMEBUFFER), i !== e.FRAMEBUFFER_COMPLETE)
             throw new Error("Framebuffer status: " + (pne[i] || i));
            if (this.addDepthStencilBuffer) {
              var s = e.createRenderbuffer();
              e.bindRenderbuffer(e.RENDERBUFFER, s), e.renderbufferStorage(e.RENDERBUFFER, e.DEPTH_STENCIL,
              this.width, this.height), e.framebufferRenderbuffer(e.FRAMEBUFFER, e.DEPTH_STENCIL_ATTACHMENT,
              e.RENDERBUFFER, s);
            }
            e.bindFramebuffer(e.FRAMEBUFFER, null);
          }
        }, destroy: function() {
          if (this.webGLFramebuffer !== null) {
            var e = this.gl;
            if (!e.isContextLost()) {
              e.bindFramebuffer(e.FRAMEBUFFER, this.webGLFramebuffer);
              var t = e.getFramebufferAttachmentParameter(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.FRAMEBUFFER_ATTACHMENT_OBJECT_NAME);
              t !== null && (e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D,
              null, 0), e.deleteTexture(t));
              var i = e.getFramebufferAttachmentParameter(e.FRAMEBUFFER, e.DEPTH_STENCIL_ATTACHMENT,
              e.FRAMEBUFFER_ATTACHMENT_OBJECT_NAME);
              i !== null && e.deleteRenderbuffer(i), e.bindFramebuffer(e.FRAMEBUFFER, null), e.deleteFramebuffer(
              this.webGLFramebuffer);
            }
            this.renderTexture = null, this.webGLFramebuffer = null, this.gl = null;
          }
        } });
        zL.exports = mne;
      });
      Ad = u((wPe, kL) => {
        var gne = C(), xne = new gne({ initialize: function(t, i, r) {
          this.webGLAttribLocation = -1, this.gl = t, this.program = i, this.name = r, this.createResource();
        }, createResource: function() {
          if (this.program.webGLProgram === null) {
            this.webGLAttribLocation = -1;
            return;
          }
          var e = this.gl;
          e.isContextLost() || (this.webGLAttribLocation = e.getAttribLocation(this.program.webGLProgram,
          this.name));
        }, destroy: function() {
          this.gl = null, this.program = null, this.name = null, this.webGLAttribLocation = -1;
        } });
        kL.exports = xne;
      });
      Rd = u((CPe, XL) => {
        var Ene = C(), Tne = new Ene({ initialize: function(t, i, r) {
          this.webGLUniformLocation = null, this.gl = t, this.program = i, this.name = r, this.createResource();
        }, createResource: function() {
          if (this.program.webGLProgram === null) {
            this.webGLUniformLocation = null;
            return;
          }
          var e = this.gl;
          e.isContextLost() || (this.webGLUniformLocation = e.getUniformLocation(this.program.webGLProgram,
          this.name));
        }, destroy: function() {
          this.gl = null, this.program = null, this.name = null, this.webGLUniformLocation = null;
        } });
        XL.exports = Tne;
      });
      Pd = u((RPe, KL) => {
        var It = mn(), Lr = Jt(), VL = Dt(), yne = C(), Or = qt(), YL = Z(), Dr = qs(), Wo = Cs(), Sne = _s(),
        Ho = J(), wne = gd(), _d = qr(), Cne = Ss(), Ane = Fs(), Ko = wt(), WL = Ed(), HL = Td(), Rne = yd(),
        _ne = Yo(), Pne = Cd(), Mne = Ad(), qne = Rd(), _i = false, Fne = new yne({ Extends: YL, initialize: function(t) {
          YL.call(this);
          var i = t.config, r = { alpha: i.transparent, desynchronized: i.desynchronized, depth: true,
          antialias: i.antialiasGL, premultipliedAlpha: i.premultipliedAlpha, stencil: true, failIfMajorPerformanceCaveat: i.
          failIfMajorPerformanceCaveat, powerPreference: i.powerPreference, preserveDrawingBuffer: i.
          preserveDrawingBuffer, willReadFrequently: false };
          this.config = { clearBeforeRender: i.clearBeforeRender, antialias: i.antialias, backgroundColor: i.
          backgroundColor, contextCreation: r, roundPixels: i.roundPixels, maxTextures: i.maxTextures,
          maxTextureSize: i.maxTextureSize, batchSize: i.batchSize, maxLights: i.maxLights, mipmapFilter: i.
          mipmapFilter }, this.game = t, this.type = Or.WEBGL, this.pipelines = null, this.width = 0,
          this.height = 0, this.canvas = t.canvas, this.blendModes = [], this.contextLost = false, this.
          snapshotState = { x: 0, y: 0, width: 1, height: 1, getPixel: false, callback: null, type: "\
image/png", encoder: 0.92, isFramebuffer: false, bufferWidth: 0, bufferHeight: 0 }, this.maxTextures =
          0, this.textureIndexes, this.glBufferWrappers = [], this.glProgramWrappers = [], this.glTextureWrappers =
          [], this.glFramebufferWrappers = [], this.glAttribLocationWrappers = [], this.glUniformLocationWrappers =
          [], this.currentFramebuffer = null, this.fboStack = [], this.currentProgram = null, this.currentBlendMode =
          1 / 0, this.currentScissorEnabled = false, this.currentScissor = null, this.scissorStack =
          [], this.contextLostHandler = Ho, this.contextRestoredHandler = Ho, this.previousContextLostHandler =
          Ho, this.previousContextRestoredHandler = Ho, this.gl = null, this.supportedExtensions = null,
          this.instancedArraysExtension = null, this.vaoExtension = null, this.extensions = {}, this.
          glFormats, this.compression, this.drawingBufferHeight = 0, this.blankTexture = null, this.
          normalTexture = null, this.whiteTexture = null, this.maskCount = 0, this.maskStack = [], this.
          currentMask = { mask: null, camera: null }, this.currentCameraMask = { mask: null, camera: null },
          this.glFuncMap = null, this.currentType = "", this.newType = false, this.nextTypeMatch = false,
          this.finalType = false, this.mipmapFilter = null, this.defaultScissor = [0, 0, 0, 0], this.
          isBooted = false, this.renderTarget = null, this.projectionMatrix, this.projectionWidth = 0,
          this.projectionHeight = 0, this.maskSource = null, this.maskTarget = null, this.spector = null,
          this._debugCapture = false, this.init(this.config);
        }, init: function(e) {
          var t, i = this.game, r = this.canvas, s = e.backgroundColor;
          if (_i && (this.spector = new APe.Spector(), this.spector.onCapture.add(this.onCapture.bind(
          this))), i.config.context ? t = i.config.context : t = r.getContext("webgl", e.contextCreation) ||
          r.getContext("experimental-webgl", e.contextCreation), !t || t.isContextLost()) throw this.
          contextLost = true, new Error("WebGL unsupported");
          this.gl = t, this.setExtensions(), this.setContextHandlers(), i.context = t;
          for (var n = 0; n <= 27; n++) this.blendModes.push({ func: [t.ONE, t.ONE_MINUS_SRC_ALPHA],
          equation: t.FUNC_ADD });
          this.blendModes[1].func = [t.ONE, t.DST_ALPHA], this.blendModes[2].func = [t.DST_COLOR, t.
          ONE_MINUS_SRC_ALPHA], this.blendModes[3].func = [t.ONE, t.ONE_MINUS_SRC_COLOR], this.blendModes[17] =
          { func: [t.ZERO, t.ONE_MINUS_SRC_ALPHA], equation: t.FUNC_REVERSE_SUBTRACT }, this.glFormats =
          [t.BYTE, t.SHORT, t.UNSIGNED_BYTE, t.UNSIGNED_SHORT, t.FLOAT], this.glFuncMap = { mat2: { func: t.
          uniformMatrix2fv, length: 1, matrix: true }, mat3: { func: t.uniformMatrix3fv, length: 1, matrix: true },
          mat4: { func: t.uniformMatrix4fv, length: 1, matrix: true }, "1f": { func: t.uniform1f, length: 1 },
          "1fv": { func: t.uniform1fv, length: 1 }, "1i": { func: t.uniform1i, length: 1 }, "1iv": {
          func: t.uniform1iv, length: 1 }, "2f": { func: t.uniform2f, length: 2 }, "2fv": { func: t.
          uniform2fv, length: 1 }, "2i": { func: t.uniform2i, length: 2 }, "2iv": { func: t.uniform2iv,
          length: 1 }, "3f": { func: t.uniform3f, length: 3 }, "3fv": { func: t.uniform3fv, length: 1 },
          "3i": { func: t.uniform3i, length: 3 }, "3iv": { func: t.uniform3iv, length: 1 }, "4f": { func: t.
          uniform4f, length: 4 }, "4fv": { func: t.uniform4fv, length: 1 }, "4i": { func: t.uniform4i,
          length: 4 }, "4iv": { func: t.uniform4iv, length: 1 } }, (!e.maxTextures || e.maxTextures ===
          -1) && (e.maxTextures = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)), e.maxTextureSize || (e.
          maxTextureSize = t.getParameter(t.MAX_TEXTURE_SIZE)), this.compression = this.getCompressedTextures(),
          t.disable(t.DEPTH_TEST), t.disable(t.CULL_FACE), t.enable(t.BLEND), t.clearColor(s.redGL, s.
          greenGL, s.blueGL, s.alphaGL), t.clear(t.COLOR_BUFFER_BIT);
          var a = ["NEAREST", "LINEAR", "NEAREST_MIPMAP_NEAREST", "LINEAR_MIPMAP_NEAREST", "NEAREST_\
MIPMAP_LINEAR", "LINEAR_MIPMAP_LINEAR"];
          return a.indexOf(e.mipmapFilter) !== -1 && (this.mipmapFilter = t[e.mipmapFilter]), this.maxTextures =
          Ko.checkShaderMax(t, e.maxTextures), this.textureIndexes = [], this.createTemporaryTextures(),
          this.pipelines = new wne(this), this.setBlendMode(Or.BlendModes.NORMAL), this.projectionMatrix =
          new Sne().identity(), i.textures.once(Ane.READY, this.boot, this), this;
        }, boot: function() {
          var e = this.game, t = this.pipelines, i = e.scale.baseSize, r = i.width, s = i.height;
          this.width = r, this.height = s, this.isBooted = true, this.renderTarget = new _d(this, r,
          s, 1, 0, true, true), this.maskTarget = new _d(this, r, s, 1, 0, true, true), this.maskSource =
          new _d(this, r, s, 1, 0, true, true);
          var n = e.config;
          t.boot(n.pipeline, n.defaultPipeline, n.autoMobilePipeline), this.blankTexture = e.textures.
          getFrame("__DEFAULT").glTexture, this.normalTexture = e.textures.getFrame("__NORMAL").glTexture,
          this.whiteTexture = e.textures.getFrame("__WHITE").glTexture;
          var a = this.gl;
          a.bindFramebuffer(a.FRAMEBUFFER, null), a.enable(a.SCISSOR_TEST), e.scale.on(Cne.RESIZE, this.
          onResize, this), this.resize(r, s);
        }, setExtensions: function() {
          var e = this.gl, t = e.getSupportedExtensions();
          this.supportedExtensions = t;
          var i = "ANGLE_instanced_arrays";
          this.instancedArraysExtension = t.indexOf(i) > -1 ? e.getExtension(i) : null;
          var r = "OES_vertex_array_object";
          this.vaoExtension = t.indexOf(r) > -1 ? e.getExtension(r) : null;
        }, setContextHandlers: function(e, t) {
          this.previousContextLostHandler && this.canvas.removeEventListener("webglcontextlost", this.
          previousContextLostHandler, false), this.previousContextRestoredHandler && this.canvas.removeEventListener(
          "webglcontextlost", this.previousContextRestoredHandler, false), typeof e == "function" ? this.
          contextLostHandler = e.bind(this) : this.contextLostHandler = this.dispatchContextLost.bind(
          this), typeof t == "function" ? this.contextRestoredHandler = t.bind(this) : this.contextRestoredHandler =
          this.dispatchContextRestored.bind(this), this.canvas.addEventListener("webglcontextlost", this.
          contextLostHandler, false), this.canvas.addEventListener("webglcontextrestored", this.contextRestoredHandler,
          false), this.previousContextLostHandler = this.contextLostHandler, this.previousContextRestoredHandler =
          this.contextRestoredHandler;
        }, dispatchContextLost: function(e) {
          this.contextLost = true, console && console.warn("WebGL Context lost. Renderer disabled"),
          this.emit(Dr.LOSE_WEBGL, this), e.preventDefault();
        }, dispatchContextRestored: function(e) {
          var t = this.gl;
          if (t.isContextLost()) {
            console && console.log("WebGL Context restored, but context is still lost");
            return;
          }
          this.currentProgram = null, this.currentFramebuffer = null, this.setBlendMode(Or.BlendModes.
          NORMAL), t.disable(t.BLEND), t.disable(t.DEPTH_TEST), t.enable(t.CULL_FACE), this.compression =
          this.getCompressedTextures();
          var i = function(r) {
            r.createResource();
          };
          It(this.glTextureWrappers, i), It(this.glBufferWrappers, i), It(this.glFramebufferWrappers,
          i), It(this.glProgramWrappers, i), It(this.glAttribLocationWrappers, i), It(this.glUniformLocationWrappers,
          i), this.createTemporaryTextures(), this.pipelines.restoreContext(), this.resize(this.game.
          scale.baseSize.width, this.game.scale.baseSize.height), this.setExtensions(), this.contextLost =
          false, console && console.warn("WebGL Context restored. Renderer running again."), this.emit(
          Dr.RESTORE_WEBGL, this), e.preventDefault();
        }, createTemporaryTextures: function() {
          for (var e = this.gl, t = 0; t < this.maxTextures; t++) {
            var i = e.createTexture();
            e.activeTexture(e.TEXTURE0 + t), e.bindTexture(e.TEXTURE_2D, i), e.texImage2D(e.TEXTURE_2D,
            0, e.RGBA, 1, 1, 0, e.RGBA, e.UNSIGNED_BYTE, new Uint8Array([0, 0, 255, 255])), this.textureIndexes.
            push(t);
          }
        }, captureFrame: function(e, t) {
          e === void 0 && (e = false), t === void 0 && (t = false), _i && this.spector && !this._debugCapture &&
          (this.spector.captureCanvas(this.canvas, 0, e, t), this._debugCapture = true);
        }, captureNextFrame: function() {
          _i && this.spector && !this._debugCapture && (this._debugCapture = true, this.spector.captureNextFrame(
          this.canvas));
        }, getFps: function() {
          if (_i && this.spector) return this.spector.getFps();
        }, log: function() {
          if (_i && this.spector) {
            var e = Array.prototype.slice.call(arguments).join(" ");
            return this.spector.log(e);
          }
        }, startCapture: function(e, t, i) {
          e === void 0 && (e = 0), t === void 0 && (t = false), i === void 0 && (i = false), _i && this.
          spector && !this._debugCapture && (this.spector.startCapture(this.canvas, e, t, i), this._debugCapture =
          true);
        }, stopCapture: function() {
          if (_i && this.spector && this._debugCapture) return this.spector.stopCapture();
        }, onCapture: function(e) {
          if (_i) {
            var t = this.spector.getResultUI();
            t.display(e), this._debugCapture = false;
          }
        }, onResize: function(e, t) {
          (t.width !== this.width || t.height !== this.height) && this.resize(t.width, t.height);
        }, beginCapture: function(e, t) {
          e === void 0 && (e = this.width), t === void 0 && (t = this.height), this.renderTarget.bind(
          true, e, t), this.setProjectionMatrix(e, t);
        }, endCapture: function() {
          return this.renderTarget.unbind(true), this.resetProjectionMatrix(), this.renderTarget;
        }, resize: function(e, t) {
          var i = this.gl;
          return this.width = e, this.height = t, this.setProjectionMatrix(e, t), i.viewport(0, 0, e,
          t), this.drawingBufferHeight = i.drawingBufferHeight, i.scissor(0, i.drawingBufferHeight -
          t, e, t), this.defaultScissor[2] = e, this.defaultScissor[3] = t, this.emit(Dr.RESIZE, e, t),
          this;
        }, getCompressedTextures: function() {
          var e = "WEBGL_compressed_texture_", t = "WEBKIT_" + e, i = "EXT_texture_compression_", r = function(n, a) {
            var o = n.getExtension(e + a) || n.getExtension(t + a) || n.getExtension(i + a);
            if (o) {
              var h = {};
              for (var l in o) h[o[l]] = l;
              return h;
            }
          }, s = this.gl;
          return { ETC: r(s, "etc"), ETC1: r(s, "etc1"), ATC: r(s, "atc"), ASTC: r(s, "astc"), BPTC: r(
          s, "bptc"), RGTC: r(s, "rgtc"), PVRTC: r(s, "pvrtc"), S3TC: r(s, "s3tc"), S3TCSRGB: r(s, "\
s3tc_srgb"), IMG: true };
        }, getCompressedTextureName: function(e, t) {
          var i = this.compression[e.toUpperCase()];
          if (t in i) return i[t];
        }, supportsCompressedTexture: function(e, t) {
          var i = this.compression[e.toUpperCase()];
          return i ? t ? t in i : true : false;
        }, getAspectRatio: function() {
          return this.width / this.height;
        }, setProjectionMatrix: function(e, t) {
          return (e !== this.projectionWidth || t !== this.projectionHeight) && (this.projectionWidth =
          e, this.projectionHeight = t, this.projectionMatrix.ortho(0, e, t, 0, -1e3, 1e3)), this;
        }, resetProjectionMatrix: function() {
          return this.setProjectionMatrix(this.width, this.height);
        }, hasExtension: function(e) {
          return this.supportedExtensions ? this.supportedExtensions.indexOf(e) : false;
        }, getExtension: function(e) {
          return this.hasExtension(e) ? (e in this.extensions || (this.extensions[e] = this.gl.getExtension(
          e)), this.extensions[e]) : null;
        }, flush: function() {
          this.pipelines.flush();
        }, pushScissor: function(e, t, i, r, s) {
          s === void 0 && (s = this.drawingBufferHeight);
          var n = this.scissorStack, a = [e, t, i, r];
          return n.push(a), this.setScissor(e, t, i, r, s), this.currentScissor = a, a;
        }, setScissor: function(e, t, i, r, s) {
          s === void 0 && (s = this.drawingBufferHeight);
          var n = this.gl, a = this.currentScissor, o = i > 0 && r > 0;
          if (a && o) {
            var h = a[0], l = a[1], f = a[2], d = a[3];
            o = h !== e || l !== t || f !== i || d !== r;
          }
          o && (this.flush(), n.scissor(e, s - t - r, i, r));
        }, resetScissor: function() {
          var e = this.gl;
          e.enable(e.SCISSOR_TEST);
          var t = this.currentScissor;
          if (t) {
            var i = t[0], r = t[1], s = t[2], n = t[3];
            s > 0 && n > 0 && e.scissor(i, this.drawingBufferHeight - r - n, s, n);
          }
        }, popScissor: function() {
          var e = this.scissorStack;
          e.pop();
          var t = e[e.length - 1];
          t && this.setScissor(t[0], t[1], t[2], t[3]), this.currentScissor = t;
        }, hasActiveStencilMask: function() {
          var e = this.currentMask.mask, t = this.currentCameraMask.mask;
          return e && e.isStencil || t && t.isStencil;
        }, resetViewport: function() {
          var e = this.gl;
          e.viewport(0, 0, this.width, this.height), this.drawingBufferHeight = e.drawingBufferHeight;
        }, setBlendMode: function(e, t) {
          t === void 0 && (t = false);
          var i = this.gl, r = this.blendModes[e];
          return t || e !== Or.BlendModes.SKIP_CHECK && this.currentBlendMode !== e ? (this.flush(),
          i.enable(i.BLEND), i.blendEquation(r.equation), r.func.length > 2 ? i.blendFuncSeparate(r.
          func[0], r.func[1], r.func[2], r.func[3]) : i.blendFunc(r.func[0], r.func[1]), this.currentBlendMode =
          e, true) : false;
        }, addBlendMode: function(e, t) {
          var i = this.blendModes.push({ func: e, equation: t });
          return i - 1;
        }, updateBlendMode: function(e, t, i) {
          return this.blendModes[e] && (this.blendModes[e].func = t, i && (this.blendModes[e].equation =
          i)), this;
        }, removeBlendMode: function(e) {
          return e > 17 && this.blendModes[e] && this.blendModes.splice(e, 1), this;
        }, pushFramebuffer: function(e, t, i, r, s) {
          return e === this.currentFramebuffer ? this : (this.fboStack.push(e), this.setFramebuffer(
          e, t, i, r, s));
        }, setFramebuffer: function(e, t, i, r, s) {
          if (t === void 0 && (t = false), i === void 0 && (i = true), r === void 0 && (r = null), s ===
          void 0 && (s = false), e === this.currentFramebuffer) return this;
          var n = this.gl, a = this.width, o = this.height;
          return e && e.renderTexture && i ? (a = e.renderTexture.width, o = e.renderTexture.height) :
          this.flush(), e ? n.bindFramebuffer(n.FRAMEBUFFER, e.webGLFramebuffer) : n.bindFramebuffer(
          n.FRAMEBUFFER, null), i && n.viewport(0, 0, a, o), r && n.framebufferTexture2D(n.FRAMEBUFFER,
          n.COLOR_ATTACHMENT0, n.TEXTURE_2D, r.webGLTexture, 0), s && (n.clearColor(0, 0, 0, 0), n.clear(
          n.COLOR_BUFFER_BIT)), t && (e ? (this.drawingBufferHeight = o, this.pushScissor(0, 0, a, o)) :
          (this.drawingBufferHeight = this.height, this.popScissor())), this.currentFramebuffer = e,
          this;
        }, popFramebuffer: function(e, t) {
          e === void 0 && (e = false), t === void 0 && (t = true);
          var i = this.fboStack;
          i.pop();
          var r = i[i.length - 1];
          return r || (r = null), this.setFramebuffer(r, e, t), r;
        }, restoreFramebuffer: function(e, t) {
          e === void 0 && (e = false), t === void 0 && (t = true);
          var i = this.fboStack, r = i[i.length - 1];
          r || (r = null), this.currentFramebuffer = null, this.setFramebuffer(r, e, t);
        }, setProgram: function(e) {
          return e !== this.currentProgram ? (this.flush(), this.gl.useProgram(e.webGLProgram), this.
          currentProgram = e, true) : false;
        }, resetProgram: function() {
          return this.gl.useProgram(this.currentProgram.webGLProgramWrapper), this;
        }, createTextureFromSource: function(e, t, i, r, s) {
          s === void 0 && (s = false);
          var n = this.gl, a = n.NEAREST, o = n.NEAREST, h = n.CLAMP_TO_EDGE, l = null;
          t = e ? e.width : t, i = e ? e.height : i;
          var f = Wo(t, i);
          if (f && !s && (h = n.REPEAT), r === Or.ScaleModes.LINEAR && this.config.antialias) {
            var d = e && e.compressed, c = !d && f || d && e.mipmaps.length > 1;
            a = this.mipmapFilter && c ? this.mipmapFilter : n.LINEAR, o = n.LINEAR;
          }
          return !e && typeof t == "number" && typeof i == "number" ? l = this.createTexture2D(0, a,
          o, h, h, n.RGBA, null, t, i) : l = this.createTexture2D(0, a, o, h, h, n.RGBA, e), l;
        }, createTexture2D: function(e, t, i, r, s, n, a, o, h, l, f, d) {
          typeof o != "number" && (o = a ? a.width : 1), typeof h != "number" && (h = a ? a.height :
          1);
          var c = new _ne(this.gl, e, t, i, r, s, n, a, o, h, l, f, d);
          return this.glTextureWrappers.push(c), c;
        }, createFramebuffer: function(e, t, i, r) {
          this.currentFramebuffer = null;
          var s = new Pne(this.gl, e, t, i, r);
          return this.glFramebufferWrappers.push(s), s;
        }, beginBitmapMask: function(e, t) {
          var i = this.gl;
          i && (this.flush(), this.maskTarget.bind(true), this.currentCameraMask.mask !== e && (this.
          currentMask.mask = e, this.currentMask.camera = t));
        }, drawBitmapMask: function(e, t, i) {
          this.flush(), this.maskSource.bind(), this.setBlendMode(0, true), e.renderWebGL(this, e, t),
          this.maskSource.unbind(true), this.maskTarget.unbind();
          var r = this.gl, s = this.getCurrentStencilMask();
          s ? (r.enable(r.STENCIL_TEST), s.mask.applyStencil(this, s.camera, true)) : this.currentMask.
          mask = null, this.pipelines.set(i), r.activeTexture(r.TEXTURE0), r.bindTexture(r.TEXTURE_2D,
          this.maskTarget.texture.webGLTexture), r.activeTexture(r.TEXTURE1), r.bindTexture(r.TEXTURE_2D,
          this.maskSource.texture.webGLTexture);
        }, createProgram: function(e, t) {
          var i = new Rne(this.gl, e, t);
          return this.glProgramWrappers.push(i), i;
        }, createVertexBuffer: function(e, t) {
          var i = this.gl, r = new HL(i, e, i.ARRAY_BUFFER, t);
          return this.glBufferWrappers.push(r), r;
        }, createAttribLocation: function(e, t) {
          var i = new Mne(this.gl, e, t);
          return this.glAttribLocationWrappers.push(i), i;
        }, createUniformLocation: function(e, t) {
          var i = new qne(this.gl, e, t);
          return this.glUniformLocationWrappers.push(i), i;
        }, createIndexBuffer: function(e, t) {
          var i = this.gl, r = new HL(i, e, i.ELEMENT_ARRAY_BUFFER, t);
          return this.glBufferWrappers.push(r), r;
        }, deleteTexture: function(e) {
          if (e) return Lr(this.glTextureWrappers, e), e.destroy(), this;
        }, deleteFramebuffer: function(e) {
          return e ? (Lr(this.fboStack, e), Lr(this.glFramebufferWrappers, e), e.destroy(), this) : this;
        }, deleteProgram: function(e) {
          return e && (Lr(this.glProgramWrappers, e), e.destroy()), this;
        }, deleteAttribLocation: function(e) {
          return e && (Lr(this.glAttribLocationWrappers, e), e.destroy()), this;
        }, deleteUniformLocation: function(e) {
          return e && (Lr(this.glUniformLocationWrappers, e), e.destroy()), this;
        }, deleteBuffer: function(e) {
          return e ? (Lr(this.glBufferWrappers, e), e.destroy(), this) : this;
        }, preRenderCamera: function(e) {
          var t = e.x, i = e.y, r = e.width, s = e.height, n = e.backgroundColor;
          if (e.emit(VL.PRE_RENDER, e), this.pipelines.preBatchCamera(e), this.pushScissor(t, i, r, s),
          e.mask && (this.currentCameraMask.mask = e.mask, this.currentCameraMask.camera = e._maskCamera,
          e.mask.preRenderWebGL(this, e, e._maskCamera)), n.alphaGL > 0) {
            var a = this.pipelines.setMulti();
            a.drawFillRect(t, i, r, s, Ko.getTintFromFloats(n.blueGL, n.greenGL, n.redGL, 1), n.alphaGL);
          }
        }, getCurrentStencilMask: function() {
          var e = null, t = this.maskStack, i = this.currentCameraMask;
          return t.length > 0 ? e = t[t.length - 1] : i.mask && i.mask.isStencil && (e = i), e;
        }, postRenderCamera: function(e) {
          var t = e.flashEffect, i = e.fadeEffect;
          if (t.isRunning || i.isRunning || i.isComplete) {
            var r = this.pipelines.setMulti();
            t.postRenderWebGL(r, Ko.getTintFromFloats), i.postRenderWebGL(r, Ko.getTintFromFloats);
          }
          e.dirty = false, this.popScissor(), e.mask && (this.currentCameraMask.mask = null, e.mask.
          postRenderWebGL(this, e._maskCamera)), this.pipelines.postBatchCamera(e), e.emit(VL.POST_RENDER,
          e);
        }, preRender: function() {
          if (!this.contextLost) {
            var e = this.gl;
            if (e.bindFramebuffer(e.FRAMEBUFFER, null), this.emit(Dr.PRE_RENDER_CLEAR), this.config.
            clearBeforeRender) {
              var t = this.config.backgroundColor;
              e.clearColor(t.redGL, t.greenGL, t.blueGL, t.alphaGL), e.clear(e.COLOR_BUFFER_BIT | e.
              DEPTH_BUFFER_BIT | e.STENCIL_BUFFER_BIT);
            }
            e.enable(e.SCISSOR_TEST), this.currentScissor = this.defaultScissor, this.scissorStack.length =
            0, this.scissorStack.push(this.currentScissor), this.game.scene.customViewports && e.scissor(
            0, this.drawingBufferHeight - this.height, this.width, this.height), this.currentMask.mask =
            null, this.currentCameraMask.mask = null, this.maskStack.length = 0, this.emit(Dr.PRE_RENDER);
          }
        }, render: function(e, t, i) {
          if (!this.contextLost) {
            var r = t.length;
            if (this.emit(Dr.RENDER, e, i), this.preRenderCamera(i), r === 0) {
              this.setBlendMode(Or.BlendModes.NORMAL), this.postRenderCamera(i);
              return;
            }
            this.currentType = "";
            for (var s = this.currentMask, n = 0; n < r; n++) {
              this.finalType = n === r - 1;
              var a = t[n], o = a.mask;
              s = this.currentMask, s.mask && s.mask !== o && s.mask.postRenderWebGL(this, s.camera),
              o && s.mask !== o && o.preRenderWebGL(this, a, i), a.blendMode !== this.currentBlendMode &&
              this.setBlendMode(a.blendMode);
              var h = a.type;
              h !== this.currentType && (this.newType = true, this.currentType = h), this.finalType ?
              this.nextTypeMatch = false : this.nextTypeMatch = t[n + 1].type === this.currentType, a.
              renderWebGL(this, a, i), this.newType = false;
            }
            s = this.currentMask, s.mask && s.mask.postRenderWebGL(this, s.camera), this.setBlendMode(
            Or.BlendModes.NORMAL), this.postRenderCamera(i);
          }
        }, postRender: function() {
          if (!this.contextLost) {
            this.flush(), this.emit(Dr.POST_RENDER);
            var e = this.snapshotState;
            e.callback && (WL(this.gl, e), e.callback = null);
          }
        }, clearStencilMask: function() {
          this.gl.disable(this.gl.STENCIL_TEST);
        }, restoreStencilMask: function() {
          var e = this.gl, t = this.getCurrentStencilMask();
          if (t) {
            var i = t.mask;
            e.enable(e.STENCIL_TEST), i.invertAlpha ? e.stencilFunc(e.NOTEQUAL, i.level, 255) : e.stencilFunc(
            e.EQUAL, i.level, 255);
          }
        }, snapshot: function(e, t, i) {
          return this.snapshotArea(0, 0, this.gl.drawingBufferWidth, this.gl.drawingBufferHeight, e,
          t, i);
        }, snapshotArea: function(e, t, i, r, s, n, a) {
          var o = this.snapshotState;
          return o.callback = s, o.type = n, o.encoder = a, o.getPixel = false, o.x = e, o.y = t, o.
          width = i, o.height = r, this;
        }, snapshotPixel: function(e, t, i) {
          return this.snapshotArea(e, t, 1, 1, i), this.snapshotState.getPixel = true, this;
        }, snapshotFramebuffer: function(e, t, i, r, s, n, a, o, h, l, f) {
          s === void 0 && (s = false), n === void 0 && (n = 0), a === void 0 && (a = 0), o === void 0 &&
          (o = t), h === void 0 && (h = i), l === "pixel" && (s = true, l = "image/png");
          var d = this.currentFramebuffer;
          this.snapshotArea(n, a, o, h, r, l, f);
          var c = this.snapshotState;
          return c.getPixel = s, c.isFramebuffer = true, c.bufferWidth = t, c.bufferHeight = i, c.width =
          Math.min(c.width, t), c.height = Math.min(c.height, i), this.setFramebuffer(e), WL(this.gl,
          c), this.setFramebuffer(d), c.callback = null, c.isFramebuffer = false, this;
        }, canvasToTexture: function(e, t, i, r) {
          i === void 0 && (i = false), r === void 0 && (r = false);
          var s = this.gl, n = s.NEAREST, a = s.NEAREST, o = e.width, h = e.height, l = s.CLAMP_TO_EDGE,
          f = Wo(o, h);
          return !i && f && (l = s.REPEAT), this.config.antialias && (n = f && this.mipmapFilter ? this.
          mipmapFilter : s.LINEAR, a = s.LINEAR), t ? (t.update(e, o, h, r, l, l, n, a, t.format), t) :
          this.createTexture2D(0, n, a, l, l, s.RGBA, e, o, h, true, false, r);
        }, createCanvasTexture: function(e, t, i) {
          return t === void 0 && (t = false), i === void 0 && (i = false), this.canvasToTexture(e, null,
          t, i);
        }, updateCanvasTexture: function(e, t, i, r) {
          return i === void 0 && (i = false), r === void 0 && (r = false), this.canvasToTexture(e, t,
          r, i);
        }, videoToTexture: function(e, t, i, r) {
          i === void 0 && (i = false), r === void 0 && (r = false);
          var s = this.gl, n = s.NEAREST, a = s.NEAREST, o = e.videoWidth, h = e.videoHeight, l = s.
          CLAMP_TO_EDGE, f = Wo(o, h);
          return !i && f && (l = s.REPEAT), this.config.antialias && (n = f && this.mipmapFilter ? this.
          mipmapFilter : s.LINEAR, a = s.LINEAR), t ? (t.update(e, o, h, r, l, l, n, a, t.format), t) :
          this.createTexture2D(0, n, a, l, l, s.RGBA, e, o, h, true, true, r);
        }, createVideoTexture: function(e, t, i) {
          return t === void 0 && (t = false), i === void 0 && (i = false), this.videoToTexture(e, null,
          t, i);
        }, updateVideoTexture: function(e, t, i, r) {
          return i === void 0 && (i = false), r === void 0 && (r = false), this.videoToTexture(e, t,
          r, i);
        }, createUint8ArrayTexture: function(e, t, i) {
          var r = this.gl, s = r.NEAREST, n = r.NEAREST, a = r.CLAMP_TO_EDGE, o = Wo(t, i);
          return o && (a = r.REPEAT), this.createTexture2D(0, s, n, a, a, r.RGBA, e, t, i);
        }, setTextureFilter: function(e, t) {
          var i = this.gl, r = t === 0 ? i.LINEAR : i.NEAREST;
          i.activeTexture(i.TEXTURE0);
          var s = i.getParameter(i.TEXTURE_BINDING_2D);
          return i.bindTexture(i.TEXTURE_2D, e.webGLTexture), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MIN_FILTER,
          r), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MAG_FILTER, r), e.minFilter = r, e.magFilter =
          r, s && i.bindTexture(i.TEXTURE_2D, s), this;
        }, getMaxTextureSize: function() {
          return this.config.maxTextureSize;
        }, destroy: function() {
          this.canvas.removeEventListener("webglcontextlost", this.contextLostHandler, false), this.
          canvas.removeEventListener("webglcontextrestored", this.contextRestoredHandler, false);
          var e = function(t) {
            t.destroy();
          };
          It(this.glAttribLocationWrappers, e), It(this.glBufferWrappers, e), It(this.glFramebufferWrappers,
          e), It(this.glProgramWrappers, e), It(this.glTextureWrappers, e), It(this.glUniformLocationWrappers,
          e), this.maskTarget.destroy(), this.maskSource.destroy(), this.pipelines.destroy(), this.removeAllListeners(),
          this.fboStack = [], this.maskStack = [], this.extensions = {}, this.textureIndexes = [], this.
          gl = null, this.game = null, this.canvas = null, this.contextLost = true, this.currentMask =
          null, this.currentCameraMask = null, _i && (this.spector = null);
        } });
        KL.exports = Fne;
      });
      qd = u((_Pe, QL) => {
        var bne = Pq(), ZL = Tt(), Pi = qt(), Md = Xa(), Lne = function(e) {
          var t = e.config;
          if ((t.customEnvironment || t.canvas) && t.renderType === Pi.AUTO) throw new Error("Must s\
et explicit renderType in custom environment");
          if (!t.customEnvironment && !t.canvas && t.renderType !== Pi.HEADLESS) if (t.renderType ===
          Pi.AUTO && (t.renderType = Md.webGL ? Pi.WEBGL : Pi.CANVAS), t.renderType === Pi.WEBGL) {
            if (!Md.webGL) throw new Error("Cannot create WebGL context, aborting.");
          } else if (t.renderType === Pi.CANVAS) {
            if (!Md.canvas) throw new Error("Cannot create Canvas context, aborting.");
          } else throw new Error("Unknown value for renderer type: " + t.renderType);
          t.antialias || ZL.disableSmoothing();
          var i = e.scale.baseSize, r = i.width, s = i.height;
          if (t.canvas ? (e.canvas = t.canvas, e.canvas.width = r, e.canvas.height = s) : e.canvas =
          ZL.create(e, r, s, t.renderType), t.canvasStyle && (e.canvas.style = t.canvasStyle), t.antialias ||
          bne.setCrisp(e.canvas), t.renderType !== Pi.HEADLESS) {
            var n, a;
            n = uF(), a = Pd(), t.renderType === Pi.WEBGL ? e.renderer = new a(e) : (e.renderer = new n(
            e), e.context = e.renderer.gameContext);
          }
        };
        QL.exports = Lne;
      });
      Fd = u((PPe, JL) => {
        var Zo = qt(), One = function(e) {
          var t = e.config;
          if (!t.hideBanner) {
            var i = "WebGL";
            t.renderType === Zo.CANVAS ? i = "Canvas" : t.renderType === Zo.HEADLESS && (i = "Headle\
ss");
            var r = t.audio, s = e.device.audio, n;
            if (s.webAudio && !r.disableWebAudio ? n = "Web Audio" : r.noAudio || !s.webAudio && !s.
            audioData ? n = "No Audio" : n = "HTML5 Audio", e.device.browser.ie) window.console && console.
            log("Phaser v" + Zo.VERSION + " / https://phaser.io");
            else {
              var a = "", o = [a];
              if (Array.isArray(t.bannerBackgroundColor)) {
                var h;
                t.bannerBackgroundColor.forEach(function(f) {
                  a = a.concat("%c "), o.push("background: " + f), h = f;
                }), o[o.length - 1] = "color: " + t.bannerTextColor + "; background: " + h;
              } else a = a.concat("%c "), o.push("color: " + t.bannerTextColor + "; background: " + t.
              bannerBackgroundColor);
              o.push("background: transparent"), t.gameTitle && (a = a.concat(t.gameTitle), t.gameVersion &&
              (a = a.concat(" v" + t.gameVersion)), t.hidePhaser || (a = a.concat(" / ")));
              var l = "";
              t.hidePhaser || (a = a.concat("Phaser v" + Zo.VERSION + l + " (" + i + " | " + n + ")")),
              a = a.concat(" %c " + t.gameURL), o[0] = a, console.log.apply(console, o);
            }
          }
        };
        JL.exports = One;
      });
      e2 = u((MPe, jL) => {
        var Dne = C(), $L = J(), Nne = new Dne({ initialize: function() {
          this.isRunning = false, this.callback = $L, this.isSetTimeOut = false, this.timeOutID = null,
          this.delay = 0;
          var t = this;
          this.step = function i(r) {
            t.callback(r), t.isRunning && (t.timeOutID = window.requestAnimationFrame(i));
          }, this.stepTimeout = function i() {
            t.isRunning && (t.timeOutID = window.setTimeout(i, t.delay)), t.callback(window.performance.
            now());
          };
        }, start: function(e, t, i) {
          this.isRunning || (this.callback = e, this.isSetTimeOut = t, this.delay = i, this.isRunning =
          true, this.timeOutID = t ? window.setTimeout(this.stepTimeout, 0) : window.requestAnimationFrame(
          this.step));
        }, stop: function() {
          this.isRunning = false, this.isSetTimeOut ? clearTimeout(this.timeOutID) : window.cancelAnimationFrame(
          this.timeOutID);
        }, destroy: function() {
          this.stop(), this.callback = $L;
        } });
        jL.exports = Nne;
      });
      bd = u((qPe, t2) => {
        var Ine = C(), Nr = H(), Bne = J(), Gne = e2(), Une = new Ine({ initialize: function(t, i) {
          this.game = t, this.raf = new Gne(), this.started = false, this.running = false, this.minFps =
          Nr(i, "min", 5), this.targetFps = Nr(i, "target", 60), this.fpsLimit = Nr(i, "limit", 0), this.
          hasFpsLimit = this.fpsLimit > 0, this._limitRate = this.hasFpsLimit ? 1e3 / this.fpsLimit :
          0, this._min = 1e3 / this.minFps, this._target = 1e3 / this.targetFps, this.actualFps = this.
          targetFps, this.nextFpsUpdate = 0, this.framesThisSecond = 0, this.callback = Bne, this.forceSetTimeOut =
          Nr(i, "forceSetTimeOut", false), this.time = 0, this.startTime = 0, this.lastTime = 0, this.
          frame = 0, this.inFocus = true, this.pauseDuration = 0, this._pauseTime = 0, this._coolDown =
          0, this.delta = 0, this.deltaIndex = 0, this.deltaHistory = [], this.deltaSmoothingMax = Nr(
          i, "deltaHistory", 10), this.panicMax = Nr(i, "panicMax", 120), this.rawDelta = 0, this.now =
          0, this.smoothStep = Nr(i, "smoothStep", true);
        }, blur: function() {
          this.inFocus = false;
        }, focus: function() {
          this.inFocus = true, this.resetDelta();
        }, pause: function() {
          this._pauseTime = window.performance.now();
        }, resume: function() {
          this.resetDelta(), this.pauseDuration = this.time - this._pauseTime, this.startTime += this.
          pauseDuration;
        }, resetDelta: function() {
          var e = window.performance.now();
          this.time = e, this.lastTime = e, this.nextFpsUpdate = e + 1e3, this.framesThisSecond = 0;
          for (var t = 0; t < this.deltaSmoothingMax; t++) this.deltaHistory[t] = Math.min(this._target,
          this.deltaHistory[t]);
          this.delta = 0, this.deltaIndex = 0, this._coolDown = this.panicMax;
        }, start: function(e) {
          if (this.started) return this;
          this.started = true, this.running = true;
          for (var t = 0; t < this.deltaSmoothingMax; t++) this.deltaHistory[t] = this._target;
          this.resetDelta(), this.startTime = window.performance.now(), this.callback = e;
          var i = this.hasFpsLimit ? this.stepLimitFPS.bind(this) : this.step.bind(this);
          this.raf.start(i, this.forceSetTimeOut, this._target);
        }, smoothDelta: function(e) {
          var t = this.deltaIndex, i = this.deltaHistory, r = this.deltaSmoothingMax;
          (this._coolDown > 0 || !this.inFocus) && (this._coolDown--, e = Math.min(e, this._target)),
          e > this._min && (e = i[t], e = Math.min(e, this._min)), i[t] = e, this.deltaIndex++, this.
          deltaIndex >= r && (this.deltaIndex = 0);
          for (var s = 0, n = 0; n < r; n++) s += i[n];
          return s /= r, s;
        }, updateFPS: function(e) {
          this.actualFps = 0.25 * this.framesThisSecond + 0.75 * this.actualFps, this.nextFpsUpdate =
          e + 1e3, this.framesThisSecond = 0;
        }, stepLimitFPS: function(e) {
          this.now = e;
          var t = Math.max(0, e - this.lastTime);
          this.rawDelta = t, this.time += this.rawDelta, this.smoothStep && (t = this.smoothDelta(t)),
          this.delta += t, e >= this.nextFpsUpdate && this.updateFPS(e), this.framesThisSecond++, this.
          delta >= this._limitRate && (this.callback(e, this.delta), this.delta = 0), this.lastTime =
          e, this.frame++;
        }, step: function(e) {
          this.now = e;
          var t = Math.max(0, e - this.lastTime);
          this.rawDelta = t, this.time += this.rawDelta, this.smoothStep && (t = this.smoothDelta(t)),
          this.delta = t, e >= this.nextFpsUpdate && this.updateFPS(e), this.framesThisSecond++, this.
          callback(e, t), this.lastTime = e, this.frame++;
        }, tick: function() {
          var e = window.performance.now();
          this.hasFpsLimit ? this.stepLimitFPS(e) : this.step(e);
        }, sleep: function() {
          this.running && (this.raf.stop(), this.running = false);
        }, wake: function(e) {
          e === void 0 && (e = false);
          var t = window.performance.now();
          if (!this.running) {
            e && (this.startTime += -this.lastTime + (this.lastTime + t));
            var i = this.hasFpsLimit ? this.stepLimitFPS.bind(this) : this.step.bind(this);
            this.raf.start(i, this.forceSetTimeOut, this._target), this.running = true, this.nextFpsUpdate =
            t + 1e3, this.framesThisSecond = 0, this.fpsLimitTriggered = false, this.tick();
          }
        }, getDuration: function() {
          return Math.round(this.lastTime - this.startTime) / 1e3;
        }, getDurationMS: function() {
          return Math.round(this.lastTime - this.startTime);
        }, stop: function() {
          return this.running = false, this.started = false, this.raf.stop(), this;
        }, destroy: function() {
          this.stop(), this.raf.destroy(), this.raf = null, this.game = null, this.callback = null;
        } });
        t2.exports = Une;
      });
      Ld = u((FPe, i2) => {
        var Qo = Ye(), zne = function(e) {
          var t, i = e.events;
          if (document.hidden !== void 0) t = "visibilitychange";
          else {
            var r = ["webkit", "moz", "ms"];
            r.forEach(function(n) {
              document[n + "Hidden"] !== void 0 && (document.hidden = function() {
                return document[n + "Hidden"];
              }, t = n + "visibilitychange");
            });
          }
          var s = function(n) {
            document.hidden || n.type === "pause" ? i.emit(Qo.HIDDEN) : i.emit(Qo.VISIBLE);
          };
          t && document.addEventListener(t, s, false), window.onblur = function() {
            i.emit(Qo.BLUR);
          }, window.onfocus = function() {
            i.emit(Qo.FOCUS);
          }, window.focus && e.config.autoFocus && window.focus();
        };
        i2.exports = zne;
      });
      s2 = u((bPe, r2) => {
        r2.exports = { Config: gf(), CreateRenderer: qd(), DebugHeader: Fd(), Events: Ye(), TimeStep: bd(),
        VisibilityHandler: Ld() };
      });
      Jo = u((LPe, a2) => {
        var kne = he(), n2 = le(), Xne = function(e, t) {
          if (t === void 0 && (t = new kne()), e.length === 0) return t;
          for (var i = Number.MAX_VALUE, r = Number.MAX_VALUE, s = n2.MIN_SAFE_INTEGER, n = n2.MIN_SAFE_INTEGER,
          a, o, h, l = 0; l < e.length; l++) a = e[l], Array.isArray(a) ? (o = a[0], h = a[1]) : (o =
          a.x, h = a.y), i = Math.min(i, o), r = Math.min(r, h), s = Math.max(s, o), n = Math.max(n,
          h);
          return t.x = i, t.y = r, t.width = s - i, t.height = n - r, t;
        };
        a2.exports = Xne;
      });
      Ir = u((OPe, o2) => {
        var Vne = C(), Yne = Jo(), Wne = he(), Ds = Y(), Hne = new Vne({ initialize: function(t) {
          this.type = t, this.defaultDivisions = 5, this.arcLengthDivisions = 100, this.cacheArcLengths =
          [], this.needsUpdate = true, this.active = true, this._tmpVec2A = new Ds(), this._tmpVec2B =
          new Ds();
        }, draw: function(e, t) {
          return t === void 0 && (t = 32), e.strokePoints(this.getPoints(t));
        }, getBounds: function(e, t) {
          e || (e = new Wne()), t === void 0 && (t = 16);
          var i = this.getLength();
          t > i && (t = i / 2);
          var r = Math.max(1, Math.round(i / t));
          return Yne(this.getSpacedPoints(r), e);
        }, getDistancePoints: function(e) {
          var t = this.getLength(), i = Math.max(1, t / e);
          return this.getSpacedPoints(i);
        }, getEndPoint: function(e) {
          return e === void 0 && (e = new Ds()), this.getPointAt(1, e);
        }, getLength: function() {
          var e = this.getLengths();
          return e[e.length - 1];
        }, getLengths: function(e) {
          if (e === void 0 && (e = this.arcLengthDivisions), this.cacheArcLengths.length === e + 1 &&
          !this.needsUpdate) return this.cacheArcLengths;
          this.needsUpdate = false;
          var t = [], i, r = this.getPoint(0, this._tmpVec2A), s = 0;
          t.push(0);
          for (var n = 1; n <= e; n++) i = this.getPoint(n / e, this._tmpVec2B), s += i.distance(r),
          t.push(s), r.copy(i);
          return this.cacheArcLengths = t, t;
        }, getPointAt: function(e, t) {
          var i = this.getUtoTmapping(e);
          return this.getPoint(i, t);
        }, getPoints: function(e, t, i) {
          i === void 0 && (i = []), e || (t ? e = this.getLength() / t : e = this.defaultDivisions);
          for (var r = 0; r <= e; r++) i.push(this.getPoint(r / e));
          return i;
        }, getRandomPoint: function(e) {
          return e === void 0 && (e = new Ds()), this.getPoint(Math.random(), e);
        }, getSpacedPoints: function(e, t, i) {
          i === void 0 && (i = []), e || (t ? e = this.getLength() / t : e = this.defaultDivisions);
          for (var r = 0; r <= e; r++) {
            var s = this.getUtoTmapping(r / e, null, e);
            i.push(this.getPoint(s));
          }
          return i;
        }, getStartPoint: function(e) {
          return e === void 0 && (e = new Ds()), this.getPointAt(0, e);
        }, getTangent: function(e, t) {
          t === void 0 && (t = new Ds());
          var i = 1e-4, r = e - i, s = e + i;
          return r < 0 && (r = 0), s > 1 && (s = 1), this.getPoint(r, this._tmpVec2A), this.getPoint(
          s, t), t.subtract(this._tmpVec2A).normalize();
        }, getTangentAt: function(e, t) {
          var i = this.getUtoTmapping(e);
          return this.getTangent(i, t);
        }, getTFromDistance: function(e, t) {
          return e <= 0 ? 0 : this.getUtoTmapping(0, e, t);
        }, getUtoTmapping: function(e, t, i) {
          var r = this.getLengths(i), s = 0, n = r.length, a;
          t ? a = Math.min(t, r[n - 1]) : a = e * r[n - 1];
          for (var o = 0, h = n - 1, l; o <= h; ) if (s = Math.floor(o + (h - o) / 2), l = r[s] - a,
          l < 0) o = s + 1;
          else if (l > 0) h = s - 1;
          else {
            h = s;
            break;
          }
          if (s = h, r[s] === a) return s / (n - 1);
          var f = r[s], d = r[s + 1], c = d - f, p = (a - f) / c;
          return (s + p) / (n - 1);
        }, updateArcLengths: function() {
          this.needsUpdate = true, this.getLengths();
        } });
        o2.exports = Hne;
      });
      Dd = u((DPe, l2) => {
        var Kne = C(), h2 = rf(), u2 = Ir(), ii = Y(), Od = new Kne({ Extends: u2, initialize: function(t, i, r, s) {
          u2.call(this, "CubicBezierCurve"), Array.isArray(t) && (s = new ii(t[6], t[7]), r = new ii(
          t[4], t[5]), i = new ii(t[2], t[3]), t = new ii(t[0], t[1])), this.p0 = t, this.p1 = i, this.
          p2 = r, this.p3 = s;
        }, getStartPoint: function(e) {
          return e === void 0 && (e = new ii()), e.copy(this.p0);
        }, getResolution: function(e) {
          return e;
        }, getPoint: function(e, t) {
          t === void 0 && (t = new ii());
          var i = this.p0, r = this.p1, s = this.p2, n = this.p3;
          return t.set(h2(e, i.x, r.x, s.x, n.x), h2(e, i.y, r.y, s.y, n.y));
        }, draw: function(e, t) {
          t === void 0 && (t = 32);
          var i = this.getPoints(t);
          e.beginPath(), e.moveTo(this.p0.x, this.p0.y);
          for (var r = 1; r < i.length; r++) e.lineTo(i[r].x, i[r].y);
          return e.strokePath(), e;
        }, toJSON: function() {
          return { type: this.type, points: [this.p0.x, this.p0.y, this.p1.x, this.p1.y, this.p2.x, this.
          p2.y, this.p3.x, this.p3.y] };
        } });
        Od.fromJSON = function(e) {
          var t = e.points, i = new ii(t[0], t[1]), r = new ii(t[2], t[3]), s = new ii(t[4], t[5]), n = new ii(
          t[6], t[7]);
          return new Od(i, r, s, n);
        };
        l2.exports = Od;
      });
      Bd = u((NPe, d2) => {
        var Zne = C(), f2 = Ir(), Ns = Rr(), tr = H(), Is = df(), Nd = Y(), Id = new Zne({ Extends: f2,
        initialize: function(t, i, r, s, n, a, o, h) {
          if (typeof t == "object") {
            var l = t;
            t = tr(l, "x", 0), i = tr(l, "y", 0), r = tr(l, "xRadius", 0), s = tr(l, "yRadius", r), n =
            tr(l, "startAngle", 0), a = tr(l, "endAngle", 360), o = tr(l, "clockwise", false), h = tr(
            l, "rotation", 0);
          } else s === void 0 && (s = r), n === void 0 && (n = 0), a === void 0 && (a = 360), o === void 0 &&
          (o = false), h === void 0 && (h = 0);
          f2.call(this, "EllipseCurve"), this.p0 = new Nd(t, i), this._xRadius = r, this._yRadius = s,
          this._startAngle = Ns(n), this._endAngle = Ns(a), this._clockwise = o, this._rotation = Ns(
          h);
        }, getStartPoint: function(e) {
          return e === void 0 && (e = new Nd()), this.getPoint(0, e);
        }, getResolution: function(e) {
          return e * 2;
        }, getPoint: function(e, t) {
          t === void 0 && (t = new Nd());
          for (var i = Math.PI * 2, r = this._endAngle - this._startAngle, s = Math.abs(r) < Number.
          EPSILON; r < 0; ) r += i;
          for (; r > i; ) r -= i;
          r < Number.EPSILON && (s ? r = 0 : r = i), this._clockwise && !s && (r === i ? r = -i : r =
          r - i);
          var n = this._startAngle + e * r, a = this.p0.x + this._xRadius * Math.cos(n), o = this.p0.
          y + this._yRadius * Math.sin(n);
          if (this._rotation !== 0) {
            var h = Math.cos(this._rotation), l = Math.sin(this._rotation), f = a - this.p0.x, d = o -
            this.p0.y;
            a = f * h - d * l + this.p0.x, o = f * l + d * h + this.p0.y;
          }
          return t.set(a, o);
        }, setXRadius: function(e) {
          return this.xRadius = e, this;
        }, setYRadius: function(e) {
          return this.yRadius = e, this;
        }, setWidth: function(e) {
          return this.xRadius = e / 2, this;
        }, setHeight: function(e) {
          return this.yRadius = e / 2, this;
        }, setStartAngle: function(e) {
          return this.startAngle = e, this;
        }, setEndAngle: function(e) {
          return this.endAngle = e, this;
        }, setClockwise: function(e) {
          return this.clockwise = e, this;
        }, setRotation: function(e) {
          return this.rotation = e, this;
        }, x: { get: function() {
          return this.p0.x;
        }, set: function(e) {
          this.p0.x = e;
        } }, y: { get: function() {
          return this.p0.y;
        }, set: function(e) {
          this.p0.y = e;
        } }, xRadius: { get: function() {
          return this._xRadius;
        }, set: function(e) {
          this._xRadius = e;
        } }, yRadius: { get: function() {
          return this._yRadius;
        }, set: function(e) {
          this._yRadius = e;
        } }, startAngle: { get: function() {
          return Is(this._startAngle);
        }, set: function(e) {
          this._startAngle = Ns(e);
        } }, endAngle: { get: function() {
          return Is(this._endAngle);
        }, set: function(e) {
          this._endAngle = Ns(e);
        } }, clockwise: { get: function() {
          return this._clockwise;
        }, set: function(e) {
          this._clockwise = e;
        } }, angle: { get: function() {
          return Is(this._rotation);
        }, set: function(e) {
          this._rotation = Ns(e);
        } }, rotation: { get: function() {
          return this._rotation;
        }, set: function(e) {
          this._rotation = e;
        } }, toJSON: function() {
          return { type: this.type, x: this.p0.x, y: this.p0.y, xRadius: this._xRadius, yRadius: this.
          _yRadius, startAngle: Is(this._startAngle), endAngle: Is(this._endAngle), clockwise: this.
          _clockwise, rotation: Is(this._rotation) };
        } });
        Id.fromJSON = function(e) {
          return new Id(e);
        };
        d2.exports = Id;
      });
      Ud = u((IPe, v2) => {
        var Qne = C(), c2 = Ir(), Jne = Jo(), $ne = he(), Br = Y(), Gd = new Qne({ Extends: c2, initialize: function(t, i) {
          c2.call(this, "LineCurve"), Array.isArray(t) && (i = new Br(t[2], t[3]), t = new Br(t[0], t[1])),
          this.p0 = t, this.p1 = i, this.arcLengthDivisions = 1;
        }, getBounds: function(e) {
          return e === void 0 && (e = new $ne()), Jne([this.p0, this.p1], e);
        }, getStartPoint: function(e) {
          return e === void 0 && (e = new Br()), e.copy(this.p0);
        }, getResolution: function(e) {
          return e === void 0 && (e = 1), e;
        }, getPoint: function(e, t) {
          return t === void 0 && (t = new Br()), e === 1 ? t.copy(this.p1) : (t.copy(this.p1).subtract(
          this.p0).scale(e).add(this.p0), t);
        }, getPointAt: function(e, t) {
          return this.getPoint(e, t);
        }, getTangent: function(e, t) {
          return t === void 0 && (t = new Br()), t.copy(this.p1).subtract(this.p0).normalize(), t;
        }, getUtoTmapping: function(e, t, i) {
          var r;
          if (t) {
            var s = this.getLengths(i), n = s[s.length - 1], a = Math.min(t, n);
            r = a / n;
          } else r = e;
          return r;
        }, draw: function(e) {
          return e.lineBetween(this.p0.x, this.p0.y, this.p1.x, this.p1.y), e;
        }, toJSON: function() {
          return { type: this.type, points: [this.p0.x, this.p0.y, this.p1.x, this.p1.y] };
        } });
        Gd.fromJSON = function(e) {
          var t = e.points, i = new Br(t[0], t[1]), r = new Br(t[2], t[3]);
          return new Gd(i, r);
        };
        v2.exports = Gd;
      });
      zd = u((BPe, m2) => {
        var jne = C(), p2 = Y(), eae = new jne({ initialize: function(t, i) {
          this.active = false, this.p0 = new p2(t, i);
        }, getPoint: function(e, t) {
          return t === void 0 && (t = new p2()), t.copy(this.p0);
        }, getPointAt: function(e, t) {
          return this.getPoint(e, t);
        }, getResolution: function() {
          return 1;
        }, getLength: function() {
          return 0;
        }, toJSON: function() {
          return { type: "MoveTo", points: [this.p0.x, this.p0.y] };
        } });
        m2.exports = eae;
      });
      Xd = u((GPe, E2) => {
        var tae = C(), g2 = Ir(), x2 = af(), ir = Y(), kd = new tae({ Extends: g2, initialize: function(t, i, r) {
          g2.call(this, "QuadraticBezierCurve"), Array.isArray(t) && (r = new ir(t[4], t[5]), i = new ir(
          t[2], t[3]), t = new ir(t[0], t[1])), this.p0 = t, this.p1 = i, this.p2 = r;
        }, getStartPoint: function(e) {
          return e === void 0 && (e = new ir()), e.copy(this.p0);
        }, getResolution: function(e) {
          return e;
        }, getPoint: function(e, t) {
          t === void 0 && (t = new ir());
          var i = this.p0, r = this.p1, s = this.p2;
          return t.set(x2(e, i.x, r.x, s.x), x2(e, i.y, r.y, s.y));
        }, draw: function(e, t) {
          t === void 0 && (t = 32);
          var i = this.getPoints(t);
          e.beginPath(), e.moveTo(this.p0.x, this.p0.y);
          for (var r = 1; r < i.length; r++) e.lineTo(i[r].x, i[r].y);
          return e.strokePath(), e;
        }, toJSON: function() {
          return { type: this.type, points: [this.p0.x, this.p0.y, this.p1.x, this.p1.y, this.p2.x, this.
          p2.y] };
        } });
        kd.fromJSON = function(e) {
          var t = e.points, i = new ir(t[0], t[1]), r = new ir(t[2], t[3]), s = new ir(t[4], t[5]);
          return new kd(i, r, s);
        };
        E2.exports = kd;
      });
      Yd = u((UPe, S22) => {
        var T22 = To(), iae = C(), y2 = Ir(), $o = Y(), Vd = new iae({ Extends: y2, initialize: function(t) {
          t === void 0 && (t = []), y2.call(this, "SplineCurve"), this.points = [], this.addPoints(t);
        }, addPoints: function(e) {
          for (var t = 0; t < e.length; t++) {
            var i = new $o();
            typeof e[t] == "number" ? (i.x = e[t], i.y = e[t + 1], t++) : Array.isArray(e[t]) ? (i.x =
            e[t][0], i.y = e[t][1]) : (i.x = e[t].x, i.y = e[t].y), this.points.push(i);
          }
          return this;
        }, addPoint: function(e, t) {
          var i = new $o(e, t);
          return this.points.push(i), i;
        }, getStartPoint: function(e) {
          return e === void 0 && (e = new $o()), e.copy(this.points[0]);
        }, getResolution: function(e) {
          return e * this.points.length;
        }, getPoint: function(e, t) {
          t === void 0 && (t = new $o());
          var i = this.points, r = (i.length - 1) * e, s = Math.floor(r), n = r - s, a = i[s === 0 ?
          s : s - 1], o = i[s], h = i[s > i.length - 2 ? i.length - 1 : s + 1], l = i[s > i.length -
          3 ? i.length - 1 : s + 2];
          return t.set(T22(n, a.x, o.x, h.x, l.x), T22(n, a.y, o.y, h.y, l.y));
        }, toJSON: function() {
          for (var e = [], t = 0; t < this.points.length; t++) e.push(this.points[t].x), e.push(this.
          points[t].y);
          return { type: this.type, points: e };
        } });
        Vd.fromJSON = function(e) {
          return new Vd(e.points);
        };
        S22.exports = Vd;
      });
      b2 = u((zPe, F22) => {
        var rae = C(), w2 = Dd(), C2 = Bd(), sae = Ne(), Wd = Ud(), A22 = zd(), R2 = Xd(), _2 = he(),
        P2 = Yd(), Ge = Y(), M2 = le(), q2 = new rae({ initialize: function(t, i) {
          t === void 0 && (t = 0), i === void 0 && (i = 0), this.name = "", this.defaultDivisions = 12,
          this.curves = [], this.cacheLengths = [], this.autoClose = false, this.startPoint = new Ge(),
          this._tmpVec2A = new Ge(), this._tmpVec2B = new Ge(), typeof t == "object" ? this.fromJSON(
          t) : this.startPoint.set(t, i);
        }, add: function(e) {
          return this.curves.push(e), this;
        }, circleTo: function(e, t, i) {
          return t === void 0 && (t = false), this.ellipseTo(e, e, 0, 360, t, i);
        }, closePath: function() {
          var e = this.curves[0].getPoint(0), t = this.curves[this.curves.length - 1].getPoint(1);
          return e.equals(t) || this.curves.push(new Wd(t, e)), this;
        }, cubicBezierTo: function(e, t, i, r, s, n) {
          var a = this.getEndPoint(), o, h, l;
          return e instanceof Ge ? (o = e, h = t, l = i) : (o = new Ge(i, r), h = new Ge(s, n), l = new Ge(
          e, t)), this.add(new w2(a, o, h, l));
        }, quadraticBezierTo: function(e, t, i, r) {
          var s = this.getEndPoint(), n, a;
          return e instanceof Ge ? (n = e, a = t) : (n = new Ge(i, r), a = new Ge(e, t)), this.add(new R2(
          s, n, a));
        }, draw: function(e, t) {
          for (var i = 0; i < this.curves.length; i++) {
            var r = this.curves[i];
            r.active && r.draw(e, t);
          }
          return e;
        }, ellipseTo: function(e, t, i, r, s, n) {
          var a = new C2(0, 0, e, t, i, r, s, n), o = this.getEndPoint(this._tmpVec2A), h = a.getStartPoint(
          this._tmpVec2B);
          return o.subtract(h), a.x = o.x, a.y = o.y, this.add(a);
        }, fromJSON: function(e) {
          this.curves = [], this.cacheLengths = [], this.startPoint.set(e.x, e.y), this.autoClose = e.
          autoClose;
          for (var t = 0; t < e.curves.length; t++) {
            var i = e.curves[t];
            switch (i.type) {
              case "LineCurve":
                this.add(Wd.fromJSON(i));
                break;
              case "EllipseCurve":
                this.add(C2.fromJSON(i));
                break;
              case "SplineCurve":
                this.add(P2.fromJSON(i));
                break;
              case "CubicBezierCurve":
                this.add(w2.fromJSON(i));
                break;
              case "QuadraticBezierCurve":
                this.add(R2.fromJSON(i));
                break;
            }
          }
          return this;
        }, getBounds: function(e, t) {
          e === void 0 && (e = new _2()), t === void 0 && (t = 16), e.x = Number.MAX_VALUE, e.y = Number.
          MAX_VALUE;
          for (var i = new _2(), r = M2.MIN_SAFE_INTEGER, s = M2.MIN_SAFE_INTEGER, n = 0; n < this.curves.
          length; n++) {
            var a = this.curves[n];
            a.active && (a.getBounds(i, t), e.x = Math.min(e.x, i.x), e.y = Math.min(e.y, i.y), r = Math.
            max(r, i.right), s = Math.max(s, i.bottom));
          }
          return e.right = r, e.bottom = s, e;
        }, getCurveLengths: function() {
          if (this.cacheLengths.length === this.curves.length) return this.cacheLengths;
          for (var e = [], t = 0, i = 0; i < this.curves.length; i++) t += this.curves[i].getLength(),
          e.push(t);
          return this.cacheLengths = e, e;
        }, getCurveAt: function(e) {
          for (var t = e * this.getLength(), i = this.getCurveLengths(), r = 0; r < i.length; ) {
            if (i[r] >= t) return this.curves[r];
            r++;
          }
          return null;
        }, getEndPoint: function(e) {
          return e === void 0 && (e = new Ge()), this.curves.length > 0 ? this.curves[this.curves.length -
          1].getPoint(1, e) : e.copy(this.startPoint), e;
        }, getLength: function() {
          var e = this.getCurveLengths();
          return e[e.length - 1];
        }, getPoint: function(e, t) {
          t === void 0 && (t = new Ge());
          for (var i = e * this.getLength(), r = this.getCurveLengths(), s = 0; s < r.length; ) {
            if (r[s] >= i) {
              var n = r[s] - i, a = this.curves[s], o = a.getLength(), h = o === 0 ? 0 : 1 - n / o;
              return a.getPointAt(h, t);
            }
            s++;
          }
          return null;
        }, getPoints: function(e, t) {
          !e && !t && (e = this.defaultDivisions);
          for (var i = [], r, s = 0; s < this.curves.length; s++) {
            var n = this.curves[s];
            if (n.active) for (var a = n.getResolution(e), o = n.getPoints(a, t), h = 0; h < o.length; h++) {
              var l = o[h];
              r && r.equals(l) || (i.push(l), r = l);
            }
          }
          return this.autoClose && i.length > 1 && !i[i.length - 1].equals(i[0]) && i.push(i[0]), i;
        }, getRandomPoint: function(e) {
          return e === void 0 && (e = new Ge()), this.getPoint(Math.random(), e);
        }, getSpacedPoints: function(e) {
          e === void 0 && (e = 40);
          for (var t = [], i = 0; i <= e; i++) t.push(this.getPoint(i / e));
          return this.autoClose && t.push(t[0]), t;
        }, getStartPoint: function(e) {
          return e === void 0 && (e = new Ge()), e.copy(this.startPoint);
        }, getTangent: function(e, t) {
          t === void 0 && (t = new Ge());
          for (var i = e * this.getLength(), r = this.getCurveLengths(), s = 0; s < r.length; ) {
            if (r[s] >= i) {
              var n = r[s] - i, a = this.curves[s], o = a.getLength(), h = o === 0 ? 0 : 1 - n / o;
              return a.getTangentAt(h, t);
            }
            s++;
          }
          return null;
        }, lineTo: function(e, t) {
          e instanceof Ge ? this._tmpVec2B.copy(e) : typeof e == "object" ? this._tmpVec2B.setFromObject(
          e) : this._tmpVec2B.set(e, t);
          var i = this.getEndPoint(this._tmpVec2A);
          return this.add(new Wd([i.x, i.y, this._tmpVec2B.x, this._tmpVec2B.y]));
        }, splineTo: function(e) {
          return e.unshift(this.getEndPoint()), this.add(new P2(e));
        }, moveTo: function(e, t) {
          return e instanceof Ge ? this.add(new A22(e.x, e.y)) : this.add(new A22(e, t));
        }, toJSON: function() {
          for (var e = [], t = 0; t < this.curves.length; t++) e.push(this.curves[t].toJSON());
          return { type: "Path", x: this.startPoint.x, y: this.startPoint.y, autoClose: this.autoClose,
          curves: e };
        }, updateArcLengths: function() {
          this.cacheLengths = [], this.getCurveLengths();
        }, destroy: function() {
          this.curves.length = 0, this.cacheLengths.length = 0, this.startPoint = void 0;
        } });
        sae.register("path", function(e, t) {
          return new q2(e, t);
        });
        F22.exports = q2;
      });
      O2 = u((kPe, L2) => {
        L2.exports = { Path: b2(), MoveTo: zd(), CubicBezier: Dd(), Curve: Ir(), Ellipse: Bd(), Line: Ud(),
        QuadraticBezier: Xd(), Spline: Yd() };
      });
      I2 = u((XPe, N22) => {
        var nae = C(), Hd = Rn(), aae = rt(), Bs = qe(), D22 = new nae({ Extends: Hd, initialize: function(t) {
          Hd.call(this, t, t.sys.events), this.scene = t, this.systems = t.sys, t.sys.events.once(Bs.
          BOOT, this.boot, this), t.sys.events.on(Bs.START, this.start, this);
        }, boot: function() {
          this.events = this.systems.events, this.events.once(Bs.DESTROY, this.destroy, this);
        }, start: function() {
          this.events.once(Bs.SHUTDOWN, this.shutdown, this);
        }, shutdown: function() {
          this.systems.events.off(Bs.SHUTDOWN, this.shutdown, this);
        }, destroy: function() {
          Hd.prototype.destroy.call(this), this.events.off(Bs.START, this.start, this), this.scene =
          null, this.systems = null;
        } });
        aae.register("DataManagerPlugin", D22, "data");
        N22.exports = D22;
      });
      G2 = u((VPe, B22) => {
        B22.exports = { DataManager: Rn(), DataManagerPlugin: I2(), Events: fl() };
      });
      z2 = u((YPe, U2) => {
        U2.exports = { BottomCenter: bu(), BottomLeft: Lu(), BottomRight: Ou(), Center: Du(), LeftCenter: Nu(),
        QuickSet: zu(), RightCenter: Iu(), TopCenter: Bu(), TopLeft: Gu(), TopRight: Uu() };
      });
      X2 = u((WPe, k2) => {
        k2.exports = { BottomCenter: Eu(), BottomLeft: Tu(), BottomRight: yu(), LeftBottom: Su(), LeftCenter: wu(),
        LeftTop: Cu(), QuickSet: Fu(), RightBottom: Au(), RightCenter: Ru(), RightTop: _u(), TopCenter: Pu(),
        TopLeft: Mu(), TopRight: qu() };
      });
      Y2 = u((HPe, V24) => {
        var oae = cn(), hae = Xe(), Kd = { In: z2(), To: X2() };
        Kd = hae(false, Kd, oae);
        V24.exports = Kd;
      });
      H2 = u((KPe, W2) => {
        W2.exports = { BitmapMask: nl(), GeometryMask: al() };
      });
      J2 = u((ZPe, Q2) => {
        var uae = C(), K2 = Z(), lae = rt(), Z2 = new uae({ Extends: K2, initialize: function() {
          K2.call(this);
        }, shutdown: function() {
          this.removeAllListeners();
        }, destroy: function() {
          this.removeAllListeners();
        } });
        lae.register("EventEmitter", Z2, "events");
        Q2.exports = Z2;
      });
      j2 = u((QPe, $2) => {
        $2.exports = { EventEmitter: J2() };
      });
      jo = u((JPe, eO) => {
        var fae = function(e, t) {
          var i;
          if (t) typeof t == "string" ? i = document.getElementById(t) : typeof t == "object" && t.nodeType ===
          1 && (i = t);
          else if (e.parentElement || t === null) return e;
          return i || (i = document.body), i.appendChild(e), e;
        };
        eO.exports = fae;
      });
      iO = u(($Pe, tO) => {
        var dae = jo(), cae = function(e) {
          var t = e.config;
          if (!(!t.parent || !t.domCreateContainer)) {
            var i = document.createElement("div");
            i.style.cssText = ["display: block;", "width: " + e.scale.width + "px;", "height: " + e.
            scale.height + "px;", "padding: 0; margin: 0;", "position: absolute;", "overflow: hidden\
;", "pointer-events: " + t.domPointerEvents + ";", "transform: scale(1);", "transform-origin: left t\
op;"].join(" "), e.domContainer = i, dae(i, t.parent);
          }
        };
        tO.exports = cae;
      });
      sO = u((jPe, rO) => {
        var vae = ds(), pae = function(e) {
          if (document.readyState === "complete" || document.readyState === "interactive") {
            e();
            return;
          }
          var t = function() {
            document.removeEventListener("deviceready", t, true), document.removeEventListener("DOMC\
ontentLoaded", t, true), window.removeEventListener("load", t, true), e();
          };
          document.body ? vae.cordova ? document.addEventListener("deviceready", t, false) : (document.
          addEventListener("DOMContentLoaded", t, true), window.addEventListener("load", t, true)) :
          window.setTimeout(t, 20);
        };
        rO.exports = pae;
      });
      eh = u((eMe, nO) => {
        var mae = { MOUSE_DOWN: 0, MOUSE_MOVE: 1, MOUSE_UP: 2, TOUCH_START: 3, TOUCH_MOVE: 4, TOUCH_END: 5,
        POINTER_LOCK_CHANGE: 6, TOUCH_CANCEL: 7, MOUSE_WHEEL: 8 };
        nO.exports = mae;
      });
      oO = u((tMe, aO) => {
        aO.exports = "boot";
      });
      uO = u((iMe, hO) => {
        hO.exports = "destroy";
      });
      fO = u((rMe, lO) => {
        lO.exports = "dragend";
      });
      cO = u((sMe, dO) => {
        dO.exports = "dragenter";
      });
      pO = u((nMe, vO) => {
        vO.exports = "drag";
      });
      gO = u((aMe, mO) => {
        mO.exports = "dragleave";
      });
      EO = u((oMe, xO) => {
        xO.exports = "dragover";
      });
      yO = u((hMe, TO) => {
        TO.exports = "dragstart";
      });
      wO = u((uMe, SO) => {
        SO.exports = "drop";
      });
      AO = u((lMe, CO) => {
        CO.exports = "gameout";
      });
      _O = u((fMe, RO) => {
        RO.exports = "gameover";
      });
      MO = u((dMe, PO) => {
        PO.exports = "gameobjectdown";
      });
      FO = u((cMe, qO) => {
        qO.exports = "dragend";
      });
      LO = u((vMe, bO) => {
        bO.exports = "dragenter";
      });
      DO = u((pMe, OO) => {
        OO.exports = "drag";
      });
      IO = u((mMe, NO) => {
        NO.exports = "dragleave";
      });
      GO = u((gMe, BO) => {
        BO.exports = "dragover";
      });
      zO = u((xMe, UO) => {
        UO.exports = "dragstart";
      });
      XO = u((EMe, kO) => {
        kO.exports = "drop";
      });
      YO = u((TMe, VO) => {
        VO.exports = "gameobjectmove";
      });
      HO = u((yMe, WO) => {
        WO.exports = "gameobjectout";
      });
      ZO = u((SMe, KO) => {
        KO.exports = "gameobjectover";
      });
      JO = u((wMe, QO) => {
        QO.exports = "pointerdown";
      });
      jO = u((CMe, $O) => {
        $O.exports = "pointermove";
      });
      tD = u((AMe, eD) => {
        eD.exports = "pointerout";
      });
      rD = u((RMe, iD) => {
        iD.exports = "pointerover";
      });
      nD = u((_Me, sD) => {
        sD.exports = "pointerup";
      });
      oD = u((PMe, aD) => {
        aD.exports = "wheel";
      });
      uD = u((MMe, hD) => {
        hD.exports = "gameobjectup";
      });
      fD = u((qMe, lD) => {
        lD.exports = "gameobjectwheel";
      });
      cD = u((FMe, dD) => {
        dD.exports = "boot";
      });
      pD = u((bMe, vD) => {
        vD.exports = "process";
      });
      gD = u((LMe, mD) => {
        mD.exports = "update";
      });
      ED = u((OMe, xD) => {
        xD.exports = "pointerdown";
      });
      yD = u((DMe, TD) => {
        TD.exports = "pointerdownoutside";
      });
      wD = u((NMe, SD) => {
        SD.exports = "pointermove";
      });
      AD = u((IMe, CD) => {
        CD.exports = "pointerout";
      });
      _D = u((BMe, RD) => {
        RD.exports = "pointerover";
      });
      MD = u((GMe, PD) => {
        PD.exports = "pointerup";
      });
      FD = u((UMe, qD) => {
        qD.exports = "pointerupoutside";
      });
      LD = u((zMe, bD) => {
        bD.exports = "wheel";
      });
      DD = u((kMe, OD) => {
        OD.exports = "pointerlockchange";
      });
      ID = u((XMe, ND) => {
        ND.exports = "preupdate";
      });
      GD = u((VMe, BD) => {
        BD.exports = "shutdown";
      });
      zD = u((YMe, UD) => {
        UD.exports = "start";
      });
      XD = u((WMe, kD) => {
        kD.exports = "update";
      });
      Mi = u((HMe, VD) => {
        VD.exports = { BOOT: oO(), DESTROY: uO(), DRAG_END: fO(), DRAG_ENTER: cO(), DRAG: pO(), DRAG_LEAVE: gO(),
        DRAG_OVER: EO(), DRAG_START: yO(), DROP: wO(), GAME_OUT: AO(), GAME_OVER: _O(), GAMEOBJECT_DOWN: MO(),
        GAMEOBJECT_DRAG_END: FO(), GAMEOBJECT_DRAG_ENTER: LO(), GAMEOBJECT_DRAG: DO(), GAMEOBJECT_DRAG_LEAVE: IO(),
        GAMEOBJECT_DRAG_OVER: GO(), GAMEOBJECT_DRAG_START: zO(), GAMEOBJECT_DROP: XO(), GAMEOBJECT_MOVE: YO(),
        GAMEOBJECT_OUT: HO(), GAMEOBJECT_OVER: ZO(), GAMEOBJECT_POINTER_DOWN: JO(), GAMEOBJECT_POINTER_MOVE: jO(),
        GAMEOBJECT_POINTER_OUT: tD(), GAMEOBJECT_POINTER_OVER: rD(), GAMEOBJECT_POINTER_UP: nD(), GAMEOBJECT_POINTER_WHEEL: oD(),
        GAMEOBJECT_UP: uD(), GAMEOBJECT_WHEEL: fD(), MANAGER_BOOT: cD(), MANAGER_PROCESS: pD(), MANAGER_UPDATE: gD(),
        POINTER_DOWN: ED(), POINTER_DOWN_OUTSIDE: yD(), POINTER_MOVE: wD(), POINTER_OUT: AD(), POINTER_OVER: _D(),
        POINTER_UP: MD(), POINTER_UP_OUTSIDE: FD(), POINTER_WHEEL: LD(), POINTERLOCK_CHANGE: DD(), PRE_UPDATE: ID(),
        SHUTDOWN: GD(), START: zD(), UPDATE: XD() };
      });
      Jn = u((KMe, YD) => {
        var gae = { BACKSPACE: 8, TAB: 9, ENTER: 13, SHIFT: 16, CTRL: 17, ALT: 18, PAUSE: 19, CAPS_LOCK: 20,
        ESC: 27, SPACE: 32, PAGE_UP: 33, PAGE_DOWN: 34, END: 35, HOME: 36, LEFT: 37, UP: 38, RIGHT: 39,
        DOWN: 40, PRINT_SCREEN: 42, INSERT: 45, DELETE: 46, ZERO: 48, ONE: 49, TWO: 50, THREE: 51, FOUR: 52,
        FIVE: 53, SIX: 54, SEVEN: 55, EIGHT: 56, NINE: 57, NUMPAD_ZERO: 96, NUMPAD_ONE: 97, NUMPAD_TWO: 98,
        NUMPAD_THREE: 99, NUMPAD_FOUR: 100, NUMPAD_FIVE: 101, NUMPAD_SIX: 102, NUMPAD_SEVEN: 103, NUMPAD_EIGHT: 104,
        NUMPAD_NINE: 105, NUMPAD_ADD: 107, NUMPAD_SUBTRACT: 109, A: 65, B: 66, C: 67, D: 68, E: 69, F: 70,
        G: 71, H: 72, I: 73, J: 74, K: 75, L: 76, M: 77, N: 78, O: 79, P: 80, Q: 81, R: 82, S: 83, T: 84,
        U: 85, V: 86, W: 87, X: 88, Y: 89, Z: 90, F1: 112, F2: 113, F3: 114, F4: 115, F5: 116, F6: 117,
        F7: 118, F8: 119, F9: 120, F10: 121, F11: 122, F12: 123, SEMICOLON: 186, PLUS: 187, COMMA: 188,
        MINUS: 189, PERIOD: 190, FORWARD_SLASH: 191, BACK_SLASH: 220, QUOTES: 222, BACKTICK: 192, OPEN_BRACKET: 219,
        CLOSED_BRACKET: 221, SEMICOLON_FIREFOX: 59, COLON: 58, COMMA_FIREFOX_WINDOWS: 60, COMMA_FIREFOX: 62,
        BRACKET_RIGHT_FIREFOX: 174, BRACKET_LEFT_FIREFOX: 175 };
        YD.exports = gae;
      });
      Qd = u((ZMe, ZD) => {
        var xae = Jt(), Eae = C(), WD = Ye(), Zd = Mi(), HD = Jn(), KD = J(), Tae = new Eae({ initialize: function(t) {
          this.manager = t, this.queue = [], this.preventDefault = true, this.captures = [], this.enabled =
          false, this.target, this.onKeyDown = KD, this.onKeyUp = KD, t.events.once(Zd.MANAGER_BOOT,
          this.boot, this);
        }, boot: function() {
          var e = this.manager.config;
          this.enabled = e.inputKeyboard, this.target = e.inputKeyboardEventTarget, this.addCapture(
          e.inputKeyboardCapture), !this.target && window && (this.target = window), this.enabled &&
          this.target && this.startListeners(), this.manager.game.events.on(WD.POST_STEP, this.postUpdate,
          this);
        }, startListeners: function() {
          var e = this;
          this.onKeyDown = function(i) {
            if (!(i.defaultPrevented || !e.enabled || !e.manager)) {
              e.queue.push(i), e.manager.events.emit(Zd.MANAGER_PROCESS);
              var r = i.altKey || i.ctrlKey || i.shiftKey || i.metaKey;
              e.preventDefault && !r && e.captures.indexOf(i.keyCode) > -1 && i.preventDefault();
            }
          }, this.onKeyUp = function(i) {
            if (!(i.defaultPrevented || !e.enabled || !e.manager)) {
              e.queue.push(i), e.manager.events.emit(Zd.MANAGER_PROCESS);
              var r = i.altKey || i.ctrlKey || i.shiftKey || i.metaKey;
              e.preventDefault && !r && e.captures.indexOf(i.keyCode) > -1 && i.preventDefault();
            }
          };
          var t = this.target;
          t && (t.addEventListener("keydown", this.onKeyDown, false), t.addEventListener("keyup", this.
          onKeyUp, false), this.enabled = true);
        }, stopListeners: function() {
          var e = this.target;
          e.removeEventListener("keydown", this.onKeyDown, false), e.removeEventListener("keyup", this.
          onKeyUp, false), this.enabled = false;
        }, postUpdate: function() {
          this.queue = [];
        }, addCapture: function(e) {
          typeof e == "string" && (e = e.split(",")), Array.isArray(e) || (e = [e]);
          for (var t = this.captures, i = 0; i < e.length; i++) {
            var r = e[i];
            typeof r == "string" && (r = HD[r.trim().toUpperCase()]), t.indexOf(r) === -1 && t.push(
            r);
          }
          this.preventDefault = t.length > 0;
        }, removeCapture: function(e) {
          typeof e == "string" && (e = e.split(",")), Array.isArray(e) || (e = [e]);
          for (var t = this.captures, i = 0; i < e.length; i++) {
            var r = e[i];
            typeof r == "string" && (r = HD[r.toUpperCase()]), xae(t, r);
          }
          this.preventDefault = t.length > 0;
        }, clearCaptures: function() {
          this.captures = [], this.preventDefault = false;
        }, destroy: function() {
          this.stopListeners(), this.clearCaptures(), this.queue = [], this.manager.game.events.off(
          WD.POST_RENDER, this.postUpdate, this), this.target = null, this.enabled = false, this.manager =
          null;
        } });
        ZD.exports = Tae;
      });
      Jd = u((QMe, QD) => {
        var yae = C(), th = Xa(), Sae = Mi(), qi = J(), wae = new yae({ initialize: function(t) {
          this.manager = t, this.preventDefaultDown = true, this.preventDefaultUp = true, this.preventDefaultMove =
          true, this.preventDefaultWheel = false, this.enabled = false, this.target, this.locked = false,
          this.onMouseMove = qi, this.onMouseDown = qi, this.onMouseUp = qi, this.onMouseDownWindow =
          qi, this.onMouseUpWindow = qi, this.onMouseOver = qi, this.onMouseOut = qi, this.onMouseWheel =
          qi, this.pointerLockChange = qi, this.isTop = true, t.events.once(Sae.MANAGER_BOOT, this.boot,
          this);
        }, boot: function() {
          var e = this.manager.config;
          this.enabled = e.inputMouse, this.target = e.inputMouseEventTarget, this.passive = e.inputMousePassive,
          this.preventDefaultDown = e.inputMousePreventDefaultDown, this.preventDefaultUp = e.inputMousePreventDefaultUp,
          this.preventDefaultMove = e.inputMousePreventDefaultMove, this.preventDefaultWheel = e.inputMousePreventDefaultWheel,
          this.target ? typeof this.target == "string" && (this.target = document.getElementById(this.
          target)) : this.target = this.manager.game.canvas, e.disableContextMenu && this.disableContextMenu(),
          this.enabled && this.target && this.startListeners();
        }, disableContextMenu: function() {
          return this.target.addEventListener("contextmenu", function(e) {
            return e.preventDefault(), false;
          }), this;
        }, requestPointerLock: function() {
          if (th.pointerLock) {
            var e = this.target;
            e.requestPointerLock = e.requestPointerLock || e.mozRequestPointerLock || e.webkitRequestPointerLock,
            e.requestPointerLock();
          }
        }, releasePointerLock: function() {
          th.pointerLock && (document.exitPointerLock = document.exitPointerLock || document.mozExitPointerLock ||
          document.webkitExitPointerLock, document.exitPointerLock());
        }, startListeners: function() {
          var e = this.target;
          if (e) {
            var t = this, i = this.manager, r = i.canvas, s = window && window.focus && i.game.config.
            autoFocus;
            this.onMouseMove = function(a) {
              !a.defaultPrevented && t.enabled && i && i.enabled && (i.onMouseMove(a), t.preventDefaultMove &&
              a.preventDefault());
            }, this.onMouseDown = function(a) {
              s && window.focus(), !a.defaultPrevented && t.enabled && i && i.enabled && (i.onMouseDown(
              a), t.preventDefaultDown && a.target === r && a.preventDefault());
            }, this.onMouseDownWindow = function(a) {
              a.sourceCapabilities && a.sourceCapabilities.firesTouchEvents || !a.defaultPrevented &&
              t.enabled && i && i.enabled && a.target !== r && i.onMouseDown(a);
            }, this.onMouseUp = function(a) {
              !a.defaultPrevented && t.enabled && i && i.enabled && (i.onMouseUp(a), t.preventDefaultUp &&
              a.target === r && a.preventDefault());
            }, this.onMouseUpWindow = function(a) {
              a.sourceCapabilities && a.sourceCapabilities.firesTouchEvents || !a.defaultPrevented &&
              t.enabled && i && i.enabled && a.target !== r && i.onMouseUp(a);
            }, this.onMouseOver = function(a) {
              !a.defaultPrevented && t.enabled && i && i.enabled && i.setCanvasOver(a);
            }, this.onMouseOut = function(a) {
              !a.defaultPrevented && t.enabled && i && i.enabled && i.setCanvasOut(a);
            }, this.onMouseWheel = function(a) {
              !a.defaultPrevented && t.enabled && i && i.enabled && i.onMouseWheel(a), t.preventDefaultWheel &&
              a.target === r && a.preventDefault();
            };
            var n = { passive: true };
            if (e.addEventListener("mousemove", this.onMouseMove), e.addEventListener("mousedown", this.
            onMouseDown), e.addEventListener("mouseup", this.onMouseUp), e.addEventListener("mouseov\
er", this.onMouseOver, n), e.addEventListener("mouseout", this.onMouseOut, n), this.preventDefaultWheel ?
            e.addEventListener("wheel", this.onMouseWheel, { passive: false }) : e.addEventListener(
            "wheel", this.onMouseWheel, n), window && i.game.config.inputWindowEvents) try {
              window.top.addEventListener("mousedown", this.onMouseDownWindow, n), window.top.addEventListener(
              "mouseup", this.onMouseUpWindow, n);
            } catch (a) {
              window.addEventListener("mousedown", this.onMouseDownWindow, n), window.addEventListener(
              "mouseup", this.onMouseUpWindow, n), this.isTop = false;
            }
            th.pointerLock && (this.pointerLockChange = function(a) {
              var o = t.target;
              t.locked = document.pointerLockElement === o || document.mozPointerLockElement === o ||
              document.webkitPointerLockElement === o, i.onPointerLockChange(a);
            }, document.addEventListener("pointerlockchange", this.pointerLockChange, true), document.
            addEventListener("mozpointerlockchange", this.pointerLockChange, true), document.addEventListener(
            "webkitpointerlockchange", this.pointerLockChange, true)), this.enabled = true;
          }
        }, stopListeners: function() {
          var e = this.target;
          e.removeEventListener("mousemove", this.onMouseMove), e.removeEventListener("mousedown", this.
          onMouseDown), e.removeEventListener("mouseup", this.onMouseUp), e.removeEventListener("mou\
seover", this.onMouseOver), e.removeEventListener("mouseout", this.onMouseOut), window && (e = this.
          isTop ? window.top : window, e.removeEventListener("mousedown", this.onMouseDownWindow), e.
          removeEventListener("mouseup", this.onMouseUpWindow)), th.pointerLock && (document.removeEventListener(
          "pointerlockchange", this.pointerLockChange, true), document.removeEventListener("mozpoint\
erlockchange", this.pointerLockChange, true), document.removeEventListener("webkitpointerlockchange",
          this.pointerLockChange, true));
        }, destroy: function() {
          this.stopListeners(), this.target = null, this.enabled = false, this.manager = null;
        } });
        QD.exports = wae;
      });
      jd = u((JMe, jD) => {
        var $d = Kl(), Cae = C(), JD = Nn(), $D = Ja(), ih = of(), rh = Y(), Aae = ds(), Rae = new Cae(
        { initialize: function(t, i) {
          this.manager = t, this.id = i, this.event, this.downElement, this.upElement, this.camera =
          null, this.button = 0, this.buttons = 0, this.position = new rh(), this.prevPosition = new rh(),
          this.midPoint = new rh(-1, -1), this.velocity = new rh(), this.angle = 0, this.distance = 0,
          this.smoothFactor = 0, this.motionFactor = 0.2, this.worldX = 0, this.worldY = 0, this.moveTime =
          0, this.downX = 0, this.downY = 0, this.downTime = 0, this.upX = 0, this.upY = 0, this.upTime =
          0, this.primaryDown = false, this.isDown = false, this.wasTouch = false, this.wasCanceled =
          false, this.movementX = 0, this.movementY = 0, this.identifier = 0, this.pointerId = null,
          this.active = i === 0, this.locked = false, this.deltaX = 0, this.deltaY = 0, this.deltaZ =
          0;
        }, updateWorldPoint: function(e) {
          var t = e.getWorldPoint(this.x, this.y);
          return this.worldX = t.x, this.worldY = t.y, this;
        }, positionToCamera: function(e, t) {
          return e.getWorldPoint(this.x, this.y, t);
        }, updateMotion: function() {
          var e = this.position.x, t = this.position.y, i = this.midPoint.x, r = this.midPoint.y;
          if (!(e === i && t === r)) {
            var s = ih(this.motionFactor, i, e), n = ih(this.motionFactor, r, t);
            $D(s, e, 0.1) && (s = e), $D(n, t, 0.1) && (n = t), this.midPoint.set(s, n);
            var a = e - s, o = t - n;
            this.velocity.set(a, o), this.angle = $d(s, n, e, t), this.distance = Math.sqrt(a * a + o *
            o);
          }
        }, up: function(e) {
          "buttons" in e && (this.buttons = e.buttons), this.event = e, this.button = e.button, this.
          upElement = e.target, this.manager.transformPointer(this, e.pageX, e.pageY, false), e.button ===
          0 && (this.primaryDown = false, this.upX = this.x, this.upY = this.y), this.buttons === 0 &&
          (this.isDown = false, this.upTime = e.timeStamp, this.wasTouch = false);
        }, down: function(e) {
          "buttons" in e && (this.buttons = e.buttons), this.event = e, this.button = e.button, this.
          downElement = e.target, this.manager.transformPointer(this, e.pageX, e.pageY, false), e.button ===
          0 && (this.primaryDown = true, this.downX = this.x, this.downY = this.y), Aae.macOS && e.ctrlKey &&
          (this.buttons = 2, this.primaryDown = false), this.isDown || (this.isDown = true, this.downTime =
          e.timeStamp), this.wasTouch = false;
        }, move: function(e) {
          "buttons" in e && (this.buttons = e.buttons), this.event = e, this.manager.transformPointer(
          this, e.pageX, e.pageY, true), this.locked && (this.movementX = e.movementX || e.mozMovementX ||
          e.webkitMovementX || 0, this.movementY = e.movementY || e.mozMovementY || e.webkitMovementY ||
          0), this.moveTime = e.timeStamp, this.wasTouch = false;
        }, wheel: function(e) {
          "buttons" in e && (this.buttons = e.buttons), this.event = e, this.manager.transformPointer(
          this, e.pageX, e.pageY, false), this.deltaX = e.deltaX, this.deltaY = e.deltaY, this.deltaZ =
          e.deltaZ, this.wasTouch = false;
        }, touchstart: function(e, t) {
          e.pointerId && (this.pointerId = e.pointerId), this.identifier = e.identifier, this.target =
          e.target, this.active = true, this.buttons = 1, this.event = t, this.downElement = e.target,
          this.manager.transformPointer(this, e.pageX, e.pageY, false), this.primaryDown = true, this.
          downX = this.x, this.downY = this.y, this.downTime = t.timeStamp, this.isDown = true, this.
          wasTouch = true, this.wasCanceled = false, this.updateMotion();
        }, touchmove: function(e, t) {
          this.event = t, this.manager.transformPointer(this, e.pageX, e.pageY, true), this.moveTime =
          t.timeStamp, this.wasTouch = true, this.updateMotion();
        }, touchend: function(e, t) {
          this.buttons = 0, this.event = t, this.upElement = e.target, this.manager.transformPointer(
          this, e.pageX, e.pageY, false), this.primaryDown = false, this.upX = this.x, this.upY = this.
          y, this.upTime = t.timeStamp, this.isDown = false, this.wasTouch = true, this.wasCanceled =
          false, this.active = false, this.updateMotion();
        }, touchcancel: function(e, t) {
          this.buttons = 0, this.event = t, this.upElement = e.target, this.manager.transformPointer(
          this, e.pageX, e.pageY, false), this.primaryDown = false, this.upX = this.x, this.upY = this.
          y, this.upTime = t.timeStamp, this.isDown = false, this.wasTouch = true, this.wasCanceled =
          true, this.active = false;
        }, noButtonDown: function() {
          return this.buttons === 0;
        }, leftButtonDown: function() {
          return !!(this.buttons & 1);
        }, rightButtonDown: function() {
          return !!(this.buttons & 2);
        }, middleButtonDown: function() {
          return !!(this.buttons & 4);
        }, backButtonDown: function() {
          return !!(this.buttons & 8);
        }, forwardButtonDown: function() {
          return !!(this.buttons & 16);
        }, leftButtonReleased: function() {
          return this.buttons === 0 ? this.button === 0 && !this.isDown : this.button === 0;
        }, rightButtonReleased: function() {
          return this.buttons === 0 ? this.button === 2 && !this.isDown : this.button === 2;
        }, middleButtonReleased: function() {
          return this.buttons === 0 ? this.button === 1 && !this.isDown : this.button === 1;
        }, backButtonReleased: function() {
          return this.buttons === 0 ? this.button === 3 && !this.isDown : this.button === 3;
        }, forwardButtonReleased: function() {
          return this.buttons === 0 ? this.button === 4 && !this.isDown : this.button === 4;
        }, getDistance: function() {
          return this.isDown ? JD(this.downX, this.downY, this.x, this.y) : JD(this.downX, this.downY,
          this.upX, this.upY);
        }, getDistanceX: function() {
          return this.isDown ? Math.abs(this.downX - this.x) : Math.abs(this.downX - this.upX);
        }, getDistanceY: function() {
          return this.isDown ? Math.abs(this.downY - this.y) : Math.abs(this.downY - this.upY);
        }, getDuration: function() {
          return this.isDown ? this.manager.time - this.downTime : this.upTime - this.downTime;
        }, getAngle: function() {
          return this.isDown ? $d(this.downX, this.downY, this.x, this.y) : $d(this.downX, this.downY,
          this.upX, this.upY);
        }, getInterpolatedPosition: function(e, t) {
          e === void 0 && (e = 10), t === void 0 && (t = []);
          for (var i = this.prevPosition.x, r = this.prevPosition.y, s = this.position.x, n = this.position.
          y, a = 0; a < e; a++) {
            var o = 1 / e * a;
            t[a] = { x: ih(o, i, s), y: ih(o, r, n) };
          }
          return t;
        }, reset: function() {
          this.event = null, this.downElement = null, this.upElement = null, this.button = 0, this.buttons =
          0, this.position.set(0, 0), this.prevPosition.set(0, 0), this.midPoint.set(-1, -1), this.velocity.
          set(0, 0), this.angle = 0, this.distance = 0, this.worldX = 0, this.worldY = 0, this.downX =
          0, this.downY = 0, this.upX = 0, this.upY = 0, this.moveTime = 0, this.upTime = 0, this.downTime =
          0, this.primaryDown = false, this.isDown = false, this.wasTouch = false, this.wasCanceled =
          false, this.movementX = 0, this.movementY = 0, this.identifier = 0, this.pointerId = null,
          this.deltaX = 0, this.deltaY = 0, this.deltaZ = 0, this.active = this.id === 0;
        }, destroy: function() {
          this.camera = null, this.manager = null, this.position = null;
        }, x: { get: function() {
          return this.position.x;
        }, set: function(e) {
          this.position.x = e;
        } }, y: { get: function() {
          return this.position.y;
        }, set: function(e) {
          this.position.y = e;
        } }, time: { get: function() {
          return this.event ? this.event.timeStamp : 0;
        } } });
        jD.exports = Rae;
      });
      ec = u(($Me, eN) => {
        var _ae = C(), Pae = Mi(), Gr = J(), Mae = new _ae({ initialize: function(t) {
          this.manager = t, this.capture = true, this.enabled = false, this.target, this.onTouchStart =
          Gr, this.onTouchStartWindow = Gr, this.onTouchMove = Gr, this.onTouchEnd = Gr, this.onTouchEndWindow =
          Gr, this.onTouchCancel = Gr, this.onTouchCancelWindow = Gr, this.isTop = true, t.events.once(
          Pae.MANAGER_BOOT, this.boot, this);
        }, boot: function() {
          var e = this.manager.config;
          this.enabled = e.inputTouch, this.target = e.inputTouchEventTarget, this.capture = e.inputTouchCapture,
          this.target ? typeof this.target == "string" && (this.target = document.getElementById(this.
          target)) : this.target = this.manager.game.canvas, e.disableContextMenu && this.disableContextMenu(),
          this.enabled && this.target && this.startListeners();
        }, disableContextMenu: function() {
          return this.target.addEventListener("contextmenu", function(e) {
            return e.preventDefault(), false;
          }), this;
        }, startListeners: function() {
          var e = this.target;
          if (e) {
            var t = this, i = this.manager, r = i.canvas, s = window && window.focus && i.game.config.
            autoFocus;
            this.onTouchMove = function(h) {
              !h.defaultPrevented && t.enabled && i && i.enabled && (i.onTouchMove(h), t.capture && h.
              cancelable && h.preventDefault());
            }, this.onTouchStart = function(h) {
              s && window.focus(), !h.defaultPrevented && t.enabled && i && i.enabled && (i.onTouchStart(
              h), t.capture && h.cancelable && h.target === r && h.preventDefault());
            }, this.onTouchStartWindow = function(h) {
              !h.defaultPrevented && t.enabled && i && i.enabled && h.target !== r && i.onTouchStart(
              h);
            }, this.onTouchEnd = function(h) {
              !h.defaultPrevented && t.enabled && i && i.enabled && (i.onTouchEnd(h), t.capture && h.
              cancelable && h.target === r && h.preventDefault());
            }, this.onTouchEndWindow = function(h) {
              !h.defaultPrevented && t.enabled && i && i.enabled && h.target !== r && i.onTouchEnd(h);
            }, this.onTouchCancel = function(h) {
              !h.defaultPrevented && t.enabled && i && i.enabled && (i.onTouchCancel(h), t.capture &&
              h.preventDefault());
            }, this.onTouchCancelWindow = function(h) {
              !h.defaultPrevented && t.enabled && i && i.enabled && i.onTouchCancel(h);
            };
            var n = this.capture, a = { passive: true }, o = { passive: false };
            if (e.addEventListener("touchstart", this.onTouchStart, n ? o : a), e.addEventListener("\
touchmove", this.onTouchMove, n ? o : a), e.addEventListener("touchend", this.onTouchEnd, n ? o : a),
            e.addEventListener("touchcancel", this.onTouchCancel, n ? o : a), window && i.game.config.
            inputWindowEvents) try {
              window.top.addEventListener("touchstart", this.onTouchStartWindow, o), window.top.addEventListener(
              "touchend", this.onTouchEndWindow, o), window.top.addEventListener("touchcancel", this.
              onTouchCancelWindow, o);
            } catch (h) {
              window.addEventListener("touchstart", this.onTouchStartWindow, o), window.addEventListener(
              "touchend", this.onTouchEndWindow, o), window.addEventListener("touchcancel", this.onTouchCancelWindow,
              o), this.isTop = false;
            }
            this.enabled = true;
          }
        }, stopListeners: function() {
          var e = this.target;
          e.removeEventListener("touchstart", this.onTouchStart), e.removeEventListener("touchmove",
          this.onTouchMove), e.removeEventListener("touchend", this.onTouchEnd), e.removeEventListener(
          "touchcancel", this.onTouchCancel), window && (e = this.isTop ? window.top : window, e.removeEventListener(
          "touchstart", this.onTouchStartWindow), e.removeEventListener("touchend", this.onTouchEndWindow),
          e.removeEventListener("touchcancel", this.onTouchCancelWindow));
        }, destroy: function() {
          this.stopListeners(), this.target = null, this.enabled = false, this.manager = null;
        } });
        eN.exports = Mae;
      });
      tc = u((jMe, rN) => {
        var qae = C(), rr = eh(), Fae = Z(), $n = Mi(), sh = Ye(), bae = Qd(), Lae = Jd(), tN = jd(),
        Oae = ec(), iN = Lt(), Dae = ro(), Nae = new qae({ initialize: function(t, i) {
          this.game = t, this.scaleManager, this.canvas, this.config = i, this.enabled = true, this.
          events = new Fae(), this.isOver = true, this.defaultCursor = "", this.keyboard = i.inputKeyboard ?
          new bae(this) : null, this.mouse = i.inputMouse ? new Lae(this) : null, this.touch = i.inputTouch ?
          new Oae(this) : null, this.pointers = [], this.pointersTotal = i.inputActivePointers;
          for (var r = 0; r <= this.pointersTotal; r++) {
            var s = new tN(this, r);
            s.smoothFactor = i.inputSmoothFactor, this.pointers.push(s);
          }
          this.mousePointer = i.inputMouse ? this.pointers[0] : null, this.activePointer = this.pointers[0],
          this.globalTopOnly = true, this.time = 0, this._tempPoint = { x: 0, y: 0 }, this._tempHitTest =
          [], this._tempMatrix = new iN(), this._tempMatrix2 = new iN(), this._tempSkip = false, this.
          mousePointerContainer = [this.mousePointer], t.events.once(sh.BOOT, this.boot, this);
        }, boot: function() {
          var e = this.game, t = e.events;
          this.canvas = e.canvas, this.scaleManager = e.scale, this.events.emit($n.MANAGER_BOOT), t.
          on(sh.PRE_RENDER, this.preRender, this), t.once(sh.DESTROY, this.destroy, this);
        }, setCanvasOver: function(e) {
          this.isOver = true, this.events.emit($n.GAME_OVER, e);
        }, setCanvasOut: function(e) {
          this.isOver = false, this.events.emit($n.GAME_OUT, e);
        }, preRender: function() {
          var e = this.game.loop.now, t = this.game.loop.delta, i = this.game.scene.getScenes(true, true);
          this.time = e, this.events.emit($n.MANAGER_UPDATE);
          for (var r = 0; r < i.length; r++) {
            var s = i[r];
            if (s.sys.input && s.sys.input.updatePoll(e, t) && this.globalTopOnly) return;
          }
        }, setDefaultCursor: function(e) {
          this.defaultCursor = e, this.canvas.style.cursor !== e && (this.canvas.style.cursor = e);
        }, setCursor: function(e) {
          e.cursor && (this.canvas.style.cursor = e.cursor);
        }, resetCursor: function(e, t) {
          (t || e && e.cursor) && this.canvas && (this.canvas.style.cursor = this.defaultCursor);
        }, addPointer: function(e) {
          e === void 0 && (e = 1);
          var t = [];
          this.pointersTotal + e > 10 && (e = 10 - this.pointersTotal);
          for (var i = 0; i < e; i++) {
            var r = this.pointers.length, s = new tN(this, r);
            s.smoothFactor = this.config.inputSmoothFactor, this.pointers.push(s), this.pointersTotal++,
            t.push(s);
          }
          return t;
        }, updateInputPlugins: function(e, t) {
          var i = this.game.scene.getScenes(false, true);
          this._tempSkip = false;
          for (var r = 0; r < i.length; r++) {
            var s = i[r];
            if (s.sys.input) {
              var n = s.sys.input.update(e, t);
              if (n && this.globalTopOnly || this._tempSkip) return;
            }
          }
        }, onTouchStart: function(e) {
          for (var t = this.pointers, i = [], r = 0; r < e.changedTouches.length; r++) for (var s = e.
          changedTouches[r], n = 1; n < t.length; n++) {
            var a = t[n];
            if (!a.active) {
              a.touchstart(s, e), this.activePointer = a, i.push(a);
              break;
            }
          }
          this.updateInputPlugins(rr.TOUCH_START, i);
        }, onTouchMove: function(e) {
          for (var t = this.pointers, i = [], r = 0; r < e.changedTouches.length; r++) for (var s = e.
          changedTouches[r], n = 1; n < t.length; n++) {
            var a = t[n];
            if (a.active && a.identifier === s.identifier) {
              var o = document.elementFromPoint(s.clientX, s.clientY), h = o === this.canvas;
              !this.isOver && h ? this.setCanvasOver(e) : this.isOver && !h && this.setCanvasOut(e),
              this.isOver && (a.touchmove(s, e), this.activePointer = a, i.push(a));
              break;
            }
          }
          this.updateInputPlugins(rr.TOUCH_MOVE, i);
        }, onTouchEnd: function(e) {
          for (var t = this.pointers, i = [], r = 0; r < e.changedTouches.length; r++) for (var s = e.
          changedTouches[r], n = 1; n < t.length; n++) {
            var a = t[n];
            if (a.active && a.identifier === s.identifier) {
              a.touchend(s, e), i.push(a);
              break;
            }
          }
          this.updateInputPlugins(rr.TOUCH_END, i);
        }, onTouchCancel: function(e) {
          for (var t = this.pointers, i = [], r = 0; r < e.changedTouches.length; r++) for (var s = e.
          changedTouches[r], n = 1; n < t.length; n++) {
            var a = t[n];
            if (a.active && a.identifier === s.identifier) {
              a.touchcancel(s, e), i.push(a);
              break;
            }
          }
          this.updateInputPlugins(rr.TOUCH_CANCEL, i);
        }, onMouseDown: function(e) {
          var t = this.mousePointer;
          t.down(e), t.updateMotion(), this.activePointer = t, this.updateInputPlugins(rr.MOUSE_DOWN,
          this.mousePointerContainer);
        }, onMouseMove: function(e) {
          var t = this.mousePointer;
          t.move(e), t.updateMotion(), this.activePointer = t, this.updateInputPlugins(rr.MOUSE_MOVE,
          this.mousePointerContainer);
        }, onMouseUp: function(e) {
          var t = this.mousePointer;
          t.up(e), t.updateMotion(), this.activePointer = t, this.updateInputPlugins(rr.MOUSE_UP, this.
          mousePointerContainer);
        }, onMouseWheel: function(e) {
          var t = this.mousePointer;
          t.wheel(e), this.activePointer = t, this.updateInputPlugins(rr.MOUSE_WHEEL, this.mousePointerContainer);
        }, onPointerLockChange: function(e) {
          var t = this.mouse.locked;
          this.mousePointer.locked = t, this.events.emit($n.POINTERLOCK_CHANGE, e, t);
        }, inputCandidate: function(e, t) {
          var i = e.input;
          if (!i || !i.enabled || !e.willRender(t)) return false;
          var r = true, s = e.parentContainer;
          if (s) do {
            if (!s.willRender(t)) {
              r = false;
              break;
            }
            s = s.parentContainer;
          } while (s);
          return r;
        }, hitTest: function(e, t, i, r) {
          r === void 0 && (r = this._tempHitTest);
          var s = this._tempPoint, n = i.scrollX, a = i.scrollY;
          r.length = 0;
          var o = e.x, h = e.y;
          i.getWorldPoint(o, h, s), e.worldX = s.x, e.worldY = s.y;
          for (var l = { x: 0, y: 0 }, f = this._tempMatrix, d = this._tempMatrix2, c = 0; c < t.length; c++) {
            var p = t[c];
            if (this.inputCandidate(p, i)) {
              var v = s.x + n * p.scrollFactorX - n, m = s.y + a * p.scrollFactorY - a;
              p.parentContainer ? (p.getWorldTransformMatrix(f, d), f.applyInverse(v, m, l)) : Dae(v,
              m, p.x, p.y, p.rotation, p.scaleX, p.scaleY, l), this.pointWithinHitArea(p, l.x, l.y) &&
              r.push(p);
            }
          }
          return r;
        }, pointWithinHitArea: function(e, t, i) {
          t += e.displayOriginX, i += e.displayOriginY;
          var r = e.input;
          return r && r.hitAreaCallback(r.hitArea, t, i, e) ? (r.localX = t, r.localY = i, true) : false;
        }, pointWithinInteractiveObject: function(e, t, i) {
          return e.hitArea ? (t += e.gameObject.displayOriginX, i += e.gameObject.displayOriginY, e.
          localX = t, e.localY = i, e.hitAreaCallback(e.hitArea, t, i, e)) : false;
        }, transformPointer: function(e, t, i, r) {
          var s = e.position, n = e.prevPosition;
          n.x = s.x, n.y = s.y;
          var a = this.scaleManager.transformX(t), o = this.scaleManager.transformY(i), h = e.smoothFactor;
          !r || h === 0 ? (s.x = a, s.y = o) : (s.x = a * h + n.x * (1 - h), s.y = o * h + n.y * (1 -
          h));
        }, destroy: function() {
          this.events.removeAllListeners(), this.game.events.off(sh.PRE_RENDER), this.keyboard && this.
          keyboard.destroy(), this.mouse && this.mouse.destroy(), this.touch && this.touch.destroy();
          for (var e = 0; e < this.pointers.length; e++) this.pointers[e].destroy();
          this.pointers = [], this._tempHitTest = [], this._tempMatrix.destroy(), this.canvas = null,
          this.game = null;
        } });
        rN.exports = Nae;
      });
      Fi = u((eqe, sN) => {
        var nh = {}, Iae = { install: function(e) {
          for (var t in nh) e[t] = nh[t];
        }, register: function(e, t) {
          nh[e] = t;
        }, destroy: function() {
          nh = {};
        } };
        sN.exports = Iae;
      });
      gt = u((tqe, nN) => {
        var Bae = C(), Gae = rt(), Gs = qe(), sr = new Bae({ initialize: function(t) {
          this.scene = t, this.systems = t.sys, this.events = t.sys.events, this.displayList, this.updateList,
          this.events.once(Gs.BOOT, this.boot, this), this.events.on(Gs.START, this.start, this);
        }, boot: function() {
          this.displayList = this.systems.displayList, this.updateList = this.systems.updateList, this.
          events.once(Gs.DESTROY, this.destroy, this);
        }, start: function() {
          this.events.once(Gs.SHUTDOWN, this.shutdown, this);
        }, shutdown: function() {
          this.events.off(Gs.SHUTDOWN, this.shutdown, this);
        }, destroy: function() {
          this.shutdown(), this.events.off(Gs.START, this.start, this), this.scene = null, this.systems =
          null, this.events = null, this.displayList = null, this.updateList = null;
        } });
        sr.register = function(e, t) {
          sr.prototype.hasOwnProperty(e) || (sr.prototype[e] = t);
        };
        sr.remove = function(e) {
          sr.prototype.hasOwnProperty(e) && delete sr.prototype[e];
        };
        Gae.register("GameObjectCreator", sr, "make");
        nN.exports = sr;
      });
      dN = u((iqe, fN) => {
        var Uae = C(), aN = Ye(), oN = Z(), zae = Fi(), hN = gt(), uN = Ne(), nr = B(), Ct = rt(), lN = Jt(),
        kae = qt(), Xae = new Uae({ Extends: oN, initialize: function(t) {
          oN.call(this), this.game = t, this.plugins = [], this.scenePlugins = [], this._pendingGlobal =
          [], this._pendingScene = [], t.isBooted || t.config.renderType === kae.HEADLESS ? this.boot() :
          t.events.once(aN.BOOT, this.boot, this);
        }, boot: function() {
          var e, t, i, r, s, n, a, o = this.game.config, h = o.installGlobalPlugins;
          for (h = h.concat(this._pendingGlobal), e = 0; e < h.length; e++) t = h[e], i = nr(t, "key",
          null), r = nr(t, "plugin", null), s = nr(t, "start", false), n = nr(t, "mapping", null), a =
          nr(t, "data", null), i && (r ? this.install(i, r, s, n, a) : console.warn("Missing `plugin\
` for key: " + i));
          for (h = o.installScenePlugins, h = h.concat(this._pendingScene), e = 0; e < h.length; e++)
           t = h[e], i = nr(t, "key", null), r = nr(t, "plugin", null), n = nr(t, "mapping", null), i &&
          (r ? this.installScenePlugin(i, r, n) : console.warn("Missing `plugin` for key: " + i));
          this._pendingGlobal = [], this._pendingScene = [], this.game.events.once(aN.DESTROY, this.
          destroy, this);
        }, addToScene: function(e, t, i) {
          var r, s, n, a = this.game, o = e.scene, h = e.settings.map, l = e.settings.isBooted;
          for (r = 0; r < t.length; r++) s = t[r], a[s] ? (e[s] = a[s], h.hasOwnProperty(s) && (o[h[s]] =
          e[s])) : s === "game" && h.hasOwnProperty(s) && (o[h[s]] = a);
          for (var f = 0; f < i.length; f++) for (n = i[f], r = 0; r < n.length; r++) if (s = n[r], !!Ct.
          hasCore(s)) {
            var d = Ct.getCore(s), c = d.mapping, p = new d.plugin(o, this, c);
            e[c] = p, d.custom ? o[c] = p : h.hasOwnProperty(c) && (o[h[c]] = p), l && p.boot();
          }
          for (n = this.plugins, r = 0; r < n.length; r++) {
            var v = n[r];
            v.mapping && (o[v.mapping] = v.plugin);
          }
        }, getDefaultScenePlugins: function() {
          var e = this.game.config.defaultPlugins;
          return e = e.concat(this.scenePlugins), e;
        }, installScenePlugin: function(e, t, i, r, s) {
          if (s === void 0 && (s = false), typeof t != "function") {
            console.warn("Invalid Scene Plugin: " + e);
            return;
          }
          if (Ct.hasCore(e) || Ct.register(e, t, i, true), this.scenePlugins.indexOf(e) === -1) this.
          scenePlugins.push(e);
          else if (!s && Ct.hasCore(e)) {
            console.warn("Scene Plugin key in use: " + e);
            return;
          }
          if (r) {
            var n = new t(r, this, e);
            r.sys[e] = n, i && i !== "" && (r[i] = n), n.boot();
          }
        }, install: function(e, t, i, r, s) {
          if (i === void 0 && (i = false), r === void 0 && (r = null), s === void 0 && (s = null), typeof t !=
          "function") return console.warn("Invalid Plugin: " + e), null;
          if (Ct.hasCustom(e)) return console.warn("Plugin key in use: " + e), null;
          if (r !== null && (i = true), !this.game.isBooted) this._pendingGlobal.push({ key: e, plugin: t,
          start: i, mapping: r, data: s });
          else if (Ct.registerCustom(e, t, r, s), i) return this.start(e);
          return null;
        }, getIndex: function(e) {
          for (var t = this.plugins, i = 0; i < t.length; i++) {
            var r = t[i];
            if (r.key === e) return i;
          }
          return -1;
        }, getEntry: function(e) {
          var t = this.getIndex(e);
          if (t !== -1) return this.plugins[t];
        }, isActive: function(e) {
          var t = this.getEntry(e);
          return t && t.active;
        }, start: function(e, t) {
          t === void 0 && (t = e);
          var i = this.getEntry(t);
          return i && !i.active ? (i.active = true, i.plugin.start()) : i || (i = this.createEntry(e,
          t)), i ? i.plugin : null;
        }, createEntry: function(e, t) {
          var i = Ct.getCustom(e);
          if (i) {
            var r = new i.plugin(this);
            i = { key: t, plugin: r, active: true, mapping: i.mapping, data: i.data }, this.plugins.
            push(i), r.init(i.data), r.start();
          }
          return i;
        }, stop: function(e) {
          var t = this.getEntry(e);
          return t && t.active && (t.active = false, t.plugin.stop()), this;
        }, get: function(e, t) {
          t === void 0 && (t = true);
          var i = this.getEntry(e);
          if (i) return i.plugin;
          var r = this.getClass(e);
          return r && t ? (i = this.createEntry(e, e), i ? i.plugin : null) : r || null;
        }, getClass: function(e) {
          return Ct.getCustomClass(e);
        }, removeGlobalPlugin: function(e) {
          var t = this.getEntry(e);
          t && lN(this.plugins, t), Ct.removeCustom(e);
        }, removeScenePlugin: function(e) {
          lN(this.scenePlugins, e), Ct.remove(e);
        }, registerGameObject: function(e, t, i) {
          return t && uN.register(e, t), i && hN.register(e, i), this;
        }, removeGameObject: function(e, t, i) {
          return t === void 0 && (t = true), i === void 0 && (i = true), t && uN.remove(e), i && hN.
          remove(e), this;
        }, registerFileType: function(e, t, i) {
          zae.register(e, t), i && i.sys.load && (i.sys.load[e] = t);
        }, destroy: function() {
          for (var e = 0; e < this.plugins.length; e++) this.plugins[e].plugin.destroy();
          Ct.destroyCustomPlugins(), this.game.noReturn && Ct.destroyCorePlugins(), this.game = null,
          this.plugins = [], this.scenePlugins = [];
        } });
        fN.exports = Xae;
      });
      ic = u((rqe, cN) => {
        cN.exports = { NO_CENTER: 0, CENTER_BOTH: 1, CENTER_HORIZONTALLY: 2, CENTER_VERTICALLY: 3 };
      });
      rc = u((sqe, vN) => {
        vN.exports = { LANDSCAPE: "landscape-primary", LANDSCAPE_SECONDARY: "landscape-secondary", PORTRAIT: "\
portrait-primary", PORTRAIT_SECONDARY: "portrait-secondary" };
      });
      sc = u((nqe, pN) => {
        pN.exports = { NONE: 0, WIDTH_CONTROLS_HEIGHT: 1, HEIGHT_CONTROLS_WIDTH: 2, FIT: 3, ENVELOP: 4,
        RESIZE: 5, EXPAND: 6 };
      });
      nc = u((aqe, mN) => {
        mN.exports = { NO_ZOOM: 1, ZOOM_2X: 2, ZOOM_4X: 4, MAX_ZOOM: -1 };
      });
      ah = u((oqe, gN) => {
        var Vae = { CENTER: ic(), ORIENTATION: rc(), SCALE_MODE: sc(), ZOOM: nc() };
        gN.exports = Vae;
      });
      EN = u((hqe, xN) => {
        var Yae = function(e) {
          if (!e) return window.innerHeight;
          var t = Math.abs(window.orientation), i = { w: 0, h: 0 }, r = document.createElement("div");
          return r.setAttribute("style", "position: fixed; height: 100vh; width: 0; top: 0"), document.
          documentElement.appendChild(r), i.w = t === 90 ? r.offsetHeight : window.innerWidth, i.h =
          t === 90 ? window.innerWidth : r.offsetHeight, document.documentElement.removeChild(r), r =
          null, Math.abs(window.orientation) !== 90 ? i.h : i.w;
        };
        xN.exports = Yae;
      });
      yN = u((uqe, TN) => {
        var Wae = function(e) {
          var t;
          return e !== "" && (typeof e == "string" ? t = document.getElementById(e) : e && e.nodeType ===
          1 && (t = e)), t || (t = document.body), t;
        };
        TN.exports = Wae;
      });
      wN = u((lqe, SN) => {
        var Us = ah(), Hae = function(e, t) {
          var i = window.screen, r = i ? i.orientation || i.mozOrientation || i.msOrientation : false;
          if (r && typeof r.type == "string") return r.type;
          if (typeof r == "string") return r;
          if (typeof window.orientation == "number") return window.orientation === 0 || window.orientation ===
          180 ? Us.ORIENTATION.PORTRAIT : Us.ORIENTATION.LANDSCAPE;
          if (window.matchMedia) {
            if (window.matchMedia("(orientation: portrait)").matches) return Us.ORIENTATION.PORTRAIT;
            if (window.matchMedia("(orientation: landscape)").matches) return Us.ORIENTATION.LANDSCAPE;
          } else return t > e ? Us.ORIENTATION.PORTRAIT : Us.ORIENTATION.LANDSCAPE;
        };
        SN.exports = Hae;
      });
      ac = u((fqe, CN) => {
        var zs = ne(), Kae = C(), ri = Un(), Zae = Y(), Wt = new Kae({ initialize: function(t, i, r, s) {
          t === void 0 && (t = 0), i === void 0 && (i = t), r === void 0 && (r = 0), s === void 0 &&
          (s = null), this._width = t, this._height = i, this._parent = s, this.aspectMode = r, this.
          aspectRatio = i === 0 ? 1 : t / i, this.minWidth = 0, this.minHeight = 0, this.maxWidth = Number.
          MAX_VALUE, this.maxHeight = Number.MAX_VALUE, this.snapTo = new Zae();
        }, setAspectMode: function(e) {
          return e === void 0 && (e = 0), this.aspectMode = e, this.setSize(this._width, this._height);
        }, setSnap: function(e, t) {
          return e === void 0 && (e = 0), t === void 0 && (t = e), this.snapTo.set(e, t), this.setSize(
          this._width, this._height);
        }, setParent: function(e) {
          return this._parent = e, this.setSize(this._width, this._height);
        }, setMin: function(e, t) {
          return e === void 0 && (e = 0), t === void 0 && (t = e), this.minWidth = zs(e, 0, this.maxWidth),
          this.minHeight = zs(t, 0, this.maxHeight), this.setSize(this._width, this._height);
        }, setMax: function(e, t) {
          return e === void 0 && (e = Number.MAX_VALUE), t === void 0 && (t = e), this.maxWidth = zs(
          e, this.minWidth, Number.MAX_VALUE), this.maxHeight = zs(t, this.minHeight, Number.MAX_VALUE),
          this.setSize(this._width, this._height);
        }, setSize: function(e, t) {
          switch (e === void 0 && (e = 0), t === void 0 && (t = e), this.aspectMode) {
            case Wt.NONE:
              this._width = this.getNewWidth(ri(e, this.snapTo.x)), this._height = this.getNewHeight(
              ri(t, this.snapTo.y)), this.aspectRatio = this._height === 0 ? 1 : this._width / this.
              _height;
              break;
            case Wt.WIDTH_CONTROLS_HEIGHT:
              this._width = this.getNewWidth(ri(e, this.snapTo.x)), this._height = this.getNewHeight(
              this._width * (1 / this.aspectRatio), false);
              break;
            case Wt.HEIGHT_CONTROLS_WIDTH:
              this._height = this.getNewHeight(ri(t, this.snapTo.y)), this._width = this.getNewWidth(
              this._height * this.aspectRatio, false);
              break;
            case Wt.FIT:
              this.constrain(e, t, true);
              break;
            case Wt.ENVELOP:
              this.constrain(e, t, false);
              break;
          }
          return this;
        }, setAspectRatio: function(e) {
          return this.aspectRatio = e, this.setSize(this._width, this._height);
        }, resize: function(e, t) {
          return this._width = this.getNewWidth(ri(e, this.snapTo.x)), this._height = this.getNewHeight(
          ri(t, this.snapTo.y)), this.aspectRatio = this._height === 0 ? 1 : this._width / this._height,
          this;
        }, getNewWidth: function(e, t) {
          return t === void 0 && (t = true), e = zs(e, this.minWidth, this.maxWidth), t && this._parent &&
          e > this._parent.width && (e = Math.max(this.minWidth, this._parent.width)), e;
        }, getNewHeight: function(e, t) {
          return t === void 0 && (t = true), e = zs(e, this.minHeight, this.maxHeight), t && this._parent &&
          e > this._parent.height && (e = Math.max(this.minHeight, this._parent.height)), e;
        }, constrain: function(e, t, i) {
          e === void 0 && (e = 0), t === void 0 && (t = e), i === void 0 && (i = true), e = this.getNewWidth(
          e), t = this.getNewHeight(t);
          var r = this.snapTo, s = t === 0 ? 1 : e / t;
          return i && this.aspectRatio > s || !i && this.aspectRatio < s ? (e = ri(e, r.x), t = e / this.
          aspectRatio, r.y > 0 && (t = ri(t, r.y), e = t * this.aspectRatio)) : (i && this.aspectRatio <
          s || !i && this.aspectRatio > s) && (t = ri(t, r.y), e = t * this.aspectRatio, r.x > 0 && (e =
          ri(e, r.x), t = e * (1 / this.aspectRatio))), this._width = e, this._height = t, this;
        }, fitTo: function(e, t) {
          return this.constrain(e, t, true);
        }, envelop: function(e, t) {
          return this.constrain(e, t, false);
        }, setWidth: function(e) {
          return this.setSize(e, this._height);
        }, setHeight: function(e) {
          return this.setSize(this._width, e);
        }, toString: function() {
          return "[{ Size (width=" + this._width + " height=" + this._height + " aspectRatio=" + this.
          aspectRatio + " aspectMode=" + this.aspectMode + ") }]";
        }, setCSS: function(e) {
          e && e.style && (e.style.width = this._width + "px", e.style.height = this._height + "px");
        }, copy: function(e) {
          return e.setAspectMode(this.aspectMode), e.aspectRatio = this.aspectRatio, e.setSize(this.
          width, this.height);
        }, destroy: function() {
          this._parent = null, this.snapTo = null;
        }, width: { get: function() {
          return this._width;
        }, set: function(e) {
          this.setSize(e, this._height);
        } }, height: { get: function() {
          return this._height;
        }, set: function(e) {
          this.setSize(this._width, e);
        } } });
        Wt.NONE = 0;
        Wt.WIDTH_CONTROLS_HEIGHT = 1;
        Wt.HEIGHT_CONTROLS_WIDTH = 2;
        Wt.FIT = 3;
        Wt.ENVELOP = 4;
        CN.exports = Wt;
      });
      oc = u((dqe, qN) => {
        var Qe = ah(), Qae = C(), AN = Z(), Ur = Ss(), oh = Ye(), Jae = EN(), RN = yN(), _N = wN(), hh = J(),
        PN = he(), uh = ac(), MN = Un(), $ae = Y(), jae = Bn(), eoe = new Qae({ Extends: AN, initialize: function(t) {
          AN.call(this), this.game = t, this.canvas, this.canvasBounds = new PN(), this.parent = null,
          this.parentIsWindow = false, this.parentSize = new uh(), this.gameSize = new uh(), this.baseSize =
          new uh(), this.displaySize = new uh(), this.scaleMode = Qe.SCALE_MODE.NONE, this.zoom = 1,
          this._resetZoom = false, this.displayScale = new $ae(1, 1), this.autoRound = false, this.autoCenter =
          Qe.CENTER.NO_CENTER, this.orientation = Qe.ORIENTATION.LANDSCAPE, this.fullscreen, this.fullscreenTarget =
          null, this._createdFullscreenTarget = false, this.dirty = false, this.resizeInterval = 500,
          this._lastCheck = 0, this._checkOrientation = false, this.domlisteners = { orientationChange: hh,
          windowResize: hh, fullScreenChange: hh, fullScreenError: hh };
        }, preBoot: function() {
          this.parseConfig(this.game.config), this.game.events.once(oh.BOOT, this.boot, this);
        }, boot: function() {
          var e = this.game;
          this.canvas = e.canvas, this.fullscreen = e.device.fullscreen;
          var t = this.scaleMode;
          t !== Qe.SCALE_MODE.RESIZE && t !== Qe.SCALE_MODE.EXPAND && this.displaySize.setAspectMode(
          t), t === Qe.SCALE_MODE.NONE ? this.resize(this.width, this.height) : (this.getParentBounds(),
          this.parentSize.width > 0 && this.parentSize.height > 0 && this.displaySize.setParent(this.
          parentSize), this.refresh()), e.events.on(oh.PRE_STEP, this.step, this), e.events.once(oh.
          READY, this.refresh, this), e.events.once(oh.DESTROY, this.destroy, this), this.startListeners();
        }, parseConfig: function(e) {
          this.getParent(e), this.getParentBounds();
          var t = e.width, i = e.height, r = e.scaleMode, s = e.zoom, n = e.autoRound;
          if (typeof t == "string") if (t.substr(-1) !== "%") t = parseInt(t, 10);
          else {
            var a = this.parentSize.width;
            a === 0 && (a = window.innerWidth);
            var o = parseInt(t, 10) / 100;
            t = Math.floor(a * o);
          }
          if (typeof i == "string") if (i.substr(-1) !== "%") i = parseInt(i, 10);
          else {
            var h = this.parentSize.height;
            h === 0 && (h = window.innerHeight);
            var l = parseInt(i, 10) / 100;
            i = Math.floor(h * l);
          }
          this.scaleMode = r, this.autoRound = n, this.autoCenter = e.autoCenter, this.resizeInterval =
          e.resizeInterval, n && (t = Math.floor(t), i = Math.floor(i)), this.gameSize.setSize(t, i),
          s === Qe.ZOOM.MAX_ZOOM && (s = this.getMaxZoom()), this.zoom = s, s !== 1 && (this._resetZoom =
          true), this.baseSize.setSize(t, i), n && (this.baseSize.width = Math.floor(this.baseSize.width),
          this.baseSize.height = Math.floor(this.baseSize.height)), e.minWidth > 0 && this.displaySize.
          setMin(e.minWidth * s, e.minHeight * s), e.maxWidth > 0 && this.displaySize.setMax(e.maxWidth *
          s, e.maxHeight * s), this.displaySize.setSize(t, i), (e.snapWidth > 0 || e.snapHeight > 0) &&
          this.displaySize.setSnap(e.snapWidth, e.snapHeight), this.orientation = _N(t, i);
        }, getParent: function(e) {
          var t = e.parent;
          if (t !== null) {
            if (this.parent = RN(t), this.parentIsWindow = this.parent === document.body, e.expandParent &&
            e.scaleMode !== Qe.SCALE_MODE.NONE) {
              var i = this.parent.getBoundingClientRect();
              (this.parentIsWindow || i.height === 0) && (document.documentElement.style.height = "1\
00%", document.body.style.height = "100%", i = this.parent.getBoundingClientRect(), !this.parentIsWindow &&
              i.height === 0 && (this.parent.style.overflow = "hidden", this.parent.style.width = "1\
00%", this.parent.style.height = "100%"));
            }
            e.fullscreenTarget && !this.fullscreenTarget && (this.fullscreenTarget = RN(e.fullscreenTarget));
          }
        }, getParentBounds: function() {
          if (!this.parent) return false;
          var e = this.parentSize, t = this.parent.getBoundingClientRect();
          this.parentIsWindow && this.game.device.os.iOS && (t.height = Jae(true));
          var i = t.width, r = t.height;
          if (e.width !== i || e.height !== r) return e.setSize(i, r), true;
          if (this.canvas) {
            var s = this.canvasBounds, n = this.canvas.getBoundingClientRect();
            if (n.x !== s.x || n.y !== s.y) return true;
          }
          return false;
        }, lockOrientation: function(e) {
          var t = screen.lockOrientation || screen.mozLockOrientation || screen.msLockOrientation;
          return t ? t.call(screen, e) : false;
        }, setParentSize: function(e, t) {
          return this.parentSize.setSize(e, t), this.refresh();
        }, setGameSize: function(e, t) {
          var i = this.autoRound;
          i && (e = Math.floor(e), t = Math.floor(t));
          var r = this.width, s = this.height;
          return this.gameSize.resize(e, t), this.baseSize.resize(e, t), i && (this.baseSize.width =
          Math.floor(this.baseSize.width), this.baseSize.height = Math.floor(this.baseSize.height)),
          this.displaySize.setAspectRatio(e / t), this.canvas.width = this.baseSize.width, this.canvas.
          height = this.baseSize.height, this.refresh(r, s);
        }, resize: function(e, t) {
          var i = this.zoom, r = this.autoRound;
          r && (e = Math.floor(e), t = Math.floor(t));
          var s = this.width, n = this.height;
          this.gameSize.resize(e, t), this.baseSize.resize(e, t), r && (this.baseSize.width = Math.floor(
          this.baseSize.width), this.baseSize.height = Math.floor(this.baseSize.height)), this.displaySize.
          setSize(e * i, t * i), this.canvas.width = this.baseSize.width, this.canvas.height = this.
          baseSize.height;
          var a = this.canvas.style, o = e * i, h = t * i;
          return r && (o = Math.floor(o), h = Math.floor(h)), (o !== e || h !== t) && (a.width = o +
          "px", a.height = h + "px"), this.refresh(s, n);
        }, setZoom: function(e) {
          return this.zoom = e, this._resetZoom = true, this.refresh();
        }, setMaxZoom: function() {
          return this.zoom = this.getMaxZoom(), this._resetZoom = true, this.refresh();
        }, setSnap: function(e, t) {
          return e === void 0 && (e = 0), t === void 0 && (t = e), this.displaySize.setSnap(e, t), this.
          refresh();
        }, refresh: function(e, t) {
          e === void 0 && (e = this.width), t === void 0 && (t = this.height), this.updateScale(), this.
          updateBounds(), this.updateOrientation(), this.displayScale.set(this.baseSize.width / this.
          canvasBounds.width, this.baseSize.height / this.canvasBounds.height);
          var i = this.game.domContainer;
          if (i) {
            this.baseSize.setCSS(i);
            var r = this.canvas.style, s = i.style;
            s.transform = "scale(" + this.displaySize.width / this.baseSize.width + "," + this.displaySize.
            height / this.baseSize.height + ")", s.marginLeft = r.marginLeft, s.marginTop = r.marginTop;
          }
          return this.emit(Ur.RESIZE, this.gameSize, this.baseSize, this.displaySize, e, t), this;
        }, updateOrientation: function() {
          if (this._checkOrientation) {
            this._checkOrientation = false;
            var e = _N(this.width, this.height);
            e !== this.orientation && (this.orientation = e, this.emit(Ur.ORIENTATION_CHANGE, e));
          }
        }, updateScale: function() {
          var e = this.canvas.style, t = this.gameSize.width, i = this.gameSize.height, r, s, n = this.
          zoom, a = this.autoRound;
          if (this.scaleMode === Qe.SCALE_MODE.NONE) this.displaySize.setSize(t * n, i * n), r = this.
          displaySize.width, s = this.displaySize.height, a && (r = Math.floor(r), s = Math.floor(s)),
          this._resetZoom && (e.width = r + "px", e.height = s + "px", this._resetZoom = false);
          else if (this.scaleMode === Qe.SCALE_MODE.RESIZE) this.displaySize.setSize(this.parentSize.
          width, this.parentSize.height), this.gameSize.setSize(this.displaySize.width, this.displaySize.
          height), this.baseSize.setSize(this.displaySize.width, this.displaySize.height), r = this.
          displaySize.width, s = this.displaySize.height, a && (r = Math.floor(r), s = Math.floor(s)),
          this.canvas.width = r, this.canvas.height = s;
          else if (this.scaleMode === Qe.SCALE_MODE.EXPAND) {
            var o = this.game.config.width, h = this.game.config.height;
            this.displaySize.setSize(this.parentSize.width, this.parentSize.height), r = this.displaySize.
            width, s = this.displaySize.height, a && (r = Math.floor(r), s = Math.floor(s)), e.width =
            r + "px", e.height = s + "px";
            var l = this.parentSize.width / o, f = this.parentSize.height / h;
            l < f && l !== 0 ? this.baseSize.setSize(o, this.parentSize.height / l) : f !== 0 && this.
            baseSize.setSize(this.displaySize.width / f, h), this.gameSize.setSize(this.baseSize.width,
            this.baseSize.height), r = this.baseSize.width, s = this.baseSize.height, a && (r = Math.
            floor(r), s = Math.floor(s)), this.canvas.width = r, this.canvas.height = s;
          } else this.displaySize.setSize(this.parentSize.width, this.parentSize.height), r = this.displaySize.
          width, s = this.displaySize.height, a && (r = Math.floor(r), s = Math.floor(s)), e.width =
          r + "px", e.height = s + "px";
          this.getParentBounds(), this.updateCenter();
        }, getMaxZoom: function() {
          var e = MN(this.parentSize.width, this.gameSize.width, 0, true), t = MN(this.parentSize.height,
          this.gameSize.height, 0, true);
          return Math.max(Math.min(e, t), 1);
        }, updateCenter: function() {
          var e = this.autoCenter;
          if (e !== Qe.CENTER.NO_CENTER) {
            var t = this.canvas, i = t.style, r = t.getBoundingClientRect(), s = r.width, n = r.height,
            a = Math.floor((this.parentSize.width - s) / 2), o = Math.floor((this.parentSize.height -
            n) / 2);
            e === Qe.CENTER.CENTER_HORIZONTALLY ? o = 0 : e === Qe.CENTER.CENTER_VERTICALLY && (a = 0),
            i.marginLeft = a + "px", i.marginTop = o + "px";
          }
        }, updateBounds: function() {
          var e = this.canvasBounds, t = this.canvas.getBoundingClientRect();
          e.x = t.left + (window.pageXOffset || 0) - (document.documentElement.clientLeft || 0), e.y =
          t.top + (window.pageYOffset || 0) - (document.documentElement.clientTop || 0), e.width = t.
          width, e.height = t.height;
        }, transformX: function(e) {
          return (e - this.canvasBounds.left) * this.displayScale.x;
        }, transformY: function(e) {
          return (e - this.canvasBounds.top) * this.displayScale.y;
        }, startFullscreen: function(e) {
          e === void 0 && (e = { navigationUI: "hide" });
          var t = this.fullscreen;
          if (!t.available) {
            this.emit(Ur.FULLSCREEN_UNSUPPORTED);
            return;
          }
          if (!t.active) {
            var i = this.getFullscreenTarget();
            t.keyboard ? i[t.request](Element.ALLOW_KEYBOARD_INPUT) : i[t.request](e);
          }
        }, fullscreenSuccessHandler: function() {
          this.getParentBounds(), this.refresh(), this.emit(Ur.ENTER_FULLSCREEN);
        }, fullscreenErrorHandler: function(e) {
          this.removeFullscreenTarget(), this.emit(Ur.FULLSCREEN_FAILED, e);
        }, getFullscreenTarget: function() {
          if (!this.fullscreenTarget) {
            var e = document.createElement("div");
            e.style.margin = "0", e.style.padding = "0", e.style.width = "100%", e.style.height = "1\
00%", this.fullscreenTarget = e, this._createdFullscreenTarget = true;
          }
          if (this._createdFullscreenTarget) {
            var t = this.canvas.parentNode;
            t.insertBefore(this.fullscreenTarget, this.canvas), this.fullscreenTarget.appendChild(this.
            canvas);
          }
          return this.fullscreenTarget;
        }, removeFullscreenTarget: function() {
          if (this._createdFullscreenTarget) {
            var e = this.fullscreenTarget;
            if (e && e.parentNode) {
              var t = e.parentNode;
              t.insertBefore(this.canvas, e), t.removeChild(e);
            }
          }
        }, stopFullscreen: function() {
          var e = this.fullscreen;
          if (!e.available) return this.emit(Ur.FULLSCREEN_UNSUPPORTED), false;
          e.active && document[e.cancel](), this.removeFullscreenTarget();
        }, leaveFullScreenSuccessHandler: function() {
          this.getParentBounds(), this.emit(Ur.LEAVE_FULLSCREEN), this.refresh();
        }, toggleFullscreen: function(e) {
          this.fullscreen.active ? this.stopFullscreen() : this.startFullscreen(e);
        }, startListeners: function() {
          var e = this, t = this.domlisteners;
          if (t.orientationChange = function() {
            e.updateBounds(), e._checkOrientation = true, e.dirty = true, e.refresh();
          }, t.windowResize = function() {
            e.updateBounds(), e.dirty = true;
          }, screen.orientation && screen.orientation.addEventListener ? screen.orientation.addEventListener(
          "change", t.orientationChange, false) : window.addEventListener("orientationchange", t.orientationChange,
          false), window.addEventListener("resize", t.windowResize, false), this.fullscreen.available) {
            t.fullScreenChange = function(r) {
              return e.onFullScreenChange(r);
            }, t.fullScreenError = function(r) {
              return e.onFullScreenError(r);
            };
            var i = ["webkit", "moz", ""];
            i.forEach(function(r) {
              document.addEventListener(r + "fullscreenchange", t.fullScreenChange, false), document.
              addEventListener(r + "fullscreenerror", t.fullScreenError, false);
            }), document.addEventListener("MSFullscreenChange", t.fullScreenChange, false), document.
            addEventListener("MSFullscreenError", t.fullScreenError, false);
          }
        }, onFullScreenChange: function() {
          document.fullscreenElement || document.webkitFullscreenElement || document.msFullscreenElement ||
          document.mozFullScreenElement ? this.fullscreenSuccessHandler() : (this.stopFullscreen(), this.
          leaveFullScreenSuccessHandler());
        }, onFullScreenError: function() {
          this.removeFullscreenTarget();
        }, getViewPort: function(e, t) {
          e instanceof jae || (t = e, e = void 0), t === void 0 && (t = new PN());
          var i = this.baseSize, r = this.parentSize, s = this.canvasBounds, n = this.displayScale, a = s.
          x >= 0 ? 0 : -(s.x * n.x), o = s.y >= 0 ? 0 : -(s.y * n.y), h;
          r.width >= s.width ? h = i.width : h = i.width - (s.width - r.width) * n.x;
          var l;
          return r.height >= s.height ? l = i.height : l = i.height - (s.height - r.height) * n.y, t.
          setTo(a, o, h, l), e && (t.width /= e.zoomX, t.height /= e.zoomY, t.centerX = e.centerX + e.
          scrollX, t.centerY = e.centerY + e.scrollY), t;
        }, step: function(e, t) {
          this.parent && (this._lastCheck += t, (this.dirty || this._lastCheck > this.resizeInterval) &&
          (this.getParentBounds() && this.refresh(), this.dirty = false, this._lastCheck = 0));
        }, stopListeners: function() {
          var e = this.domlisteners;
          screen.orientation && screen.orientation.addEventListener ? screen.orientation.removeEventListener(
          "change", e.orientationChange, false) : window.removeEventListener("orientationchange", e.
          orientationChange, false), window.removeEventListener("resize", e.windowResize, false);
          var t = ["webkit", "moz", ""];
          t.forEach(function(i) {
            document.removeEventListener(i + "fullscreenchange", e.fullScreenChange, false), document.
            removeEventListener(i + "fullscreenerror", e.fullScreenError, false);
          }), document.removeEventListener("MSFullscreenChange", e.fullScreenChange, false), document.
          removeEventListener("MSFullscreenError", e.fullScreenError, false);
        }, destroy: function() {
          this.removeAllListeners(), this.stopListeners(), this.game = null, this.canvas = null, this.
          canvasBounds = null, this.parent = null, this.fullscreenTarget = null, this.parentSize.destroy(),
          this.gameSize.destroy(), this.baseSize.destroy(), this.displaySize.destroy();
        }, isFullscreen: { get: function() {
          return this.fullscreen.active;
        } }, width: { get: function() {
          return this.gameSize.width;
        } }, height: { get: function() {
          return this.gameSize.height;
        } }, isPortrait: { get: function() {
          return this.orientation === Qe.ORIENTATION.PORTRAIT;
        } }, isLandscape: { get: function() {
          return this.orientation === Qe.ORIENTATION.LANDSCAPE;
        } }, isGamePortrait: { get: function() {
          return this.height > this.width;
        } }, isGameLandscape: { get: function() {
          return this.width > this.height;
        } } });
        qN.exports = eoe;
      });
      jn = u((cqe, FN) => {
        var toe = { PENDING: 0, INIT: 1, START: 2, LOADING: 3, CREATING: 4, RUNNING: 5, PAUSED: 6, SLEEPING: 7,
        SHUTDOWN: 8, DESTROYED: 9 };
        FN.exports = toe;
      });
      LN = u((vqe, bN) => {
        bN.exports = "addfile";
      });
      DN = u((pqe, ON) => {
        ON.exports = "complete";
      });
      IN = u((mqe, NN) => {
        NN.exports = "filecomplete";
      });
      GN = u((gqe, BN) => {
        BN.exports = "filecomplete-";
      });
      zN = u((xqe, UN) => {
        UN.exports = "loaderror";
      });
      XN = u((Eqe, kN) => {
        kN.exports = "load";
      });
      YN = u((Tqe, VN) => {
        VN.exports = "fileprogress";
      });
      HN = u((yqe, WN) => {
        WN.exports = "postprocess";
      });
      ZN = u((Sqe, KN) => {
        KN.exports = "progress";
      });
      JN = u((wqe, QN) => {
        QN.exports = "start";
      });
      zr = u((Cqe, $N) => {
        $N.exports = { ADD: LN(), COMPLETE: DN(), FILE_COMPLETE: IN(), FILE_KEY_COMPLETE: GN(), FILE_LOAD_ERROR: zN(),
        FILE_LOAD: XN(), FILE_PROGRESS: YN(), POST_PROCESS: HN(), PROGRESS: ZN(), START: JN() };
      });
      hc = u((Aqe, eI) => {
        var ioe = B(), jN = lo(), roe = function(e) {
          var t = e.game.config.defaultPhysicsSystem, i = ioe(e.settings, "physics", false);
          if (!(!t && !i)) {
            var r = [];
            if (t && r.push(jN(t + "Physics")), i) for (var s in i) s = jN(s.concat("Physics")), r.indexOf(
            s) === -1 && r.push(s);
            return r;
          }
        };
        eI.exports = roe;
      });
      uc = u((Rqe, tI) => {
        var soe = B(), noe = function(e) {
          var t = e.plugins.getDefaultScenePlugins(), i = soe(e.settings, "plugins", false);
          return Array.isArray(i) ? i : t || [];
        };
        tI.exports = noe;
      });
      kr = u((_qe, iI) => {
        var aoe = function(e) {
          var t = {};
          for (var i in e) Array.isArray(e[i]) ? t[i] = e[i].slice(0) : t[i] = e[i];
          return t;
        };
        iI.exports = aoe;
      });
      lc = u((Pqe, rI) => {
        var ooe = kr(), hoe = function(e, t) {
          var i = ooe(e);
          for (var r in t) i.hasOwnProperty(r) || (i[r] = t[r]);
          return i;
        };
        rI.exports = hoe;
      });
      aI = u((Mqe, nI) => {
        var sI = { game: "game", renderer: "renderer", anims: "anims", cache: "cache", plugins: "plu\
gins", registry: "registry", scale: "scale", sound: "sound", textures: "textures", events: "events",
        cameras: "cameras", add: "add", make: "make", scenePlugin: "scene", displayList: "children",
        lights: "lights", data: "data", input: "input", load: "load", time: "time", tweens: "tweens",
        arcadePhysics: "physics", impactPhysics: "impact", matterPhysics: "matter" };
        sI.cameras3d = "cameras3d";
        nI.exports = sI;
      });
      fc = u((qqe, oI) => {
        var uoe = jn(), Ht = H(), loe = lc(), foe = aI(), doe = { create: function(e) {
          return typeof e == "string" ? e = { key: e } : e === void 0 && (e = {}), { status: uoe.PENDING,
          key: Ht(e, "key", ""), active: Ht(e, "active", false), visible: Ht(e, "visible", true), isBooted: false,
          isTransition: false, transitionFrom: null, transitionDuration: 0, transitionAllowInput: true,
          data: {}, pack: Ht(e, "pack", false), cameras: Ht(e, "cameras", null), map: Ht(e, "map", loe(
          foe, Ht(e, "mapAdd", {}))), physics: Ht(e, "physics", {}), loader: Ht(e, "loader", {}), plugins: Ht(
          e, "plugins", false), input: Ht(e, "input", {}) };
        } };
        oI.exports = doe;
      });
      lh = u((Fqe, lI) => {
        var coe = C(), Ue = jn(), hI = Hl(), Se = qe(), voe = hc(), poe = uc(), uI = J(), moe = fc(),
        goe = new coe({ initialize: function(t, i) {
          this.scene = t, this.game, this.renderer, this.config = i, this.settings = moe.create(i), this.
          canvas, this.context, this.anims, this.cache, this.plugins, this.registry, this.scale, this.
          sound, this.textures, this.add, this.cameras, this.displayList, this.events, this.make, this.
          scenePlugin, this.updateList, this.sceneUpdate = uI;
        }, init: function(e) {
          this.settings.status = Ue.INIT, this.sceneUpdate = uI, this.game = e, this.renderer = e.renderer,
          this.canvas = e.canvas, this.context = e.context;
          var t = e.plugins;
          this.plugins = t, t.addToScene(this, hI.Global, [hI.CoreScene, poe(this), voe(this)]), this.
          events.emit(Se.BOOT, this), this.settings.isBooted = true;
        }, step: function(e, t) {
          var i = this.events;
          i.emit(Se.PRE_UPDATE, e, t), i.emit(Se.UPDATE, e, t), this.sceneUpdate.call(this.scene, e,
          t), i.emit(Se.POST_UPDATE, e, t);
        }, render: function(e) {
          var t = this.displayList;
          t.depthSort(), this.events.emit(Se.PRE_RENDER, e), this.cameras.render(e, t), this.events.
          emit(Se.RENDER, e);
        }, queueDepthSort: function() {
          this.displayList.queueDepthSort();
        }, depthSort: function() {
          this.displayList.depthSort();
        }, pause: function(e) {
          var t = this.settings, i = this.getStatus();
          return i !== Ue.CREATING && i !== Ue.RUNNING ? console.warn("Cannot pause non-running Scen\
e", t.key) : this.settings.active && (t.status = Ue.PAUSED, t.active = false, this.events.emit(Se.PAUSE,
          this, e)), this;
        }, resume: function(e) {
          var t = this.events, i = this.settings;
          return this.settings.active || (i.status = Ue.RUNNING, i.active = true, t.emit(Se.RESUME, this,
          e)), this;
        }, sleep: function(e) {
          var t = this.settings, i = this.getStatus();
          return i !== Ue.CREATING && i !== Ue.RUNNING ? console.warn("Cannot sleep non-running Scen\
e", t.key) : (t.status = Ue.SLEEPING, t.active = false, t.visible = false, this.events.emit(Se.SLEEP,
          this, e)), this;
        }, wake: function(e) {
          var t = this.events, i = this.settings;
          return i.status = Ue.RUNNING, i.active = true, i.visible = true, t.emit(Se.WAKE, this, e),
          i.isTransition && t.emit(Se.TRANSITION_WAKE, i.transitionFrom, i.transitionDuration), this;
        }, getData: function() {
          return this.settings.data;
        }, getStatus: function() {
          return this.settings.status;
        }, canInput: function() {
          var e = this.settings.status;
          return e > Ue.PENDING && e <= Ue.RUNNING;
        }, isSleeping: function() {
          return this.settings.status === Ue.SLEEPING;
        }, isActive: function() {
          return this.settings.status === Ue.RUNNING;
        }, isPaused: function() {
          return this.settings.status === Ue.PAUSED;
        }, isTransitioning: function() {
          return this.settings.isTransition || this.scenePlugin._target !== null;
        }, isTransitionOut: function() {
          return this.scenePlugin._target !== null && this.scenePlugin._duration > 0;
        }, isTransitionIn: function() {
          return this.settings.isTransition;
        }, isVisible: function() {
          return this.settings.visible;
        }, setVisible: function(e) {
          return this.settings.visible = e, this;
        }, setActive: function(e, t) {
          return e ? this.resume(t) : this.pause(t);
        }, start: function(e) {
          var t = this.events, i = this.settings;
          e && (i.data = e), i.status = Ue.START, i.active = true, i.visible = true, t.emit(Se.START,
          this), t.emit(Se.READY, this, e);
        }, shutdown: function(e) {
          var t = this.events, i = this.settings;
          t.off(Se.TRANSITION_INIT), t.off(Se.TRANSITION_START), t.off(Se.TRANSITION_COMPLETE), t.off(
          Se.TRANSITION_OUT), i.status = Ue.SHUTDOWN, i.active = false, i.visible = false, t.emit(Se.
          SHUTDOWN, this, e);
        }, destroy: function() {
          var e = this.events, t = this.settings;
          t.status = Ue.DESTROYED, t.active = false, t.visible = false, e.emit(Se.DESTROY, this), e.
          removeAllListeners();
          for (var i = ["scene", "game", "anims", "cache", "plugins", "registry", "sound", "textures",
          "add", "camera", "displayList", "events", "make", "scenePlugin", "updateList"], r = 0; r <
          i.length; r++) this[i[r]] = null;
        } });
        lI.exports = goe;
      });
      dc = u((bqe, fI) => {
        var xoe = C(), Eoe = lh(), Toe = new xoe({ initialize: function(t) {
          this.sys = new Eoe(this, t), this.game, this.anims, this.cache, this.registry, this.sound,
          this.textures, this.events, this.cameras, this.add, this.make, this.scene, this.children, this.
          lights, this.data, this.input, this.load, this.time, this.tweens, this.physics, this.matter,
          this.scale, this.plugins, this.renderer;
        }, update: function() {
        } });
        fI.exports = Toe;
      });
      vc = u((Lqe, cI) => {
        var yoe = C(), ze = jn(), cc = qe(), dI = Ye(), Soe = H(), fh = zr(), dh = J(), ks = dc(), woe = lh(),
        Coe = new yoe({ initialize: function(t, i) {
          if (this.game = t, this.keys = {}, this.scenes = [], this._pending = [], this._start = [],
          this._queue = [], this._data = {}, this.isProcessing = false, this.isBooted = false, this.
          customViewports = 0, this.systemScene, i) {
            Array.isArray(i) || (i = [i]);
            for (var r = 0; r < i.length; r++) this._pending.push({ key: "default", scene: i[r], autoStart: r ===
            0, data: {} });
          }
          t.events.once(dI.READY, this.bootQueue, this);
        }, bootQueue: function() {
          if (!this.isBooted) {
            this.systemScene = this.createSceneFromInstance("__SYSTEM", new ks()), this.game.events.
            emit(dI.SYSTEM_READY, this.systemScene, this);
            var e, t, i, r;
            for (e = 0; e < this._pending.length; e++) {
              t = this._pending[e], i = t.key, r = t.scene;
              var s;
              r instanceof ks ? s = this.createSceneFromInstance(i, r) : typeof r == "object" ? s = this.
              createSceneFromObject(i, r) : typeof r == "function" && (s = this.createSceneFromFunction(
              i, r)), i = s.sys.settings.key, this.keys[i] = s, this.scenes.push(s), this._data[i] &&
              (s.sys.settings.data = this._data[i].data, this._data[i].autoStart && (t.autoStart = true)),
              (t.autoStart || s.sys.settings.active) && this._start.push(i);
            }
            for (this._pending.length = 0, this._data = {}, this.isBooted = true, e = 0; e < this._start.
            length; e++) t = this._start[e], this.start(t);
            this._start.length = 0;
          }
        }, processQueue: function() {
          var e = this._pending.length, t = this._queue.length;
          if (!(e === 0 && t === 0)) {
            var i, r;
            if (e) {
              for (i = 0; i < e; i++) r = this._pending[i], this.add(r.key, r.scene, r.autoStart, r.
              data);
              for (i = 0; i < this._start.length; i++) r = this._start[i], this.start(r);
              this._start.length = 0, this._pending.length = 0;
            }
            for (i = 0; i < this._queue.length; i++) r = this._queue[i], this[r.op](r.keyA, r.keyB, r.
            data);
            this._queue.length = 0;
          }
        }, add: function(e, t, i, r) {
          if (i === void 0 && (i = false), r === void 0 && (r = {}), this.isProcessing || !this.isBooted)
           return this._pending.push({ key: e, scene: t, autoStart: i, data: r }), this.isBooted || (this.
          _data[e] = { data: r }), null;
          e = this.getKey(e, t);
          var s;
          return t instanceof ks ? s = this.createSceneFromInstance(e, t) : typeof t == "object" ? (t.
          key = e, s = this.createSceneFromObject(e, t)) : typeof t == "function" && (s = this.createSceneFromFunction(
          e, t)), s.sys.settings.data = r, e = s.sys.settings.key, this.keys[e] = s, this.scenes.push(
          s), (i || s.sys.settings.active) && (this._pending.length ? this._start.push(e) : this.start(
          e)), s;
        }, remove: function(e) {
          if (this.isProcessing) return this.queueOp("remove", e);
          var t = this.getScene(e);
          if (!t || t.sys.isTransitioning()) return this;
          var i = this.scenes.indexOf(t), r = t.sys.settings.key;
          return i > -1 && (delete this.keys[r], this.scenes.splice(i, 1), this._start.indexOf(r) > -1 &&
          (i = this._start.indexOf(r), this._start.splice(i, 1)), t.sys.destroy()), this;
        }, bootScene: function(e) {
          var t = e.sys, i = t.settings;
          t.sceneUpdate = dh, e.init && (e.init.call(e, i.data), i.status = ze.INIT, i.isTransition &&
          t.events.emit(cc.TRANSITION_INIT, i.transitionFrom, i.transitionDuration));
          var r;
          t.load && (r = t.load, r.reset()), r && e.preload ? (e.preload.call(e), i.status = ze.LOADING,
          r.once(fh.COMPLETE, this.loadComplete, this), r.start()) : this.create(e);
        }, loadComplete: function(e) {
          this.create(e.scene);
        }, payloadComplete: function(e) {
          this.bootScene(e.scene);
        }, update: function(e, t) {
          this.processQueue(), this.isProcessing = true;
          for (var i = this.scenes.length - 1; i >= 0; i--) {
            var r = this.scenes[i].sys;
            r.settings.status > ze.START && r.settings.status <= ze.RUNNING && r.step(e, t), r.scenePlugin &&
            r.scenePlugin._target && r.scenePlugin.step(e, t);
          }
        }, render: function(e) {
          for (var t = 0; t < this.scenes.length; t++) {
            var i = this.scenes[t].sys;
            i.settings.visible && i.settings.status >= ze.LOADING && i.settings.status < ze.SLEEPING &&
            i.render(e);
          }
          this.isProcessing = false;
        }, create: function(e) {
          var t = e.sys, i = t.settings;
          e.create && (i.status = ze.CREATING, e.create.call(e, i.data), i.status === ze.DESTROYED) ||
          (i.isTransition && t.events.emit(cc.TRANSITION_START, i.transitionFrom, i.transitionDuration),
          e.update && (t.sceneUpdate = e.update), i.status = ze.RUNNING, t.events.emit(cc.CREATE, e));
        }, createSceneFromFunction: function(e, t) {
          var i = new t();
          if (i instanceof ks) {
            var r = i.sys.settings.key;
            if (r !== "" && (e = r), this.keys.hasOwnProperty(e)) throw new Error("Cannot add Scene \
with duplicate key: " + e);
            return this.createSceneFromInstance(e, i);
          } else return i.sys = new woe(i), i.sys.settings.key = e, i.sys.init(this.game), i;
        }, createSceneFromInstance: function(e, t) {
          var i = t.sys.settings.key;
          return i === "" && (t.sys.settings.key = e), t.sys.init(this.game), t;
        }, createSceneFromObject: function(e, t) {
          var i = new ks(t), r = i.sys.settings.key;
          r !== "" ? e = r : i.sys.settings.key = e, i.sys.init(this.game);
          for (var s = ["init", "preload", "create", "update", "render"], n = 0; n < s.length; n++) {
            var a = Soe(t, s[n], null);
            a && (i[s[n]] = a);
          }
          if (t.hasOwnProperty("extend")) {
            for (var o in t.extend) if (t.extend.hasOwnProperty(o)) {
              var h = t.extend[o];
              o === "data" && i.hasOwnProperty("data") && typeof h == "object" ? i.data.merge(h) : o !==
              "sys" && (i[o] = h);
            }
          }
          return i;
        }, getKey: function(e, t) {
          if (e || (e = "default"), typeof t == "function") return e;
          if (t instanceof ks ? e = t.sys.settings.key : typeof t == "object" && t.hasOwnProperty("k\
ey") && (e = t.key), this.keys.hasOwnProperty(e)) throw new Error("Cannot add Scene with duplicate k\
ey: " + e);
          return e;
        }, getScenes: function(e, t) {
          e === void 0 && (e = true), t === void 0 && (t = false);
          for (var i = [], r = this.scenes, s = 0; s < r.length; s++) {
            var n = r[s];
            n && (!e || e && n.sys.isActive()) && i.push(n);
          }
          return t ? i.reverse() : i;
        }, getScene: function(e) {
          if (typeof e == "string") {
            if (this.keys[e]) return this.keys[e];
          } else for (var t = 0; t < this.scenes.length; t++) if (e === this.scenes[t]) return e;
          return null;
        }, isActive: function(e) {
          var t = this.getScene(e);
          return t ? t.sys.isActive() : null;
        }, isPaused: function(e) {
          var t = this.getScene(e);
          return t ? t.sys.isPaused() : null;
        }, isVisible: function(e) {
          var t = this.getScene(e);
          return t ? t.sys.isVisible() : null;
        }, isSleeping: function(e) {
          var t = this.getScene(e);
          return t ? t.sys.isSleeping() : null;
        }, pause: function(e, t) {
          var i = this.getScene(e);
          return i && i.sys.pause(t), this;
        }, resume: function(e, t) {
          var i = this.getScene(e);
          return i && i.sys.resume(t), this;
        }, sleep: function(e, t) {
          var i = this.getScene(e);
          return i && !i.sys.isTransitioning() && i.sys.sleep(t), this;
        }, wake: function(e, t) {
          var i = this.getScene(e);
          return i && i.sys.wake(t), this;
        }, run: function(e, t) {
          var i = this.getScene(e);
          if (!i) {
            for (var r = 0; r < this._pending.length; r++) if (this._pending[r].key === e) {
              this.queueOp("start", e, t);
              break;
            }
            return this;
          }
          i.sys.isSleeping() ? i.sys.wake(t) : i.sys.isPaused() ? i.sys.resume(t) : this.start(e, t);
        }, start: function(e, t) {
          if (!this.isBooted) return this._data[e] = { autoStart: true, data: t }, this;
          var i = this.getScene(e);
          if (!i) return console.warn("Scene key not found: " + e), this;
          var r = i.sys, s = r.settings.status;
          if (s >= ze.START && s <= ze.CREATING) return this;
          if (s >= ze.RUNNING && s <= ze.SLEEPING) r.shutdown(), r.sceneUpdate = dh, r.start(t);
          else {
            r.sceneUpdate = dh, r.start(t);
            var n;
            if (r.load && (n = r.load), n && r.settings.hasOwnProperty("pack") && (n.reset(), n.addPack(
            { payload: r.settings.pack }))) return r.settings.status = ze.LOADING, n.once(fh.COMPLETE,
            this.payloadComplete, this), n.start(), this;
          }
          return this.bootScene(i), this;
        }, stop: function(e, t) {
          var i = this.getScene(e);
          if (i && !i.sys.isTransitioning() && i.sys.settings.status !== ze.SHUTDOWN) {
            var r = i.sys.load;
            r && (r.off(fh.COMPLETE, this.loadComplete, this), r.off(fh.COMPLETE, this.payloadComplete,
            this)), i.sys.shutdown(t);
          }
          return this;
        }, switch: function(e, t, i) {
          var r = this.getScene(e), s = this.getScene(t);
          return r && s && r !== s && (this.sleep(e), this.isSleeping(t) ? this.wake(t, i) : this.start(
          t, i)), this;
        }, getAt: function(e) {
          return this.scenes[e];
        }, getIndex: function(e) {
          var t = this.getScene(e);
          return this.scenes.indexOf(t);
        }, bringToTop: function(e) {
          if (this.isProcessing) return this.queueOp("bringToTop", e);
          var t = this.getIndex(e), i = this.scenes;
          if (t !== -1 && t < i.length) {
            var r = this.getScene(e);
            i.splice(t, 1), i.push(r);
          }
          return this;
        }, sendToBack: function(e) {
          if (this.isProcessing) return this.queueOp("sendToBack", e);
          var t = this.getIndex(e);
          if (t !== -1 && t > 0) {
            var i = this.getScene(e);
            this.scenes.splice(t, 1), this.scenes.unshift(i);
          }
          return this;
        }, moveDown: function(e) {
          if (this.isProcessing) return this.queueOp("moveDown", e);
          var t = this.getIndex(e);
          if (t > 0) {
            var i = t - 1, r = this.getScene(e), s = this.getAt(i);
            this.scenes[t] = s, this.scenes[i] = r;
          }
          return this;
        }, moveUp: function(e) {
          if (this.isProcessing) return this.queueOp("moveUp", e);
          var t = this.getIndex(e);
          if (t < this.scenes.length - 1) {
            var i = t + 1, r = this.getScene(e), s = this.getAt(i);
            this.scenes[t] = s, this.scenes[i] = r;
          }
          return this;
        }, moveAbove: function(e, t) {
          if (e === t) return this;
          if (this.isProcessing) return this.queueOp("moveAbove", e, t);
          var i = this.getIndex(e), r = this.getIndex(t);
          if (i !== -1 && r !== -1 && r < i) {
            var s = this.getAt(r);
            this.scenes.splice(r, 1), this.scenes.splice(i + (r > i), 0, s);
          }
          return this;
        }, moveBelow: function(e, t) {
          if (e === t) return this;
          if (this.isProcessing) return this.queueOp("moveBelow", e, t);
          var i = this.getIndex(e), r = this.getIndex(t);
          if (i !== -1 && r !== -1 && r > i) {
            var s = this.getAt(r);
            this.scenes.splice(r, 1), i === 0 ? this.scenes.unshift(s) : this.scenes.splice(i - (r <
            i), 0, s);
          }
          return this;
        }, queueOp: function(e, t, i, r) {
          return this._queue.push({ op: e, keyA: t, keyB: i, data: r }), this;
        }, swapPosition: function(e, t) {
          if (e === t) return this;
          if (this.isProcessing) return this.queueOp("swapPosition", e, t);
          var i = this.getIndex(e), r = this.getIndex(t);
          if (i !== r && i !== -1 && r !== -1) {
            var s = this.getAt(i);
            this.scenes[i] = this.scenes[r], this.scenes[r] = s;
          }
          return this;
        }, dump: function() {
          for (var e = [], t = ["pending", "init", "start", "loading", "creating", "running", "pause\
d", "sleeping", "shutdown", "destroyed"], i = 0; i < this.scenes.length; i++) {
            var r = this.scenes[i].sys, s = r.settings.visible && (r.settings.status === ze.RUNNING ||
            r.settings.status === ze.PAUSED) ? "[*] " : "[-] ";
            s += r.settings.key + " (" + t[r.settings.status] + ")", e.push(s);
          }
          console.log(e.join(`
`));
        }, destroy: function() {
          for (var e = 0; e < this.scenes.length; e++) {
            var t = this.scenes[e].sys;
            t.destroy();
          }
          this.systemScene.sys.destroy(), this.update = dh, this.scenes = [], this._pending = [], this.
          _start = [], this._queue = [], this.game = null, this.systemScene = null;
        } });
        cI.exports = Coe;
      });
      pc = u((Oqe, vI) => {
        var Aoe = Tt(), Roe = C(), _oe = Cs(), Poe = Ma(), Moe = Yo(), qoe = new Roe({ initialize: function(t, i, r, s, n) {
          n === void 0 && (n = false);
          var a = t.manager.game;
          this.renderer = a.renderer, this.texture = t, this.source = i, this.image = i.compressed ?
          null : i, this.compressionAlgorithm = i.compressed ? i.format : null, this.resolution = 1,
          this.width = r || i.naturalWidth || i.videoWidth || i.width || 0, this.height = s || i.naturalHeight ||
          i.videoHeight || i.height || 0, this.scaleMode = Poe.DEFAULT, this.isCanvas = i instanceof
          HTMLCanvasElement, this.isVideo = window.hasOwnProperty("HTMLVideoElement") && i instanceof
          HTMLVideoElement, this.isRenderTexture = i.type === "RenderTexture" || i.type === "Dynamic\
Texture", this.isGLTexture = i instanceof Moe, this.isPowerOf2 = _oe(this.width, this.height), this.
          glTexture = null, this.flipY = n, this.init(a);
        }, init: function(e) {
          var t = this.renderer;
          if (t) {
            var i = this.source;
            if (t.gl) {
              var r = this.image, s = this.flipY, n = this.width, a = this.height, o = this.scaleMode;
              this.isCanvas ? this.glTexture = t.createCanvasTexture(r, false, s) : this.isVideo ? this.
              glTexture = t.createVideoTexture(r, false, s) : this.isRenderTexture ? this.glTexture =
              t.createTextureFromSource(null, n, a, o) : this.isGLTexture ? this.glTexture = i : this.
              compressionAlgorithm ? this.glTexture = t.createTextureFromSource(i, void 0, void 0, o) :
              i instanceof Uint8Array ? this.glTexture = t.createUint8ArrayTexture(i, n, a, o) : this.
              glTexture = t.createTextureFromSource(r, n, a, o);
            } else this.isRenderTexture && (this.image = i.canvas);
          }
          e.config.antialias || this.setFilter(1);
        }, setFilter: function(e) {
          this.renderer && this.renderer.gl && this.renderer.setTextureFilter(this.glTexture, e), this.
          scaleMode = e;
        }, setFlipY: function(e) {
          return e === void 0 && (e = true), e === this.flipY ? this : (this.flipY = e, this.update(),
          this);
        }, update: function() {
          var e = this.renderer, t = this.image, i = this.flipY, r = e.gl;
          r && this.isCanvas ? e.updateCanvasTexture(t, this.glTexture, i) : r && this.isVideo && e.
          updateVideoTexture(t, this.glTexture, i);
        }, destroy: function() {
          this.glTexture && this.renderer.deleteTexture(this.glTexture), this.isCanvas && Aoe.remove(
          this.image), this.renderer = null, this.texture = null, this.source = null, this.image = null,
          this.glTexture = null;
        } });
        vI.exports = qoe;
      });
      ea = u((Dqe, mI) => {
        var Foe = C(), boe = Pr(), pI = pc(), mc = 'Texture "%s" has no frame "%s"', Loe = new Foe({
        initialize: function(t, i, r, s, n) {
          Array.isArray(r) || (r = [r]), this.manager = t, this.key = i, this.source = [], this.dataSource =
          [], this.frames = {}, this.customData = {}, this.firstFrame = "__BASE", this.frameTotal = 0;
          for (var a = 0; a < r.length; a++) this.source.push(new pI(this, r[a], s, n));
        }, add: function(e, t, i, r, s, n) {
          if (this.has(e)) return null;
          var a = new boe(this, e, t, i, r, s, n);
          return this.frames[e] = a, this.firstFrame === "__BASE" && (this.firstFrame = e), this.frameTotal++,
          a;
        }, remove: function(e) {
          if (this.has(e)) {
            var t = this.get(e);
            return t.destroy(), delete this.frames[e], true;
          }
          return false;
        }, has: function(e) {
          return this.frames.hasOwnProperty(e);
        }, get: function(e) {
          e || (e = this.firstFrame);
          var t = this.frames[e];
          return t || (console.warn(mc, this.key, e), t = this.frames[this.firstFrame]), t;
        }, getTextureSourceIndex: function(e) {
          for (var t = 0; t < this.source.length; t++) if (this.source[t] === e) return t;
          return -1;
        }, getFramesFromTextureSource: function(e, t) {
          t === void 0 && (t = false);
          var i = [];
          for (var r in this.frames) if (!(r === "__BASE" && !t)) {
            var s = this.frames[r];
            s.sourceIndex === e && i.push(s);
          }
          return i;
        }, getFrameBounds: function(e) {
          e === void 0 && (e = 0);
          for (var t = this.getFramesFromTextureSource(e, true), i = t[0], r = i.cutX, s = i.cutY, n = i.
          cutX + i.cutWidth, a = i.cutY + i.cutHeight, o = 1; o < t.length; o++) {
            var h = t[o];
            h.cutX < r && (r = h.cutX), h.cutY < s && (s = h.cutY), h.cutX + h.cutWidth > n && (n = h.
            cutX + h.cutWidth), h.cutY + h.cutHeight > a && (a = h.cutY + h.cutHeight);
          }
          return { x: r, y: s, width: n - r, height: a - s };
        }, getFrameNames: function(e) {
          e === void 0 && (e = false);
          var t = Object.keys(this.frames);
          if (!e) {
            var i = t.indexOf("__BASE");
            i !== -1 && t.splice(i, 1);
          }
          return t;
        }, getSourceImage: function(e) {
          (e == null || this.frameTotal === 1) && (e = "__BASE");
          var t = this.frames[e];
          return t ? t.source.image : (console.warn(mc, this.key, e), this.frames.__BASE.source.image);
        }, getDataSourceImage: function(e) {
          (e == null || this.frameTotal === 1) && (e = "__BASE");
          var t = this.frames[e], i;
          return t ? i = t.sourceIndex : (console.warn(mc, this.key, e), i = this.frames.__BASE.sourceIndex),
          this.dataSource[i].image;
        }, setDataSource: function(e) {
          Array.isArray(e) || (e = [e]);
          for (var t = 0; t < e.length; t++) {
            var i = this.source[t];
            this.dataSource.push(new pI(this, e[t], i.width, i.height));
          }
        }, setFilter: function(e) {
          var t;
          for (t = 0; t < this.source.length; t++) this.source[t].setFilter(e);
          for (t = 0; t < this.dataSource.length; t++) this.dataSource[t].setFilter(e);
        }, destroy: function() {
          var e, t = this.source, i = this.dataSource;
          for (e = 0; e < t.length; e++) t[e] && t[e].destroy();
          for (e = 0; e < i.length; e++) i[e] && i[e].destroy();
          for (var r in this.frames) {
            var s = this.frames[r];
            s && s.destroy();
          }
          this.source = [], this.dataSource = [], this.frames = {}, this.manager.removeKey(this.key),
          this.manager = null;
        } });
        mI.exports = Loe;
      });
      xc = u((Nqe, xI) => {
        var Ooe = C(), ar = ne(), gI = Ai(), Doe = qt(), Noe = Cs(), gc = ea(), Ioe = new Ooe({ Extends: gc,
        initialize: function(t, i, r, s, n) {
          gc.call(this, t, i, r, s, n), this.add("__BASE", 0, 0, 0, s, n), this._source = this.frames.
          __BASE.source, this.canvas = this._source.image, this.context = this.canvas.getContext("2d",
          { willReadFrequently: true }), this.width = s, this.height = n, this.imageData = this.context.
          getImageData(0, 0, s, n), this.data = null, this.imageData && (this.data = this.imageData.
          data), this.pixels = null, this.buffer, this.data && (this.imageData.data.buffer ? (this.buffer =
          this.imageData.data.buffer, this.pixels = new Uint32Array(this.buffer)) : window.ArrayBuffer ?
          (this.buffer = new ArrayBuffer(this.imageData.data.length), this.pixels = new Uint32Array(
          this.buffer)) : this.pixels = this.imageData.data);
        }, update: function() {
          return this.imageData = this.context.getImageData(0, 0, this.width, this.height), this.data =
          this.imageData.data, this.imageData.data.buffer ? (this.buffer = this.imageData.data.buffer,
          this.pixels = new Uint32Array(this.buffer)) : window.ArrayBuffer ? (this.buffer = new ArrayBuffer(
          this.imageData.data.length), this.pixels = new Uint32Array(this.buffer)) : this.pixels = this.
          imageData.data, this.manager.game.config.renderType === Doe.WEBGL && this.refresh(), this;
        }, draw: function(e, t, i, r) {
          return r === void 0 && (r = true), this.context.drawImage(i, e, t), r && this.update(), this;
        }, drawFrame: function(e, t, i, r, s) {
          i === void 0 && (i = 0), r === void 0 && (r = 0), s === void 0 && (s = true);
          var n = this.manager.getFrame(e, t);
          if (n) {
            var a = n.canvasData, o = n.cutWidth, h = n.cutHeight, l = n.source.resolution;
            this.context.drawImage(n.source.image, a.x, a.y, o, h, i, r, o / l, h / l), s && this.update();
          }
          return this;
        }, setPixel: function(e, t, i, r, s, n) {
          n === void 0 && (n = 255), e = Math.abs(Math.floor(e)), t = Math.abs(Math.floor(t));
          var a = this.getIndex(e, t);
          if (a > -1) {
            var o = this.context.getImageData(e, t, 1, 1);
            o.data[0] = i, o.data[1] = r, o.data[2] = s, o.data[3] = n, this.context.putImageData(o,
            e, t);
          }
          return this;
        }, putData: function(e, t, i, r, s, n, a) {
          return r === void 0 && (r = 0), s === void 0 && (s = 0), n === void 0 && (n = e.width), a ===
          void 0 && (a = e.height), this.context.putImageData(e, t, i, r, s, n, a), this;
        }, getData: function(e, t, i, r) {
          e = ar(Math.floor(e), 0, this.width - 1), t = ar(Math.floor(t), 0, this.height - 1), i = ar(
          i, 1, this.width - e), r = ar(r, 1, this.height - t);
          var s = this.context.getImageData(e, t, i, r);
          return s;
        }, getPixel: function(e, t, i) {
          i || (i = new gI());
          var r = this.getIndex(e, t);
          if (r > -1) {
            var s = this.data, n = s[r + 0], a = s[r + 1], o = s[r + 2], h = s[r + 3];
            i.setTo(n, a, o, h);
          }
          return i;
        }, getPixels: function(e, t, i, r) {
          e === void 0 && (e = 0), t === void 0 && (t = 0), i === void 0 && (i = this.width), r === void 0 &&
          (r = i), e = Math.abs(Math.round(e)), t = Math.abs(Math.round(t));
          for (var s = ar(e, 0, this.width), n = ar(e + i, 0, this.width), a = ar(t, 0, this.height),
          o = ar(t + r, 0, this.height), h = new gI(), l = [], f = a; f < o; f++) {
            for (var d = [], c = s; c < n; c++) h = this.getPixel(c, f, h), d.push({ x: c, y: f, color: h.
            color, alpha: h.alphaGL });
            l.push(d);
          }
          return l;
        }, getIndex: function(e, t) {
          return e = Math.abs(Math.round(e)), t = Math.abs(Math.round(t)), e < this.width && t < this.
          height ? (e + t * this.width) * 4 : -1;
        }, refresh: function() {
          return this._source.update(), this;
        }, getCanvas: function() {
          return this.canvas;
        }, getContext: function() {
          return this.context;
        }, clear: function(e, t, i, r, s) {
          return e === void 0 && (e = 0), t === void 0 && (t = 0), i === void 0 && (i = this.width),
          r === void 0 && (r = this.height), s === void 0 && (s = true), this.context.clearRect(e, t,
          i, r), s && this.update(), this;
        }, setSize: function(e, t) {
          return t === void 0 && (t = e), (e !== this.width || t !== this.height) && (this.canvas.width =
          e, this.canvas.height = t, this._source.width = e, this._source.height = t, this._source.isPowerOf2 =
          Noe(e, t), this.frames.__BASE.setSize(e, t, 0, 0), this.width = e, this.height = t, this.refresh()),
          this;
        }, destroy: function() {
          gc.prototype.destroy.call(this), this._source = null, this.canvas = null, this.context = null,
          this.imageData = null, this.data = null, this.pixels = null, this.buffer = null;
        } });
        xI.exports = Ioe;
      });
      Tc = u((Iqe, yI) => {
        var Boe = Qt(), Goe = Bn(), EI = Tt(), Uoe = C(), zoe = qt(), TI = Pr(), Bt = B(), koe = kn(),
        Xoe = qr(), Ec = ea(), Voe = wt(), Yoe = new Uoe({ Extends: Ec, initialize: function(t, i, r, s, n) {
          r === void 0 && (r = 256), s === void 0 && (s = 256), n === void 0 && (n = true), this.type =
          "DynamicTexture";
          var a = t.game.renderer, o = a && a.type === zoe.CANVAS, h = o ? EI.create2D(this, r, s) :
          [this];
          Ec.call(this, t, i, h, r, s), this.add("__BASE", 0, 0, 0, r, s), this.renderer = a, this.width =
          -1, this.height = -1, this.isDrawing = false, this.canvas = o ? h : null, this.context = o ?
          h.getContext("2d", { willReadFrequently: true }) : null, this.dirty = false, this.isSpriteTexture =
          true, this._eraseMode = false, this.camera = new Goe(0, 0, r, s).setScene(t.game.scene.systemScene,
          false), this.renderTarget = o ? null : new Xoe(a, r, s, 1, 0, false, false, true, false), this.
          pipeline = o ? null : a.pipelines.get(koe.SINGLE_PIPELINE), this.setSize(r, s, n);
        }, setSize: function(e, t, i) {
          t === void 0 && (t = e), i === void 0 && (i = true), i && (e = Math.floor(e), t = Math.floor(
          t), e % 2 !== 0 && e++, t % 2 !== 0 && t++);
          var r = this.get(), s = r.source;
          if (e !== this.width || t !== this.height) {
            this.canvas && (this.canvas.width = e, this.canvas.height = t);
            var n = this.renderTarget;
            n && (n.willResize(e, t) && n.resize(e, t), n.texture !== s.glTexture && this.renderer.deleteTexture(
            s.glTexture), this.setFromRenderTarget()), this.camera.setSize(e, t), s.width = e, s.height =
            t, r.setSize(e, t), this.width = e, this.height = t;
          } else {
            var a = this.getSourceImage();
            r.cutX + e > a.width && (e = a.width - r.cutX), r.cutY + t > a.height && (t = a.height -
            r.cutY), r.setSize(e, t, r.cutX, r.cutY);
          }
          return this;
        }, setFromRenderTarget: function() {
          var e = this.get(), t = e.source, i = this.renderTarget;
          return t.isRenderTexture = true, t.isGLTexture = true, t.glTexture = i.texture, this;
        }, setIsSpriteTexture: function(e) {
          return this.isSpriteTexture = e, this;
        }, fill: function(e, t, i, r, s, n) {
          var a = this.camera, o = this.renderer;
          t === void 0 && (t = 1), i === void 0 && (i = 0), r === void 0 && (r = 0), s === void 0 &&
          (s = this.width), n === void 0 && (n = this.height);
          var h = e >> 16 & 255, l = e >> 8 & 255, f = e & 255, d = this.renderTarget;
          if (a.preRender(), d) {
            d.bind(true);
            var c = this.pipeline.manager.set(this.pipeline), p = o.width / d.width, v = o.height / d.
            height, m = d.height - (r + n);
            c.drawFillRect(i * p, m * v, s * p, n * v, Voe.getTintFromFloats(f / 255, l / 255, h / 255,
            1), t), d.unbind(true);
          } else {
            var g = this.context;
            o.setContext(g), g.globalCompositeOperation = "source-over", g.fillStyle = "rgba(" + h +
            "," + l + "," + f + "," + t + ")", g.fillRect(i, r, s, n), o.setContext();
          }
          return this.dirty = true, this;
        }, clear: function(e, t, i, r) {
          if (this.dirty) {
            var s = this.context, n = this.renderTarget;
            n ? n.clear(e, t, i, r) : s && (e !== void 0 && t !== void 0 && i !== void 0 && r !== void 0 ?
            s.clearRect(e, t, i, r) : (s.save(), s.setTransform(1, 0, 0, 1, 0, 0), s.clearRect(0, 0,
            this.width, this.height), s.restore())), this.dirty = false;
          }
          return this;
        }, stamp: function(e, t, i, r, s) {
          i === void 0 && (i = 0), r === void 0 && (r = 0);
          var n = Bt(s, "alpha", 1), a = Bt(s, "tint", 16777215), o = Bt(s, "angle", 0), h = Bt(s, "\
rotation", 0), l = Bt(s, "scale", 1), f = Bt(s, "scaleX", l), d = Bt(s, "scaleY", l), c = Bt(s, "ori\
ginX", 0.5), p = Bt(s, "originY", 0.5), v = Bt(s, "blendMode", 0), m = Bt(s, "erase", false), g = Bt(
          s, "skipBatch", false), x = this.manager.resetStamp(n, a);
          return x.setAngle(0), o !== 0 ? x.setAngle(o) : h !== 0 && x.setRotation(h), x.setScale(f,
          d), x.setTexture(e, t), x.setOrigin(c, p), x.setBlendMode(v), m && (this._eraseMode = true),
          g ? this.batchGameObject(x, i, r) : this.draw(x, i, r), m && (this._eraseMode = false), this;
        }, erase: function(e, t, i) {
          return this._eraseMode = true, this.draw(e, t, i), this._eraseMode = false, this;
        }, draw: function(e, t, i, r, s) {
          return this.beginDraw(), this.batchDraw(e, t, i, r, s), this.endDraw(), this;
        }, drawFrame: function(e, t, i, r, s, n) {
          return this.beginDraw(), this.batchDrawFrame(e, t, i, r, s, n), this.endDraw(), this;
        }, repeat: function(e, t, i, r, s, n, a, o, h) {
          if (i === void 0 && (i = 0), r === void 0 && (r = 0), s === void 0 && (s = this.width), n ===
          void 0 && (n = this.height), a === void 0 && (a = 1), o === void 0 && (o = 16777215), h ===
          void 0 && (h = false), e instanceof TI ? t = e : t = this.manager.getFrame(e, t), !t) return this;
          var l = this.manager.resetStamp(a, o);
          l.setFrame(t), l.setOrigin(0);
          var f = t.width, d = t.height;
          s = Math.floor(s), n = Math.floor(n);
          var c = Math.ceil(s / f), p = Math.ceil(n / d), v = c * f - s, m = p * d - n;
          v > 0 && (v = f - v), m > 0 && (m = d - m), i < 0 && (c += Math.ceil(Math.abs(i) / f)), r <
          0 && (p += Math.ceil(Math.abs(r) / d));
          var g = i, x = r, E = false, T15 = this.manager.stampCrop.setTo(0, 0, f, d);
          h || this.beginDraw();
          for (var w = 0; w < p; w++) {
            if (x + d < 0) {
              x += d;
              continue;
            }
            for (var y = 0; y < c; y++) {
              if (E = false, g + f < 0) {
                g += f;
                continue;
              } else g < 0 && (E = true, T15.width = f + g, T15.x = f - T15.width);
              x < 0 && (E = true, T15.height = d + x, T15.y = d - T15.height), v > 0 && y === c - 1 &&
              (E = true, T15.width = v), m > 0 && w === p - 1 && (E = true, T15.height = m), E && l.
              setCrop(T15), this.batchGameObject(l, g, x), l.isCropped = false, T15.setTo(0, 0, f, d),
              g += f;
            }
            g = i, x += d;
          }
          return h || this.endDraw(), this;
        }, beginDraw: function() {
          if (!this.isDrawing) {
            var e = this.camera, t = this.renderer, i = this.renderTarget;
            e.preRender(), i ? t.beginCapture(i.width, i.height) : t.setContext(this.context), this.
            isDrawing = true;
          }
          return this;
        }, batchDraw: function(e, t, i, r, s) {
          return Array.isArray(e) || (e = [e]), this.batchList(e, t, i, r, s), this;
        }, batchDrawFrame: function(e, t, i, r, s, n) {
          i === void 0 && (i = 0), r === void 0 && (r = 0), s === void 0 && (s = 1), n === void 0 &&
          (n = 16777215);
          var a = this.manager.getFrame(e, t);
          return a && (this.renderTarget ? this.pipeline.batchTextureFrame(a, i, r, n, s, this.camera.
          matrix, null) : this.batchTextureFrame(a, i, r, s, n)), this;
        }, endDraw: function(e) {
          if (e === void 0 && (e = this._eraseMode), this.isDrawing) {
            var t = this.renderer, i = this.renderTarget;
            if (i) {
              var r = t.endCapture(), s = t.pipelines.setUtility();
              s.blitFrame(r, i, 1, false, false, e, this.isSpriteTexture), t.resetScissor(), t.resetViewport();
            } else t.setContext();
            this.dirty = true, this.isDrawing = false;
          }
          return this;
        }, batchList: function(e, t, i, r, s) {
          var n = e.length;
          if (n !== 0) for (var a = 0; a < n; a++) {
            var o = e[a];
            !o || o === this || (o.renderWebGL || o.renderCanvas ? this.batchGameObject(o, t, i) : o.
            isParent || o.list ? this.batchGroup(o.getChildren(), t, i) : typeof o == "string" ? this.
            batchTextureFrameKey(o, null, t, i, r, s) : o instanceof TI ? this.batchTextureFrame(o, t,
            i, r, s) : Array.isArray(o) && this.batchList(o, t, i, r, s));
          }
        }, batchGroup: function(e, t, i) {
          t === void 0 && (t = 0), i === void 0 && (i = 0);
          for (var r = 0; r < e.length; r++) {
            var s = e[r];
            s.willRender(this.camera) && this.batchGameObject(s, s.x + t, s.y + i);
          }
        }, batchGameObject: function(e, t, i) {
          t === void 0 && (t = e.x), i === void 0 && (i = e.y);
          var r = e.x, s = e.y, n = this.camera, a = this.renderer, o = this._eraseMode, h = e.mask;
          if (e.setPosition(t, i), this.canvas) {
            if (o) {
              var l = e.blendMode;
              e.blendMode = Boe.ERASE;
            }
            h && h.preRenderCanvas(a, e, n), e.renderCanvas(a, e, n, null), h && h.postRenderCanvas(
            a, e, n), o && (e.blendMode = l);
          } else a && (h && h.preRenderWebGL(a, e, n), o || a.setBlendMode(e.blendMode), e.renderWebGL(
          a, e, n), h && h.postRenderWebGL(a, n, this.renderTarget));
          e.setPosition(r, s);
        }, batchTextureFrameKey: function(e, t, i, r, s, n) {
          var a = this.manager.getFrame(e, t);
          a && this.batchTextureFrame(a, i, r, s, n);
        }, batchTextureFrame: function(e, t, i, r, s) {
          t === void 0 && (t = 0), i === void 0 && (i = 0), r === void 0 && (r = 1), s === void 0 &&
          (s = 16777215);
          var n = this.camera.matrix, a = this.renderTarget;
          if (a) this.pipeline.batchTextureFrame(e, t, i, s, r, n, null);
          else {
            var o = this.context, h = e.canvasData, l = e.source.image;
            o.save(), o.globalCompositeOperation = this._eraseMode ? "destination-out" : "source-ove\
r", o.globalAlpha = r, n.setToContext(o), h.width > 0 && h.height > 0 && o.drawImage(l, h.x, h.y, h.
            width, h.height, t, i, h.width, h.height), o.restore();
          }
        }, snapshotArea: function(e, t, i, r, s, n, a) {
          return this.renderTarget ? this.renderer.snapshotFramebuffer(this.renderTarget.framebuffer,
          this.width, this.height, s, false, e, t, i, r, n, a) : this.renderer.snapshotCanvas(this.canvas,
          s, false, e, t, i, r, n, a), this;
        }, snapshot: function(e, t, i) {
          return this.snapshotArea(0, 0, this.width, this.height, e, t, i);
        }, snapshotPixel: function(e, t, i) {
          return this.snapshotArea(e, t, 1, 1, i, "pixel");
        }, getWebGLTexture: function() {
          if (this.renderTarget) return this.renderTarget.texture;
        }, renderWebGL: function(e, t, i, r) {
          var s = this.manager.resetStamp();
          s.setTexture(this), s.setOrigin(0), s.renderWebGL(e, s, i, r);
        }, renderCanvas: function() {
        }, destroy: function() {
          var e = this.manager.stamp;
          e && e.texture === this && this.manager.resetStamp(), Ec.prototype.destroy.call(this), EI.
          remove(this.canvas), this.renderTarget && this.renderTarget.destroy(), this.camera.destroy(),
          this.canvas = null, this.context = null, this.renderer = null;
        } });
        yI.exports = Yoe;
      });
      wI = u((Bqe, SI) => {
        SI.exports = { 0: "#000", 1: "#9D9D9D", 2: "#FFF", 3: "#BE2633", 4: "#E06F8B", 5: "#493C2B",
        6: "#A46422", 7: "#EB8931", 8: "#F7E26B", 9: "#2F484E", A: "#44891A", B: "#A3CE27", C: "#1B2\
632", D: "#005784", E: "#31A2F2", F: "#B2DCEF" };
      });
      AI = u((Gqe, CI) => {
        var Woe = wI(), Hoe = Tt(), bi = H(), Koe = function(e) {
          var t = bi(e, "data", []), i = bi(e, "canvas", null), r = bi(e, "palette", Woe), s = bi(e,
          "pixelWidth", 1), n = bi(e, "pixelHeight", s), a = bi(e, "resizeCanvas", true), o = bi(e, "\
clearCanvas", true), h = bi(e, "preRender", null), l = bi(e, "postRender", null), f = Math.floor(Math.
          abs(t[0].length * s)), d = Math.floor(Math.abs(t.length * n));
          i || (i = Hoe.create2D(this, f, d), a = false, o = false), a && (i.width = f, i.height = d);
          var c = i.getContext("2d", { willReadFrequently: true });
          o && c.clearRect(0, 0, f, d), h && h(i, c);
          for (var p = 0; p < t.length; p++) for (var v = t[p], m = 0; m < v.length; m++) {
            var g = v[m];
            g !== "." && g !== " " && (c.fillStyle = r[g], c.fillRect(m * s, p * n, s, n));
          }
          return l && l(i, c), i;
        };
        CI.exports = Koe;
      });
      _I = u((Uqe, RI) => {
        var Zoe = function(e, t, i, r) {
          i.addToRenderList(t), this.pipeline.batchSprite(t, i, r);
        };
        RI.exports = Zoe;
      });
      FI = u((zqe, qI) => {
        var PI = J(), MI = PI, Qoe = PI;
        MI = _I();
        qI.exports = { renderWebGL: MI, renderCanvas: Qoe };
      });
      ta = u((kqe, LI) => {
        var Joe = C(), st = Ot(), bI = ei(), $oe = FI(), joe = new Joe({ Extends: bI, Mixins: [st.Alpha,
        st.BlendMode, st.Depth, st.Flip, st.GetBounds, st.Mask, st.Origin, st.Pipeline, st.PostPipeline,
        st.ScrollFactor, st.Size, st.TextureCrop, st.Tint, st.Transform, st.Visible, $oe], initialize: function(t, i, r, s, n) {
          bI.call(this, t, "Image"), this._crop = this.resetCropObject(), this.setTexture(s, n), this.
          setPosition(i, r), this.setSizeToFrame(), this.setOriginFromFrame(), this.initPipeline(), this.
          initPostPipeline(true);
        } });
        LI.exports = joe;
      });
      DI = u((Xqe, OI) => {
        var ehe = function(e, t, i) {
          if (!i.getElementsByTagName("TextureAtlas")) {
            console.warn("Invalid Texture Atlas XML given");
            return;
          }
          var r = e.source[t];
          e.add("__BASE", t, 0, 0, r.width, r.height);
          for (var s = i.getElementsByTagName("SubTexture"), n, a = 0; a < s.length; a++) {
            var o = s[a].attributes, h = o.name.value, l = parseInt(o.x.value, 10), f = parseInt(o.y.
            value, 10), d = parseInt(o.width.value, 10), c = parseInt(o.height.value, 10);
            if (n = e.add(h, t, l, f, d, c), o.frameX) {
              var p = Math.abs(parseInt(o.frameX.value, 10)), v = Math.abs(parseInt(o.frameY.value, 10)),
              m = parseInt(o.frameWidth.value, 10), g = parseInt(o.frameHeight.value, 10);
              n.setTrim(d, c, p, v, m, g);
            }
          }
          return e;
        };
        OI.exports = ehe;
      });
      II = u((Vqe, NI) => {
        var the = function(e, t) {
          var i = e.source[t];
          return e.add("__BASE", t, 0, 0, i.width, i.height), e;
        };
        NI.exports = the;
      });
      GI = u((Yqe, BI) => {
        var ihe = function(e, t) {
          var i = e.source[t];
          return e.add("__BASE", t, 0, 0, i.width, i.height), e;
        };
        BI.exports = ihe;
      });
      zI = u((Wqe, UI) => {
        var rhe = kr(), she = function(e, t, i) {
          if (!i.frames && !i.textures) {
            console.warn("Invalid Texture Atlas JSON Array");
            return;
          }
          var r = e.source[t];
          e.add("__BASE", t, 0, 0, r.width, r.height);
          for (var s = Array.isArray(i.textures) ? i.textures[t].frames : i.frames, n, a = 0; a < s.
          length; a++) {
            var o = s[a];
            if (n = e.add(o.filename, t, o.frame.x, o.frame.y, o.frame.w, o.frame.h), !n) {
              console.warn("Invalid atlas json, frame already exists: " + o.filename);
              continue;
            }
            o.trimmed && n.setTrim(o.sourceSize.w, o.sourceSize.h, o.spriteSourceSize.x, o.spriteSourceSize.
            y, o.spriteSourceSize.w, o.spriteSourceSize.h), o.rotated && (n.rotated = true, n.updateUVsInverted());
            var h = o.anchor || o.pivot;
            h && (n.customPivot = true, n.pivotX = h.x, n.pivotY = h.y), o.scale9Borders && n.setScale9(
            o.scale9Borders.x, o.scale9Borders.y, o.scale9Borders.w, o.scale9Borders.h), n.customData =
            rhe(o);
          }
          for (var l in i) l !== "frames" && (Array.isArray(i[l]) ? e.customData[l] = i[l].slice(0) :
          e.customData[l] = i[l]);
          return e;
        };
        UI.exports = she;
      });
      XI = u((Hqe, kI) => {
        var nhe = kr(), ahe = function(e, t, i) {
          if (!i.frames) {
            console.warn("Invalid Texture Atlas JSON Hash given, missing 'frames' Object");
            return;
          }
          var r = e.source[t];
          e.add("__BASE", t, 0, 0, r.width, r.height);
          var s = i.frames, n;
          for (var a in s) if (s.hasOwnProperty(a)) {
            var o = s[a];
            if (n = e.add(a, t, o.frame.x, o.frame.y, o.frame.w, o.frame.h), !n) {
              console.warn("Invalid atlas json, frame already exists: " + a);
              continue;
            }
            o.trimmed && n.setTrim(o.sourceSize.w, o.sourceSize.h, o.spriteSourceSize.x, o.spriteSourceSize.
            y, o.spriteSourceSize.w, o.spriteSourceSize.h), o.rotated && (n.rotated = true, n.updateUVsInverted());
            var h = o.anchor || o.pivot;
            h && (n.customPivot = true, n.pivotX = h.x, n.pivotY = h.y), o.scale9Borders && n.setScale9(
            o.scale9Borders.x, o.scale9Borders.y, o.scale9Borders.w, o.scale9Borders.h), n.customData =
            nhe(o);
          }
          for (var l in i) l !== "frames" && (Array.isArray(i[l]) ? e.customData[l] = i[l].slice(0) :
          e.customData[l] = i[l]);
          return e;
        };
        kI.exports = ahe;
      });
      YI = u((Kqe, VI) => {
        var ohe = function(e) {
          var t = [171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10], i, r = new Uint8Array(e, 0, 12);
          for (i = 0; i < r.length; i++) if (r[i] !== t[i]) {
            console.warn("KTXParser - Invalid file format");
            return;
          }
          var s = Uint32Array.BYTES_PER_ELEMENT, n = new DataView(e, 12, 13 * s), a = n.getUint32(0,
          true) === 67305985, o = n.getUint32(1 * s, a);
          if (o !== 0) {
            console.warn("KTXParser - Only compressed formats supported");
            return;
          }
          var h = n.getUint32(4 * s, a), l = n.getUint32(6 * s, a), f = n.getUint32(7 * s, a), d = Math.
          max(1, n.getUint32(11 * s, a)), c = n.getUint32(12 * s, a), p = new Array(d), v = 12 + 13 *
          4 + c, m = l, g = f;
          for (i = 0; i < d; i++) {
            var x = new Int32Array(e, v, 1)[0];
            v += 4, p[i] = { data: new Uint8Array(e, v, x), width: m, height: g }, m = Math.max(1, m >>
            1), g = Math.max(1, g >> 1), v += x;
          }
          return { mipmaps: p, width: l, height: f, internalFormat: h, compressed: true, generateMipmap: false };
        };
        VI.exports = ohe;
      });
      JI = u((Zqe, QI) => {
        function nt(e, t, i, r, s, n, a) {
          return a === void 0 && (a = 16), Math.floor((e + i) / s) * Math.floor((t + r) / n) * a;
        }
        function WI(e, t) {
          return e = Math.max(e, 16), t = Math.max(t, 8), e * t / 4;
        }
        function HI(e, t) {
          return e = Math.max(e, 8), t = Math.max(t, 8), e * t / 2;
        }
        function KI(e, t) {
          return Math.ceil(e / 4) * Math.ceil(t / 4) * 16;
        }
        function ia(e, t) {
          return nt(e, t, 3, 3, 4, 4, 8);
        }
        function Xs(e, t) {
          return nt(e, t, 3, 3, 4, 4);
        }
        function hhe(e, t) {
          return nt(e, t, 4, 3, 5, 4);
        }
        function uhe(e, t) {
          return nt(e, t, 4, 4, 5, 5);
        }
        function lhe(e, t) {
          return nt(e, t, 5, 4, 6, 5);
        }
        function fhe(e, t) {
          return nt(e, t, 5, 5, 6, 6);
        }
        function dhe(e, t) {
          return nt(e, t, 7, 4, 8, 5);
        }
        function che(e, t) {
          return nt(e, t, 7, 5, 8, 6);
        }
        function vhe(e, t) {
          return nt(e, t, 7, 7, 8, 8);
        }
        function phe(e, t) {
          return nt(e, t, 9, 4, 10, 5);
        }
        function mhe(e, t) {
          return nt(e, t, 9, 5, 10, 6);
        }
        function ghe(e, t) {
          return nt(e, t, 9, 7, 10, 8);
        }
        function xhe(e, t) {
          return nt(e, t, 9, 9, 10, 10);
        }
        function Ehe(e, t) {
          return nt(e, t, 11, 9, 12, 10);
        }
        function The(e, t) {
          return nt(e, t, 11, 11, 12, 12);
        }
        var ZI = { 0: { sizeFunc: WI, glFormat: [35841] }, 1: { sizeFunc: WI, glFormat: [35843] }, 2: {
        sizeFunc: HI, glFormat: [35840] }, 3: { sizeFunc: HI, glFormat: [35842] }, 6: { sizeFunc: ia,
        glFormat: [36196] }, 7: { sizeFunc: ia, glFormat: [33776, 35916] }, 8: { sizeFunc: Xs, glFormat: [
        33777, 35917] }, 9: { sizeFunc: Xs, glFormat: [33778, 35918] }, 11: { sizeFunc: Xs, glFormat: [
        33779, 35919] }, 14: { sizeFunc: KI, glFormat: [36494, 36495] }, 15: { sizeFunc: KI, glFormat: [
        36492, 36493] }, 22: { sizeFunc: ia, glFormat: [37492, 37493] }, 23: { sizeFunc: Xs, glFormat: [
        37496, 37497] }, 24: { sizeFunc: ia, glFormat: [37494, 37495] }, 25: { sizeFunc: ia, glFormat: [
        37488] }, 26: { sizeFunc: Xs, glFormat: [37490] }, 27: { sizeFunc: Xs, glFormat: [37808, 37840] },
        28: { sizeFunc: hhe, glFormat: [37809, 37841] }, 29: { sizeFunc: uhe, glFormat: [37810, 37842] },
        30: { sizeFunc: lhe, glFormat: [37811, 37843] }, 31: { sizeFunc: fhe, glFormat: [37812, 37844] },
        32: { sizeFunc: dhe, glFormat: [37813, 37845] }, 33: { sizeFunc: che, glFormat: [37814, 37846] },
        34: { sizeFunc: vhe, glFormat: [37815, 37847] }, 35: { sizeFunc: phe, glFormat: [37816, 37848] },
        36: { sizeFunc: mhe, glFormat: [37817, 37849] }, 37: { sizeFunc: ghe, glFormat: [37818, 37850] },
        38: { sizeFunc: xhe, glFormat: [37819, 37851] }, 39: { sizeFunc: Ehe, glFormat: [37820, 37852] },
        40: { sizeFunc: The, glFormat: [37821, 37853] } }, yhe = function(e) {
          for (var t = new Uint32Array(e, 0, 13), i = t[0], r = i === 55727696, s = r ? t[2] : t[3],
          n = t[4], a = ZI[s].glFormat[n], o = ZI[s].sizeFunc, h = t[11], l = t[7], f = t[6], d = 52 +
          t[12], c = new Uint8Array(e, d), p = new Array(h), v = 0, m = l, g = f, x = 0; x < h; x++) {
            var E = o(m, g);
            p[x] = { data: new Uint8Array(c.buffer, c.byteOffset + v, E), width: m, height: g }, m =
            Math.max(1, m >> 1), g = Math.max(1, g >> 1), v += E;
          }
          return { mipmaps: p, width: l, height: f, internalFormat: a, compressed: true, generateMipmap: false };
        };
        QI.exports = yhe;
      });
      jI = u((Qqe, $I) => {
        var Vs = B(), She = function(e, t, i, r, s, n, a) {
          var o = Vs(a, "frameWidth", null), h = Vs(a, "frameHeight", o);
          if (o === null) throw new Error("TextureManager.SpriteSheet: Invalid frameWidth given.");
          var l = e.source[t];
          e.add("__BASE", t, 0, 0, l.width, l.height);
          var f = Vs(a, "startFrame", 0), d = Vs(a, "endFrame", -1), c = Vs(a, "margin", 0), p = Vs(
          a, "spacing", 0), v = Math.floor((s - c + p) / (o + p)), m = Math.floor((n - c + p) / (h +
          p)), g = v * m;
          g === 0 && console.warn("SpriteSheet frame dimensions will result in zero frames for textu\
re:", e.key), (f > g || f < -g) && (f = 0), f < 0 && (f = g + f), (d === -1 || d > g || d < f) && (d =
          g);
          for (var x = c, E = c, T15 = 0, w = 0, y = 0, A10 = 0; A10 < g; A10++) {
            T15 = 0, w = 0;
            var S14 = x + o, _ = E + h;
            S14 > s && (T15 = S14 - s), _ > n && (w = _ - n), A10 >= f && A10 <= d && (e.add(y, t, i +
            x, r + E, o - T15, h - w), y++), x += o + p, x + o > s && (x = c, E += h + p);
          }
          return e;
        };
        $I.exports = She;
      });
      tB = u((Jqe, eB) => {
        var Ys = B(), whe = function(e, t, i) {
          var r = Ys(i, "frameWidth", null), s = Ys(i, "frameHeight", r);
          if (!r) throw new Error("TextureManager.SpriteSheetFromAtlas: Invalid frameWidth given.");
          var n = e.source[0];
          e.add("__BASE", 0, 0, 0, n.width, n.height);
          var a = Ys(i, "startFrame", 0), o = Ys(i, "endFrame", -1), h = Ys(i, "margin", 0), l = Ys(
          i, "spacing", 0), f = t.cutX, d = t.cutY, c = t.cutWidth, p = t.cutHeight, v = t.realWidth,
          m = t.realHeight, g = Math.floor((v - h + l) / (r + l)), x = Math.floor((m - h + l) / (s +
          l)), E = g * x, T15 = t.x, w = r - T15, y = r - (v - c - T15), A10 = t.y, S14 = s - A10, _ = s -
          (m - p - A10);
          (a > E || a < -E) && (a = 0), a < 0 && (a = E + a), o !== -1 && (E = a + (o + 1));
          for (var q, P = h, L = h, N5 = 0, O19 = 0, M = 0; M < x; M++) {
            for (var F8 = M === 0, b = M === x - 1, G = 0; G < g; G++) {
              var I = G === 0, W = G === g - 1;
              if (q = e.add(N5, O19, f + P, d + L, r, s), I || F8 || W || b) {
                var Ae = I ? T15 : 0, Re = F8 ? A10 : 0, ge = 0, _e = 0;
                I && (ge += r - w), W && (ge += r - y), F8 && (_e += s - S14), b && (_e += s - _);
                var V24 = r - ge, Te = s - _e;
                q.cutWidth = V24, q.cutHeight = Te, q.setTrim(r, s, Ae, Re, V24, Te);
              }
              P += l, I ? P += w : W ? P += y : P += r, N5++;
            }
            P = h, L += l, F8 ? L += S14 : b ? L += _ : L += s;
          }
          return e;
        };
        eB.exports = whe;
      });
      nB = u(($qe, sB) => {
        var rB = 0, iB = function(e, t, i, r) {
          var s = rB - r.y - r.height;
          e.add(i, t, r.x, s, r.width, r.height);
        }, Che = function(e, t, i) {
          var r = e.source[t];
          e.add("__BASE", t, 0, 0, r.width, r.height), rB = r.height;
          for (var s = i.split(`
`), n = /^[ ]*(- )*(\w+)+[: ]+(.*)/, a = "", o = "", h = { x: 0, y: 0, width: 0, height: 0 }, l = 0; l <
          s.length; l++) {
            var f = s[l].match(n);
            if (f) {
              var d = f[1] === "- ", c = f[2], p = f[3];
              if (d && (o !== a && (iB(e, t, o, h), a = o), h = { x: 0, y: 0, width: 0, height: 0 }),
              c === "name") {
                o = p;
                continue;
              }
              switch (c) {
                case "x":
                case "y":
                case "width":
                case "height":
                  h[c] = parseInt(p, 10);
                  break;
              }
            }
          }
          return o !== a && iB(e, t, o, h), e;
        };
        sB.exports = Che;
      });
      yc = u((jqe, aB) => {
        aB.exports = { AtlasXML: DI(), Canvas: II(), Image: GI(), JSONArray: zI(), JSONHash: XI(), KTXParser: YI(),
        PVRParser: JI(), SpriteSheet: jI(), SpriteSheetFromAtlas: tB(), UnityYAML: nB() };
      });
      wc = u((eFe, fB) => {
        var Ws = Tt(), oB = xc(), Ahe = C(), Rhe = Ai(), _he = qt(), Phe = Tc(), hB = Z(), z = Fs(),
        uB = Pr(), Sc = Ye(), Mhe = AI(), lB = H(), qhe = ta(), Fhe = lt(), At = yc(), bhe = he(), or = ea(),
        Lhe = new Ahe({ Extends: hB, initialize: function(t) {
          hB.call(this), this.game = t, this.name = "TextureManager", this.list = {}, this._tempCanvas =
          Ws.create2D(this), this._tempContext = this._tempCanvas.getContext("2d", { willReadFrequently: true }),
          this._pending = 0, this.stamp, this.stampCrop = new bhe(), this.silentWarnings = false, t.
          events.once(Sc.BOOT, this.boot, this);
        }, boot: function() {
          this._pending = 3, this.on(z.LOAD, this.updatePending, this), this.on(z.ERROR, this.updatePending,
          this);
          var e = this.game.config;
          e.defaultImage !== null && this.addBase64("__DEFAULT", e.defaultImage), e.missingImage !==
          null && this.addBase64("__MISSING", e.missingImage), e.whiteImage !== null && this.addBase64(
          "__WHITE", e.whiteImage), this.game.renderer && this.game.renderer.gl && this.addUint8Array(
          "__NORMAL", new Uint8Array([127, 127, 255, 255]), 1, 1), this.game.events.once(Sc.DESTROY,
          this.destroy, this), this.game.events.once(Sc.SYSTEM_READY, function(t) {
            this.stamp = new qhe(t).setOrigin(0);
          }, this);
        }, updatePending: function() {
          this._pending--, this._pending === 0 && (this.off(z.LOAD), this.off(z.ERROR), this.emit(z.
          READY));
        }, checkKey: function(e) {
          return !e || typeof e != "string" || this.exists(e) ? (this.silentWarnings || console.error(
          "Texture key already in use: " + e), false) : true;
        }, remove: function(e) {
          if (typeof e == "string") if (this.exists(e)) e = this.get(e);
          else return this.silentWarnings || console.warn("No texture found matching key: " + e), this;
          var t = e.key;
          return this.list.hasOwnProperty(t) && (e.destroy(), this.emit(z.REMOVE, t), this.emit(z.REMOVE_KEY +
          t)), this;
        }, removeKey: function(e) {
          return this.list.hasOwnProperty(e) && delete this.list[e], this;
        }, addBase64: function(e, t) {
          if (this.checkKey(e)) {
            var i = this, r = new Image();
            r.onerror = function() {
              i.emit(z.ERROR, e);
            }, r.onload = function() {
              var s = i.create(e, r);
              s && (At.Image(s, 0), i.emit(z.ADD, e, s), i.emit(z.ADD_KEY + e, s), i.emit(z.LOAD, e,
              s));
            }, r.src = t;
          }
          return this;
        }, getBase64: function(e, t, i, r) {
          i === void 0 && (i = "image/png"), r === void 0 && (r = 0.92);
          var s = "", n = this.getFrame(e, t);
          if (n && (n.source.isRenderTexture || n.source.isGLTexture)) this.silentWarnings || console.
          warn("Cannot getBase64 from WebGL Texture");
          else if (n) {
            var a = n.canvasData, o = Ws.create2D(this, a.width, a.height), h = o.getContext("2d", {
            willReadFrequently: true });
            a.width > 0 && a.height > 0 && h.drawImage(n.source.image, a.x, a.y, a.width, a.height, 0,
            0, a.width, a.height), s = o.toDataURL(i, r), Ws.remove(o);
          }
          return s;
        }, addImage: function(e, t, i) {
          var r = null;
          return this.checkKey(e) && (r = this.create(e, t), At.Image(r, 0), i && r.setDataSource(i),
          this.emit(z.ADD, e, r), this.emit(z.ADD_KEY + e, r)), r;
        }, addGLTexture: function(e, t) {
          var i = null;
          if (this.checkKey(e)) {
            var r = t.width, s = t.height;
            i = this.create(e, t, r, s), i.add("__BASE", 0, 0, 0, r, s), this.emit(z.ADD, e, i), this.
            emit(z.ADD_KEY + e, i);
          }
          return i;
        }, addCompressedTexture: function(e, t, i) {
          var r = null;
          if (this.checkKey(e)) {
            if (r = this.create(e, t), r.add("__BASE", 0, 0, 0, t.width, t.height), i) {
              var s = function(a, o, h) {
                Array.isArray(h.textures) || Array.isArray(h.frames) ? At.JSONArray(a, o, h) : At.JSONHash(
                a, o, h);
              };
              if (Array.isArray(i)) for (var n = 0; n < i.length; n++) s(r, n, i[n]);
              else s(r, 0, i);
            }
            this.emit(z.ADD, e, r), this.emit(z.ADD_KEY + e, r);
          }
          return r;
        }, addRenderTexture: function(e, t) {
          var i = null;
          return this.checkKey(e) && (i = this.create(e, t), i.add("__BASE", 0, 0, 0, t.width, t.height),
          this.emit(z.ADD, e, i), this.emit(z.ADD_KEY + e, i)), i;
        }, generate: function(e, t) {
          if (this.checkKey(e)) {
            var i = Ws.create(this, 1, 1);
            return t.canvas = i, Mhe(t), this.addCanvas(e, i);
          } else return null;
        }, createCanvas: function(e, t, i) {
          if (t === void 0 && (t = 256), i === void 0 && (i = 256), this.checkKey(e)) {
            var r = Ws.create(this, t, i, _he.CANVAS, true);
            return this.addCanvas(e, r);
          }
          return null;
        }, addCanvas: function(e, t, i) {
          i === void 0 && (i = false);
          var r = null;
          return i ? r = new oB(this, e, t, t.width, t.height) : this.checkKey(e) && (r = new oB(this,
          e, t, t.width, t.height), this.list[e] = r, this.emit(z.ADD, e, r), this.emit(z.ADD_KEY + e,
          r)), r;
        }, addDynamicTexture: function(e, t, i) {
          var r = null;
          return typeof e == "string" && !this.exists(e) ? r = new Phe(this, e, t, i) : (r = e, e = r.
          key), this.checkKey(e) ? (this.list[e] = r, this.emit(z.ADD, e, r), this.emit(z.ADD_KEY + e,
          r)) : r = null, r;
        }, addAtlas: function(e, t, i, r) {
          return Array.isArray(i.textures) || Array.isArray(i.frames) ? this.addAtlasJSONArray(e, t,
          i, r) : this.addAtlasJSONHash(e, t, i, r);
        }, addAtlasJSONArray: function(e, t, i, r) {
          var s = null;
          if (t instanceof or ? (e = t.key, s = t) : this.checkKey(e) && (s = this.create(e, t)), s) {
            if (Array.isArray(i)) for (var n = i.length === 1, a = 0; a < s.source.length; a++) {
              var o = n ? i[0] : i[a];
              At.JSONArray(s, a, o);
            }
            else At.JSONArray(s, 0, i);
            r && s.setDataSource(r), this.emit(z.ADD, e, s), this.emit(z.ADD_KEY + e, s);
          }
          return s;
        }, addAtlasJSONHash: function(e, t, i, r) {
          var s = null;
          if (t instanceof or ? (e = t.key, s = t) : this.checkKey(e) && (s = this.create(e, t)), s) {
            if (Array.isArray(i)) for (var n = 0; n < i.length; n++) At.JSONHash(s, n, i[n]);
            else At.JSONHash(s, 0, i);
            r && s.setDataSource(r), this.emit(z.ADD, e, s), this.emit(z.ADD_KEY + e, s);
          }
          return s;
        }, addAtlasXML: function(e, t, i, r) {
          var s = null;
          return t instanceof or ? (e = t.key, s = t) : this.checkKey(e) && (s = this.create(e, t)),
          s && (At.AtlasXML(s, 0, i), r && s.setDataSource(r), this.emit(z.ADD, e, s), this.emit(z.ADD_KEY +
          e, s)), s;
        }, addUnityAtlas: function(e, t, i, r) {
          var s = null;
          return t instanceof or ? (e = t.key, s = t) : this.checkKey(e) && (s = this.create(e, t)),
          s && (At.UnityYAML(s, 0, i), r && s.setDataSource(r), this.emit(z.ADD, e, s), this.emit(z.
          ADD_KEY + e, s)), s;
        }, addSpriteSheet: function(e, t, i, r) {
          var s = null;
          if (t instanceof or ? (e = t.key, s = t) : this.checkKey(e) && (s = this.create(e, t)), s) {
            var n = s.source[0].width, a = s.source[0].height;
            At.SpriteSheet(s, 0, 0, 0, n, a, i), r && s.setDataSource(r), this.emit(z.ADD, e, s), this.
            emit(z.ADD_KEY + e, s);
          }
          return s;
        }, addSpriteSheetFromAtlas: function(e, t) {
          if (!this.checkKey(e)) return null;
          var i = lB(t, "atlas", null), r = lB(t, "frame", null);
          if (!(!i || !r)) {
            var s = this.get(i), n = s.get(r);
            if (n) {
              var a = n.source.image;
              a || (a = n.source.glTexture);
              var o = this.create(e, a);
              return n.trimmed ? At.SpriteSheetFromAtlas(o, n, t) : At.SpriteSheet(o, 0, n.cutX, n.cutY,
              n.cutWidth, n.cutHeight, t), this.emit(z.ADD, e, o), this.emit(z.ADD_KEY + e, o), o;
            }
          }
        }, addUint8Array: function(e, t, i, r) {
          if (!this.checkKey(e) || t.length / 4 !== i * r) return null;
          var s = this.create(e, t, i, r);
          return s.add("__BASE", 0, 0, 0, i, r), this.emit(z.ADD, e, s), this.emit(z.ADD_KEY + e, s),
          s;
        }, create: function(e, t, i, r) {
          var s = null;
          return this.checkKey(e) && (s = new or(this, e, t, i, r), this.list[e] = s), s;
        }, exists: function(e) {
          return this.list.hasOwnProperty(e);
        }, get: function(e) {
          return e === void 0 && (e = "__DEFAULT"), this.list[e] ? this.list[e] : e instanceof or ? e :
          e instanceof uB ? e.texture : this.list.__MISSING;
        }, cloneFrame: function(e, t) {
          if (this.list[e]) return this.list[e].get(t).clone();
        }, getFrame: function(e, t) {
          if (this.list[e]) return this.list[e].get(t);
        }, parseFrame: function(e) {
          if (e) {
            if (typeof e == "string") return this.getFrame(e);
            if (Array.isArray(e) && e.length === 2) return this.getFrame(e[0], e[1]);
            if (Fhe(e)) return this.getFrame(e.key, e.frame);
            if (e instanceof or) return e.get();
            if (e instanceof uB) return e;
          } else return;
        }, getTextureKeys: function() {
          var e = [];
          for (var t in this.list) t !== "__DEFAULT" && t !== "__MISSING" && t !== "__WHITE" && t !==
          "__NORMAL" && e.push(t);
          return e;
        }, getPixel: function(e, t, i, r) {
          var s = this.getFrame(i, r);
          if (s) {
            e -= s.x, t -= s.y;
            var n = s.data.cut;
            if (e += n.x, t += n.y, e >= n.x && e < n.r && t >= n.y && t < n.b) {
              var a = this._tempContext;
              a.clearRect(0, 0, 1, 1), a.drawImage(s.source.image, e, t, 1, 1, 0, 0, 1, 1);
              var o = a.getImageData(0, 0, 1, 1);
              return new Rhe(o.data[0], o.data[1], o.data[2], o.data[3]);
            }
          }
          return null;
        }, getPixelAlpha: function(e, t, i, r) {
          var s = this.getFrame(i, r);
          if (s) {
            e -= s.x, t -= s.y;
            var n = s.data.cut;
            if (e += n.x, t += n.y, e >= n.x && e < n.r && t >= n.y && t < n.b) {
              var a = this._tempContext;
              a.clearRect(0, 0, 1, 1), a.drawImage(s.source.image, e, t, 1, 1, 0, 0, 1, 1);
              var o = a.getImageData(0, 0, 1, 1);
              return o.data[3];
            }
          }
          return null;
        }, setTexture: function(e, t, i) {
          return this.list[t] && (e.texture = this.list[t], e.frame = e.texture.get(i)), e;
        }, renameTexture: function(e, t) {
          var i = this.get(e);
          return i && e !== t ? (i.key = t, this.list[t] = i, delete this.list[e], true) : false;
        }, each: function(e, t) {
          for (var i = [null], r = 1; r < arguments.length; r++) i.push(arguments[r]);
          for (var s in this.list) i[0] = this.list[s], e.apply(t, i);
        }, resetStamp: function(e, t) {
          e === void 0 && (e = 1), t === void 0 && (t = 16777215);
          var i = this.stamp;
          return i.setCrop(), i.setPosition(0), i.setAngle(0), i.setScale(1), i.setAlpha(e), i.setTint(
          t), i.setTexture("__WHITE"), i;
        }, destroy: function() {
          for (var e in this.list) this.list[e].destroy();
          this.list = {}, this.stamp.destroy(), this.game = null, this.stamp = null, Ws.remove(this.
          _tempCanvas);
        } });
        fB.exports = Lhe;
      });
      cB = u((tFe, dB) => {
        dB.exports = "complete";
      });
      pB = u((iFe, vB) => {
        vB.exports = "decoded";
      });
      gB = u((rFe, mB) => {
        mB.exports = "decodedall";
      });
      EB = u((sFe, xB) => {
        xB.exports = "destroy";
      });
      yB = u((nFe, TB) => {
        TB.exports = "detune";
      });
      wB = u((aFe, SB) => {
        SB.exports = "detune";
      });
      AB = u((oFe, CB) => {
        CB.exports = "mute";
      });
      _B = u((hFe, RB) => {
        RB.exports = "rate";
      });
      MB = u((uFe, PB) => {
        PB.exports = "volume";
      });
      FB = u((lFe, qB) => {
        qB.exports = "loop";
      });
      LB = u((fFe, bB) => {
        bB.exports = "looped";
      });
      DB = u((dFe, OB) => {
        OB.exports = "mute";
      });
      IB = u((cFe, NB) => {
        NB.exports = "pan";
      });
      GB = u((vFe, BB) => {
        BB.exports = "pauseall";
      });
      zB = u((pFe, UB) => {
        UB.exports = "pause";
      });
      XB = u((mFe, kB) => {
        kB.exports = "play";
      });
      YB = u((gFe, VB) => {
        VB.exports = "rate";
      });
      HB = u((xFe, WB) => {
        WB.exports = "resumeall";
      });
      ZB = u((EFe, KB) => {
        KB.exports = "resume";
      });
      JB = u((TFe, QB) => {
        QB.exports = "seek";
      });
      jB = u((yFe, $B) => {
        $B.exports = "stopall";
      });
      tG = u((SFe, eG) => {
        eG.exports = "stop";
      });
      rG = u((wFe, iG) => {
        iG.exports = "unlocked";
      });
      nG = u((CFe, sG) => {
        sG.exports = "volume";
      });
      hr = u((AFe, aG) => {
        aG.exports = { COMPLETE: cB(), DECODED: pB(), DECODED_ALL: gB(), DESTROY: EB(), DETUNE: yB(),
        GLOBAL_DETUNE: wB(), GLOBAL_MUTE: AB(), GLOBAL_RATE: _B(), GLOBAL_VOLUME: MB(), LOOP: FB(), LOOPED: LB(),
        MUTE: DB(), PAN: IB(), PAUSE_ALL: GB(), PAUSE: zB(), PLAY: XB(), RATE: YB(), RESUME_ALL: HB(),
        RESUME: ZB(), SEEK: JB(), STOP_ALL: jB(), STOP: tG(), UNLOCKED: rG(), VOLUME: nG() };
      });
      sa = u((RFe, hG) => {
        var Ohe = C(), Dhe = kr(), oG = Z(), ur = hr(), Xr = Ye(), Cc = Ua(), Nhe = Hu(), ra = J(), Ihe = Y(),
        Bhe = new Ohe({ Extends: oG, initialize: function(t) {
          oG.call(this), this.game = t, this.jsonCache = t.cache.json, this.sounds = [], this.mute =
          false, this.volume = 1, this.pauseOnBlur = true, this._rate = 1, this._detune = 0, this.locked =
          this.locked || false, this.unlocked = false, this.gameLostFocus = false, this.listenerPosition =
          new Ihe();
          var i = t.events;
          i.on(Xr.BLUR, this.onGameBlur, this), i.on(Xr.FOCUS, this.onGameFocus, this), i.on(Xr.PRE_STEP,
          this.update, this), i.once(Xr.DESTROY, this.destroy, this);
        }, add: ra, addAudioSprite: function(e, t) {
          t === void 0 && (t = {});
          var i = this.add(e, t);
          i.spritemap = this.jsonCache.get(e).spritemap;
          for (var r in i.spritemap) if (i.spritemap.hasOwnProperty(r)) {
            var s = Dhe(t), n = i.spritemap[r];
            s.loop = n.hasOwnProperty("loop") ? n.loop : false, i.addMarker({ name: r, start: n.start,
            duration: n.end - n.start, config: s });
          }
          return i;
        }, get: function(e) {
          return Nhe(this.sounds, "key", e);
        }, getAll: function(e) {
          return e ? Cc(this.sounds, "key", e) : Cc(this.sounds);
        }, getAllPlaying: function() {
          return Cc(this.sounds, "isPlaying", true);
        }, play: function(e, t) {
          var i = this.add(e);
          return i.once(ur.COMPLETE, i.destroy, i), t ? t.name ? (i.addMarker(t), i.play(t.name)) : i.
          play(t) : i.play();
        }, playAudioSprite: function(e, t, i) {
          var r = this.addAudioSprite(e);
          return r.once(ur.COMPLETE, r.destroy, r), r.play(t, i);
        }, remove: function(e) {
          var t = this.sounds.indexOf(e);
          return t !== -1 ? (e.destroy(), this.sounds.splice(t, 1), true) : false;
        }, removeAll: function() {
          this.sounds.forEach(function(e) {
            e.destroy();
          }), this.sounds.length = 0;
        }, removeByKey: function(e) {
          for (var t = 0, i = this.sounds.length - 1; i >= 0; i--) {
            var r = this.sounds[i];
            r.key === e && (r.destroy(), this.sounds.splice(i, 1), t++);
          }
          return t;
        }, pauseAll: function() {
          this.forEachActiveSound(function(e) {
            e.pause();
          }), this.emit(ur.PAUSE_ALL, this);
        }, resumeAll: function() {
          this.forEachActiveSound(function(e) {
            e.resume();
          }), this.emit(ur.RESUME_ALL, this);
        }, setListenerPosition: ra, stopAll: function() {
          this.forEachActiveSound(function(e) {
            e.stop();
          }), this.emit(ur.STOP_ALL, this);
        }, stopByKey: function(e) {
          var t = 0;
          return this.getAll(e).forEach(function(i) {
            i.stop() && t++;
          }), t;
        }, isPlaying: function(e) {
          var t = this.sounds, i = t.length - 1, r;
          if (e === void 0) {
            for (; i >= 0; i--) if (r = this.sounds[i], r.isPlaying) return true;
          } else for (; i >= 0; i--) if (r = this.sounds[i], r.key === e && r.isPlaying) return true;
          return false;
        }, unlock: ra, onBlur: ra, onFocus: ra, onGameBlur: function() {
          this.gameLostFocus = true, this.pauseOnBlur && this.onBlur();
        }, onGameFocus: function() {
          this.gameLostFocus = false, this.pauseOnBlur && this.onFocus();
        }, update: function(e, t) {
          this.unlocked && (this.unlocked = false, this.locked = false, this.emit(ur.UNLOCKED, this));
          for (var i = this.sounds.length - 1; i >= 0; i--) this.sounds[i].pendingRemove && this.sounds.
          splice(i, 1);
          this.sounds.forEach(function(r) {
            r.update(e, t);
          });
        }, destroy: function() {
          this.game.events.off(Xr.BLUR, this.onGameBlur, this), this.game.events.off(Xr.FOCUS, this.
          onGameFocus, this), this.game.events.off(Xr.PRE_STEP, this.update, this), this.removeAllListeners(),
          this.removeAll(), this.sounds.length = 0, this.sounds = null, this.listenerPosition = null,
          this.game = null;
        }, forEachActiveSound: function(e, t) {
          var i = this;
          this.sounds.forEach(function(r, s) {
            r && !r.pendingRemove && e.call(t || i, r, s, i.sounds);
          });
        }, setRate: function(e) {
          return this.rate = e, this;
        }, rate: { get: function() {
          return this._rate;
        }, set: function(e) {
          this._rate = e, this.forEachActiveSound(function(t) {
            t.calculateRate();
          }), this.emit(ur.GLOBAL_RATE, this, e);
        } }, setDetune: function(e) {
          return this.detune = e, this;
        }, detune: { get: function() {
          return this._detune;
        }, set: function(e) {
          this._detune = e, this.forEachActiveSound(function(t) {
            t.calculateRate();
          }), this.emit(ur.GLOBAL_DETUNE, this, e);
        } } });
        hG.exports = Bhe;
      });
      na = u((_Fe, lG) => {
        var Ghe = C(), uG = Z(), Uhe = hr(), ch = Xe(), zhe = J(), khe = new Ghe({ Extends: uG, initialize: function(t, i, r) {
          uG.call(this), this.manager = t, this.key = i, this.isPlaying = false, this.isPaused = false,
          this.totalRate = 1, this.duration = this.duration || 0, this.totalDuration = this.totalDuration ||
          0, this.config = { mute: false, volume: 1, rate: 1, detune: 0, seek: 0, loop: false, delay: 0,
          pan: 0 }, this.currentConfig = this.config, this.config = ch(this.config, r), this.markers =
          {}, this.currentMarker = null, this.pendingRemove = false;
        }, addMarker: function(e) {
          return !e || !e.name || typeof e.name != "string" ? false : this.markers[e.name] ? (console.
          error("addMarker " + e.name + " already exists in Sound"), false) : (e = ch(true, { name: "",
          start: 0, duration: this.totalDuration - (e.start || 0), config: { mute: false, volume: 1,
          rate: 1, detune: 0, seek: 0, loop: false, delay: 0, pan: 0 } }, e), this.markers[e.name] =
          e, true);
        }, updateMarker: function(e) {
          return !e || !e.name || typeof e.name != "string" ? false : this.markers[e.name] ? (this.markers[e.
          name] = ch(true, this.markers[e.name], e), true) : (console.warn("Audio Marker: " + e.name +
          " missing in Sound: " + this.key), false);
        }, removeMarker: function(e) {
          var t = this.markers[e];
          return t ? (this.markers[e] = null, t) : null;
        }, play: function(e, t) {
          if (e === void 0 && (e = ""), typeof e == "object" && (t = e, e = ""), typeof e != "string")
           return false;
          if (!e) this.currentMarker = null, this.currentConfig = this.config, this.duration = this.
          totalDuration;
          else {
            if (!this.markers[e]) return console.warn("Marker: " + e + " missing in Sound: " + this.
            key), false;
            this.currentMarker = this.markers[e], this.currentConfig = this.currentMarker.config, this.
            duration = this.currentMarker.duration;
          }
          return this.resetConfig(), this.currentConfig = ch(this.currentConfig, t), this.isPlaying =
          true, this.isPaused = false, true;
        }, pause: function() {
          return this.isPaused || !this.isPlaying ? false : (this.isPlaying = false, this.isPaused =
          true, true);
        }, resume: function() {
          return !this.isPaused || this.isPlaying ? false : (this.isPlaying = true, this.isPaused = false,
          true);
        }, stop: function() {
          return !this.isPaused && !this.isPlaying ? false : (this.isPlaying = false, this.isPaused =
          false, this.resetConfig(), true);
        }, applyConfig: function() {
          this.mute = this.currentConfig.mute, this.volume = this.currentConfig.volume, this.rate = this.
          currentConfig.rate, this.detune = this.currentConfig.detune, this.loop = this.currentConfig.
          loop, this.pan = this.currentConfig.pan;
        }, resetConfig: function() {
          this.currentConfig.seek = 0, this.currentConfig.delay = 0;
        }, update: zhe, calculateRate: function() {
          var e = 1.0005777895065548, t = this.currentConfig.detune + this.manager.detune, i = Math.
          pow(e, t);
          this.totalRate = this.currentConfig.rate * this.manager.rate * i;
        }, destroy: function() {
          this.pendingRemove || (this.stop(), this.emit(Uhe.DESTROY, this), this.removeAllListeners(),
          this.pendingRemove = true, this.manager = null, this.config = null, this.currentConfig = null,
          this.markers = null, this.currentMarker = null);
        } });
        lG.exports = khe;
      });
      Ac = u((PFe, fG) => {
        var Li = na(), Xhe = C(), at = hr(), Vhe = ne(), Yhe = new Xhe({ Extends: Li, initialize: function(t, i, r) {
          if (r === void 0 && (r = {}), this.tags = t.game.cache.audio.get(i), !this.tags) throw new Error(
          'No cached audio asset with key "' + i);
          this.audio = null, this.startTime = 0, this.previousTime = 0, this.duration = this.tags[0].
          duration, this.totalDuration = this.tags[0].duration, Li.call(this, t, i, r);
        }, play: function(e, t) {
          return this.manager.isLocked(this, "play", [e, t]) || !Li.prototype.play.call(this, e, t) ||
          !this.pickAndPlayAudioTag() ? false : (this.emit(at.PLAY, this), true);
        }, pause: function() {
          return this.manager.isLocked(this, "pause") || this.startTime > 0 || !Li.prototype.pause.call(
          this) ? false : (this.currentConfig.seek = this.audio.currentTime - (this.currentMarker ? this.
          currentMarker.start : 0), this.stopAndReleaseAudioTag(), this.emit(at.PAUSE, this), true);
        }, resume: function() {
          return this.manager.isLocked(this, "resume") || this.startTime > 0 || !Li.prototype.resume.
          call(this) || !this.pickAndPlayAudioTag() ? false : (this.emit(at.RESUME, this), true);
        }, stop: function() {
          return this.manager.isLocked(this, "stop") || !Li.prototype.stop.call(this) ? false : (this.
          stopAndReleaseAudioTag(), this.emit(at.STOP, this), true);
        }, pickAndPlayAudioTag: function() {
          if (!this.pickAudioTag()) return this.reset(), false;
          var e = this.currentConfig.seek, t = this.currentConfig.delay, i = (this.currentMarker ? this.
          currentMarker.start : 0) + e;
          return this.previousTime = i, this.audio.currentTime = i, this.applyConfig(), t === 0 ? (this.
          startTime = 0, this.audio.paused && this.playCatchPromise()) : (this.startTime = window.performance.
          now() + t * 1e3, this.audio.paused || this.audio.pause()), this.resetConfig(), true;
        }, pickAudioTag: function() {
          if (this.audio) return true;
          for (var e = 0; e < this.tags.length; e++) {
            var t = this.tags[e];
            if (t.dataset.used === "false") return t.dataset.used = "true", this.audio = t, true;
          }
          if (!this.manager.override) return false;
          var i = [];
          this.manager.forEachActiveSound(function(s) {
            s.key === this.key && s.audio && i.push(s);
          }, this), i.sort(function(s, n) {
            return s.loop === n.loop ? n.seek / n.duration - s.seek / s.duration : s.loop ? 1 : -1;
          });
          var r = i[0];
          return this.audio = r.audio, r.reset(), r.audio = null, r.startTime = 0, r.previousTime = 0,
          true;
        }, playCatchPromise: function() {
          var e = this.audio.play();
          e && e.catch(function(t) {
            console.warn(t);
          });
        }, stopAndReleaseAudioTag: function() {
          this.startTime = 0, this.previousTime = 0, this.audio && (this.audio.pause(), this.audio.dataset.
          used = "false", this.audio = null);
        }, reset: function() {
          Li.prototype.stop.call(this);
        }, onBlur: function() {
          this.isPlaying = false, this.isPaused = true, this.currentConfig.seek = this.audio.currentTime -
          (this.currentMarker ? this.currentMarker.start : 0), this.currentConfig.delay = Math.max(0,
          (this.startTime - window.performance.now()) / 1e3), this.stopAndReleaseAudioTag();
        }, onFocus: function() {
          this.isPlaying = true, this.isPaused = false, this.pickAndPlayAudioTag();
        }, update: function(e) {
          if (this.isPlaying) {
            if (this.startTime > 0) {
              this.startTime < e - this.manager.audioPlayDelay && (this.audio.currentTime += Math.max(
              0, e - this.startTime) / 1e3, this.startTime = 0, this.previousTime = this.audio.currentTime,
              this.playCatchPromise());
              return;
            }
            var t = this.currentMarker ? this.currentMarker.start : 0, i = t + this.duration, r = this.
            audio.currentTime;
            if (this.currentConfig.loop) r >= i - this.manager.loopEndOffset ? (this.audio.currentTime =
            t + Math.max(0, r - i), r = this.audio.currentTime) : r < t && (this.audio.currentTime +=
            t, r = this.audio.currentTime), r < this.previousTime && this.emit(at.LOOPED, this);
            else if (r >= i) {
              this.reset(), this.stopAndReleaseAudioTag(), this.emit(at.COMPLETE, this);
              return;
            }
            this.previousTime = r;
          }
        }, destroy: function() {
          Li.prototype.destroy.call(this), this.tags = null, this.audio && this.stopAndReleaseAudioTag();
        }, updateMute: function() {
          this.audio && (this.audio.muted = this.currentConfig.mute || this.manager.mute);
        }, updateVolume: function() {
          this.audio && (this.audio.volume = Vhe(this.currentConfig.volume * this.manager.volume, 0,
          1));
        }, calculateRate: function() {
          Li.prototype.calculateRate.call(this), this.audio && (this.audio.playbackRate = this.totalRate);
        }, mute: { get: function() {
          return this.currentConfig.mute;
        }, set: function(e) {
          this.currentConfig.mute = e, !this.manager.isLocked(this, "mute", e) && (this.updateMute(),
          this.emit(at.MUTE, this, e));
        } }, setMute: function(e) {
          return this.mute = e, this;
        }, volume: { get: function() {
          return this.currentConfig.volume;
        }, set: function(e) {
          this.currentConfig.volume = e, !this.manager.isLocked(this, "volume", e) && (this.updateVolume(),
          this.emit(at.VOLUME, this, e));
        } }, setVolume: function(e) {
          return this.volume = e, this;
        }, rate: { get: function() {
          return this.currentConfig.rate;
        }, set: function(e) {
          this.currentConfig.rate = e, !this.manager.isLocked(this, at.RATE, e) && (this.calculateRate(),
          this.emit(at.RATE, this, e));
        } }, setRate: function(e) {
          return this.rate = e, this;
        }, detune: { get: function() {
          return this.currentConfig.detune;
        }, set: function(e) {
          this.currentConfig.detune = e, !this.manager.isLocked(this, at.DETUNE, e) && (this.calculateRate(),
          this.emit(at.DETUNE, this, e));
        } }, setDetune: function(e) {
          return this.detune = e, this;
        }, seek: { get: function() {
          return this.isPlaying ? this.audio.currentTime - (this.currentMarker ? this.currentMarker.
          start : 0) : this.isPaused ? this.currentConfig.seek : 0;
        }, set: function(e) {
          this.manager.isLocked(this, "seek", e) || this.startTime > 0 || (this.isPlaying || this.isPaused) &&
          (e = Math.min(Math.max(0, e), this.duration), this.isPlaying ? (this.previousTime = e, this.
          audio.currentTime = e) : this.isPaused && (this.currentConfig.seek = e), this.emit(at.SEEK,
          this, e));
        } }, setSeek: function(e) {
          return this.seek = e, this;
        }, loop: { get: function() {
          return this.currentConfig.loop;
        }, set: function(e) {
          this.currentConfig.loop = e, !this.manager.isLocked(this, "loop", e) && (this.audio && (this.
          audio.loop = e), this.emit(at.LOOP, this, e));
        } }, setLoop: function(e) {
          return this.loop = e, this;
        }, pan: { get: function() {
          return this.currentConfig.pan;
        }, set: function(e) {
          this.currentConfig.pan = e, this.emit(at.PAN, this, e);
        } }, setPan: function(e) {
          return this.pan = e, this;
        } });
        fG.exports = Yhe;
      });
      Pc = u((MFe, dG) => {
        var Rc = sa(), Whe = C(), _c = hr(), Hhe = Ac(), Khe = new Whe({ Extends: Rc, initialize: function(t) {
          this.override = true, this.audioPlayDelay = 0.1, this.loopEndOffset = 0.05, this.onBlurPausedSounds =
          [], this.locked = "ontouchstart" in window, this.lockedActionsQueue = this.locked ? [] : null,
          this._mute = false, this._volume = 1, Rc.call(this, t);
        }, add: function(e, t) {
          var i = new Hhe(this, e, t);
          return this.sounds.push(i), i;
        }, unlock: function() {
          this.locked = false;
          var e = this;
          if (this.game.cache.audio.entries.each(function(s, n) {
            for (var a = 0; a < n.length; a++) if (n[a].dataset.locked === "true") return e.locked =
            true, false;
            return true;
          }), !!this.locked) {
            var t = false, i = function() {
              t = true;
            }, r = function() {
              if (t) {
                t = false;
                return;
              }
              document.body.removeEventListener("touchmove", i), document.body.removeEventListener("\
touchend", r);
              var s = [];
              if (e.game.cache.audio.entries.each(function(a, o) {
                for (var h = 0; h < o.length; h++) {
                  var l = o[h];
                  l.dataset.locked === "true" && s.push(l);
                }
                return true;
              }), s.length !== 0) {
                var n = s[s.length - 1];
                n.oncanplaythrough = function() {
                  n.oncanplaythrough = null, s.forEach(function(a) {
                    a.dataset.locked = "false";
                  }), e.unlocked = true;
                }, s.forEach(function(a) {
                  a.load();
                });
              }
            };
            this.once(_c.UNLOCKED, function() {
              for (this.forEachActiveSound(function(n) {
                n.currentMarker === null && n.duration === 0 && (n.duration = n.tags[0].duration), n.
                totalDuration = n.tags[0].duration;
              }); this.lockedActionsQueue.length; ) {
                var s = this.lockedActionsQueue.shift();
                s.sound[s.prop].apply ? s.sound[s.prop].apply(s.sound, s.value || []) : s.sound[s.prop] =
                s.value;
              }
            }, this), document.body.addEventListener("touchmove", i, false), document.body.addEventListener(
            "touchend", r, false);
          }
        }, onBlur: function() {
          this.forEachActiveSound(function(e) {
            e.isPlaying && (this.onBlurPausedSounds.push(e), e.onBlur());
          });
        }, onFocus: function() {
          this.onBlurPausedSounds.forEach(function(e) {
            e.onFocus();
          }), this.onBlurPausedSounds.length = 0;
        }, destroy: function() {
          Rc.prototype.destroy.call(this), this.onBlurPausedSounds.length = 0, this.onBlurPausedSounds =
          null;
        }, isLocked: function(e, t, i) {
          return e.tags[0].dataset.locked === "true" ? (this.lockedActionsQueue.push({ sound: e, prop: t,
          value: i }), true) : false;
        }, setMute: function(e) {
          return this.mute = e, this;
        }, mute: { get: function() {
          return this._mute;
        }, set: function(e) {
          this._mute = e, this.forEachActiveSound(function(t) {
            t.updateMute();
          }), this.emit(_c.GLOBAL_MUTE, this, e);
        } }, setVolume: function(e) {
          return this.volume = e, this;
        }, volume: { get: function() {
          return this._volume;
        }, set: function(e) {
          this._volume = e, this.forEachActiveSound(function(t) {
            t.updateVolume();
          }), this.emit(_c.GLOBAL_VOLUME, this, e);
        } } });
        dG.exports = Khe;
      });
      Mc = u((qFe, vG) => {
        var Zhe = na(), Qhe = C(), cG = Z(), Jhe = Xe(), $he = J(), Hs = function() {
          return false;
        }, vh = function() {
          return null;
        }, Vr = function() {
          return this;
        }, jhe = new Qhe({ Extends: cG, initialize: function(t, i, r) {
          r === void 0 && (r = {}), cG.call(this), this.manager = t, this.key = i, this.isPlaying = false,
          this.isPaused = false, this.totalRate = 1, this.duration = 0, this.totalDuration = 0, this.
          config = Jhe({ mute: false, volume: 1, rate: 1, detune: 0, seek: 0, loop: false, delay: 0,
          pan: 0 }, r), this.currentConfig = this.config, this.mute = false, this.volume = 1, this.rate =
          1, this.detune = 0, this.seek = 0, this.loop = false, this.pan = 0, this.markers = {}, this.
          currentMarker = null, this.pendingRemove = false;
        }, addMarker: Hs, updateMarker: Hs, removeMarker: vh, play: Hs, pause: Hs, resume: Hs, stop: Hs,
        setMute: Vr, setVolume: Vr, setRate: Vr, setDetune: Vr, setSeek: Vr, setLoop: Vr, setPan: Vr,
        applyConfig: vh, resetConfig: vh, update: $he, calculateRate: vh, destroy: function() {
          Zhe.prototype.destroy.call(this);
        } });
        vG.exports = jhe;
      });
      qc = u((FFe, mG) => {
        var lr = sa(), eue = C(), pG = Z(), tue = Mc(), Rt = J(), iue = new eue({ Extends: pG, initialize: function(t) {
          pG.call(this), this.game = t, this.sounds = [], this.mute = false, this.volume = 1, this.rate =
          1, this.detune = 0, this.pauseOnBlur = true, this.locked = false;
        }, add: function(e, t) {
          var i = new tue(this, e, t);
          return this.sounds.push(i), i;
        }, addAudioSprite: function(e, t) {
          var i = this.add(e, t);
          return i.spritemap = {}, i;
        }, get: function(e) {
          return lr.prototype.get.call(this, e);
        }, getAll: function(e) {
          return lr.prototype.getAll.call(this, e);
        }, play: function(e, t) {
          return false;
        }, playAudioSprite: function(e, t, i) {
          return false;
        }, remove: function(e) {
          return lr.prototype.remove.call(this, e);
        }, removeAll: function() {
          return lr.prototype.removeAll.call(this);
        }, removeByKey: function(e) {
          return lr.prototype.removeByKey.call(this, e);
        }, stopByKey: function(e) {
          return lr.prototype.stopByKey.call(this, e);
        }, onBlur: Rt, onFocus: Rt, onGameBlur: Rt, onGameFocus: Rt, pauseAll: Rt, resumeAll: Rt, stopAll: Rt,
        update: Rt, setRate: Rt, setDetune: Rt, setMute: Rt, setVolume: Rt, unlock: Rt, forEachActiveSound: function(e, t) {
          lr.prototype.forEachActiveSound.call(this, e, t);
        }, destroy: function() {
          lr.prototype.destroy.call(this);
        } });
        mG.exports = iue;
      });
      Fc = u((bFe, xG) => {
        var gG = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", oa = new Uint8Array(
        256);
        for (aa = 0; aa < gG.length; aa++) oa[gG.charCodeAt(aa)] = aa;
        var aa, rue = function(e) {
          e = e.substr(e.indexOf(",") + 1);
          var t = e.length, i = t * 0.75, r = 0, s, n, a, o;
          e[t - 1] === "=" && (i--, e[t - 2] === "=" && i--);
          for (var h = new ArrayBuffer(i), l = new Uint8Array(h), f = 0; f < t; f += 4) s = oa[e.charCodeAt(
          f)], n = oa[e.charCodeAt(f + 1)], a = oa[e.charCodeAt(f + 2)], o = oa[e.charCodeAt(f + 3)],
          l[r++] = s << 2 | n >> 4, l[r++] = (n & 15) << 4 | a >> 2, l[r++] = (a & 3) << 6 | o & 63;
          return h;
        };
        xG.exports = rue;
      });
      bc = u((LFe, EG) => {
        var si = na(), sue = C(), _t = hr(), ke = B(), nue = new sue({ Extends: si, initialize: function(t, i, r) {
          if (r === void 0 && (r = {}), this.audioBuffer = t.game.cache.audio.get(i), !this.audioBuffer)
           throw new Error('Audio key "' + i + '" not found in cache');
          this.source = null, this.loopSource = null, this.muteNode = t.context.createGain(), this.volumeNode =
          t.context.createGain(), this.pannerNode = null, this.spatialNode = null, this.spatialSource =
          null, this.playTime = 0, this.startTime = 0, this.loopTime = 0, this.rateUpdates = [], this.
          hasEnded = false, this.hasLooped = false, this.muteNode.connect(this.volumeNode), t.context.
          createPanner && (this.spatialNode = t.context.createPanner(), this.volumeNode.connect(this.
          spatialNode)), t.context.createStereoPanner ? (this.pannerNode = t.context.createStereoPanner(),
          t.context.createPanner ? this.spatialNode.connect(this.pannerNode) : this.volumeNode.connect(
          this.pannerNode), this.pannerNode.connect(t.destination)) : t.context.createPanner ? this.
          spatialNode.connect(t.destination) : this.volumeNode.connect(t.destination), this.duration =
          this.audioBuffer.duration, this.totalDuration = this.audioBuffer.duration, si.call(this, t,
          i, r);
        }, play: function(e, t) {
          return si.prototype.play.call(this, e, t) ? (this.stopAndRemoveBufferSource(), this.createAndStartBufferSource(),
          this.emit(_t.PLAY, this), true) : false;
        }, pause: function() {
          return this.manager.context.currentTime < this.startTime || !si.prototype.pause.call(this) ?
          false : (this.currentConfig.seek = this.getCurrentTime(), this.stopAndRemoveBufferSource(),
          this.emit(_t.PAUSE, this), true);
        }, resume: function() {
          return this.manager.context.currentTime < this.startTime || !si.prototype.resume.call(this) ?
          false : (this.createAndStartBufferSource(), this.emit(_t.RESUME, this), true);
        }, stop: function() {
          return si.prototype.stop.call(this) ? (this.stopAndRemoveBufferSource(), this.emit(_t.STOP,
          this), true) : false;
        }, createAndStartBufferSource: function() {
          var e = this.currentConfig.seek, t = this.currentConfig.delay, i = this.manager.context.currentTime +
          t, r = (this.currentMarker ? this.currentMarker.start : 0) + e, s = this.duration - e;
          this.playTime = i - e, this.startTime = i, this.source = this.createBufferSource(), this.applyConfig(),
          this.source.start(Math.max(0, i), Math.max(0, r), Math.max(0, s)), this.resetConfig();
        }, createAndStartLoopBufferSource: function() {
          var e = this.getLoopTime(), t = this.currentMarker ? this.currentMarker.start : 0, i = this.
          duration;
          this.loopTime = e, this.loopSource = this.createBufferSource(), this.loopSource.playbackRate.
          setValueAtTime(this.totalRate, 0), this.loopSource.start(Math.max(0, e), Math.max(0, t), Math.
          max(0, i));
        }, createBufferSource: function() {
          var e = this, t = this.manager.context.createBufferSource();
          return t.buffer = this.audioBuffer, t.connect(this.muteNode), t.onended = function(i) {
            var r = i.target;
            (r === e.source || r === e.loopSource) && (e.currentConfig.loop ? e.hasLooped = true : e.
            hasEnded = true);
          }, t;
        }, stopAndRemoveBufferSource: function() {
          if (this.source) {
            var e = this.source;
            this.source = null, e.stop(), e.disconnect();
          }
          this.playTime = 0, this.startTime = 0, this.hasEnded = false, this.stopAndRemoveLoopBufferSource();
        }, stopAndRemoveLoopBufferSource: function() {
          this.loopSource && (this.loopSource.stop(), this.loopSource.disconnect(), this.loopSource =
          null), this.loopTime = 0;
        }, applyConfig: function() {
          this.rateUpdates.length = 0, this.rateUpdates.push({ time: 0, rate: 1 });
          var e = this.currentConfig.source;
          if (e && this.manager.context.createPanner) {
            var t = this.spatialNode;
            t.panningModel = ke(e, "panningModel", "equalpower"), t.distanceModel = ke(e, "distanceM\
odel", "inverse"), t.orientationX.value = ke(e, "orientationX", 0), t.orientationY.value = ke(e, "or\
ientationY", 0), t.orientationZ.value = ke(e, "orientationZ", -1), t.refDistance = ke(e, "refDistanc\
e", 1), t.maxDistance = ke(e, "maxDistance", 1e4), t.rolloffFactor = ke(e, "rolloffFactor", 1), t.coneInnerAngle =
            ke(e, "coneInnerAngle", 360), t.coneOuterAngle = ke(e, "coneOuterAngle", 0), t.coneOuterGain =
            ke(e, "coneOuterGain", 0), this.spatialSource = ke(e, "follow", null), this.spatialSource ||
            (t.positionX.value = ke(e, "x", 0), t.positionY.value = ke(e, "y", 0), t.positionZ.value =
            ke(e, "z", 0));
          }
          si.prototype.applyConfig.call(this);
        }, x: { get: function() {
          return this.spatialNode ? this.spatialNode.positionX : 0;
        }, set: function(e) {
          this.spatialNode && (this.spatialNode.positionX.value = e);
        } }, y: { get: function() {
          return this.spatialNode ? this.spatialNode.positionY : 0;
        }, set: function(e) {
          this.spatialNode && (this.spatialNode.positionY.value = e);
        } }, update: function() {
          if (this.isPlaying && this.spatialSource) {
            var e = ke(this.spatialSource, "x", null), t = ke(this.spatialSource, "y", null);
            e && e !== this._spatialx && (this._spatialx = this.spatialNode.positionX.value = e), t &&
            t !== this._spatialy && (this._spatialy = this.spatialNode.positionY.value = t);
          }
          this.hasEnded ? (si.prototype.stop.call(this), this.stopAndRemoveBufferSource(), this.emit(
          _t.COMPLETE, this)) : this.hasLooped && (this.hasLooped = false, this.source = this.loopSource,
          this.loopSource = null, this.playTime = this.startTime = this.loopTime, this.rateUpdates.length =
          0, this.rateUpdates.push({ time: 0, rate: this.totalRate }), this.createAndStartLoopBufferSource(),
          this.emit(_t.LOOPED, this));
        }, destroy: function() {
          this.pendingRemove || (si.prototype.destroy.call(this), this.audioBuffer = null, this.stopAndRemoveBufferSource(),
          this.muteNode.disconnect(), this.muteNode = null, this.volumeNode.disconnect(), this.volumeNode =
          null, this.pannerNode && (this.pannerNode.disconnect(), this.pannerNode = null), this.spatialNode &&
          (this.spatialNode.disconnect(), this.spatialNode = null, this.spatialSource = null), this.
          rateUpdates.length = 0, this.rateUpdates = null);
        }, calculateRate: function() {
          si.prototype.calculateRate.call(this);
          var e = this.manager.context.currentTime;
          this.source && typeof this.totalRate == "number" && this.source.playbackRate.setValueAtTime(
          this.totalRate, e), this.isPlaying && (this.rateUpdates.push({ time: Math.max(this.startTime,
          e) - this.playTime, rate: this.totalRate }), this.loopSource && (this.stopAndRemoveLoopBufferSource(),
          this.createAndStartLoopBufferSource()));
        }, getCurrentTime: function() {
          for (var e = 0, t = 0; t < this.rateUpdates.length; t++) {
            var i = 0;
            t < this.rateUpdates.length - 1 ? i = this.rateUpdates[t + 1].time : i = this.manager.context.
            currentTime - this.playTime, e += (i - this.rateUpdates[t].time) * this.rateUpdates[t].rate;
          }
          return e;
        }, getLoopTime: function() {
          for (var e = 0, t = 0; t < this.rateUpdates.length - 1; t++) e += (this.rateUpdates[t + 1].
          time - this.rateUpdates[t].time) * this.rateUpdates[t].rate;
          var i = this.rateUpdates[this.rateUpdates.length - 1];
          return this.playTime + i.time + (this.duration - e) / i.rate;
        }, rate: { get: function() {
          return this.currentConfig.rate;
        }, set: function(e) {
          this.currentConfig.rate = e, this.calculateRate(), this.emit(_t.RATE, this, e);
        } }, setRate: function(e) {
          return this.rate = e, this;
        }, detune: { get: function() {
          return this.currentConfig.detune;
        }, set: function(e) {
          this.currentConfig.detune = e, this.calculateRate(), this.emit(_t.DETUNE, this, e);
        } }, setDetune: function(e) {
          return this.detune = e, this;
        }, mute: { get: function() {
          return this.muteNode.gain.value === 0;
        }, set: function(e) {
          this.currentConfig.mute = e, this.muteNode.gain.setValueAtTime(e ? 0 : 1, 0), this.emit(_t.
          MUTE, this, e);
        } }, setMute: function(e) {
          return this.mute = e, this;
        }, volume: { get: function() {
          return this.volumeNode.gain.value;
        }, set: function(e) {
          this.currentConfig.volume = e, this.volumeNode.gain.setValueAtTime(e, 0), this.emit(_t.VOLUME,
          this, e);
        } }, setVolume: function(e) {
          return this.volume = e, this;
        }, seek: { get: function() {
          return this.isPlaying ? this.manager.context.currentTime < this.startTime ? this.startTime -
          this.playTime : this.getCurrentTime() : this.isPaused ? this.currentConfig.seek : 0;
        }, set: function(e) {
          this.manager.context.currentTime < this.startTime || (this.isPlaying || this.isPaused) && (e =
          Math.min(Math.max(0, e), this.duration), this.currentConfig.seek = e, this.isPlaying && (this.
          stopAndRemoveBufferSource(), this.createAndStartBufferSource()), this.emit(_t.SEEK, this, e));
        } }, setSeek: function(e) {
          return this.seek = e, this;
        }, loop: { get: function() {
          return this.currentConfig.loop;
        }, set: function(e) {
          this.currentConfig.loop = e, this.isPlaying && (this.stopAndRemoveLoopBufferSource(), e &&
          this.createAndStartLoopBufferSource()), this.emit(_t.LOOP, this, e);
        } }, setLoop: function(e) {
          return this.loop = e, this;
        }, pan: { get: function() {
          return this.pannerNode ? this.pannerNode.pan.value : 0;
        }, set: function(e) {
          this.currentConfig.pan = e, this.pannerNode && this.pannerNode.pan.setValueAtTime(e, this.
          manager.context.currentTime), this.emit(_t.PAN, this, e);
        } }, setPan: function(e) {
          return this.pan = e, this;
        } });
        EG.exports = nue;
      });
      Oc = u((OFe, yG) => {
        var aue = Fc(), ph = sa(), oue = C(), ha = hr(), Lc = Ye(), hue = bc(), TG = B(), uue = new oue(
        { Extends: ph, initialize: function(t) {
          this.context = this.createAudioContext(t), this.masterMuteNode = this.context.createGain(),
          this.masterVolumeNode = this.context.createGain(), this.masterMuteNode.connect(this.masterVolumeNode),
          this.masterVolumeNode.connect(this.context.destination), this.destination = this.masterMuteNode,
          this.locked = this.context.state === "suspended", ph.call(this, t), this.locked && (t.isBooted ?
          this.unlock() : t.events.once(Lc.BOOT, this.unlock, this)), t.events.on(Lc.VISIBLE, this.onGameVisible,
          this);
        }, onGameVisible: function() {
          var e = this.context;
          window.setTimeout(function() {
            e && (e.suspend(), e.resume());
          }, 100);
        }, createAudioContext: function(e) {
          var t = e.config.audio;
          if (t.context) return t.context.resume(), t.context;
          if (window.hasOwnProperty("AudioContext")) return new AudioContext();
          if (window.hasOwnProperty("webkitAudioContext")) return new window.webkitAudioContext();
        }, setAudioContext: function(e) {
          return this.context && this.context.close(), this.masterMuteNode && this.masterMuteNode.disconnect(),
          this.masterVolumeNode && this.masterVolumeNode.disconnect(), this.context = e, this.masterMuteNode =
          e.createGain(), this.masterVolumeNode = e.createGain(), this.masterMuteNode.connect(this.masterVolumeNode),
          this.masterVolumeNode.connect(e.destination), this.destination = this.masterMuteNode, this;
        }, add: function(e, t) {
          var i = new hue(this, e, t);
          return this.sounds.push(i), i;
        }, decodeAudio: function(e, t) {
          var i;
          Array.isArray(e) ? i = e : i = [{ key: e, data: t }];
          for (var r = this.game.cache.audio, s = i.length, n = 0; n < i.length; n++) {
            var a = i[n], o = a.key, h = a.data;
            typeof h == "string" && (h = aue(h));
            var l = function(d, c) {
              r.add(d, c), this.emit(ha.DECODED, d), s--, s === 0 && this.emit(ha.DECODED_ALL);
            }.bind(this, o), f = function(d, c) {
              console.error("Error decoding audio: " + d + " - ", c ? c.message : ""), s--, s === 0 &&
              this.emit(ha.DECODED_ALL);
            }.bind(this, o);
            this.context.decodeAudioData(h, l, f);
          }
        }, setListenerPosition: function(e, t) {
          return e === void 0 && (e = this.game.scale.width / 2), t === void 0 && (t = this.game.scale.
          height / 2), this.listenerPosition.set(e, t), this;
        }, unlock: function() {
          var e = this, t = document.body, i = function r() {
            if (e.context && t) {
              var s = t.removeEventListener.bind(t);
              e.context.resume().then(function() {
                s("touchstart", r), s("touchend", r), s("mousedown", r), s("mouseup", r), s("keydown",
                r), e.unlocked = true;
              }, function() {
                s("touchstart", r), s("touchend", r), s("mousedown", r), s("mouseup", r), s("keydown",
                r);
              });
            }
          };
          t && (t.addEventListener("touchstart", i, false), t.addEventListener("touchend", i, false),
          t.addEventListener("mousedown", i, false), t.addEventListener("mouseup", i, false), t.addEventListener(
          "keydown", i, false));
        }, onBlur: function() {
          this.locked || this.context.suspend();
        }, onFocus: function() {
          var e = this.context;
          e && !this.locked && (e.state === "suspended" || e.state === "interrupted") && e.resume();
        }, update: function(e, t) {
          var i = this.context.listener;
          if (i && i.positionX !== void 0) {
            var r = TG(this.listenerPosition, "x", null), s = TG(this.listenerPosition, "y", null);
            r && r !== this._spatialx && (this._spatialx = i.positionX.value = r), s && s !== this._spatialy &&
            (this._spatialy = i.positionY.value = s);
          }
          ph.prototype.update.call(this, e, t), this.gameLostFocus || this.onFocus();
        }, destroy: function() {
          if (this.destination = null, this.masterVolumeNode.disconnect(), this.masterVolumeNode = null,
          this.masterMuteNode.disconnect(), this.masterMuteNode = null, this.game.config.audio.context)
           this.context.suspend();
          else {
            var e = this;
            this.context.close().then(function() {
              e.context = null;
            });
          }
          this.game.events.off(Lc.VISIBLE, this.onGameVisible, this), ph.prototype.destroy.call(this);
        }, setMute: function(e) {
          return this.mute = e, this;
        }, mute: { get: function() {
          return this.masterMuteNode.gain.value === 0;
        }, set: function(e) {
          this.masterMuteNode.gain.setValueAtTime(e ? 0 : 1, 0), this.emit(ha.GLOBAL_MUTE, this, e);
        } }, setVolume: function(e) {
          return this.volume = e, this;
        }, volume: { get: function() {
          return this.masterVolumeNode.gain.value;
        }, set: function(e) {
          this.masterVolumeNode.gain.setValueAtTime(e, 0), this.emit(ha.GLOBAL_VOLUME, this, e);
        } } });
        yG.exports = uue;
      });
      Dc = u((DFe, SG) => {
        var lue = Pc(), fue = qc(), due = Oc(), cue = { create: function(e) {
          var t = e.config.audio, i = e.device.audio;
          return t.noAudio || !i.webAudio && !i.audioData ? new fue(e) : i.webAudio && !t.disableWebAudio ?
          new due(e) : new lue(e);
        } };
        SG.exports = cue;
      });
      RG = u((NFe, AG) => {
        var vue = jo(), pue = xu(), mue = Dl(), gue = Tt(), xue = C(), Eue = gf(), Tue = iO(), yue = qd(),
        Sue = Rn(), wue = Fd(), Cue = En(), Aue = sO(), wG = Z(), ve = Ye(), Rue = tc(), _ue = rt(),
        Pue = dN(), Mue = oc(), que = vc(), Fue = Fs(), bue = wc(), Lue = bd(), Oue = Ld();
        CG = Dc();
        var CG, Due = new xue({ initialize: function(t) {
          this.config = new Eue(t), this.renderer = null, this.domContainer = null, this.canvas = null,
          this.context = null, this.isBooted = false, this.isRunning = false, this.events = new wG(),
          this.anims = new pue(this), this.textures = new bue(this), this.cache = new mue(this), this.
          registry = new Sue(this, new wG()), this.input = new Rue(this, this.config), this.scene = new que(
          this, this.config.sceneConfig), this.device = Cue, this.scale = new Mue(this, this.config),
          this.sound = null, this.sound = CG.create(this), this.loop = new Lue(this, this.config.fps),
          this.plugins = new Pue(this, this.config), this.pendingDestroy = false, this.removeCanvas =
          false, this.noReturn = false, this.hasFocus = false, this.isPaused = false, Aue(this.boot.
          bind(this));
        }, boot: function() {
          if (!_ue.hasCore("EventEmitter")) {
            console.warn("Aborting. Core Plugins missing.");
            return;
          }
          this.isBooted = true, this.config.preBoot(this), this.scale.preBoot(), yue(this), Tue(this),
          wue(this), vue(this.canvas, this.config.parent), this.textures.once(Fue.READY, this.texturesReady,
          this), this.events.emit(ve.BOOT), window && (window.PHASER_GAME = this);
        }, texturesReady: function() {
          this.events.emit(ve.READY), this.start();
        }, start: function() {
          this.isRunning = true, this.config.postBoot(this), this.renderer ? this.loop.start(this.step.
          bind(this)) : this.loop.start(this.headlessStep.bind(this)), Oue(this);
          var e = this.events;
          e.on(ve.HIDDEN, this.onHidden, this), e.on(ve.VISIBLE, this.onVisible, this), e.on(ve.BLUR,
          this.onBlur, this), e.on(ve.FOCUS, this.onFocus, this);
        }, step: function(e, t) {
          if (this.pendingDestroy) return this.runDestroy();
          if (!this.isPaused) {
            var i = this.events;
            i.emit(ve.PRE_STEP, e, t), i.emit(ve.STEP, e, t), this.scene.update(e, t), i.emit(ve.POST_STEP,
            e, t);
            var r = this.renderer;
            r.preRender(), i.emit(ve.PRE_RENDER, r, e, t), this.scene.render(r), r.postRender(), i.emit(
            ve.POST_RENDER, r, e, t);
          }
        }, headlessStep: function(e, t) {
          if (this.pendingDestroy) return this.runDestroy();
          if (!this.isPaused) {
            var i = this.events;
            i.emit(ve.PRE_STEP, e, t), i.emit(ve.STEP, e, t), this.scene.update(e, t), i.emit(ve.POST_STEP,
            e, t), this.scene.isProcessing = false, i.emit(ve.PRE_RENDER, null, e, t), i.emit(ve.POST_RENDER,
            null, e, t);
          }
        }, onHidden: function() {
          this.loop.pause(), this.events.emit(ve.PAUSE);
        }, pause: function() {
          var e = this.isPaused;
          this.isPaused = true, e || this.events.emit(ve.PAUSE);
        }, onVisible: function() {
          this.loop.resume(), this.events.emit(ve.RESUME, this.loop.pauseDuration);
        }, resume: function() {
          var e = this.isPaused;
          this.isPaused = false, e && this.events.emit(ve.RESUME, 0);
        }, onBlur: function() {
          this.hasFocus = false, this.loop.blur();
        }, onFocus: function() {
          this.hasFocus = true, this.loop.focus();
        }, getFrame: function() {
          return this.loop.frame;
        }, getTime: function() {
          return this.loop.now;
        }, destroy: function(e, t) {
          t === void 0 && (t = false), this.pendingDestroy = true, this.removeCanvas = e, this.noReturn =
          t;
        }, runDestroy: function() {
          this.scene.destroy(), this.events.emit(ve.DESTROY), this.events.removeAllListeners(), this.
          renderer && this.renderer.destroy(), this.removeCanvas && this.canvas && (gue.remove(this.
          canvas), this.canvas.parentNode && this.canvas.parentNode.removeChild(this.canvas)), this.
          domContainer && this.domContainer.parentNode && this.domContainer.parentNode.removeChild(this.
          domContainer), this.loop.destroy(), this.pendingDestroy = false;
        } });
        AG.exports = Due;
      });
      PG = u((IFe, _G) => {
        var Nue = function(e) {
          return e.radius > 0 ? Math.PI * e.radius * e.radius : 0;
        };
        _G.exports = Nue;
      });
      qG = u((BFe, MG) => {
        var Iue = vn(), Bue = function(e) {
          return new Iue(e.x, e.y, e.radius);
        };
        MG.exports = Bue;
      });
      bG = u((GFe, FG) => {
        var Gue = Tr(), Uue = function(e, t) {
          return Gue(e, t.x, t.y);
        };
        FG.exports = Uue;
      });
      OG = u((UFe, LG) => {
        var mh = Tr(), zue = function(e, t) {
          return mh(e, t.x, t.y) && mh(e, t.right, t.y) && mh(e, t.x, t.bottom) && mh(e, t.right, t.
          bottom);
        };
        LG.exports = zue;
      });
      NG = u((zFe, DG) => {
        var kue = function(e, t) {
          return t.setTo(e.x, e.y, e.radius);
        };
        DG.exports = kue;
      });
      BG = u((kFe, IG) => {
        var Xue = function(e, t) {
          return e.x === t.x && e.y === t.y && e.radius === t.radius;
        };
        IG.exports = Xue;
      });
      UG = u((XFe, GG) => {
        var Vue = he(), Yue = function(e, t) {
          return t === void 0 && (t = new Vue()), t.x = e.left, t.y = e.top, t.width = e.diameter, t.
          height = e.diameter, t;
        };
        GG.exports = Yue;
      });
      kG = u((VFe, zG) => {
        var Wue = function(e, t, i) {
          return e.x += t, e.y += i, e;
        };
        zG.exports = Wue;
      });
      VG = u((YFe, XG) => {
        var Hue = function(e, t) {
          return e.x += t.x, e.y += t.y, e;
        };
        XG.exports = Hue;
      });
      WG = u((WFe, YG) => {
        var Je = vn();
        Je.Area = PG();
        Je.Circumference = Xu();
        Je.CircumferencePoint = Da();
        Je.Clone = qG();
        Je.Contains = Tr();
        Je.ContainsPoint = bG();
        Je.ContainsRect = OG();
        Je.CopyFrom = NG();
        Je.Equals = BG();
        Je.GetBounds = UG();
        Je.GetPoint = ku();
        Je.GetPoints = Vu();
        Je.Offset = kG();
        Je.OffsetPoint = VG();
        Je.Random = Na();
        YG.exports = Je;
      });
      Yr = u((HFe, HG) => {
        var Kue = function(e) {
          return Math.atan2(e.y2 - e.y1, e.x2 - e.x1);
        };
        HG.exports = Kue;
      });
      ZG = u((KFe, KG) => {
        var Zue = function(e, t, i) {
          var r = t - (e.x1 + e.x2) / 2, s = i - (e.y1 + e.y2) / 2;
          return e.x1 += r, e.y1 += s, e.x2 += r, e.y2 += s, e;
        };
        KG.exports = Zue;
      });
      JG = u((ZFe, QG) => {
        var Que = wn(), Jue = function(e) {
          return new Que(e.x1, e.y1, e.x2, e.y2);
        };
        QG.exports = Jue;
      });
      jG = u((QFe, $G) => {
        var $ue = function(e, t) {
          return t.setTo(e.x1, e.y1, e.x2, e.y2);
        };
        $G.exports = $ue;
      });
      tU = u((JFe, eU) => {
        var jue = function(e, t) {
          return e.x1 === t.x1 && e.y1 === t.y1 && e.x2 === t.x2 && e.y2 === t.y2;
        };
        eU.exports = jue;
      });
      rU = u(($Fe, iU) => {
        var ele = cs(), tle = function(e, t, i) {
          i === void 0 && (i = t);
          var r = ele(e), s = e.x2 - e.x1, n = e.y2 - e.y1;
          return t && (e.x1 = e.x1 - s / r * t, e.y1 = e.y1 - n / r * t), i && (e.x2 = e.x2 + s / r *
          i, e.y2 = e.y2 + n / r * i), e;
        };
        iU.exports = tle;
      });
      nU = u((jFe, sU) => {
        var ile = ae(), rle = function(e, t) {
          return t === void 0 && (t = new ile()), t.x = (e.x1 + e.x2) / 2, t.y = (e.y1 + e.y2) / 2, t;
        };
        sU.exports = rle;
      });
      oU = u((ebe, aU) => {
        var sle = ae(), nle = function(e, t, i) {
          i === void 0 && (i = new sle());
          var r = e.x1, s = e.y1, n = e.x2, a = e.y2, o = (n - r) * (n - r) + (a - s) * (a - s);
          if (o === 0) return i;
          var h = ((t.x - r) * (n - r) + (t.y - s) * (a - s)) / o;
          return i.x = r + h * (n - r), i.y = s + h * (a - s), i;
        };
        aU.exports = nle;
      });
      uU = u((tbe, hU) => {
        var ale = le(), ole = Yr(), hle = ae(), ule = function(e, t) {
          t === void 0 && (t = new hle());
          var i = ole(e) - ale.TAU;
          return t.x = Math.cos(i), t.y = Math.sin(i), t;
        };
        hU.exports = ule;
      });
      fU = u((ibe, lU) => {
        var lle = function(e, t) {
          var i = e.x1, r = e.y1, s = e.x2, n = e.y2, a = (s - i) * (s - i) + (n - r) * (n - r);
          if (a === 0) return false;
          var o = ((r - t.y) * (s - i) - (i - t.x) * (n - r)) / a;
          return Math.abs(o) * Math.sqrt(a);
        };
        lU.exports = lle;
      });
      cU = u((rbe, dU) => {
        var fle = function(e) {
          return Math.abs(e.y1 - e.y2);
        };
        dU.exports = fle;
      });
      Nc = u((sbe, vU) => {
        var dle = le(), cle = Ki(), vle = Yr(), ple = function(e) {
          var t = vle(e) - dle.TAU;
          return cle(t, -Math.PI, Math.PI);
        };
        vU.exports = ple;
      });
      mU = u((nbe, pU) => {
        var mle = le(), gle = Yr(), xle = function(e) {
          return Math.cos(gle(e) - mle.TAU);
        };
        pU.exports = xle;
      });
      xU = u((abe, gU) => {
        var Ele = le(), Tle = Yr(), yle = function(e) {
          return Math.sin(Tle(e) - Ele.TAU);
        };
        gU.exports = yle;
      });
      TU = u((obe, EU) => {
        var Sle = function(e, t, i) {
          return e.x1 += t, e.y1 += i, e.x2 += t, e.y2 += i, e;
        };
        EU.exports = Sle;
      });
      SU = u((hbe, yU) => {
        var wle = function(e) {
          return -((e.x2 - e.x1) / (e.y2 - e.y1));
        };
        yU.exports = wle;
      });
      CU = u((ube, wU) => {
        var Cle = Yr(), Ale = Nc(), Rle = function(e, t) {
          return 2 * Ale(t) - Math.PI - Cle(e);
        };
        wU.exports = Rle;
      });
      gh = u((lbe, AU) => {
        var _le = function(e, t, i, r) {
          var s = Math.cos(r), n = Math.sin(r), a = e.x1 - t, o = e.y1 - i;
          return e.x1 = a * s - o * n + t, e.y1 = a * n + o * s + i, a = e.x2 - t, o = e.y2 - i, e.x2 =
          a * s - o * n + t, e.y2 = a * n + o * s + i, e;
        };
        AU.exports = _le;
      });
      _U = u((fbe, RU) => {
        var Ple = gh(), Mle = function(e, t) {
          var i = (e.x1 + e.x2) / 2, r = (e.y1 + e.y2) / 2;
          return Ple(e, i, r, t);
        };
        RU.exports = Mle;
      });
      MU = u((dbe, PU) => {
        var qle = gh(), Fle = function(e, t, i) {
          return qle(e, t.x, t.y, i);
        };
        PU.exports = Fle;
      });
      FU = u((cbe, qU) => {
        var ble = function(e, t, i, r, s) {
          return e.x1 = t, e.y1 = i, e.x2 = t + Math.cos(r) * s, e.y2 = i + Math.sin(r) * s, e;
        };
        qU.exports = ble;
      });
      LU = u((vbe, bU) => {
        var Lle = function(e) {
          return (e.y2 - e.y1) / (e.x2 - e.x1);
        };
        bU.exports = Lle;
      });
      DU = u((pbe, OU) => {
        var Ole = function(e) {
          return Math.abs(e.x1 - e.x2);
        };
        OU.exports = Ole;
      });
      IU = u((mbe, NU) => {
        var K = wn();
        K.Angle = Yr();
        K.BresenhamPoints = Pl();
        K.CenterOn = ZG();
        K.Clone = JG();
        K.CopyFrom = jG();
        K.Equals = tU();
        K.Extend = rU();
        K.GetEasedPoints = Rl();
        K.GetMidPoint = nU();
        K.GetNearestPoint = oU();
        K.GetNormal = uU();
        K.GetPoint = sl();
        K.GetPoints = Za();
        K.GetShortestDistance = fU();
        K.Height = cU();
        K.Length = cs();
        K.NormalAngle = Nc();
        K.NormalX = mU();
        K.NormalY = xU();
        K.Offset = TU();
        K.PerpSlope = SU();
        K.Random = Qa();
        K.ReflectAngle = CU();
        K.Rotate = _U();
        K.RotateAroundPoint = MU();
        K.RotateAroundXY = gh();
        K.SetToAngle = FU();
        K.Slope = LU();
        K.Width = DU();
        NU.exports = K;
      });
      GU = u((gbe, BU) => {
        var Dle = function(e) {
          return e.width * e.height;
        };
        BU.exports = Dle;
      });
      zU = u((xbe, UU) => {
        var Nle = function(e) {
          return e.x = Math.ceil(e.x), e.y = Math.ceil(e.y), e;
        };
        UU.exports = Nle;
      });
      XU = u((Ebe, kU) => {
        var Ile = function(e) {
          return e.x = Math.ceil(e.x), e.y = Math.ceil(e.y), e.width = Math.ceil(e.width), e.height =
          Math.ceil(e.height), e;
        };
        kU.exports = Ile;
      });
      YU = u((Tbe, VU) => {
        var Ble = he(), Gle = function(e) {
          return new Ble(e.x, e.y, e.width, e.height);
        };
        VU.exports = Gle;
      });
      HU = u((ybe, WU) => {
        var Ule = Ar(), zle = function(e, t) {
          return Ule(e, t.x, t.y);
        };
        WU.exports = zle;
      });
      Ic = u((Sbe, KU) => {
        var kle = function(e, t) {
          return t.width * t.height > e.width * e.height ? false : t.x > e.x && t.x < e.right && t.right >
          e.x && t.right < e.right && t.y > e.y && t.y < e.bottom && t.bottom > e.y && t.bottom < e.
          bottom;
        };
        KU.exports = kle;
      });
      Bc = u((wbe, ZU) => {
        var Xle = function(e, t) {
          return t.setTo(e.x, e.y, e.width, e.height);
        };
        ZU.exports = Xle;
      });
      JU = u((Cbe, QU) => {
        var Vle = function(e, t) {
          return t === void 0 && (t = []), t.push({ x: e.x, y: e.y }), t.push({ x: e.right, y: e.y }),
          t.push({ x: e.right, y: e.bottom }), t.push({ x: e.x, y: e.bottom }), t;
        };
        QU.exports = Vle;
      });
      jU = u((Abe, $U) => {
        var Yle = function(e, t) {
          return e.x === t.x && e.y === t.y && e.width === t.width && e.height === t.height;
        };
        $U.exports = Yle;
      });
      xh = u((Rbe, ez) => {
        var Wle = function(e) {
          return e.height === 0 ? NaN : e.width / e.height;
        };
        ez.exports = Wle;
      });
      rz = u((_be, iz) => {
        var tz = xh(), Hle = function(e, t) {
          var i = tz(e);
          return i < tz(t) ? e.setSize(t.height * i, t.height) : e.setSize(t.width, t.width / i), e.
          setPosition(t.centerX - e.width / 2, t.centerY - e.height / 2);
        };
        iz.exports = Hle;
      });
      az = u((Pbe, nz) => {
        var sz = xh(), Kle = function(e, t) {
          var i = sz(e);
          return i > sz(t) ? e.setSize(t.height * i, t.height) : e.setSize(t.width, t.width / i), e.
          setPosition(t.centerX - e.width / 2, t.centerY - e.height / 2);
        };
        nz.exports = Kle;
      });
      hz = u((Mbe, oz) => {
        var Zle = function(e) {
          return e.x = Math.floor(e.x), e.y = Math.floor(e.y), e;
        };
        oz.exports = Zle;
      });
      lz = u((qbe, uz) => {
        var Qle = function(e) {
          return e.x = Math.floor(e.x), e.y = Math.floor(e.y), e.width = Math.floor(e.width), e.height =
          Math.floor(e.height), e;
        };
        uz.exports = Qle;
      });
      dz = u((Fbe, fz) => {
        var Jle = he(), $le = function(e, t, i, r, s) {
          return s === void 0 && (s = new Jle()), s.setTo(Math.min(e, i), Math.min(t, r), Math.abs(e -
          i), Math.abs(t - r));
        };
        fz.exports = $le;
      });
      vz = u((bbe, cz) => {
        var jle = ae(), efe = function(e, t) {
          return t === void 0 && (t = new jle()), t.x = e.centerX, t.y = e.centerY, t;
        };
        cz.exports = efe;
      });
      mz = u((Lbe, pz) => {
        var tfe = ae(), ife = function(e, t) {
          return t === void 0 && (t = new tfe()), t.x = e.width, t.y = e.height, t;
        };
        pz.exports = ife;
      });
      Gc = u((Obe, gz) => {
        var rfe = In(), sfe = function(e, t, i) {
          var r = e.centerX, s = e.centerY;
          return e.setSize(e.width + t * 2, e.height + i * 2), rfe(e, r, s);
        };
        gz.exports = sfe;
      });
      Eh = u((Dbe, xz) => {
        var nfe = function(e, t) {
          return e.width <= 0 || e.height <= 0 || t.width <= 0 || t.height <= 0 ? false : !(e.right <
          t.x || e.bottom < t.y || e.x > t.right || e.y > t.bottom);
        };
        xz.exports = nfe;
      });
      Tz = u((Nbe, Ez) => {
        var afe = he(), ofe = Eh(), hfe = function(e, t, i) {
          return i === void 0 && (i = new afe()), ofe(e, t) ? (i.x = Math.max(e.x, t.x), i.y = Math.
          max(e.y, t.y), i.width = Math.min(e.right, t.right) - i.x, i.height = Math.min(e.bottom, t.
          bottom) - i.y) : i.setEmpty(), i;
        };
        Ez.exports = hfe;
      });
      Sz = u((Ibe, yz) => {
        var ufe = function(e, t) {
          for (var i = e.x, r = e.right, s = e.y, n = e.bottom, a = 0; a < t.length; a++) i = Math.min(
          i, t[a].x), r = Math.max(r, t[a].x), s = Math.min(s, t[a].y), n = Math.max(n, t[a].y);
          return e.x = i, e.y = s, e.width = r - i, e.height = n - s, e;
        };
        yz.exports = ufe;
      });
      Uc = u((Bbe, wz) => {
        var lfe = function(e, t) {
          var i = Math.min(e.x, t.x), r = Math.max(e.right, t.right);
          e.x = i, e.width = r - i;
          var s = Math.min(e.y, t.y), n = Math.max(e.bottom, t.bottom);
          return e.y = s, e.height = n - s, e;
        };
        wz.exports = lfe;
      });
      Az = u((Gbe, Cz) => {
        var ffe = function(e, t, i) {
          var r = Math.min(e.x, t), s = Math.max(e.right, t);
          e.x = r, e.width = s - r;
          var n = Math.min(e.y, i), a = Math.max(e.bottom, i);
          return e.y = n, e.height = a - n, e;
        };
        Cz.exports = ffe;
      });
      _z = u((Ube, Rz) => {
        var dfe = function(e, t, i) {
          return e.x += t, e.y += i, e;
        };
        Rz.exports = dfe;
      });
      Mz = u((zbe, Pz) => {
        var cfe = function(e, t) {
          return e.x += t.x, e.y += t.y, e;
        };
        Pz.exports = cfe;
      });
      Fz = u((kbe, qz) => {
        var vfe = function(e, t) {
          return e.x < t.right && e.right > t.x && e.y < t.bottom && e.bottom > t.y;
        };
        qz.exports = vfe;
      });
      Lz = u((Xbe, bz) => {
        var pfe = ae(), mfe = Rr(), gfe = function(e, t, i) {
          i === void 0 && (i = new pfe()), t = mfe(t);
          var r = Math.sin(t), s = Math.cos(t), n = s > 0 ? e.width / 2 : e.width / -2, a = r > 0 ? e.
          height / 2 : e.height / -2;
          return Math.abs(n * r) < Math.abs(a * s) ? a = n * r / s : n = a * s / r, i.x = n + e.centerX,
          i.y = a + e.centerY, i;
        };
        bz.exports = gfe;
      });
      Dz = u((Vbe, Oz) => {
        var xfe = ss(), Efe = Ic(), Tfe = ae(), yfe = function(e, t, i) {
          if (i === void 0 && (i = new Tfe()), Efe(e, t)) switch (xfe(0, 3)) {
            case 0:
              i.x = e.x + Math.random() * (t.right - e.x), i.y = e.y + Math.random() * (t.top - e.y);
              break;
            case 1:
              i.x = t.x + Math.random() * (e.right - t.x), i.y = t.bottom + Math.random() * (e.bottom -
              t.bottom);
              break;
            case 2:
              i.x = e.x + Math.random() * (t.x - e.x), i.y = t.y + Math.random() * (e.bottom - t.y);
              break;
            case 3:
              i.x = t.right + Math.random() * (e.right - t.right), i.y = e.y + Math.random() * (t.bottom -
              e.y);
              break;
          }
          return i;
        };
        Oz.exports = yfe;
      });
      Iz = u((Ybe, Nz) => {
        var Sfe = function(e, t) {
          return e.width === t.width && e.height === t.height;
        };
        Nz.exports = Sfe;
      });
      Gz = u((Wbe, Bz) => {
        var wfe = function(e, t, i) {
          return i === void 0 && (i = t), e.width *= t, e.height *= i, e;
        };
        Bz.exports = wfe;
      });
      zc = u((Hbe, Uz) => {
        var Cfe = he(), Afe = function(e, t, i) {
          i === void 0 && (i = new Cfe());
          var r = Math.min(e.x, t.x), s = Math.min(e.y, t.y), n = Math.max(e.right, t.right) - r, a = Math.
          max(e.bottom, t.bottom) - s;
          return i.setTo(r, s, n, a);
        };
        Uz.exports = Afe;
      });
      kz = u((Kbe, zz) => {
        var U = he();
        U.Area = GU();
        U.Ceil = zU();
        U.CeilAll = XU();
        U.CenterOn = In();
        U.Clone = YU();
        U.Contains = Ar();
        U.ContainsPoint = HU();
        U.ContainsRect = Ic();
        U.CopyFrom = Bc();
        U.Decompose = JU();
        U.Equals = jU();
        U.FitInside = rz();
        U.FitOutside = az();
        U.Floor = hz();
        U.FloorAll = lz();
        U.FromPoints = Jo();
        U.FromXY = dz();
        U.GetAspectRatio = xh();
        U.GetCenter = vz();
        U.GetPoint = Ka();
        U.GetPoints = rl();
        U.GetSize = mz();
        U.Inflate = Gc();
        U.Intersection = Tz();
        U.MarchingAnts = _l();
        U.MergePoints = Sz();
        U.MergeRect = Uc();
        U.MergeXY = Az();
        U.Offset = _z();
        U.OffsetPoint = Mz();
        U.Overlaps = Fz();
        U.Perimeter = Sn();
        U.PerimeterPoint = Lz();
        U.Random = $a();
        U.RandomOutside = Dz();
        U.SameDimensions = Iz();
        U.Scale = Gz();
        U.Union = zc();
        zz.exports = U;
      });
      Th = u((Zbe, Vz) => {
        var te = yn(), Rfe = C(), Xz = J(), _fe = Tn(), Pfe = new Rfe({ initialize: function(t) {
          this.parent = t, this.list = [], this.position = 0, this.addCallback = Xz, this.removeCallback =
          Xz, this._sortKey = "";
        }, add: function(e, t) {
          return t ? te.Add(this.list, e) : te.Add(this.list, e, 0, this.addCallback, this);
        }, addAt: function(e, t, i) {
          return i ? te.AddAt(this.list, e, t) : te.AddAt(this.list, e, t, 0, this.addCallback, this);
        }, getAt: function(e) {
          return this.list[e];
        }, getIndex: function(e) {
          return this.list.indexOf(e);
        }, sort: function(e, t) {
          return e ? (t === void 0 && (t = function(i, r) {
            return i[e] - r[e];
          }), _fe(this.list, t), this) : this;
        }, getByName: function(e) {
          return te.GetFirst(this.list, "name", e);
        }, getRandom: function(e, t) {
          return te.GetRandom(this.list, e, t);
        }, getFirst: function(e, t, i, r) {
          return te.GetFirst(this.list, e, t, i, r);
        }, getAll: function(e, t, i, r) {
          return te.GetAll(this.list, e, t, i, r);
        }, count: function(e, t) {
          return te.CountAllMatching(this.list, e, t);
        }, swap: function(e, t) {
          te.Swap(this.list, e, t);
        }, moveTo: function(e, t) {
          return te.MoveTo(this.list, e, t);
        }, moveAbove: function(e, t) {
          return te.MoveAbove(this.list, e, t);
        }, moveBelow: function(e, t) {
          return te.MoveBelow(this.list, e, t);
        }, remove: function(e, t) {
          return t ? te.Remove(this.list, e) : te.Remove(this.list, e, this.removeCallback, this);
        }, removeAt: function(e, t) {
          return t ? te.RemoveAt(this.list, e) : te.RemoveAt(this.list, e, this.removeCallback, this);
        }, removeBetween: function(e, t, i) {
          return i ? te.RemoveBetween(this.list, e, t) : te.RemoveBetween(this.list, e, t, this.removeCallback,
          this);
        }, removeAll: function(e) {
          for (var t = this.list.length; t--; ) this.remove(this.list[t], e);
          return this;
        }, bringToTop: function(e) {
          return te.BringToTop(this.list, e);
        }, sendToBack: function(e) {
          return te.SendToBack(this.list, e);
        }, moveUp: function(e) {
          return te.MoveUp(this.list, e), e;
        }, moveDown: function(e) {
          return te.MoveDown(this.list, e), e;
        }, reverse: function() {
          return this.list.reverse(), this;
        }, shuffle: function() {
          return te.Shuffle(this.list), this;
        }, replace: function(e, t) {
          return te.Replace(this.list, e, t);
        }, exists: function(e) {
          return this.list.indexOf(e) > -1;
        }, setAll: function(e, t, i, r) {
          return te.SetAll(this.list, e, t, i, r), this;
        }, each: function(e, t) {
          for (var i = [null], r = 2; r < arguments.length; r++) i.push(arguments[r]);
          for (r = 0; r < this.list.length; r++) i[0] = this.list[r], e.apply(t, i);
        }, shutdown: function() {
          this.removeAll(), this.list = [];
        }, destroy: function() {
          this.removeAll(), this.parent = null, this.addCallback = null, this.removeCallback = null;
        }, length: { get: function() {
          return this.list.length;
        } }, first: { get: function() {
          return this.position = 0, this.list.length > 0 ? this.list[0] : null;
        } }, last: { get: function() {
          return this.list.length > 0 ? (this.position = this.list.length - 1, this.list[this.position]) :
          null;
        } }, next: { get: function() {
          return this.position < this.list.length ? (this.position++, this.list[this.position]) : null;
        } }, previous: { get: function() {
          return this.position > 0 ? (this.position--, this.list[this.position]) : null;
        } } });
        Vz.exports = Pfe;
      });
      Zz = u((Qbe, Kz) => {
        var Mfe = C(), Yz = Th(), qfe = rt(), Wz = xs(), fr = qe(), Ffe = Tn(), Hz = new Mfe({ Extends: Yz,
        initialize: function(t) {
          Yz.call(this, t), this.sortChildrenFlag = false, this.scene = t, this.systems = t.sys, this.
          events = t.sys.events, this.addCallback = this.addChildCallback, this.removeCallback = this.
          removeChildCallback, this.events.once(fr.BOOT, this.boot, this), this.events.on(fr.START, this.
          start, this);
        }, boot: function() {
          this.events.once(fr.DESTROY, this.destroy, this);
        }, addChildCallback: function(e) {
          e.displayList && e.displayList !== this && e.removeFromDisplayList(), e.parentContainer &&
          e.parentContainer.remove(e), e.displayList || (this.queueDepthSort(), e.displayList = this,
          e.emit(Wz.ADDED_TO_SCENE, e, this.scene), this.events.emit(fr.ADDED_TO_SCENE, e, this.scene));
        }, removeChildCallback: function(e) {
          this.queueDepthSort(), e.displayList = null, e.emit(Wz.REMOVED_FROM_SCENE, e, this.scene),
          this.events.emit(fr.REMOVED_FROM_SCENE, e, this.scene);
        }, start: function() {
          this.events.once(fr.SHUTDOWN, this.shutdown, this);
        }, queueDepthSort: function() {
          this.sortChildrenFlag = true;
        }, depthSort: function() {
          this.sortChildrenFlag && (Ffe(this.list, this.sortByDepth), this.sortChildrenFlag = false);
        }, sortByDepth: function(e, t) {
          return e._depth - t._depth;
        }, getChildren: function() {
          return this.list;
        }, shutdown: function() {
          for (var e = this.list, t = e.length; t--; ) e[t].destroy(true);
          e.length = 0, this.events.off(fr.SHUTDOWN, this.shutdown, this);
        }, destroy: function() {
          this.shutdown(), this.events.off(fr.START, this.start, this), this.scene = null, this.systems =
          null, this.events = null;
        } });
        qfe.register("DisplayList", Hz, "displayList");
        Kz.exports = Hz;
      });
      Jz = u((Jbe, Qz) => {
        Qz.exports = "add";
      });
      jz = u(($be, $z) => {
        $z.exports = "remove";
      });
      t3 = u((jbe, e3) => {
        e3.exports = { PROCESS_QUEUE_ADD: Jz(), PROCESS_QUEUE_REMOVE: jz() };
      });
      kc = u((eLe, s3) => {
        var bfe = C(), i3 = Z(), r3 = t3(), Lfe = new bfe({ Extends: i3, initialize: function() {
          i3.call(this), this._pending = [], this._active = [], this._destroy = [], this._toProcess =
          0, this.checkQueue = false;
        }, isActive: function(e) {
          return this._active.indexOf(e) > -1;
        }, isPending: function(e) {
          return this._toProcess > 0 && this._pending.indexOf(e) > -1;
        }, isDestroying: function(e) {
          return this._destroy.indexOf(e) > -1;
        }, add: function(e) {
          return this.checkQueue && this.isActive(e) && !this.isDestroying(e) || this.isPending(e) ||
          (this._pending.push(e), this._toProcess++), e;
        }, remove: function(e) {
          if (this.isPending(e)) {
            var t = this._pending, i = t.indexOf(e);
            i !== -1 && t.splice(i, 1);
          } else this.isActive(e) && (this._destroy.push(e), this._toProcess++);
          return e;
        }, removeAll: function() {
          for (var e = this._active, t = this._destroy, i = e.length; i--; ) t.push(e[i]), this._toProcess++;
          return this;
        }, update: function() {
          if (this._toProcess === 0) return this._active;
          var e = this._destroy, t = this._active, i, r;
          for (i = 0; i < e.length; i++) {
            r = e[i];
            var s = t.indexOf(r);
            s !== -1 && (t.splice(s, 1), this.emit(r3.PROCESS_QUEUE_REMOVE, r));
          }
          for (e.length = 0, e = this._pending, i = 0; i < e.length; i++) r = e[i], (!this.checkQueue ||
          this.checkQueue && t.indexOf(r) === -1) && (t.push(r), this.emit(r3.PROCESS_QUEUE_ADD, r));
          return e.length = 0, this._toProcess = 0, t;
        }, getActive: function() {
          return this._active;
        }, length: { get: function() {
          return this._active.length;
        } }, destroy: function() {
          this._toProcess = 0, this._pending = [], this._active = [], this._destroy = [];
        } });
        s3.exports = Lfe;
      });
      h3 = u((tLe, o3) => {
        var Ofe = C(), n3 = kc(), Dfe = rt(), ni = qe(), a3 = new Ofe({ Extends: n3, initialize: function(t) {
          n3.call(this), this.checkQueue = true, this.scene = t, this.systems = t.sys, t.sys.events.
          once(ni.BOOT, this.boot, this), t.sys.events.on(ni.START, this.start, this);
        }, boot: function() {
          this.systems.events.once(ni.DESTROY, this.destroy, this);
        }, start: function() {
          var e = this.systems.events;
          e.on(ni.PRE_UPDATE, this.update, this), e.on(ni.UPDATE, this.sceneUpdate, this), e.once(ni.
          SHUTDOWN, this.shutdown, this);
        }, sceneUpdate: function(e, t) {
          for (var i = this._active, r = i.length, s = 0; s < r; s++) {
            var n = i[s];
            n.active && n.preUpdate.call(n, e, t);
          }
        }, shutdown: function() {
          for (var e = this._active.length; e--; ) this._active[e].destroy(true);
          for (e = this._pending.length; e--; ) this._pending[e].destroy(true);
          for (e = this._destroy.length; e--; ) this._destroy[e].destroy(true);
          this._toProcess = 0, this._pending = [], this._active = [], this._destroy = [], this.removeAllListeners();
          var t = this.systems.events;
          t.off(ni.PRE_UPDATE, this.update, this), t.off(ni.UPDATE, this.sceneUpdate, this), t.off(ni.
          SHUTDOWN, this.shutdown, this);
        }, destroy: function() {
          this.shutdown(), this.systems.events.off(ni.START, this.start, this), this.scene = null, this.
          systems = null;
        } });
        Dfe.register("UpdateList", a3, "updateList");
        o3.exports = a3;
      });
      ot = u((iLe, u3) => {
        var Xc = Ao(), Nfe = H(), Ife = function(e, t, i) {
          var r = Nfe(e, t, null);
          if (r === null) return i;
          if (Array.isArray(r)) return Xc.RND.pick(r);
          if (typeof r == "object") {
            if (r.hasOwnProperty("randInt")) return Xc.RND.integerInRange(r.randInt[0], r.randInt[1]);
            if (r.hasOwnProperty("randFloat")) return Xc.RND.realInRange(r.randFloat[0], r.randFloat[1]);
          } else if (typeof r == "function") return r(t);
          return r;
        };
        u3.exports = Ife;
      });
      dr = u((rLe, l3) => {
        var Bfe = Qt(), xe = ot(), Gfe = function(e, t, i) {
          t.x = xe(i, "x", 0), t.y = xe(i, "y", 0), t.depth = xe(i, "depth", 0), t.flipX = xe(i, "fl\
ipX", false), t.flipY = xe(i, "flipY", false);
          var r = xe(i, "scale", null);
          typeof r == "number" ? t.setScale(r) : r !== null && (t.scaleX = xe(r, "x", 1), t.scaleY =
          xe(r, "y", 1));
          var s = xe(i, "scrollFactor", null);
          typeof s == "number" ? t.setScrollFactor(s) : s !== null && (t.scrollFactorX = xe(s, "x", 1),
          t.scrollFactorY = xe(s, "y", 1)), t.rotation = xe(i, "rotation", 0);
          var n = xe(i, "angle", null);
          n !== null && (t.angle = n), t.alpha = xe(i, "alpha", 1);
          var a = xe(i, "origin", null);
          if (typeof a == "number") t.setOrigin(a);
          else if (a !== null) {
            var o = xe(a, "x", 0.5), h = xe(a, "y", 0.5);
            t.setOrigin(o, h);
          }
          t.blendMode = xe(i, "blendMode", Bfe.NORMAL), t.visible = xe(i, "visible", true);
          var l = xe(i, "add", true);
          return l && e.sys.displayList.add(t), t.preUpdate && e.sys.updateList.add(t), t;
        };
        l3.exports = Gfe;
      });
      ua = u((sLe, f3) => {
        var Ufe = function(e, t) {
          return e.hasOwnProperty(t);
        };
        f3.exports = Ufe;
      });
      Sh = u((nLe, d3) => {
        var zfe = C(), yh = new zfe({ initialize: function(t) {
          if (this.entries = [], Array.isArray(t)) for (var i = 0; i < t.length; i++) this.set(t[i]);
        }, set: function(e) {
          return this.entries.indexOf(e) === -1 && this.entries.push(e), this;
        }, get: function(e, t) {
          for (var i = 0; i < this.entries.length; i++) {
            var r = this.entries[i];
            if (r[e] === t) return r;
          }
        }, getArray: function() {
          return this.entries.slice(0);
        }, delete: function(e) {
          var t = this.entries.indexOf(e);
          return t > -1 && this.entries.splice(t, 1), this;
        }, dump: function() {
          console.group("Set");
          for (var e = 0; e < this.entries.length; e++) {
            var t = this.entries[e];
            console.log(t);
          }
          console.groupEnd();
        }, each: function(e, t) {
          var i, r = this.entries.slice(), s = r.length;
          if (t) for (i = 0; i < s && e.call(t, r[i], i) !== false; i++) ;
          else for (i = 0; i < s && e(r[i], i) !== false; i++) ;
          return this;
        }, iterate: function(e, t) {
          var i, r = this.entries.length;
          if (t) for (i = 0; i < r && e.call(t, this.entries[i], i) !== false; i++) ;
          else for (i = 0; i < r && e(this.entries[i], i) !== false; i++) ;
          return this;
        }, iterateLocal: function(e) {
          var t, i = [];
          for (t = 1; t < arguments.length; t++) i.push(arguments[t]);
          var r = this.entries.length;
          for (t = 0; t < r; t++) {
            var s = this.entries[t];
            s[e].apply(s, i);
          }
          return this;
        }, clear: function() {
          return this.entries.length = 0, this;
        }, contains: function(e) {
          return this.entries.indexOf(e) > -1;
        }, union: function(e) {
          var t = new yh();
          return e.entries.forEach(function(i) {
            t.set(i);
          }), this.entries.forEach(function(i) {
            t.set(i);
          }), t;
        }, intersect: function(e) {
          var t = new yh();
          return this.entries.forEach(function(i) {
            e.contains(i) && t.set(i);
          }), t;
        }, difference: function(e) {
          var t = new yh();
          return this.entries.forEach(function(i) {
            e.contains(i) || t.set(i);
          }), t;
        }, size: { get: function() {
          return this.entries.length;
        }, set: function(e) {
          return e < this.entries.length ? this.entries.length = e : this.entries.length;
        } } });
        d3.exports = yh;
      });
      v3 = u((aLe, c3) => {
        var kfe = function(e, t, i, r) {
          i.addToRenderList(t), t.pipeline.batchSprite(t, i, r);
        };
        c3.exports = kfe;
      });
      x3 = u((oLe, g3) => {
        var p3 = J(), m3 = p3, Xfe = p3;
        m3 = v3();
        g3.exports = { renderWebGL: m3, renderCanvas: Xfe };
      });
      la = u((hLe, T32) => {
        var Vfe = Oa(), Yfe = C(), $e = Ot(), E3 = ei(), Wfe = x3(), Hfe = new Yfe({ Extends: E3, Mixins: [
        $e.Alpha, $e.BlendMode, $e.Depth, $e.Flip, $e.GetBounds, $e.Mask, $e.Origin, $e.Pipeline, $e.
        PostPipeline, $e.ScrollFactor, $e.Size, $e.TextureCrop, $e.Tint, $e.Transform, $e.Visible, Wfe],
        initialize: function(t, i, r, s, n) {
          E3.call(this, t, "Sprite"), this._crop = this.resetCropObject(), this.anims = new Vfe(this),
          this.setTexture(s, n), this.setPosition(i, r), this.setSizeToFrame(), this.setOriginFromFrame(),
          this.initPipeline(), this.initPostPipeline(true);
        }, addedToScene: function() {
          this.scene.sys.updateList.add(this);
        }, removedFromScene: function() {
          this.scene.sys.updateList.remove(this);
        }, preUpdate: function(e, t) {
          this.anims.update(e, t);
        }, play: function(e, t) {
          return this.anims.play(e, t);
        }, playReverse: function(e, t) {
          return this.anims.playReverse(e, t);
        }, playAfterDelay: function(e, t) {
          return this.anims.playAfterDelay(e, t);
        }, playAfterRepeat: function(e, t) {
          return this.anims.playAfterRepeat(e, t);
        }, chain: function(e) {
          return this.anims.chain(e);
        }, stop: function() {
          return this.anims.stop();
        }, stopAfterDelay: function(e) {
          return this.anims.stopAfterDelay(e);
        }, stopAfterRepeat: function(e) {
          return this.anims.stopAfterRepeat(e);
        }, stopOnFrame: function(e) {
          return this.anims.stopOnFrame(e);
        }, toJSON: function() {
          return $e.ToJSON(this);
        }, preDestroy: function() {
          this.anims.destroy(), this.anims = void 0;
        } });
        T32.exports = Hfe;
      });
      wh = u((uLe, w3) => {
        var X = bl(), Kfe = C(), Ks = xs(), y3 = Z(), Zfe = Ua(), j = B(), fe = H(), Wr = ua(), S32 = lt(),
        Qfe = Qu(), Jfe = Sh(), $fe = la(), jfe = new Kfe({ Extends: y3, initialize: function(t, i, r) {
          y3.call(this), r ? i && !Array.isArray(i) && (i = [i]) : Array.isArray(i) ? S32(i[0]) && (r =
          i, i = null) : S32(i) && (r = i, i = null), this.scene = t, this.children = new Jfe(), this.
          isParent = true, this.type = "Group", this.classType = j(r, "classType", $fe), this.name =
          j(r, "name", ""), this.active = j(r, "active", true), this.maxSize = j(r, "maxSize", -1), this.
          defaultKey = j(r, "defaultKey", null), this.defaultFrame = j(r, "defaultFrame", null), this.
          runChildUpdate = j(r, "runChildUpdate", false), this.createCallback = j(r, "createCallback",
          null), this.removeCallback = j(r, "removeCallback", null), this.createMultipleCallback = j(
          r, "createMultipleCallback", null), this.internalCreateCallback = j(r, "internalCreateCall\
back", null), this.internalRemoveCallback = j(r, "internalRemoveCallback", null), i && this.addMultiple(
          i), r && this.createMultiple(r), this.on(Ks.ADDED_TO_SCENE, this.addedToScene, this), this.
          on(Ks.REMOVED_FROM_SCENE, this.removedFromScene, this);
        }, addedToScene: function() {
          this.scene.sys.updateList.add(this);
        }, removedFromScene: function() {
          this.scene.sys.updateList.remove(this);
        }, create: function(e, t, i, r, s, n) {
          if (e === void 0 && (e = 0), t === void 0 && (t = 0), i === void 0 && (i = this.defaultKey),
          r === void 0 && (r = this.defaultFrame), s === void 0 && (s = true), n === void 0 && (n = true),
          this.isFull()) return null;
          var a = new this.classType(this.scene, e, t, i, r);
          return a.addToDisplayList(this.scene.sys.displayList), a.addToUpdateList(), a.visible = s,
          a.setActive(n), this.add(a), a;
        }, createMultiple: function(e) {
          if (this.isFull()) return [];
          Array.isArray(e) || (e = [e]);
          var t = [];
          if (e[0].key) for (var i = 0; i < e.length; i++) {
            var r = this.createFromConfig(e[i]);
            t = t.concat(r);
          }
          return t;
        }, createFromConfig: function(e) {
          if (this.isFull()) return [];
          this.classType = j(e, "classType", this.classType);
          var t = j(e, "key", void 0), i = j(e, "frame", null), r = j(e, "visible", true), s = j(e, "\
active", true), n = [];
          if (t === void 0) return n;
          Array.isArray(t) || (t = [t]), Array.isArray(i) || (i = [i]);
          var a = j(e, "repeat", 0), o = j(e, "randomKey", false), h = j(e, "randomFrame", false), l = j(
          e, "yoyo", false), f = j(e, "quantity", false), d = j(e, "frameQuantity", 1), c = j(e, "ma\
x", 0), p = Qfe(t, i, { max: c, qty: f || d, random: o, randomB: h, repeat: a, yoyo: l });
          e.createCallback && (this.createCallback = e.createCallback), e.removeCallback && (this.removeCallback =
          e.removeCallback), e.internalCreateCallback && (this.internalCreateCallback = e.internalCreateCallback),
          e.internalRemoveCallback && (this.internalRemoveCallback = e.internalRemoveCallback);
          for (var v = 0; v < p.length; v++) {
            var m = this.create(0, 0, p[v].a, p[v].b, r, s);
            if (!m) break;
            n.push(m);
          }
          if (Wr(e, "setXY")) {
            var g = fe(e, "setXY.x", 0), x = fe(e, "setXY.y", 0), E = fe(e, "setXY.stepX", 0), T15 = fe(
            e, "setXY.stepY", 0);
            X.SetXY(n, g, x, E, T15);
          }
          if (Wr(e, "setRotation")) {
            var w = fe(e, "setRotation.value", 0), y = fe(e, "setRotation.step", 0);
            X.SetRotation(n, w, y);
          }
          if (Wr(e, "setScale")) {
            var A10 = fe(e, "setScale.x", 1), S14 = fe(e, "setScale.y", A10), _ = fe(e, "setScale.st\
epX", 0), q = fe(e, "setScale.stepY", 0);
            X.SetScale(n, A10, S14, _, q);
          }
          if (Wr(e, "setOrigin")) {
            var P = fe(e, "setOrigin.x", 0.5), L = fe(e, "setOrigin.y", P), N5 = fe(e, "setOrigin.st\
epX", 0), O19 = fe(e, "setOrigin.stepY", 0);
            X.SetOrigin(n, P, L, N5, O19);
          }
          if (Wr(e, "setAlpha")) {
            var M = fe(e, "setAlpha.value", 1), F8 = fe(e, "setAlpha.step", 0);
            X.SetAlpha(n, M, F8);
          }
          if (Wr(e, "setDepth")) {
            var b = fe(e, "setDepth.value", 0), G = fe(e, "setDepth.step", 0);
            X.SetDepth(n, b, G);
          }
          if (Wr(e, "setScrollFactor")) {
            var I = fe(e, "setScrollFactor.x", 1), W = fe(e, "setScrollFactor.y", I), Ae = fe(e, "se\
tScrollFactor.stepX", 0), Re = fe(e, "setScrollFactor.stepY", 0);
            X.SetScrollFactor(n, I, W, Ae, Re);
          }
          var ge = j(e, "hitArea", null), _e = j(e, "hitAreaCallback", null);
          ge && X.SetHitArea(n, ge, _e);
          var V24 = j(e, "gridAlign", false);
          return V24 && X.GridAlign(n, V24), this.createMultipleCallback && this.createMultipleCallback.
          call(this, n), n;
        }, preUpdate: function(e, t) {
          if (!(!this.runChildUpdate || this.children.size === 0)) for (var i = this.children.entries.
          slice(), r = 0; r < i.length; r++) {
            var s = i[r];
            s.active && s.update(e, t);
          }
        }, add: function(e, t) {
          return t === void 0 && (t = false), this.isFull() ? this : (this.children.set(e), this.internalCreateCallback &&
          this.internalCreateCallback.call(this, e), this.createCallback && this.createCallback.call(
          this, e), t && (e.addToDisplayList(this.scene.sys.displayList), e.addToUpdateList()), e.on(
          Ks.DESTROY, this.remove, this), this);
        }, addMultiple: function(e, t) {
          if (t === void 0 && (t = false), Array.isArray(e)) for (var i = 0; i < e.length; i++) this.
          add(e[i], t);
          return this;
        }, remove: function(e, t, i) {
          return t === void 0 && (t = false), i === void 0 && (i = false), this.children.contains(e) ?
          (this.children.delete(e), this.internalRemoveCallback && this.internalRemoveCallback.call(
          this, e), this.removeCallback && this.removeCallback.call(this, e), e.off(Ks.DESTROY, this.
          remove, this), i ? e.destroy() : t && (e.removeFromDisplayList(), e.removeFromUpdateList()),
          this) : this;
        }, clear: function(e, t) {
          e === void 0 && (e = false), t === void 0 && (t = false);
          for (var i = this.children, r = 0; r < i.size; r++) {
            var s = i.entries[r];
            s.off(Ks.DESTROY, this.remove, this), t ? s.destroy() : e && (s.removeFromDisplayList(),
            s.removeFromUpdateList());
          }
          return this.children.clear(), this;
        }, contains: function(e) {
          return this.children.contains(e);
        }, getChildren: function() {
          return this.children.entries;
        }, getLength: function() {
          return this.children.size;
        }, getMatching: function(e, t, i, r) {
          return Zfe(this.children.entries, e, t, i, r);
        }, getFirst: function(e, t, i, r, s, n, a) {
          return this.getHandler(true, 1, e, t, i, r, s, n, a);
        }, getFirstNth: function(e, t, i, r, s, n, a, o) {
          return this.getHandler(true, e, t, i, r, s, n, a, o);
        }, getLast: function(e, t, i, r, s, n, a) {
          return this.getHandler(false, 1, e, t, i, r, s, n, a);
        }, getLastNth: function(e, t, i, r, s, n, a, o) {
          return this.getHandler(false, e, t, i, r, s, n, a, o);
        }, getHandler: function(e, t, i, r, s, n, a, o, h) {
          i === void 0 && (i = false), r === void 0 && (r = false);
          var l, f, d = 0, c = this.children.entries;
          if (e) for (f = 0; f < c.length; f++) if (l = c[f], l.active === i) {
            if (d++, d === t) break;
          } else l = null;
          else for (f = c.length - 1; f >= 0; f--) if (l = c[f], l.active === i) {
            if (d++, d === t) break;
          } else l = null;
          return l ? (typeof s == "number" && (l.x = s), typeof n == "number" && (l.y = n), l) : r ?
          this.create(s, n, a, o, h) : null;
        }, get: function(e, t, i, r, s) {
          return this.getFirst(false, true, e, t, i, r, s);
        }, getFirstAlive: function(e, t, i, r, s, n) {
          return this.getFirst(true, e, t, i, r, s, n);
        }, getFirstDead: function(e, t, i, r, s, n) {
          return this.getFirst(false, e, t, i, r, s, n);
        }, playAnimation: function(e, t) {
          return X.PlayAnimation(this.children.entries, e, t), this;
        }, isFull: function() {
          return this.maxSize === -1 ? false : this.children.size >= this.maxSize;
        }, countActive: function(e) {
          e === void 0 && (e = true);
          for (var t = 0, i = 0; i < this.children.size; i++) this.children.entries[i].active === e &&
          t++;
          return t;
        }, getTotalUsed: function() {
          return this.countActive();
        }, getTotalFree: function() {
          var e = this.getTotalUsed(), t = this.maxSize === -1 ? 999999999999 : this.maxSize;
          return t - e;
        }, setActive: function(e) {
          return this.active = e, this;
        }, setName: function(e) {
          return this.name = e, this;
        }, propertyValueSet: function(e, t, i, r, s) {
          return X.PropertyValueSet(this.children.entries, e, t, i, r, s), this;
        }, propertyValueInc: function(e, t, i, r, s) {
          return X.PropertyValueInc(this.children.entries, e, t, i, r, s), this;
        }, setX: function(e, t) {
          return X.SetX(this.children.entries, e, t), this;
        }, setY: function(e, t) {
          return X.SetY(this.children.entries, e, t), this;
        }, setXY: function(e, t, i, r) {
          return X.SetXY(this.children.entries, e, t, i, r), this;
        }, incX: function(e, t) {
          return X.IncX(this.children.entries, e, t), this;
        }, incY: function(e, t) {
          return X.IncY(this.children.entries, e, t), this;
        }, incXY: function(e, t, i, r) {
          return X.IncXY(this.children.entries, e, t, i, r), this;
        }, shiftPosition: function(e, t, i) {
          return X.ShiftPosition(this.children.entries, e, t, i), this;
        }, angle: function(e, t) {
          return X.Angle(this.children.entries, e, t), this;
        }, rotate: function(e, t) {
          return X.Rotate(this.children.entries, e, t), this;
        }, rotateAround: function(e, t) {
          return X.RotateAround(this.children.entries, e, t), this;
        }, rotateAroundDistance: function(e, t, i) {
          return X.RotateAroundDistance(this.children.entries, e, t, i), this;
        }, setAlpha: function(e, t) {
          return X.SetAlpha(this.children.entries, e, t), this;
        }, setTint: function(e, t, i, r) {
          return X.SetTint(this.children.entries, e, t, i, r), this;
        }, setOrigin: function(e, t, i, r) {
          return X.SetOrigin(this.children.entries, e, t, i, r), this;
        }, scaleX: function(e, t) {
          return X.ScaleX(this.children.entries, e, t), this;
        }, scaleY: function(e, t) {
          return X.ScaleY(this.children.entries, e, t), this;
        }, scaleXY: function(e, t, i, r) {
          return X.ScaleXY(this.children.entries, e, t, i, r), this;
        }, setDepth: function(e, t) {
          return X.SetDepth(this.children.entries, e, t), this;
        }, setBlendMode: function(e) {
          return X.SetBlendMode(this.children.entries, e), this;
        }, setHitArea: function(e, t) {
          return X.SetHitArea(this.children.entries, e, t), this;
        }, shuffle: function() {
          return X.Shuffle(this.children.entries), this;
        }, kill: function(e) {
          this.children.contains(e) && e.setActive(false);
        }, killAndHide: function(e) {
          this.children.contains(e) && (e.setActive(false), e.setVisible(false));
        }, setVisible: function(e, t, i) {
          return X.SetVisible(this.children.entries, e, t, i), this;
        }, toggleVisible: function() {
          return X.ToggleVisible(this.children.entries), this;
        }, destroy: function(e, t) {
          e === void 0 && (e = false), t === void 0 && (t = false), !(!this.scene || this.ignoreDestroy) &&
          (this.emit(Ks.DESTROY, this), this.removeAllListeners(), this.scene.sys.updateList.remove(
          this), this.clear(t, e), this.scene = void 0, this.children = void 0);
        } });
        w3.exports = jfe;
      });
      Ch = u((lLe, C3) => {
        C3.exports = { ARC: 0, BEGIN_PATH: 1, CLOSE_PATH: 2, FILL_RECT: 3, LINE_TO: 4, MOVE_TO: 5, LINE_STYLE: 6,
        FILL_STYLE: 7, FILL_PATH: 8, STROKE_PATH: 9, FILL_TRIANGLE: 10, STROKE_TRIANGLE: 11, SAVE: 14,
        RESTORE: 15, TRANSLATE: 16, SCALE: 17, ROTATE: 18, GRADIENT_FILL_STYLE: 21, GRADIENT_LINE_STYLE: 22 };
      });
      Vc = u((fLe, A32) => {
        var ede = function(e, t, i) {
          if (e.width <= 0 || e.height <= 0) return false;
          var r = (t - e.x) / e.width, s = (i - e.y) / e.height;
          return r *= r, s *= s, r + s < 0.25;
        };
        A32.exports = ede;
      });
      Yc = u((dLe, R3) => {
        var tde = ae(), ide = function(e, t, i) {
          i === void 0 && (i = new tde());
          var r = e.width / 2, s = e.height / 2;
          return i.x = e.x + r * Math.cos(t), i.y = e.y + s * Math.sin(t), i;
        };
        R3.exports = ide;
      });
      P3 = u((cLe, _3) => {
        var rde = Yc(), sde = us(), nde = le(), ade = ae(), ode = function(e, t, i) {
          i === void 0 && (i = new ade());
          var r = sde(t, 0, nde.PI2);
          return rde(e, r, i);
        };
        _3.exports = ode;
      });
      q3 = u((vLe, M3) => {
        var hde = function(e) {
          var t = e.width / 2, i = e.height / 2, r = Math.pow(t - i, 2) / Math.pow(t + i, 2);
          return Math.PI * (t + i) * (1 + 3 * r / (10 + Math.sqrt(4 - 3 * r)));
        };
        M3.exports = hde;
      });
      b3 = u((pLe, F32) => {
        var ude = q3(), lde = Yc(), fde = us(), dde = le(), cde = function(e, t, i, r) {
          r === void 0 && (r = []), !t && i > 0 && (t = ude(e) / i);
          for (var s = 0; s < t; s++) {
            var n = fde(s / t, 0, dde.PI2);
            r.push(lde(e, n));
          }
          return r;
        };
        F32.exports = cde;
      });
      Wc = u((mLe, L3) => {
        var vde = C(), pde = Vc(), mde = P3(), gde = b3(), xde = ki(), Ede = ql(), Tde = new vde({ initialize: function(t, i, r, s) {
          t === void 0 && (t = 0), i === void 0 && (i = 0), r === void 0 && (r = 0), s === void 0 &&
          (s = 0), this.type = xde.ELLIPSE, this.x = t, this.y = i, this.width = r, this.height = s;
        }, contains: function(e, t) {
          return pde(this, e, t);
        }, getPoint: function(e, t) {
          return mde(this, e, t);
        }, getPoints: function(e, t, i) {
          return gde(this, e, t, i);
        }, getRandomPoint: function(e) {
          return Ede(this, e);
        }, setTo: function(e, t, i, r) {
          return this.x = e, this.y = t, this.width = i, this.height = r, this;
        }, setEmpty: function() {
          return this.width = 0, this.height = 0, this;
        }, setPosition: function(e, t) {
          return t === void 0 && (t = e), this.x = e, this.y = t, this;
        }, setSize: function(e, t) {
          return t === void 0 && (t = e), this.width = e, this.height = t, this;
        }, isEmpty: function() {
          return this.width <= 0 || this.height <= 0;
        }, getMinorRadius: function() {
          return Math.min(this.width, this.height) / 2;
        }, getMajorRadius: function() {
          return Math.max(this.width, this.height) / 2;
        }, left: { get: function() {
          return this.x - this.width / 2;
        }, set: function(e) {
          this.x = e + this.width / 2;
        } }, right: { get: function() {
          return this.x + this.width / 2;
        }, set: function(e) {
          this.x = e - this.width / 2;
        } }, top: { get: function() {
          return this.y - this.height / 2;
        }, set: function(e) {
          this.y = e + this.height / 2;
        } }, bottom: { get: function() {
          return this.y + this.height / 2;
        }, set: function(e) {
          this.y = e - this.height / 2;
        } } });
        L3.exports = Tde;
      });
      Ah = u((gLe, I3) => {
        var Hc = Lt(), O32 = new Hc(), D32 = new Hc(), N32 = new Hc(), yde = { camera: O32, sprite: D32,
        calc: N32 }, Sde = function(e, t, i) {
          var r = O32, s = D32, n = N32;
          return s.applyITRS(e.x, e.y, e.rotation, e.scaleX, e.scaleY), r.copyFrom(t.matrix), i ? (r.
          multiplyWithOffset(i, -t.scrollX * e.scrollFactorX, -t.scrollY * e.scrollFactorY), s.e = e.
          x, s.f = e.y) : (s.e -= t.scrollX * e.scrollFactorX, s.f -= t.scrollY * e.scrollFactorY), r.
          multiply(s, n), yde;
        };
        I3.exports = Sde;
      });
      U3 = u((xLe, G3) => {
        var we = Ch(), wde = Ah(), Cde = Lt(), Ade = wt(), Rh = function(e, t, i) {
          this.x = e, this.y = t, this.width = i;
        }, Kc = function(e, t, i) {
          this.points = [], this.pointsLength = 1, this.points[0] = new Rh(e, t, i);
        }, B32 = [], Rde = new Cde(), _de = function(e, t, i, r) {
          if (t.commandBuffer.length !== 0) {
            i.addToRenderList(t);
            var s = e.pipelines.set(t.pipeline, t);
            e.pipelines.preBatch(t);
            for (var n = wde(t, i, r).calc, a = Rde.loadIdentity(), o = t.commandBuffer, h = i.alpha *
            t.alpha, l = 1, f = s.fillTint, d = s.strokeTint, c = 0, p = 0, v = 0, m = 0.01, g = Math.
            PI * 2, x, E = [], T15 = 0, w = true, y = null, A10 = Ade.getTintAppendFloatAlpha, S14 = 0; S14 <
            o.length; S14++) switch (x = o[S14], x) {
              case we.BEGIN_PATH: {
                E.length = 0, y = null, w = true;
                break;
              }
              case we.CLOSE_PATH: {
                w = false, y && y.points.length && y.points.push(y.points[0]);
                break;
              }
              case we.FILL_PATH: {
                for (T15 = 0; T15 < E.length; T15++) s.batchFillPath(E[T15].points, a, n);
                break;
              }
              case we.STROKE_PATH: {
                for (T15 = 0; T15 < E.length; T15++) s.batchStrokePath(E[T15].points, l, w, a, n);
                break;
              }
              case we.LINE_STYLE: {
                l = o[++S14];
                var _ = o[++S14], q = o[++S14] * h, P = A10(_, q);
                d.TL = P, d.TR = P, d.BL = P, d.BR = P;
                break;
              }
              case we.FILL_STYLE: {
                var L = o[++S14], N5 = o[++S14] * h, O19 = A10(L, N5);
                f.TL = O19, f.TR = O19, f.BL = O19, f.BR = O19;
                break;
              }
              case we.GRADIENT_FILL_STYLE: {
                var M = o[++S14] * h, F8 = o[++S14] * h, b = o[++S14] * h, G = o[++S14] * h;
                f.TL = A10(o[++S14], M), f.TR = A10(o[++S14], F8), f.BL = A10(o[++S14], b), f.BR = A10(
                o[++S14], G);
                break;
              }
              case we.GRADIENT_LINE_STYLE: {
                l = o[++S14];
                var I = o[++S14] * h;
                d.TL = A10(o[++S14], I), d.TR = A10(o[++S14], I), d.BL = A10(o[++S14], I), d.BR = A10(
                o[++S14], I);
                break;
              }
              case we.ARC: {
                var W = 0, Ae = o[++S14], Re = o[++S14], ge = o[++S14], _e = o[++S14], V24 = o[++S14],
                Te = o[++S14], ts = o[++S14];
                for (V24 -= _e, Te ? V24 < -g ? V24 = -g : V24 > 0 && (V24 = -g + V24 % g) : V24 > g ?
                V24 = g : V24 < 0 && (V24 = g + V24 % g), y === null && (y = new Kc(Ae + Math.cos(_e) *
                ge, Re + Math.sin(_e) * ge, l), E.push(y), W += m); W < 1 + ts; ) v = V24 * W + _e, c =
                Ae + Math.cos(v) * ge, p = Re + Math.sin(v) * ge, y.points.push(new Rh(c, p, l)), W +=
                m;
                v = V24 + _e, c = Ae + Math.cos(v) * ge, p = Re + Math.sin(v) * ge, y.points.push(new Rh(
                c, p, l));
                break;
              }
              case we.FILL_RECT: {
                s.batchFillRect(o[++S14], o[++S14], o[++S14], o[++S14], a, n);
                break;
              }
              case we.FILL_TRIANGLE: {
                s.batchFillTriangle(o[++S14], o[++S14], o[++S14], o[++S14], o[++S14], o[++S14], a, n);
                break;
              }
              case we.STROKE_TRIANGLE: {
                s.batchStrokeTriangle(o[++S14], o[++S14], o[++S14], o[++S14], o[++S14], o[++S14], l,
                a, n);
                break;
              }
              case we.LINE_TO: {
                y !== null ? y.points.push(new Rh(o[++S14], o[++S14], l)) : (y = new Kc(o[++S14], o[++S14],
                l), E.push(y));
                break;
              }
              case we.MOVE_TO: {
                y = new Kc(o[++S14], o[++S14], l), E.push(y);
                break;
              }
              case we.SAVE: {
                B32.push(a.copyToArray());
                break;
              }
              case we.RESTORE: {
                a.copyFromArray(B32.pop());
                break;
              }
              case we.TRANSLATE: {
                Ae = o[++S14], Re = o[++S14], a.translate(Ae, Re);
                break;
              }
              case we.SCALE: {
                Ae = o[++S14], Re = o[++S14], a.scale(Ae, Re);
                break;
              }
              case we.ROTATE: {
                a.rotate(o[++S14]);
                break;
              }
            }
            e.pipelines.postBatch(t);
          }
        };
        G3.exports = _de;
      });
      k3 = u((ELe, z3) => {
        var Pde = Ah(), Mde = function(e, t, i, r, s) {
          var n = r.alpha * i.alpha;
          if (n <= 0) return false;
          var a = Pde(i, r, s).calc;
          return t.globalCompositeOperation = e.blendModes[i.blendMode], t.globalAlpha = n, t.save(),
          a.setToContext(t), t.imageSmoothingEnabled = i.frame ? !i.frame.source.scaleMode : e.antialias,
          true;
        };
        z3.exports = Mde;
      });
      V3 = u((TLe, X3) => {
        var pe = Ch(), qde = k3(), Fde = function(e, t, i, r, s, n) {
          var a = t.commandBuffer, o = a.length, h = s || e.currentContext;
          if (!(o === 0 || !qde(e, h, t, i, r))) {
            i.addToRenderList(t);
            var l = 1, f = 1, d = 0, c = 0, p = 1, v = 0, m = 0, g = 0;
            h.beginPath();
            for (var x = 0; x < o; ++x) {
              var E = a[x];
              switch (E) {
                case pe.ARC:
                  h.arc(a[x + 1], a[x + 2], a[x + 3], a[x + 4], a[x + 5], a[x + 6]), x += 7;
                  break;
                case pe.LINE_STYLE:
                  p = a[x + 1], d = a[x + 2], l = a[x + 3], v = (d & 16711680) >>> 16, m = (d & 65280) >>>
                  8, g = d & 255, h.strokeStyle = "rgba(" + v + "," + m + "," + g + "," + l + ")", h.
                  lineWidth = p, x += 3;
                  break;
                case pe.FILL_STYLE:
                  c = a[x + 1], f = a[x + 2], v = (c & 16711680) >>> 16, m = (c & 65280) >>> 8, g = c &
                  255, h.fillStyle = "rgba(" + v + "," + m + "," + g + "," + f + ")", x += 2;
                  break;
                case pe.BEGIN_PATH:
                  h.beginPath();
                  break;
                case pe.CLOSE_PATH:
                  h.closePath();
                  break;
                case pe.FILL_PATH:
                  n || h.fill();
                  break;
                case pe.STROKE_PATH:
                  n || h.stroke();
                  break;
                case pe.FILL_RECT:
                  n ? h.rect(a[x + 1], a[x + 2], a[x + 3], a[x + 4]) : h.fillRect(a[x + 1], a[x + 2],
                  a[x + 3], a[x + 4]), x += 4;
                  break;
                case pe.FILL_TRIANGLE:
                  h.beginPath(), h.moveTo(a[x + 1], a[x + 2]), h.lineTo(a[x + 3], a[x + 4]), h.lineTo(
                  a[x + 5], a[x + 6]), h.closePath(), n || h.fill(), x += 6;
                  break;
                case pe.STROKE_TRIANGLE:
                  h.beginPath(), h.moveTo(a[x + 1], a[x + 2]), h.lineTo(a[x + 3], a[x + 4]), h.lineTo(
                  a[x + 5], a[x + 6]), h.closePath(), n || h.stroke(), x += 6;
                  break;
                case pe.LINE_TO:
                  h.lineTo(a[x + 1], a[x + 2]), x += 2;
                  break;
                case pe.MOVE_TO:
                  h.moveTo(a[x + 1], a[x + 2]), x += 2;
                  break;
                case pe.LINE_FX_TO:
                  h.lineTo(a[x + 1], a[x + 2]), x += 5;
                  break;
                case pe.MOVE_FX_TO:
                  h.moveTo(a[x + 1], a[x + 2]), x += 5;
                  break;
                case pe.SAVE:
                  h.save();
                  break;
                case pe.RESTORE:
                  h.restore();
                  break;
                case pe.TRANSLATE:
                  h.translate(a[x + 1], a[x + 2]), x += 2;
                  break;
                case pe.SCALE:
                  h.scale(a[x + 1], a[x + 2]), x += 2;
                  break;
                case pe.ROTATE:
                  h.rotate(a[x + 1]), x += 1;
                  break;
                case pe.GRADIENT_FILL_STYLE:
                  x += 5;
                  break;
                case pe.GRADIENT_LINE_STYLE:
                  x += 6;
                  break;
              }
            }
            h.restore();
          }
        };
        X3.exports = Fde;
      });
      Z3 = u((yLe, K3) => {
        var Y3 = J(), W3 = Y3, H3 = Y3;
        W3 = U3(), H3 = V3();
        K3.exports = { renderWebGL: W3, renderCanvas: H3 };
      });
      _h = u((SLe, $3) => {
        var bde = go(), Lde = C(), ie = Ch(), Oi = Ot(), Q3 = Wc(), J32 = ei(), cr = B(), Di = H(), be = le(),
        Ode = Z3(), Hr = new Lde({ Extends: J32, Mixins: [Oi.AlphaSingle, Oi.BlendMode, Oi.Depth, Oi.
        Mask, Oi.Pipeline, Oi.PostPipeline, Oi.Transform, Oi.Visible, Oi.ScrollFactor, Ode], initialize: function(t, i) {
          var r = Di(i, "x", 0), s = Di(i, "y", 0);
          J32.call(this, t, "Graphics"), this.setPosition(r, s), this.initPipeline(), this.initPostPipeline(),
          this.displayOriginX = 0, this.displayOriginY = 0, this.commandBuffer = [], this.defaultFillColor =
          -1, this.defaultFillAlpha = 1, this.defaultStrokeWidth = 1, this.defaultStrokeColor = -1, this.
          defaultStrokeAlpha = 1, this._lineWidth = 1, this.lineStyle(1, 0, 0), this.fillStyle(0, 0),
          this.setDefaultStyles(i);
        }, setDefaultStyles: function(e) {
          return Di(e, "lineStyle", null) && (this.defaultStrokeWidth = Di(e, "lineStyle.width", 1),
          this.defaultStrokeColor = Di(e, "lineStyle.color", 16777215), this.defaultStrokeAlpha = Di(
          e, "lineStyle.alpha", 1), this.lineStyle(this.defaultStrokeWidth, this.defaultStrokeColor,
          this.defaultStrokeAlpha)), Di(e, "fillStyle", null) && (this.defaultFillColor = Di(e, "fil\
lStyle.color", 16777215), this.defaultFillAlpha = Di(e, "fillStyle.alpha", 1), this.fillStyle(this.defaultFillColor,
          this.defaultFillAlpha)), this;
        }, lineStyle: function(e, t, i) {
          return i === void 0 && (i = 1), this.commandBuffer.push(ie.LINE_STYLE, e, t, i), this._lineWidth =
          e, this;
        }, fillStyle: function(e, t) {
          return t === void 0 && (t = 1), this.commandBuffer.push(ie.FILL_STYLE, e, t), this;
        }, fillGradientStyle: function(e, t, i, r, s, n, a, o) {
          return s === void 0 && (s = 1), n === void 0 && (n = s), a === void 0 && (a = s), o === void 0 &&
          (o = s), this.commandBuffer.push(ie.GRADIENT_FILL_STYLE, s, n, a, o, e, t, i, r), this;
        }, lineGradientStyle: function(e, t, i, r, s, n) {
          return n === void 0 && (n = 1), this.commandBuffer.push(ie.GRADIENT_LINE_STYLE, e, n, t, i,
          r, s), this;
        }, beginPath: function() {
          return this.commandBuffer.push(ie.BEGIN_PATH), this;
        }, closePath: function() {
          return this.commandBuffer.push(ie.CLOSE_PATH), this;
        }, fillPath: function() {
          return this.commandBuffer.push(ie.FILL_PATH), this;
        }, fill: function() {
          return this.commandBuffer.push(ie.FILL_PATH), this;
        }, strokePath: function() {
          return this.commandBuffer.push(ie.STROKE_PATH), this;
        }, stroke: function() {
          return this.commandBuffer.push(ie.STROKE_PATH), this;
        }, fillCircleShape: function(e) {
          return this.fillCircle(e.x, e.y, e.radius);
        }, strokeCircleShape: function(e) {
          return this.strokeCircle(e.x, e.y, e.radius);
        }, fillCircle: function(e, t, i) {
          return this.beginPath(), this.arc(e, t, i, 0, be.PI2), this.fillPath(), this;
        }, strokeCircle: function(e, t, i) {
          return this.beginPath(), this.arc(e, t, i, 0, be.PI2), this.strokePath(), this;
        }, fillRectShape: function(e) {
          return this.fillRect(e.x, e.y, e.width, e.height);
        }, strokeRectShape: function(e) {
          return this.strokeRect(e.x, e.y, e.width, e.height);
        }, fillRect: function(e, t, i, r) {
          return this.commandBuffer.push(ie.FILL_RECT, e, t, i, r), this;
        }, strokeRect: function(e, t, i, r) {
          var s = this._lineWidth / 2, n = e - s, a = e + s;
          return this.beginPath(), this.moveTo(e, t), this.lineTo(e, t + r), this.strokePath(), this.
          beginPath(), this.moveTo(e + i, t), this.lineTo(e + i, t + r), this.strokePath(), this.beginPath(),
          this.moveTo(n, t), this.lineTo(a + i, t), this.strokePath(), this.beginPath(), this.moveTo(
          n, t + r), this.lineTo(a + i, t + r), this.strokePath(), this;
        }, fillRoundedRect: function(e, t, i, r, s) {
          s === void 0 && (s = 20);
          var n = s, a = s, o = s, h = s;
          typeof s != "number" && (n = cr(s, "tl", 20), a = cr(s, "tr", 20), o = cr(s, "bl", 20), h =
          cr(s, "br", 20));
          var l = n >= 0, f = a >= 0, d = o >= 0, c = h >= 0;
          return n = Math.abs(n), a = Math.abs(a), o = Math.abs(o), h = Math.abs(h), this.beginPath(),
          this.moveTo(e + n, t), this.lineTo(e + i - a, t), f ? this.arc(e + i - a, t + a, a, -be.TAU,
          0) : this.arc(e + i, t, a, Math.PI, be.TAU, true), this.lineTo(e + i, t + r - h), c ? this.
          arc(e + i - h, t + r - h, h, 0, be.TAU) : this.arc(e + i, t + r, h, -be.TAU, Math.PI, true),
          this.lineTo(e + o, t + r), d ? this.arc(e + o, t + r - o, o, be.TAU, Math.PI) : this.arc(e,
          t + r, o, 0, -be.TAU, true), this.lineTo(e, t + n), l ? this.arc(e + n, t + n, n, -Math.PI,
          -be.TAU) : this.arc(e, t, n, be.TAU, 0, true), this.fillPath(), this;
        }, strokeRoundedRect: function(e, t, i, r, s) {
          s === void 0 && (s = 20);
          var n = s, a = s, o = s, h = s, l = Math.min(i, r) / 2;
          typeof s != "number" && (n = cr(s, "tl", 20), a = cr(s, "tr", 20), o = cr(s, "bl", 20), h =
          cr(s, "br", 20));
          var f = n >= 0, d = a >= 0, c = o >= 0, p = h >= 0;
          return n = Math.min(Math.abs(n), l), a = Math.min(Math.abs(a), l), o = Math.min(Math.abs(o),
          l), h = Math.min(Math.abs(h), l), this.beginPath(), this.moveTo(e + n, t), this.lineTo(e +
          i - a, t), this.moveTo(e + i - a, t), d ? this.arc(e + i - a, t + a, a, -be.TAU, 0) : this.
          arc(e + i, t, a, Math.PI, be.TAU, true), this.lineTo(e + i, t + r - h), this.moveTo(e + i,
          t + r - h), p ? this.arc(e + i - h, t + r - h, h, 0, be.TAU) : this.arc(e + i, t + r, h, -be.
          TAU, Math.PI, true), this.lineTo(e + o, t + r), this.moveTo(e + o, t + r), c ? this.arc(e +
          o, t + r - o, o, be.TAU, Math.PI) : this.arc(e, t + r, o, 0, -be.TAU, true), this.lineTo(e,
          t + n), this.moveTo(e, t + n), f ? this.arc(e + n, t + n, n, -Math.PI, -be.TAU) : this.arc(
          e, t, n, be.TAU, 0, true), this.strokePath(), this;
        }, fillPointShape: function(e, t) {
          return this.fillPoint(e.x, e.y, t);
        }, fillPoint: function(e, t, i) {
          return !i || i < 1 ? i = 1 : (e -= i / 2, t -= i / 2), this.commandBuffer.push(ie.FILL_RECT,
          e, t, i, i), this;
        }, fillTriangleShape: function(e) {
          return this.fillTriangle(e.x1, e.y1, e.x2, e.y2, e.x3, e.y3);
        }, strokeTriangleShape: function(e) {
          return this.strokeTriangle(e.x1, e.y1, e.x2, e.y2, e.x3, e.y3);
        }, fillTriangle: function(e, t, i, r, s, n) {
          return this.commandBuffer.push(ie.FILL_TRIANGLE, e, t, i, r, s, n), this;
        }, strokeTriangle: function(e, t, i, r, s, n) {
          return this.commandBuffer.push(ie.STROKE_TRIANGLE, e, t, i, r, s, n), this;
        }, strokeLineShape: function(e) {
          return this.lineBetween(e.x1, e.y1, e.x2, e.y2);
        }, lineBetween: function(e, t, i, r) {
          return this.beginPath(), this.moveTo(e, t), this.lineTo(i, r), this.strokePath(), this;
        }, lineTo: function(e, t) {
          return this.commandBuffer.push(ie.LINE_TO, e, t), this;
        }, moveTo: function(e, t) {
          return this.commandBuffer.push(ie.MOVE_TO, e, t), this;
        }, strokePoints: function(e, t, i, r) {
          t === void 0 && (t = false), i === void 0 && (i = false), r === void 0 && (r = e.length), this.
          beginPath(), this.moveTo(e[0].x, e[0].y);
          for (var s = 1; s < r; s++) this.lineTo(e[s].x, e[s].y);
          return t && this.lineTo(e[0].x, e[0].y), i && this.closePath(), this.strokePath(), this;
        }, fillPoints: function(e, t, i, r) {
          t === void 0 && (t = false), i === void 0 && (i = false), r === void 0 && (r = e.length), this.
          beginPath(), this.moveTo(e[0].x, e[0].y);
          for (var s = 1; s < r; s++) this.lineTo(e[s].x, e[s].y);
          return t && this.lineTo(e[0].x, e[0].y), i && this.closePath(), this.fillPath(), this;
        }, strokeEllipseShape: function(e, t) {
          t === void 0 && (t = 32);
          var i = e.getPoints(t);
          return this.strokePoints(i, true);
        }, strokeEllipse: function(e, t, i, r, s) {
          s === void 0 && (s = 32);
          var n = new Q3(e, t, i, r), a = n.getPoints(s);
          return this.strokePoints(a, true);
        }, fillEllipseShape: function(e, t) {
          t === void 0 && (t = 32);
          var i = e.getPoints(t);
          return this.fillPoints(i, true);
        }, fillEllipse: function(e, t, i, r, s) {
          s === void 0 && (s = 32);
          var n = new Q3(e, t, i, r), a = n.getPoints(s);
          return this.fillPoints(a, true);
        }, arc: function(e, t, i, r, s, n, a) {
          return n === void 0 && (n = false), a === void 0 && (a = 0), this.commandBuffer.push(ie.ARC,
          e, t, i, r, s, n, a), this;
        }, slice: function(e, t, i, r, s, n, a) {
          return n === void 0 && (n = false), a === void 0 && (a = 0), this.commandBuffer.push(ie.BEGIN_PATH),
          this.commandBuffer.push(ie.MOVE_TO, e, t), this.commandBuffer.push(ie.ARC, e, t, i, r, s, n,
          a), this.commandBuffer.push(ie.CLOSE_PATH), this;
        }, save: function() {
          return this.commandBuffer.push(ie.SAVE), this;
        }, restore: function() {
          return this.commandBuffer.push(ie.RESTORE), this;
        }, translateCanvas: function(e, t) {
          return this.commandBuffer.push(ie.TRANSLATE, e, t), this;
        }, scaleCanvas: function(e, t) {
          return this.commandBuffer.push(ie.SCALE, e, t), this;
        }, rotateCanvas: function(e) {
          return this.commandBuffer.push(ie.ROTATE, e), this;
        }, clear: function() {
          return this.commandBuffer.length = 0, this.defaultFillColor > -1 && this.fillStyle(this.defaultFillColor,
          this.defaultFillAlpha), this.defaultStrokeColor > -1 && this.lineStyle(this.defaultStrokeWidth,
          this.defaultStrokeColor, this.defaultStrokeAlpha), this;
        }, generateTexture: function(e, t, i) {
          var r = this.scene.sys, s = r.game.renderer;
          t === void 0 && (t = r.scale.width), i === void 0 && (i = r.scale.height), Hr.TargetCamera.
          setScene(this.scene), Hr.TargetCamera.setViewport(0, 0, t, i), Hr.TargetCamera.scrollX = this.
          x, Hr.TargetCamera.scrollY = this.y;
          var n, a, o = { willReadFrequently: true };
          if (typeof e == "string") if (r.textures.exists(e)) {
            n = r.textures.get(e);
            var h = n.getSourceImage();
            h instanceof HTMLCanvasElement && (a = h.getContext("2d", o));
          } else n = r.textures.createCanvas(e, t, i), a = n.getSourceImage().getContext("2d", o);
          else e instanceof HTMLCanvasElement && (a = e.getContext("2d", o));
          return a && (this.renderCanvas(s, this, Hr.TargetCamera, null, a, false), n && n.refresh()),
          this;
        }, preDestroy: function() {
          this.commandBuffer = [];
        } });
        Hr.TargetCamera = new bde();
        $3.exports = Hr;
      });
      fa = u((wLe, e5) => {
        var Dde = ef(), j3 = tf(), Nde = nf(), Zc = { bezier: Dde, catmull: j3, catmullrom: j3, linear: Nde },
        Ide = function(e) {
          if (e === null) return null;
          var t = Zc.linear;
          return typeof e == "string" ? Zc.hasOwnProperty(e) && (t = Zc[e]) : typeof e == "function" &&
          (t = e), t;
        };
        e5.exports = Ide;
      });
      Ph = u((CLe, i5) => {
        var Bde = ss(), Gde = ne(), Ude = C(), zde = ws(), t5 = Zi(), kde = B(), Xde = fa(), Vde = uf(),
        Yde = Ki(), Wde = new Ude({ initialize: function(t, i, r) {
          r === void 0 && (r = false), this.propertyKey = t, this.propertyValue = i, this.defaultValue =
          i, this.steps = 0, this.counter = 0, this.yoyo = false, this.direction = 0, this.start = 0,
          this.current = 0, this.end = 0, this.ease = null, this.interpolation = null, this.emitOnly =
          r, this.onEmit = this.defaultEmit, this.onUpdate = this.defaultUpdate, this.active = true,
          this.method = 0, this._onEmit, this._onUpdate;
        }, loadConfig: function(e, t) {
          e === void 0 && (e = {}), t && (this.propertyKey = t), this.propertyValue = kde(e, this.propertyKey,
          this.defaultValue), this.method = this.getMethod(), this.setMethods(), this.emitOnly && (this.
          onUpdate = this.defaultUpdate);
        }, toJSON: function() {
          return JSON.stringify(this.propertyValue);
        }, onChange: function(e) {
          var t;
          switch (this.method) {
            case 1:
            case 3:
            case 8:
              t = e;
              break;
            case 2:
              this.propertyValue.indexOf(e) >= 0 && (t = e);
              break;
            case 4:
              var i = (this.end - this.start) / this.steps;
              t = Vde(e, i), this.counter = t;
              break;
            case 5:
            case 6:
            case 7:
              t = Gde(e, this.start, this.end);
              break;
            case 9:
              t = this.start[0];
              break;
          }
          return this.current = t, this;
        }, getMethod: function() {
          var e = this.propertyValue;
          if (e === null) return 0;
          var t = typeof e;
          if (t === "number") return 1;
          if (Array.isArray(e)) return 2;
          if (t === "function") return 3;
          if (t === "object") {
            if (this.hasBoth(e, "start", "end")) return this.has(e, "steps") ? 4 : 5;
            if (this.hasBoth(e, "min", "max")) return 6;
            if (this.has(e, "random")) return 7;
            if (this.hasEither(e, "onEmit", "onUpdate")) return 8;
            if (this.hasEither(e, "values", "interpolation")) return 9;
          }
          return 0;
        }, setMethods: function() {
          var e = this.propertyValue, t = e, i = this.defaultEmit, r = this.defaultUpdate;
          switch (this.method) {
            case 1:
              i = this.staticValueEmit;
              break;
            case 2:
              i = this.randomStaticValueEmit, t = e[0];
              break;
            case 3:
              this._onEmit = e, i = this.proxyEmit, t = this.defaultValue;
              break;
            case 4:
              this.start = e.start, this.end = e.end, this.steps = e.steps, this.counter = this.start,
              this.yoyo = this.has(e, "yoyo") ? e.yoyo : false, this.direction = 0, i = this.steppedEmit,
              t = this.start;
              break;
            case 5:
              this.start = e.start, this.end = e.end;
              var s = this.has(e, "ease") ? e.ease : "Linear";
              this.ease = t5(s, e.easeParams), i = this.has(e, "random") && e.random ? this.randomRangedValueEmit :
              this.easedValueEmit, r = this.easeValueUpdate, t = this.start;
              break;
            case 6:
              this.start = e.min, this.end = e.max, i = this.has(e, "int") && e.int ? this.randomRangedIntEmit :
              this.randomRangedValueEmit, t = this.start;
              break;
            case 7:
              var n = e.random;
              Array.isArray(n) && (this.start = n[0], this.end = n[1]), i = this.randomRangedIntEmit,
              t = this.start;
              break;
            case 8:
              this._onEmit = this.has(e, "onEmit") ? e.onEmit : this.defaultEmit, this._onUpdate = this.
              has(e, "onUpdate") ? e.onUpdate : this.defaultUpdate, i = this.proxyEmit, r = this.proxyUpdate,
              t = this.defaultValue;
              break;
            case 9:
              this.start = e.values;
              var a = this.has(e, "ease") ? e.ease : "Linear";
              this.ease = t5(a, e.easeParams), this.interpolation = Xde(e.interpolation), i = this.easedValueEmit,
              r = this.easeValueUpdate, t = this.start[0];
              break;
          }
          return this.onEmit = i, this.onUpdate = r, this.current = t, this;
        }, has: function(e, t) {
          return e.hasOwnProperty(t);
        }, hasBoth: function(e, t, i) {
          return e.hasOwnProperty(t) && e.hasOwnProperty(i);
        }, hasEither: function(e, t, i) {
          return e.hasOwnProperty(t) || e.hasOwnProperty(i);
        }, defaultEmit: function() {
          return this.defaultValue;
        }, defaultUpdate: function(e, t, i, r) {
          return r;
        }, proxyEmit: function(e, t, i) {
          var r = this._onEmit(e, t, i);
          return this.current = r, r;
        }, proxyUpdate: function(e, t, i, r) {
          var s = this._onUpdate(e, t, i, r);
          return this.current = s, s;
        }, staticValueEmit: function() {
          return this.current;
        }, staticValueUpdate: function() {
          return this.current;
        }, randomStaticValueEmit: function() {
          var e = Math.floor(Math.random() * this.propertyValue.length);
          return this.current = this.propertyValue[e], this.current;
        }, randomRangedValueEmit: function(e, t) {
          var i = zde(this.start, this.end);
          return e && e.data[t] && (e.data[t].min = i, e.data[t].max = this.end), this.current = i, i;
        }, randomRangedIntEmit: function(e, t) {
          var i = Bde(this.start, this.end);
          return e && e.data[t] && (e.data[t].min = i, e.data[t].max = this.end), this.current = i, i;
        }, steppedEmit: function() {
          var e = this.counter, t = e, i = (this.end - this.start) / this.steps;
          if (this.yoyo) {
            var r;
            this.direction === 0 ? (t += i, t >= this.end && (r = t - this.end, t = this.end - r, this.
            direction = 1)) : (t -= i, t <= this.start && (r = this.start - t, t = this.start + r, this.
            direction = 0)), this.counter = t;
          } else this.counter = Yde(t + i, this.start, this.end);
          return this.current = e, e;
        }, easedValueEmit: function(e, t) {
          if (e && e.data[t]) {
            var i = e.data[t];
            i.min = this.start, i.max = this.end;
          }
          return this.current = this.start, this.start;
        }, easeValueUpdate: function(e, t, i) {
          var r = e.data[t], s, n = this.ease(i);
          return this.interpolation ? s = this.interpolation(this.start, n) : s = (r.max - r.min) * n +
          r.min, this.current = s, s;
        }, destroy: function() {
          this.propertyValue = null, this.defaultValue = null, this.ease = null, this.interpolation =
          null, this._onEmit = null, this._onUpdate = null;
        } });
        i5.exports = Wde;
      });
      Qc = u((ALe, n5) => {
        var Hde = C(), r5 = Ph(), Kde = po(), s5 = Zi(), Zde = fa(), Qde = Il(), Jde = new Hde({ Extends: r5,
        initialize: function(t) {
          r5.call(this, t, null, false), this.active = false, this.easeName = "Linear", this.r = [],
          this.g = [], this.b = [];
        }, getMethod: function() {
          return this.propertyValue === null ? 0 : 9;
        }, setMethods: function() {
          var e = this.propertyValue, t = e, i = this.defaultEmit, r = this.defaultUpdate;
          if (this.method === 9) {
            this.start = e[0], this.ease = s5("Linear"), this.interpolation = Zde("linear"), i = this.
            easedValueEmit, r = this.easeValueUpdate, t = e[0], this.active = true;
            for (var s = 0; s < e.length; s++) {
              var n = Qde(e[s]);
              this.r.push(n.r), this.g.push(n.g), this.b.push(n.b);
            }
          }
          return this.onEmit = i, this.onUpdate = r, this.current = t, this;
        }, setEase: function(e) {
          this.easeName = e, this.ease = s5(e);
        }, easedValueEmit: function() {
          return this.current = this.start, this.start;
        }, easeValueUpdate: function(e, t, i) {
          var r = this.ease(i), s = this.interpolation(this.r, r), n = this.interpolation(this.g, r),
          a = this.interpolation(this.b, r), o = Kde(s, n, a);
          return this.current = o, o;
        } });
        n5.exports = Jde;
      });
      o5 = u((RLe, a5) => {
        a5.exports = "complete";
      });
      u5 = u((_Le, h5) => {
        h5.exports = "deathzone";
      });
      f5 = u((PLe, l5) => {
        l5.exports = "explode";
      });
      c5 = u((MLe, d5) => {
        d5.exports = "start";
      });
      p5 = u((qLe, v5) => {
        v5.exports = "stop";
      });
      Jc = u((FLe, m5) => {
        m5.exports = { COMPLETE: o5(), DEATH_ZONE: u5(), EXPLODE: f5(), START: c5(), STOP: p5() };
      });
      Mh = u((bLe, g5) => {
        var $de = C(), jde = new $de({ initialize: function(t, i, r) {
          t === void 0 && (t = 0), i === void 0 && (i = 0), r === void 0 && (r = true), this.emitter,
          this.x = t, this.y = i, this.active = r;
        }, update: function() {
        }, destroy: function() {
          this.emitter = null;
        } });
        g5.exports = jde;
      });
      $c = u((LLe, E5) => {
        var ece = C(), da = B(), x5 = Mh(), tce = new ece({ Extends: x5, initialize: function(t, i, r, s, n) {
          if (typeof t == "object") {
            var a = t;
            t = da(a, "x", 0), i = da(a, "y", 0), r = da(a, "power", 0), s = da(a, "epsilon", 100), n =
            da(a, "gravity", 50);
          } else t === void 0 && (t = 0), i === void 0 && (i = 0), r === void 0 && (r = 0), s === void 0 &&
          (s = 100), n === void 0 && (n = 50);
          x5.call(this, t, i, true), this._gravity = n, this._power = r * n, this._epsilon = s * s;
        }, update: function(e, t) {
          var i = this.x - e.x, r = this.y - e.y, s = i * i + r * r;
          if (s !== 0) {
            var n = Math.sqrt(s);
            s < this._epsilon && (s = this._epsilon);
            var a = this._power * t / (s * n) * 100;
            e.velocityX += i * a, e.velocityY += r * a;
          }
        }, epsilon: { get: function() {
          return Math.sqrt(this._epsilon);
        }, set: function(e) {
          this._epsilon = e * e;
        } }, power: { get: function() {
          return this._power / this._gravity;
        }, set: function(e) {
          this._power = e * this._gravity;
        } }, gravity: { get: function() {
          return this._gravity;
        }, set: function(e) {
          var t = this.power;
          this._gravity = e, this.power = t;
        } } });
        E5.exports = tce;
      });
      tv = u((OLe, T52) => {
        var ice = Oa(), jc = ne(), rce = C(), ev = Rr(), sce = he(), qh = eo(), ca = Y(), nce = new rce(
        { initialize: function(t) {
          this.emitter = t, this.texture = null, this.frame = null, this.x = 0, this.y = 0, this.worldPosition =
          new ca(), this.velocityX = 0, this.velocityY = 0, this.accelerationX = 0, this.accelerationY =
          0, this.maxVelocityX = 1e4, this.maxVelocityY = 1e4, this.bounce = 0, this.scaleX = 1, this.
          scaleY = 1, this.alpha = 1, this.angle = 0, this.rotation = 0, this.tint = 16777215, this.
          life = 1e3, this.lifeCurrent = 1e3, this.delayCurrent = 0, this.holdCurrent = 0, this.lifeT =
          0, this.data = { tint: { min: 16777215, max: 16777215 }, alpha: { min: 1, max: 1 }, rotate: {
          min: 0, max: 0 }, scaleX: { min: 1, max: 1 }, scaleY: { min: 1, max: 1 }, x: { min: 0, max: 0 },
          y: { min: 0, max: 0 }, accelerationX: { min: 0, max: 0 }, accelerationY: { min: 0, max: 0 },
          maxVelocityX: { min: 0, max: 0 }, maxVelocityY: { min: 0, max: 0 }, moveToX: { min: 0, max: 0 },
          moveToY: { min: 0, max: 0 }, bounce: { min: 0, max: 0 } }, this.isCropped = false, this.scene =
          t.scene, this.anims = null, this.emitter.anims.length > 0 && (this.anims = new ice(this)),
          this.bounds = new sce();
        }, emit: function(e, t, i, r, s, n) {
          return this.emitter.emit(e, t, i, r, s, n);
        }, isAlive: function() {
          return this.lifeCurrent > 0;
        }, kill: function() {
          this.lifeCurrent = 0;
        }, setPosition: function(e, t) {
          e === void 0 && (e = 0), t === void 0 && (t = 0), this.x = e, this.y = t;
        }, fire: function(e, t) {
          var i = this.emitter, r = i.ops, s = i.getAnim();
          if (s ? this.anims.play(s) : (this.frame = i.getFrame(), this.texture = this.frame.texture),
          !this.frame) throw new Error("Particle has no texture frame");
          if (i.getEmitZone(this), e === void 0 ? this.x += r.x.onEmit(this, "x") : r.x.steps > 0 ? this.
          x += e + r.x.onEmit(this, "x") : this.x += e, t === void 0 ? this.y += r.y.onEmit(this, "y") :
          r.y.steps > 0 ? this.y += t + r.y.onEmit(this, "y") : this.y += t, this.life = r.lifespan.
          onEmit(this, "lifespan"), this.lifeCurrent = this.life, this.lifeT = 0, this.delayCurrent =
          r.delay.onEmit(this, "delay"), this.holdCurrent = r.hold.onEmit(this, "hold"), this.scaleX =
          r.scaleX.onEmit(this, "scaleX"), this.scaleY = r.scaleY.active ? r.scaleY.onEmit(this, "sc\
aleY") : this.scaleX, this.angle = r.rotate.onEmit(this, "rotate"), this.rotation = ev(this.angle), i.
          worldMatrix.transformPoint(this.x, this.y, this.worldPosition), this.delayCurrent === 0 &&
          i.getDeathZone(this)) return this.lifeCurrent = 0, false;
          var n = r.speedX.onEmit(this, "speedX"), a = r.speedY.active ? r.speedY.onEmit(this, "spee\
dY") : n;
          if (i.radial) {
            var o = ev(r.angle.onEmit(this, "angle"));
            this.velocityX = Math.cos(o) * Math.abs(n), this.velocityY = Math.sin(o) * Math.abs(a);
          } else if (i.moveTo) {
            var h = r.moveToX.onEmit(this, "moveToX"), l = r.moveToY.onEmit(this, "moveToY"), f = this.
            life / 1e3;
            this.velocityX = (h - this.x) / f, this.velocityY = (l - this.y) / f;
          } else this.velocityX = n, this.velocityY = a;
          return i.acceleration && (this.accelerationX = r.accelerationX.onEmit(this, "accelerationX"),
          this.accelerationY = r.accelerationY.onEmit(this, "accelerationY")), this.maxVelocityX = r.
          maxVelocityX.onEmit(this, "maxVelocityX"), this.maxVelocityY = r.maxVelocityY.onEmit(this,
          "maxVelocityY"), this.bounce = r.bounce.onEmit(this, "bounce"), this.alpha = r.alpha.onEmit(
          this, "alpha"), r.color.active ? this.tint = r.color.onEmit(this, "tint") : this.tint = r.
          tint.onEmit(this, "tint"), true;
        }, update: function(e, t, i) {
          if (this.lifeCurrent <= 0) return this.holdCurrent > 0 ? (this.holdCurrent -= e, this.holdCurrent <=
          0) : true;
          if (this.delayCurrent > 0) return this.delayCurrent -= e, false;
          this.anims && this.anims.update(0, e);
          var r = this.emitter, s = r.ops, n = 1 - this.lifeCurrent / this.life;
          if (this.lifeT = n, this.x = s.x.onUpdate(this, "x", n, this.x), this.y = s.y.onUpdate(this,
          "y", n, this.y), r.moveTo) {
            var a = s.moveToX.onUpdate(this, "moveToX", n, r.moveToX), o = s.moveToY.onUpdate(this, "\
moveToY", n, r.moveToY), h = this.lifeCurrent / 1e3;
            this.velocityX = (a - this.x) / h, this.velocityY = (o - this.y) / h;
          }
          return this.computeVelocity(r, e, t, i, n), this.scaleX = s.scaleX.onUpdate(this, "scaleX",
          n, this.scaleX), s.scaleY.active ? this.scaleY = s.scaleY.onUpdate(this, "scaleY", n, this.
          scaleY) : this.scaleY = this.scaleX, this.angle = s.rotate.onUpdate(this, "rotate", n, this.
          angle), this.rotation = ev(this.angle), r.getDeathZone(this) ? (this.lifeCurrent = 0, true) :
          (this.alpha = jc(s.alpha.onUpdate(this, "alpha", n, this.alpha), 0, 1), s.color.active ? this.
          tint = s.color.onUpdate(this, "color", n, this.tint) : this.tint = s.tint.onUpdate(this, "\
tint", n, this.tint), this.lifeCurrent -= e, this.lifeCurrent <= 0 && this.holdCurrent <= 0);
        }, computeVelocity: function(e, t, i, r, s) {
          var n = e.ops, a = this.velocityX, o = this.velocityY, h = n.accelerationX.onUpdate(this, "\
accelerationX", s, this.accelerationX), l = n.accelerationY.onUpdate(this, "accelerationY", s, this.
          accelerationY), f = n.maxVelocityX.onUpdate(this, "maxVelocityX", s, this.maxVelocityX), d = n.
          maxVelocityY.onUpdate(this, "maxVelocityY", s, this.maxVelocityY);
          this.bounce = n.bounce.onUpdate(this, "bounce", s, this.bounce), a += e.gravityX * i + h *
          i, o += e.gravityY * i + l * i, a = jc(a, -f, f), o = jc(o, -d, d), this.velocityX = a, this.
          velocityY = o, this.x += a * i, this.y += o * i, e.worldMatrix.transformPoint(this.x, this.
          y, this.worldPosition);
          for (var c = 0; c < r.length; c++) {
            var p = r[c];
            p.active && p.update(this, t, i, s);
          }
        }, setSizeToFrame: function() {
        }, getBounds: function(e) {
          e === void 0 && (e = this.emitter.getWorldTransformMatrix());
          var t = Math.abs(e.scaleX) * this.scaleX, i = Math.abs(e.scaleY) * this.scaleY, r = this.x,
          s = this.y, n = this.rotation, a = this.frame.width * t / 2, o = this.frame.height * i / 2,
          h = this.bounds, l = new ca(r - a, s - o), f = new ca(r + a, s - o), d = new ca(r - a, s +
          o), c = new ca(r + a, s + o);
          return n !== 0 && (qh(l, r, s, n), qh(f, r, s, n), qh(d, r, s, n), qh(c, r, s, n)), e.transformPoint(
          l.x, l.y, l), e.transformPoint(f.x, f.y, f), e.transformPoint(d.x, d.y, d), e.transformPoint(
          c.x, c.y, c), h.x = Math.min(l.x, f.x, d.x, c.x), h.y = Math.min(l.y, f.y, d.y, c.y), h.width =
          Math.max(l.x, f.x, d.x, c.x) - h.x, h.height = Math.max(l.y, f.y, d.y, c.y) - h.y, h;
        }, destroy: function() {
          this.anims && this.anims.destroy(), this.anims = null, this.emitter = null, this.texture =
          null, this.frame = null, this.scene = null;
        } });
        T52.exports = nce;
      });
      iv = u((DLe, S52) => {
        var ace = C(), y5 = Mh(), oce = he(), hce = new ace({ Extends: y5, initialize: function(t, i, r, s, n, a, o, h) {
          n === void 0 && (n = true), a === void 0 && (a = true), o === void 0 && (o = true), h === void 0 &&
          (h = true), y5.call(this, t, i, true), this.bounds = new oce(t, i, r, s), this.collideLeft =
          n, this.collideRight = a, this.collideTop = o, this.collideBottom = h;
        }, update: function(e) {
          var t = this.bounds, i = -e.bounce, r = e.worldPosition;
          r.x < t.x && this.collideLeft ? (e.x += t.x - r.x, e.velocityX *= i) : r.x > t.right && this.
          collideRight && (e.x -= r.x - t.right, e.velocityX *= i), r.y < t.y && this.collideTop ? (e.
          y += t.y - r.y, e.velocityY *= i) : r.y > t.bottom && this.collideBottom && (e.y -= r.y - t.
          bottom, e.velocityY *= i);
        } });
        S52.exports = hce;
      });
      rv = u((NLe, w5) => {
        var uce = C(), lce = new uce({ initialize: function(t, i) {
          this.source = t, this.killOnEnter = i;
        }, willKill: function(e) {
          var t = e.worldPosition, i = this.source.contains(t.x, t.y);
          return i && this.killOnEnter || !i && !this.killOnEnter;
        } });
        w5.exports = lce;
      });
      sv = u((ILe, C5) => {
        var fce = C(), dce = new fce({ initialize: function(t, i, r, s, n, a) {
          s === void 0 && (s = false), n === void 0 && (n = true), a === void 0 && (a = -1), this.source =
          t, this.points = [], this.quantity = i, this.stepRate = r, this.yoyo = s, this.counter = -1,
          this.seamless = n, this._length = 0, this._direction = 0, this.total = a, this.updateSource();
        }, updateSource: function() {
          if (this.points = this.source.getPoints(this.quantity, this.stepRate), this.seamless) {
            var e = this.points[0], t = this.points[this.points.length - 1];
            e.x === t.x && e.y === t.y && this.points.pop();
          }
          var i = this._length;
          return this._length = this.points.length, this._length < i && this.counter > this._length &&
          (this.counter = this._length - 1), this;
        }, changeSource: function(e) {
          return this.source = e, this.updateSource();
        }, getPoint: function(e) {
          this._direction === 0 ? (this.counter++, this.counter >= this._length && (this.yoyo ? (this.
          _direction = 1, this.counter = this._length - 1) : this.counter = 0)) : (this.counter--, this.
          counter === -1 && (this.yoyo ? (this._direction = 0, this.counter = 0) : this.counter = this.
          _length - 1));
          var t = this.points[this.counter];
          t && (e.x = t.x, e.y = t.y);
        } });
        C5.exports = dce;
      });
      nv = u((BLe, A52) => {
        var cce = function(e, t) {
          for (var i = 0; i < t.length; i++) if (e.hasOwnProperty(t[i])) return true;
          return false;
        };
        A52.exports = cce;
      });
      va = u((GLe, R5) => {
        var vce = kr(), pce = function(e, t) {
          var i = vce(e);
          for (var r in t) i.hasOwnProperty(r) && (i[r] = t[r]);
          return i;
        };
        R5.exports = pce;
      });
      av = u((ULe, _5) => {
        var mce = C(), gce = Y(), xce = new mce({ initialize: function(t) {
          this.source = t, this._tempVec = new gce(), this.total = -1;
        }, getPoint: function(e) {
          var t = this._tempVec;
          this.source.getRandomPoint(t), e.x = t.x, e.y = t.y;
        } });
        _5.exports = xce;
      });
      M5 = u((zLe, P5) => {
        var Ece = Eh(), Fh = Lt(), Tce = wt(), yce = new Fh(), Sce = new Fh(), wce = new Fh(), Cce = new Fh(),
        Ace = function(e, t, i, r) {
          var s = e.pipelines.set(t.pipeline), n = yce, a = Sce, o = wce, h = Cce;
          r ? (h.loadIdentity(), h.multiply(r), h.translate(t.x, t.y), h.rotate(t.rotation), h.scale(
          t.scaleX, t.scaleY)) : h.applyITRS(t.x, t.y, t.rotation, t.scaleX, t.scaleY);
          var l = Tce.getTintAppendFloatAlpha, f = i.alpha, d = t.alpha;
          e.pipelines.preBatch(t);
          var c = t.alive, p = c.length, v = t.viewBounds;
          if (!(p === 0 || v && !Ece(v, i.worldView))) {
            t.sortCallback && t.depthSort(), i.addToRenderList(t), n.copyFrom(i.matrix), n.multiplyWithOffset(
            h, -i.scrollX * t.scrollFactorX, -i.scrollY * t.scrollFactorY), e.setBlendMode(t.blendMode),
            t.mask && (t.mask.preRenderWebGL(e, t, i), e.pipelines.set(t.pipeline));
            for (var m = t.tintFill, g, x, E = 0; E < p; E++) {
              var T15 = c[E], w = T15.alpha * d * f;
              if (!(w <= 0 || T15.scaleX === 0 || T15.scaleY === 0)) {
                o.applyITRS(T15.x, T15.y, T15.rotation, T15.scaleX, T15.scaleY), o.e = T15.x, o.f = T15.
                y, n.multiply(o, a);
                var y = T15.frame;
                y.glTexture !== x && (x = y.glTexture, g = s.setGameObject(t, y));
                var A10 = -y.halfWidth, S14 = -y.halfHeight, _ = a.setQuad(A10, S14, A10 + y.width, S14 +
                y.height), q = l(T15.tint, w);
                s.shouldFlush(6) && (s.flush(), g = s.setGameObject(t, y)), s.batchQuad(t, _[0], _[1],
                _[2], _[3], _[4], _[5], _[6], _[7], y.u0, y.v0, y.u1, y.v1, q, q, q, q, m, x, g);
              }
            }
            t.mask && t.mask.postRenderWebGL(e, i), e.pipelines.postBatch(t);
          }
        };
        P5.exports = Ace;
      });
      L5 = u((kLe, b5) => {
        var q5 = J(), F52 = q5, Rce = q5;
        F52 = M5();
        b5.exports = { renderWebGL: F52, renderCanvas: Rce };
      });
      Lh = u((XLe, z5) => {
        var _ce = C(), ai = Ot(), Pce = io(), O52 = Bc(), ov = rv(), D52 = sv(), Mce = Qc(), me = Ph(),
        Zs = Jc(), N5 = ei(), de = B(), I5 = Ku(), qce = $c(), Fce = nv(), ht = ua(), bce = Gc(), Lce = Th(),
        B52 = Uc(), Oce = va(), Dce = tv(), Nce = iv(), G5 = av(), Ice = he(), Bce = Eh(), U5 = Jt(),
        Gce = L5(), Uce = Tn(), zce = Lt(), kce = Y(), Xce = Ki(), bh = ["active", "advance", "blend\
Mode", "colorEase", "deathCallback", "deathCallbackScope", "duration", "emitCallback", "emitCallback\
Scope", "follow", "frequency", "gravityX", "gravityY", "maxAliveParticles", "maxParticles", "name", "\
emitting", "particleBringToTop", "particleClass", "radial", "sortCallback", "sortOrderAsc", "sortPro\
perty", "stopAfter", "tintFill", "timeScale", "trackVisible", "visible"], Qs = ["accelerationX", "ac\
celerationY", "alpha", "angle", "bounce", "color", "delay", "hold", "lifespan", "maxVelocityX", "max\
VelocityY", "moveToX", "moveToY", "quantity", "rotate", "scaleX", "scaleY", "speedX", "speedY", "tin\
t", "x", "y"], Vce = new _ce({ Extends: N5, Mixins: [ai.AlphaSingle, ai.BlendMode, ai.Depth, ai.Mask,
        ai.Pipeline, ai.PostPipeline, ai.ScrollFactor, ai.Texture, ai.Transform, ai.Visible, Gce], initialize: function(t, i, r, s, n) {
          N5.call(this, t, "ParticleEmitter"), this.particleClass = Dce, this.config = null, this.ops =
          { accelerationX: new me("accelerationX", 0), accelerationY: new me("accelerationY", 0), alpha: new me(
          "alpha", 1), angle: new me("angle", { min: 0, max: 360 }, true), bounce: new me("bounce", 0),
          color: new Mce("color"), delay: new me("delay", 0, true), hold: new me("hold", 0, true), lifespan: new me(
          "lifespan", 1e3, true), maxVelocityX: new me("maxVelocityX", 1e4), maxVelocityY: new me("m\
axVelocityY", 1e4), moveToX: new me("moveToX", 0), moveToY: new me("moveToY", 0), quantity: new me("\
quantity", 1, true), rotate: new me("rotate", 0), scaleX: new me("scaleX", 1), scaleY: new me("scale\
Y", 1), speedX: new me("speedX", 0, true), speedY: new me("speedY", 0, true), tint: new me("tint", 16777215),
          x: new me("x", 0), y: new me("y", 0) }, this.radial = true, this.gravityX = 0, this.gravityY =
          0, this.acceleration = false, this.moveTo = false, this.emitCallback = null, this.emitCallbackScope =
          null, this.deathCallback = null, this.deathCallbackScope = null, this.maxParticles = 0, this.
          maxAliveParticles = 0, this.stopAfter = 0, this.duration = 0, this.frequency = 0, this.emitting =
          true, this.particleBringToTop = true, this.timeScale = 1, this.emitZones = [], this.deathZones =
          [], this.viewBounds = null, this.follow = null, this.followOffset = new kce(), this.trackVisible =
          false, this.frames = [], this.randomFrame = true, this.frameQuantity = 1, this.anims = [],
          this.randomAnim = true, this.animQuantity = 1, this.dead = [], this.alive = [], this.counters =
          new Float32Array(10), this.skipping = false, this.worldMatrix = new zce(), this.sortProperty =
          "", this.sortOrderAsc = true, this.sortCallback = this.depthSortCallback, this.processors =
          new Lce(this), this.tintFill = false, this.initPipeline(), this.initPostPipeline(), this.setPosition(
          i, r), this.setTexture(s), n && this.setConfig(n);
        }, addedToScene: function() {
          this.scene.sys.updateList.add(this);
        }, removedFromScene: function() {
          this.scene.sys.updateList.remove(this);
        }, setConfig: function(e) {
          if (!e) return this;
          this.config = e;
          var t = 0, i = "", r = this.ops;
          for (t = 0; t < Qs.length; t++) i = Qs[t], r[i].loadConfig(e);
          for (t = 0; t < bh.length; t++) i = bh[t], ht(e, i) && (this[i] = de(e, i));
          if (this.acceleration = this.accelerationX !== 0 || this.accelerationY !== 0, this.moveTo =
          this.moveToX !== 0 && this.moveToY !== 0, ht(e, "speed") && (r.speedX.loadConfig(e, "speed"),
          r.speedY.active = false), (Fce(e, ["speedX", "speedY"]) || this.moveTo) && (this.radial = false),
          ht(e, "scale") && (r.scaleX.loadConfig(e, "scale"), r.scaleY.active = false), ht(e, "callb\
ackScope")) {
            var s = de(e, "callbackScope", null);
            this.emitCallbackScope = s, this.deathCallbackScope = s;
          }
          if (ht(e, "emitZone") && this.addEmitZone(e.emitZone), ht(e, "deathZone") && this.addDeathZone(
          e.deathZone), ht(e, "bounds")) {
            var n = this.addParticleBounds(e.bounds);
            n.collideLeft = de(e, "collideLeft", true), n.collideRight = de(e, "collideRight", true),
            n.collideTop = de(e, "collideTop", true), n.collideBottom = de(e, "collideBottom", true);
          }
          return ht(e, "followOffset") && this.followOffset.setFromObject(de(e, "followOffset", 0)),
          ht(e, "texture") && this.setTexture(e.texture), ht(e, "frame") ? this.setEmitterFrame(e.frame) :
          ht(e, "anim") && this.setAnim(e.anim), ht(e, "reserve") && this.reserve(e.reserve), ht(e, "\
advance") && this.fastForward(e.advance), this.resetCounters(this.frequency, this.emitting), this.emitting &&
          this.emit(Zs.START, this), this;
        }, updateConfig: function(e) {
          return e && (this.config ? this.setConfig(Oce(this.config, e)) : this.setConfig(e)), this;
        }, toJSON: function() {
          var e = Pce(this), t = 0, i = "";
          for (t = 0; t < bh.length; t++) i = bh[t], e[i] = this[i];
          var r = this.ops;
          for (t = 0; t < Qs.length; t++) i = Qs[t], r[i] && (e[i] = r[i].toJSON());
          return r.speedY.active || (delete e.speedX, e.speed = r.speedX.toJSON()), this.scaleX === this.
          scaleY && (delete e.scaleX, delete e.scaleY, e.scale = r.scaleX.toJSON()), e;
        }, resetCounters: function(e, t) {
          var i = this.counters;
          i.fill(0), i[0] = e, t && (i[5] = 1);
        }, startFollow: function(e, t, i, r) {
          return t === void 0 && (t = 0), i === void 0 && (i = 0), r === void 0 && (r = false), this.
          follow = e, this.followOffset.set(t, i), this.trackVisible = r, this;
        }, stopFollow: function() {
          return this.follow = null, this.followOffset.set(0, 0), this.trackVisible = false, this;
        }, getFrame: function() {
          var e = this.frames, t = e.length, i;
          return t === 1 ? i = e[0] : this.randomFrame ? i = I5(e) : (i = e[this.currentFrame], this.
          frameCounter++, this.frameCounter === this.frameQuantity && (this.frameCounter = 0, this.currentFrame++,
          this.currentFrame === t && (this.currentFrame = 0))), this.texture.get(i);
        }, setEmitterFrame: function(e, t, i) {
          t === void 0 && (t = true), i === void 0 && (i = 1), this.randomFrame = t, this.frameQuantity =
          i, this.currentFrame = 0;
          var r = typeof e;
          if (this.frames.length = 0, Array.isArray(e)) this.frames = this.frames.concat(e);
          else if (r === "string" || r === "number") this.frames.push(e);
          else if (r === "object") {
            var s = e;
            e = de(s, "frames", null), e && (this.frames = this.frames.concat(e));
            var n = de(s, "cycle", false);
            this.randomFrame = !n, this.frameQuantity = de(s, "quantity", i);
          }
          return this.frames.length === 1 && (this.frameQuantity = 1, this.randomFrame = false), this;
        }, getAnim: function() {
          var e = this.anims, t = e.length;
          if (t === 0) return null;
          if (t === 1) return e[0];
          if (this.randomAnim) return I5(e);
          var i = e[this.currentAnim];
          return this.animCounter++, this.animCounter >= this.animQuantity && (this.animCounter = 0,
          this.currentAnim = Xce(this.currentAnim + 1, 0, t)), i;
        }, setAnim: function(e, t, i) {
          t === void 0 && (t = true), i === void 0 && (i = 1), this.randomAnim = t, this.animQuantity =
          i, this.currentAnim = 0;
          var r = typeof e;
          if (this.anims.length = 0, Array.isArray(e)) this.anims = this.anims.concat(e);
          else if (r === "string") this.anims.push(e);
          else if (r === "object") {
            var s = e;
            e = de(s, "anims", null), e && (this.anims = this.anims.concat(e));
            var n = de(s, "cycle", false);
            this.randomAnim = !n, this.animQuantity = de(s, "quantity", i);
          }
          return this.anims.length === 1 && (this.animQuantity = 1, this.randomAnim = false), this;
        }, setRadial: function(e) {
          return e === void 0 && (e = true), this.radial = e, this;
        }, addParticleBounds: function(e, t, i, r, s, n, a, o) {
          if (typeof e == "object") {
            var h = e;
            e = h.x, t = h.y, i = ht(h, "w") ? h.w : h.width, r = ht(h, "h") ? h.h : h.height;
          }
          return this.addParticleProcessor(new Nce(e, t, i, r, s, n, a, o));
        }, setParticleSpeed: function(e, t) {
          return t === void 0 && (t = e), this.ops.speedX.onChange(e), e === t ? this.ops.speedY.active =
          false : this.ops.speedY.onChange(t), this.radial = true, this;
        }, setParticleScale: function(e, t) {
          return e === void 0 && (e = 1), t === void 0 && (t = e), this.ops.scaleX.onChange(e), this.
          ops.scaleY.onChange(t), this;
        }, setParticleGravity: function(e, t) {
          return this.gravityX = e, this.gravityY = t, this;
        }, setParticleAlpha: function(e) {
          return this.ops.alpha.onChange(e), this;
        }, setParticleTint: function(e) {
          return this.ops.tint.onChange(e), this;
        }, setEmitterAngle: function(e) {
          return this.ops.angle.onChange(e), this;
        }, setParticleLifespan: function(e) {
          return this.ops.lifespan.onChange(e), this;
        }, setQuantity: function(e) {
          return this.quantity = e, this;
        }, setFrequency: function(e, t) {
          return this.frequency = e, this.flowCounter = e > 0 ? e : 0, t && (this.quantity = t), this;
        }, addDeathZone: function(e) {
          Array.isArray(e) || (e = [e]);
          for (var t, i = [], r = 0; r < e.length; r++) if (t = e[r], t instanceof ov) i.push(t);
          else if (typeof t.contains == "function") t = new ov(t, true), i.push(t);
          else {
            var s = de(t, "type", "onEnter"), n = de(t, "source", null);
            if (n && typeof n.contains == "function") {
              var a = s === "onEnter";
              t = new ov(n, a), i.push(t);
            }
          }
          return this.deathZones = this.deathZones.concat(i), i;
        }, removeDeathZone: function(e) {
          return U5(this.deathZones, e), this;
        }, clearDeathZones: function() {
          return this.deathZones.length = 0, this;
        }, addEmitZone: function(e) {
          Array.isArray(e) || (e = [e]);
          for (var t, i = [], r = 0; r < e.length; r++) if (t = e[r], t instanceof G5 || t instanceof
          D52) i.push(t);
          else {
            var s = de(t, "source", null);
            if (s) {
              var n = de(t, "type", "random");
              if (n === "random" && typeof s.getRandomPoint == "function") t = new G5(s), i.push(t);
              else if (n === "edge" && typeof s.getPoints == "function") {
                var a = de(t, "quantity", 1), o = de(t, "stepRate", 0), h = de(t, "yoyo", false), l = de(
                t, "seamless", true), f = de(t, "total", -1);
                t = new D52(s, a, o, h, l, f), i.push(t);
              }
            }
          }
          return this.emitZones = this.emitZones.concat(i), i;
        }, removeEmitZone: function(e) {
          return U5(this.emitZones, e), this.zoneIndex = 0, this;
        }, clearEmitZones: function() {
          return this.emitZones.length = 0, this.zoneIndex = 0, this;
        }, getEmitZone: function(e) {
          var t = this.emitZones, i = t.length;
          if (i !== 0) {
            var r = t[this.zoneIndex];
            r.getPoint(e), r.total > -1 && (this.zoneTotal++, this.zoneTotal === r.total && (this.zoneTotal =
            0, this.zoneIndex++, this.zoneIndex === i && (this.zoneIndex = 0)));
          }
        }, getDeathZone: function(e) {
          for (var t = this.deathZones, i = 0; i < t.length; i++) {
            var r = t[i];
            if (r.willKill(e)) return this.emit(Zs.DEATH_ZONE, this, e, r), true;
          }
          return false;
        }, setEmitZone: function(e) {
          var t;
          return isFinite(e) ? t = e : t = this.emitZones.indexOf(e), t >= 0 && (this.zoneIndex = t),
          this;
        }, addParticleProcessor: function(e) {
          return this.processors.exists(e) || (e.emitter && e.emitter.removeParticleProcessor(e), this.
          processors.add(e), e.emitter = this), e;
        }, removeParticleProcessor: function(e) {
          return this.processors.exists(e) && (this.processors.remove(e, true), e.emitter = null), e;
        }, getProcessors: function() {
          return this.processors.getAll("active", true);
        }, createGravityWell: function(e) {
          return this.addParticleProcessor(new qce(e));
        }, reserve: function(e) {
          var t = this.dead;
          if (this.maxParticles > 0) {
            var i = this.getParticleCount();
            i + e > this.maxParticles && (e = this.maxParticles - (i + e));
          }
          for (var r = 0; r < e; r++) t.push(new this.particleClass(this));
          return this;
        }, getAliveParticleCount: function() {
          return this.alive.length;
        }, getDeadParticleCount: function() {
          return this.dead.length;
        }, getParticleCount: function() {
          return this.getAliveParticleCount() + this.getDeadParticleCount();
        }, atLimit: function() {
          return this.maxParticles > 0 && this.getParticleCount() >= this.maxParticles ? true : this.
          maxAliveParticles > 0 && this.getAliveParticleCount() >= this.maxAliveParticles;
        }, onParticleEmit: function(e, t) {
          return e === void 0 ? (this.emitCallback = null, this.emitCallbackScope = null) : typeof e ==
          "function" && (this.emitCallback = e, t && (this.emitCallbackScope = t)), this;
        }, onParticleDeath: function(e, t) {
          return e === void 0 ? (this.deathCallback = null, this.deathCallbackScope = null) : typeof e ==
          "function" && (this.deathCallback = e, t && (this.deathCallbackScope = t)), this;
        }, killAll: function() {
          for (var e = this.dead, t = this.alive; t.length > 0; ) e.push(t.pop());
          return this;
        }, forEachAlive: function(e, t) {
          for (var i = this.alive, r = i.length, s = 0; s < r; s++) e.call(t, i[s], this);
          return this;
        }, forEachDead: function(e, t) {
          for (var i = this.dead, r = i.length, s = 0; s < r; s++) e.call(t, i[s], this);
          return this;
        }, start: function(e, t) {
          return e === void 0 && (e = 0), this.emitting || (e > 0 && this.fastForward(e), this.emitting =
          true, this.resetCounters(this.frequency, true), t !== void 0 && (this.duration = Math.abs(
          t)), this.emit(Zs.START, this)), this;
        }, stop: function(e) {
          return e === void 0 && (e = false), this.emitting && (this.emitting = false, e && this.killAll(),
          this.emit(Zs.STOP, this)), this;
        }, pause: function() {
          return this.active = false, this;
        }, resume: function() {
          return this.active = true, this;
        }, setSortProperty: function(e, t) {
          return e === void 0 && (e = ""), t === void 0 && (t = this.true), this.sortProperty = e, this.
          sortOrderAsc = t, this.sortCallback = this.depthSortCallback, this;
        }, setSortCallback: function(e) {
          return this.sortProperty !== "" ? e = this.depthSortCallback : e = null, this.sortCallback =
          e, this;
        }, depthSort: function() {
          return Uce(this.alive, this.sortCallback.bind(this)), this;
        }, depthSortCallback: function(e, t) {
          var i = this.sortProperty;
          return this.sortOrderAsc ? e[i] - t[i] : t[i] - e[i];
        }, flow: function(e, t, i) {
          return t === void 0 && (t = 1), this.emitting = false, this.frequency = e, this.quantity =
          t, i !== void 0 && (this.stopAfter = i), this.start();
        }, explode: function(e, t, i) {
          this.frequency = -1, this.resetCounters(-1, true);
          var r = this.emitParticle(e, t, i);
          return this.emit(Zs.EXPLODE, this, r), r;
        }, emitParticleAt: function(e, t, i) {
          return this.emitParticle(i, e, t);
        }, emitParticle: function(e, t, i) {
          if (!this.atLimit()) {
            e === void 0 && (e = this.ops.quantity.onEmit());
            for (var r = this.dead, s = this.stopAfter, n = this.follow ? this.follow.x + this.followOffset.
            x : t, a = this.follow ? this.follow.y + this.followOffset.y : i, o = 0; o < e; o++) {
              var h = r.pop();
              if (h || (h = new this.particleClass(this)), h.fire(n, a) ? (this.particleBringToTop ?
              this.alive.push(h) : this.alive.unshift(h), this.emitCallback && this.emitCallback.call(
              this.emitCallbackScope, h, this)) : this.dead.push(h), s > 0 && (this.stopCounter++, this.
              stopCounter >= s) || this.atLimit()) break;
            }
            return h;
          }
        }, fastForward: function(e, t) {
          t === void 0 && (t = 1e3 / 60);
          var i = 0;
          for (this.skipping = true; i < Math.abs(e); ) this.preUpdate(0, t), i += t;
          return this.skipping = false, this;
        }, preUpdate: function(e, t) {
          t *= this.timeScale;
          var i = t / 1e3;
          this.trackVisible && (this.visible = this.follow.visible), this.getWorldTransformMatrix(this.
          worldMatrix);
          var r = this.getProcessors(), s = this.alive, n = this.dead, a = 0, o = [], h = s.length;
          for (a = 0; a < h; a++) {
            var l = s[a];
            l.update(t, i, r) && o.push({ index: a, particle: l });
          }
          if (h = o.length, h > 0) {
            var f = this.deathCallback, d = this.deathCallbackScope;
            for (a = h - 1; a >= 0; a--) {
              var c = o[a];
              s.splice(c.index, 1), n.push(c.particle), f && f.call(d, c.particle), c.particle.setPosition();
            }
          }
          if (!this.emitting && !this.skipping) {
            this.completeFlag === 1 && s.length === 0 && (this.completeFlag = 0, this.emit(Zs.COMPLETE,
            this));
            return;
          }
          if (this.frequency === 0) this.emitParticle();
          else if (this.frequency > 0) for (this.flowCounter -= t; this.flowCounter <= 0; ) this.emitParticle(),
          this.flowCounter += this.frequency;
          this.skipping || (this.duration > 0 && (this.elapsed += t, this.elapsed >= this.duration &&
          this.stop()), this.stopAfter > 0 && this.stopCounter >= this.stopAfter && this.stop());
        }, overlap: function(e) {
          for (var t = this.getWorldTransformMatrix(), i = this.alive, r = i.length, s = [], n = 0; n <
          r; n++) {
            var a = i[n];
            Bce(e, a.getBounds(t)) && s.push(a);
          }
          return s;
        }, getBounds: function(e, t, i, r) {
          e === void 0 && (e = 0), t === void 0 && (t = 0), i === void 0 && (i = 1e3 / 60), r === void 0 &&
          (r = new Ice());
          var s = this.getWorldTransformMatrix(), n, a, o = this.alive, h = false;
          if (r.setTo(0, 0, 0, 0), t > 0) {
            var l = 0;
            for (this.skipping = true; l < Math.abs(t); ) {
              for (this.preUpdate(0, i), n = 0; n < o.length; n++) a = o[n].getBounds(s), h ? B52(r,
              a) : (h = true, O52(a, r));
              l += i;
            }
            this.skipping = false;
          } else for (n = 0; n < o.length; n++) a = o[n].getBounds(s), h ? B52(r, a) : (h = true, O52(
          a, r));
          return e > 0 && bce(r, e, e), r;
        }, createEmitter: function() {
          throw new Error("createEmitter removed. See ParticleEmitter docs for info");
        }, particleX: { get: function() {
          return this.ops.x.current;
        }, set: function(e) {
          this.ops.x.onChange(e);
        } }, particleY: { get: function() {
          return this.ops.y.current;
        }, set: function(e) {
          this.ops.y.onChange(e);
        } }, accelerationX: { get: function() {
          return this.ops.accelerationX.current;
        }, set: function(e) {
          this.ops.accelerationX.onChange(e);
        } }, accelerationY: { get: function() {
          return this.ops.accelerationY.current;
        }, set: function(e) {
          this.ops.accelerationY.onChange(e);
        } }, maxVelocityX: { get: function() {
          return this.ops.maxVelocityX.current;
        }, set: function(e) {
          this.ops.maxVelocityX.onChange(e);
        } }, maxVelocityY: { get: function() {
          return this.ops.maxVelocityY.current;
        }, set: function(e) {
          this.ops.maxVelocityY.onChange(e);
        } }, speed: { get: function() {
          return this.ops.speedX.current;
        }, set: function(e) {
          this.ops.speedX.onChange(e), this.ops.speedY.onChange(e);
        } }, speedX: { get: function() {
          return this.ops.speedX.current;
        }, set: function(e) {
          this.ops.speedX.onChange(e);
        } }, speedY: { get: function() {
          return this.ops.speedY.current;
        }, set: function(e) {
          this.ops.speedY.onChange(e);
        } }, moveToX: { get: function() {
          return this.ops.moveToX.current;
        }, set: function(e) {
          this.ops.moveToX.onChange(e);
        } }, moveToY: { get: function() {
          return this.ops.moveToY.current;
        }, set: function(e) {
          this.ops.moveToY.onChange(e);
        } }, bounce: { get: function() {
          return this.ops.bounce.current;
        }, set: function(e) {
          this.ops.bounce.onChange(e);
        } }, particleScaleX: { get: function() {
          return this.ops.scaleX.current;
        }, set: function(e) {
          this.ops.scaleX.onChange(e);
        } }, particleScaleY: { get: function() {
          return this.ops.scaleY.current;
        }, set: function(e) {
          this.ops.scaleY.onChange(e);
        } }, particleColor: { get: function() {
          return this.ops.color.current;
        }, set: function(e) {
          this.ops.color.onChange(e);
        } }, colorEase: { get: function() {
          return this.ops.color.easeName;
        }, set: function(e) {
          this.ops.color.setEase(e);
        } }, particleTint: { get: function() {
          return this.ops.tint.current;
        }, set: function(e) {
          this.ops.tint.onChange(e);
        } }, particleAlpha: { get: function() {
          return this.ops.alpha.current;
        }, set: function(e) {
          this.ops.alpha.onChange(e);
        } }, lifespan: { get: function() {
          return this.ops.lifespan.current;
        }, set: function(e) {
          this.ops.lifespan.onChange(e);
        } }, particleAngle: { get: function() {
          return this.ops.angle.current;
        }, set: function(e) {
          this.ops.angle.onChange(e);
        } }, particleRotate: { get: function() {
          return this.ops.rotate.current;
        }, set: function(e) {
          this.ops.rotate.onChange(e);
        } }, quantity: { get: function() {
          return this.ops.quantity.current;
        }, set: function(e) {
          this.ops.quantity.onChange(e);
        } }, delay: { get: function() {
          return this.ops.delay.current;
        }, set: function(e) {
          this.ops.delay.onChange(e);
        } }, hold: { get: function() {
          return this.ops.hold.current;
        }, set: function(e) {
          this.ops.hold.onChange(e);
        } }, flowCounter: { get: function() {
          return this.counters[0];
        }, set: function(e) {
          this.counters[0] = e;
        } }, frameCounter: { get: function() {
          return this.counters[1];
        }, set: function(e) {
          this.counters[1] = e;
        } }, animCounter: { get: function() {
          return this.counters[2];
        }, set: function(e) {
          this.counters[2] = e;
        } }, elapsed: { get: function() {
          return this.counters[3];
        }, set: function(e) {
          this.counters[3] = e;
        } }, stopCounter: { get: function() {
          return this.counters[4];
        }, set: function(e) {
          this.counters[4] = e;
        } }, completeFlag: { get: function() {
          return this.counters[5];
        }, set: function(e) {
          this.counters[5] = e;
        } }, zoneIndex: { get: function() {
          return this.counters[6];
        }, set: function(e) {
          this.counters[6] = e;
        } }, zoneTotal: { get: function() {
          return this.counters[7];
        }, set: function(e) {
          this.counters[7] = e;
        } }, currentFrame: { get: function() {
          return this.counters[8];
        }, set: function(e) {
          this.counters[8] = e;
        } }, currentAnim: { get: function() {
          return this.counters[9];
        }, set: function(e) {
          this.counters[9] = e;
        } }, preDestroy: function() {
          this.texture = null, this.frames = null, this.anims = null, this.emitCallback = null, this.
          emitCallbackScope = null, this.deathCallback = null, this.deathCallbackScope = null, this.
          emitZones = null, this.deathZones = null, this.bounds = null, this.follow = null, this.counters =
          null;
          var e, t = this.ops;
          for (e = 0; e < Qs.length; e++) {
            var i = Qs[e];
            t[i].destroy();
          }
          for (e = 0; e < this.alive.length; e++) this.alive[e].destroy();
          for (e = 0; e < this.dead.length; e++) this.dead[e].destroy();
          this.ops = null, this.alive = [], this.dead = [], this.worldMatrix.destroy();
        } });
        z5.exports = Vce;
      });
      X5 = u((VLe, k5) => {
        k5.exports = { DeathZone: rv(), EdgeZone: sv(), RandomZone: av() };
      });
      Y5 = u((YLe, V52) => {
        V52.exports = { EmitterColorOp: Qc(), EmitterOp: Ph(), Events: Jc(), GravityWell: $c(), Particle: tv(),
        ParticleBounds: iv(), ParticleEmitter: Lh(), ParticleProcessor: Mh(), Zones: X5() };
      });
      H5 = u((WLe, W5) => {
        var Yce = function(e, t, i) {
          var r = e.canvas, s = e.context, n = e.style, a = [], o = 0, h = i.length;
          n.maxLines > 0 && n.maxLines < i.length && (h = n.maxLines), n.syncFont(r, s);
          for (var l = e.letterSpacing, f = 0; f < h; f++) {
            var d = n.strokeThickness;
            if (l === 0) d += s.measureText(i[f]).width;
            else {
              for (var c = i[f], p = 0; p < c.length; p++) d += s.measureText(c[p]).width;
              c.length > 1 && (d += l * (c.length - 1));
            }
            n.wordWrap && (d -= s.measureText(" ").width), a[f] = Math.ceil(d), o = Math.max(o, a[f]);
          }
          var v = t.fontSize + n.strokeThickness, m = v * h, g = e.lineSpacing;
          return h > 1 && (m += g * (h - 1)), { width: o, height: m, lines: h, lineWidths: a, lineSpacing: g,
          lineHeight: v };
        };
        W5.exports = Yce;
      });
      Z5 = u((HLe, K5) => {
        var Wce = function(e) {
          e.parentNode && e.parentNode.removeChild(e);
        };
        K5.exports = Wce;
      });
      J5 = u((KLe, Q5) => {
        var Hce = wt(), Kce = function(e, t, i, r) {
          if (!(t.width === 0 || t.height === 0)) {
            i.addToRenderList(t);
            var s = t.frame, n = s.width, a = s.height, o = Hce.getTintAppendFloatAlpha, h = e.pipelines.
            set(t.pipeline, t), l = h.setTexture2D(s.glTexture, t);
            h.batchTexture(t, s.glTexture, n, a, t.x, t.y, n / t.style.resolution, a / t.style.resolution,
            t.scaleX, t.scaleY, t.rotation, t.flipX, t.flipY, t.scrollFactorX, t.scrollFactorY, t.displayOriginX,
            t.displayOriginY, 0, 0, n, a, o(t.tintTopLeft, i.alpha * t._alphaTL), o(t.tintTopRight, i.
            alpha * t._alphaTR), o(t.tintBottomLeft, i.alpha * t._alphaBL), o(t.tintBottomRight, i.alpha *
            t._alphaBR), t.tintFill, 0, 0, i, r, false, l);
          }
        };
        Q5.exports = Kce;
      });
      tk = u((ZLe, ek) => {
        var $5 = J(), j5 = $5, Zce = $5;
        j5 = J5();
        ek.exports = { renderWebGL: j5, renderCanvas: Zce };
      });
      rk = u((QLe, ik) => {
        var Oh = Tt(), Qce = function(e) {
          var t = Oh.create(this), i = t.getContext("2d", { willReadFrequently: true });
          e.syncFont(t, i);
          var r = i.measureText(e.testString);
          if ("actualBoundingBoxAscent" in r) {
            var s = r.actualBoundingBoxAscent, n = r.actualBoundingBoxDescent;
            return Oh.remove(t), { ascent: s, descent: n, fontSize: s + n };
          }
          var a = Math.ceil(r.width * e.baselineX), o = a, h = 2 * o;
          o = o * e.baselineY | 0, t.width = a, t.height = h, i.fillStyle = "#f00", i.fillRect(0, 0,
          a, h), i.font = e._font, i.textBaseline = "alphabetic", i.fillStyle = "#000", i.fillText(e.
          testString, 0, o);
          var l = { ascent: 0, descent: 0, fontSize: 0 }, f = i.getImageData(0, 0, a, h);
          if (!f) return l.ascent = o, l.descent = o + 6, l.fontSize = l.ascent + l.descent, Oh.remove(
          t), l;
          var d = f.data, c = d.length, p = a * 4, v, m, g = 0, x = false;
          for (v = 0; v < o; v++) {
            for (m = 0; m < p; m += 4) if (d[g + m] !== 255) {
              x = true;
              break;
            }
            if (!x) g += p;
            else break;
          }
          for (l.ascent = o - v, g = c - p, x = false, v = h; v > o; v--) {
            for (m = 0; m < p; m += 4) if (d[g + m] !== 255) {
              x = true;
              break;
            }
            if (!x) g -= p;
            else break;
          }
          return l.descent = v - o, l.fontSize = l.ascent + l.descent, Oh.remove(t), l;
        };
        ik.exports = Qce;
      });
      ak = u((JLe, nk) => {
        var Jce = C(), $ce = ot(), oi = H(), sk = rk(), pa = { fontFamily: ["fontFamily", "Courier"],
        fontSize: ["fontSize", "16px"], fontStyle: ["fontStyle", ""], backgroundColor: ["backgroundC\
olor", null], color: ["color", "#fff"], stroke: ["stroke", "#fff"], strokeThickness: ["strokeThickne\
ss", 0], shadowOffsetX: ["shadow.offsetX", 0], shadowOffsetY: ["shadow.offsetY", 0], shadowColor: ["\
shadow.color", "#000"], shadowBlur: ["shadow.blur", 0], shadowStroke: ["shadow.stroke", false], shadowFill: [
        "shadow.fill", false], align: ["align", "left"], maxLines: ["maxLines", 0], fixedWidth: ["fi\
xedWidth", 0], fixedHeight: ["fixedHeight", 0], resolution: ["resolution", 0], rtl: ["rtl", false], testString: [
        "testString", "|M\xC3\u2030qgy"], baselineX: ["baselineX", 1.2], baselineY: ["baselineY", 1.4],
        wordWrapWidth: ["wordWrap.width", null], wordWrapCallback: ["wordWrap.callback", null], wordWrapCallbackScope: [
        "wordWrap.callbackScope", null], wordWrapUseAdvanced: ["wordWrap.useAdvancedWrap", false] },
        jce = new Jce({ initialize: function(t, i) {
          this.parent = t, this.fontFamily, this.fontSize, this.fontStyle, this.backgroundColor, this.
          color, this.stroke, this.strokeThickness, this.shadowOffsetX, this.shadowOffsetY, this.shadowColor,
          this.shadowBlur, this.shadowStroke, this.shadowFill, this.align, this.maxLines, this.fixedWidth,
          this.fixedHeight, this.resolution, this.rtl, this.testString, this.baselineX, this.baselineY,
          this.wordWrapWidth, this.wordWrapCallback, this.wordWrapCallbackScope, this.wordWrapUseAdvanced,
          this._font, this.setStyle(i, false, true);
        }, setStyle: function(e, t, i) {
          t === void 0 && (t = true), i === void 0 && (i = false);
          for (var r in pa) {
            var s = i ? pa[r][1] : this[r];
            r === "wordWrapCallback" || r === "wordWrapCallbackScope" ? this[r] = oi(e, pa[r][0], s) :
            e && r === "fontSize" && typeof e.fontSize == "number" ? this[r] = e.fontSize.toString() +
            "px" : this[r] = $ce(e, pa[r][0], s);
          }
          var n = oi(e, "font", null);
          n !== null && this.setFont(n, false), this._font = [this.fontStyle, this.fontSize, this.fontFamily].
          join(" ").trim();
          var a = oi(e, "fill", null);
          a !== null && (this.color = a);
          var o = oi(e, "metrics", false);
          return o ? this.metrics = { ascent: oi(o, "ascent", 0), descent: oi(o, "descent", 0), fontSize: oi(
          o, "fontSize", 0) } : (t || !this.metrics) && (this.metrics = sk(this)), t ? this.parent.updateText() :
          this.parent;
        }, syncFont: function(e, t) {
          t.font = this._font;
        }, syncStyle: function(e, t) {
          t.textBaseline = "alphabetic", t.fillStyle = this.color, t.strokeStyle = this.stroke, t.lineWidth =
          this.strokeThickness, t.lineCap = "round", t.lineJoin = "round";
        }, syncShadow: function(e, t) {
          t ? (e.shadowOffsetX = this.shadowOffsetX, e.shadowOffsetY = this.shadowOffsetY, e.shadowColor =
          this.shadowColor, e.shadowBlur = this.shadowBlur) : (e.shadowOffsetX = 0, e.shadowOffsetY =
          0, e.shadowColor = 0, e.shadowBlur = 0);
        }, update: function(e) {
          return e && (this._font = [this.fontStyle, this.fontSize, this.fontFamily].join(" ").trim(),
          this.metrics = sk(this)), this.parent.updateText();
        }, setFont: function(e, t) {
          t === void 0 && (t = true);
          var i = e, r = "", s = "";
          if (typeof e != "string") i = oi(e, "fontFamily", "Courier"), r = oi(e, "fontSize", "16px"),
          s = oi(e, "fontStyle", "");
          else {
            var n = e.split(" "), a = 0;
            s = n.length > 2 ? n[a++] : "", r = n[a++] || "16px", i = n[a++] || "Courier";
          }
          return (i !== this.fontFamily || r !== this.fontSize || s !== this.fontStyle) && (this.fontFamily =
          i, this.fontSize = r, this.fontStyle = s, t && this.update(true)), this.parent;
        }, setFontFamily: function(e) {
          return this.fontFamily !== e && (this.fontFamily = e, this.update(true)), this.parent;
        }, setFontStyle: function(e) {
          return this.fontStyle !== e && (this.fontStyle = e, this.update(true)), this.parent;
        }, setFontSize: function(e) {
          return typeof e == "number" && (e = e.toString() + "px"), this.fontSize !== e && (this.fontSize =
          e, this.update(true)), this.parent;
        }, setTestString: function(e) {
          return this.testString = e, this.update(true);
        }, setFixedSize: function(e, t) {
          return this.fixedWidth = e, this.fixedHeight = t, e && (this.parent.width = e), t && (this.
          parent.height = t), this.update(false);
        }, setBackgroundColor: function(e) {
          return this.backgroundColor = e, this.update(false);
        }, setFill: function(e) {
          return this.color = e, this.update(false);
        }, setColor: function(e) {
          return this.color = e, this.update(false);
        }, setResolution: function(e) {
          return this.resolution = e, this.update(false);
        }, setStroke: function(e, t) {
          return t === void 0 && (t = this.strokeThickness), e === void 0 && this.strokeThickness !==
          0 ? (this.strokeThickness = 0, this.update(true)) : (this.stroke !== e || this.strokeThickness !==
          t) && (this.stroke = e, this.strokeThickness = t, this.update(true)), this.parent;
        }, setShadow: function(e, t, i, r, s, n) {
          return e === void 0 && (e = 0), t === void 0 && (t = 0), i === void 0 && (i = "#000"), r ===
          void 0 && (r = 0), s === void 0 && (s = false), n === void 0 && (n = true), this.shadowOffsetX =
          e, this.shadowOffsetY = t, this.shadowColor = i, this.shadowBlur = r, this.shadowStroke = s,
          this.shadowFill = n, this.update(false);
        }, setShadowOffset: function(e, t) {
          return e === void 0 && (e = 0), t === void 0 && (t = e), this.shadowOffsetX = e, this.shadowOffsetY =
          t, this.update(false);
        }, setShadowColor: function(e) {
          return e === void 0 && (e = "#000"), this.shadowColor = e, this.update(false);
        }, setShadowBlur: function(e) {
          return e === void 0 && (e = 0), this.shadowBlur = e, this.update(false);
        }, setShadowStroke: function(e) {
          return this.shadowStroke = e, this.update(false);
        }, setShadowFill: function(e) {
          return this.shadowFill = e, this.update(false);
        }, setWordWrapWidth: function(e, t) {
          return t === void 0 && (t = false), this.wordWrapWidth = e, this.wordWrapUseAdvanced = t, this.
          update(false);
        }, setWordWrapCallback: function(e, t) {
          return t === void 0 && (t = null), this.wordWrapCallback = e, this.wordWrapCallbackScope =
          t, this.update(false);
        }, setAlign: function(e) {
          return e === void 0 && (e = "left"), this.align = e, this.update(false);
        }, setMaxLines: function(e) {
          return e === void 0 && (e = 0), this.maxLines = e, this.update(false);
        }, getTextMetrics: function() {
          var e = this.metrics;
          return { ascent: e.ascent, descent: e.descent, fontSize: e.fontSize };
        }, toJSON: function() {
          var e = {};
          for (var t in pa) e[t] = this[t];
          return e.metrics = this.getTextMetrics(), e;
        }, destroy: function() {
          this.parent = void 0;
        } });
        nk.exports = jce;
      });
      hv = u(($Le, ok) => {
        var eve = function() {
          return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(e) {
            var t = Math.random() * 16 | 0, i = e === "x" ? t : t & 3 | 8;
            return i.toString(16);
          });
        };
        ok.exports = eve;
      });
      Dh = u((jLe, fk) => {
        var hk = jo(), uk = Tt(), tve = C(), je = Ot(), lk = ei(), ive = H5(), Js = H(), rve = Z5(),
        sve = tk(), nve = ak(), ave = hv(), ove = new tve({ Extends: lk, Mixins: [je.Alpha, je.BlendMode,
        je.ComputedSize, je.Crop, je.Depth, je.Flip, je.GetBounds, je.Mask, je.Origin, je.Pipeline, je.
        PostPipeline, je.ScrollFactor, je.Tint, je.Transform, je.Visible, sve], initialize: function(t, i, r, s, n) {
          i === void 0 && (i = 0), r === void 0 && (r = 0), lk.call(this, t, "Text"), this.renderer =
          t.sys.renderer, this.setPosition(i, r), this.setOrigin(0, 0), this.initPipeline(), this.initPostPipeline(
          true), this.canvas = uk.create(this), this.context, this.style = new nve(this, n), this.autoRound =
          true, this.splitRegExp = /(?:\r\n|\r|\n)/, this._text = void 0, this.padding = { left: 0, right: 0,
          top: 0, bottom: 0 }, this.width = 1, this.height = 1, this.lineSpacing = 0, this.letterSpacing =
          0, this.style.resolution === 0 && (this.style.resolution = 1), this._crop = this.resetCropObject(),
          this._textureKey = ave(), this.texture = t.sys.textures.addCanvas(this._textureKey, this.canvas),
          this.context = this.texture.context, this.frame = this.texture.get(), this.frame.source.resolution =
          this.style.resolution, this.renderer && this.renderer.gl && (this.renderer.deleteTexture(this.
          frame.source.glTexture), this.frame.source.glTexture = null), this.initRTL(), this.setText(
          s), n && n.padding && this.setPadding(n.padding), n && n.lineSpacing && this.setLineSpacing(
          n.lineSpacing), n && n.letterSpacing && this.setLetterSpacing(n.letterSpacing);
        }, initRTL: function() {
          this.style.rtl && (this.canvas.dir = "rtl", this.context.direction = "rtl", this.canvas.style.
          display = "none", hk(this.canvas, this.scene.sys.canvas), this.originX = 1);
        }, runWordWrap: function(e) {
          var t = this.style;
          if (t.wordWrapCallback) {
            var i = t.wordWrapCallback.call(t.wordWrapCallbackScope, e, this);
            return Array.isArray(i) && (i = i.join(`
`)), i;
          } else return t.wordWrapWidth ? t.wordWrapUseAdvanced ? this.advancedWordWrap(e, this.context,
          this.style.wordWrapWidth) : this.basicWordWrap(e, this.context, this.style.wordWrapWidth) :
          e;
        }, advancedWordWrap: function(e, t, i) {
          for (var r = "", s = e.replace(/ +/gi, " ").split(this.splitRegExp), n = s.length, a = 0; a <
          n; a++) {
            var o = s[a], h = "";
            o = o.replace(/^ *|\s*$/gi, "");
            var l = o.length * this.letterSpacing, f = t.measureText(o).width + l;
            if (f < i) {
              r += o + `
`;
              continue;
            }
            for (var d = i, c = o.split(" "), p = 0; p < c.length; p++) {
              var v = c[p], m = v + " ", g = m.length * this.letterSpacing, x = t.measureText(m).width +
              g;
              if (console.log(c.length, v), x > d) {
                if (p === 0) {
                  for (var E = m; E.length; ) {
                    E = E.slice(0, -1);
                    var T15 = E.length * this.letterSpacing;
                    if (x = t.measureText(E).width + T15, x <= d) break;
                  }
                  if (!E.length) throw new Error("wordWrapWidth < a single character");
                  var w = v.substr(E.length);
                  c[p] = w, h += E;
                }
                var y = c[p].length ? p : p + 1, A10 = c.slice(y).join(" ").replace(/[ \n]*$/gi, "");
                s.splice(a + 1, 0, A10), n = s.length;
                break;
              } else h += m, d -= x;
            }
            r += h.replace(/[ \n]*$/gi, "") + `
`;
          }
          return r = r.replace(/[\s|\n]*$/gi, ""), r;
        }, basicWordWrap: function(e, t, i) {
          for (var r = "", s = e.split(this.splitRegExp), n = s.length - 1, a = t.measureText(" ").width,
          o = 0; o <= n; o++) {
            for (var h = i, l = s[o].split(" "), f = l.length - 1, d = 0; d <= f; d++) {
              var c = l[d], p = c.length * this.letterSpacing, v = t.measureText(c).width + p, m = v;
              d < f && (m += a), m > h && d > 0 && (r += `
`, h = i), r += c, d < f ? (r += " ", h -= m) : h -= v;
            }
            o < n && (r += `
`);
          }
          return r;
        }, getWrappedText: function(e) {
          e === void 0 && (e = this._text), this.style.syncFont(this.canvas, this.context);
          var t = this.runWordWrap(e);
          return t.split(this.splitRegExp);
        }, setText: function(e) {
          return !e && e !== 0 && (e = ""), Array.isArray(e) && (e = e.join(`
`)), e !== this._text && (this._text = e.toString(), this.updateText()), this;
        }, appendText: function(e, t) {
          t === void 0 && (t = true), !e && e !== 0 && (e = ""), Array.isArray(e) && (e = e.join(`
`)), e = e.toString();
          var i = this._text.concat(t ? `
` + e : e);
          return i !== this._text && (this._text = i, this.updateText()), this;
        }, setStyle: function(e) {
          return this.style.setStyle(e);
        }, setFont: function(e) {
          return this.style.setFont(e);
        }, setFontFamily: function(e) {
          return this.style.setFontFamily(e);
        }, setFontSize: function(e) {
          return this.style.setFontSize(e);
        }, setFontStyle: function(e) {
          return this.style.setFontStyle(e);
        }, setFixedSize: function(e, t) {
          return this.style.setFixedSize(e, t);
        }, setBackgroundColor: function(e) {
          return this.style.setBackgroundColor(e);
        }, setFill: function(e) {
          return this.style.setFill(e);
        }, setColor: function(e) {
          return this.style.setColor(e);
        }, setStroke: function(e, t) {
          return this.style.setStroke(e, t);
        }, setShadow: function(e, t, i, r, s, n) {
          return this.style.setShadow(e, t, i, r, s, n);
        }, setShadowOffset: function(e, t) {
          return this.style.setShadowOffset(e, t);
        }, setShadowColor: function(e) {
          return this.style.setShadowColor(e);
        }, setShadowBlur: function(e) {
          return this.style.setShadowBlur(e);
        }, setShadowStroke: function(e) {
          return this.style.setShadowStroke(e);
        }, setShadowFill: function(e) {
          return this.style.setShadowFill(e);
        }, setWordWrapWidth: function(e, t) {
          return this.style.setWordWrapWidth(e, t);
        }, setWordWrapCallback: function(e, t) {
          return this.style.setWordWrapCallback(e, t);
        }, setAlign: function(e) {
          return this.style.setAlign(e);
        }, setResolution: function(e) {
          return this.style.setResolution(e);
        }, setLineSpacing: function(e) {
          return this.lineSpacing = e, this.updateText();
        }, setLetterSpacing: function(e) {
          return this.letterSpacing = e, this.updateText();
        }, setPadding: function(e, t, i, r) {
          if (typeof e == "object") {
            var s = e, n = Js(s, "x", null);
            n !== null ? (e = n, i = n) : (e = Js(s, "left", 0), i = Js(s, "right", e));
            var a = Js(s, "y", null);
            a !== null ? (t = a, r = a) : (t = Js(s, "top", 0), r = Js(s, "bottom", t));
          } else e === void 0 && (e = 0), t === void 0 && (t = e), i === void 0 && (i = e), r === void 0 &&
          (r = t);
          return this.padding.left = e, this.padding.top = t, this.padding.right = i, this.padding.bottom =
          r, this.updateText();
        }, setMaxLines: function(e) {
          return this.style.setMaxLines(e);
        }, setRTL: function(e) {
          e === void 0 && (e = true);
          var t = this.style;
          return t.rtl === e ? this : (t.rtl = e, e ? (this.canvas.dir = "rtl", this.context.direction =
          "rtl", this.canvas.style.display = "none", hk(this.canvas, this.scene.sys.canvas)) : (this.
          canvas.dir = "ltr", this.context.direction = "ltr"), t.align === "left" ? t.align = "right" :
          t.align === "right" && (t.align = "left"), this);
        }, updateText: function() {
          var e = this.canvas, t = this.context, i = this.style, r = i.resolution, s = i.metrics;
          i.syncFont(e, t);
          var n = this._text;
          (i.wordWrapWidth || i.wordWrapCallback) && (n = this.runWordWrap(this._text));
          var a = n.split(this.splitRegExp), o = ive(this, s, a), h = this.padding, l;
          i.fixedWidth === 0 ? (this.width = o.width + h.left + h.right, l = o.width) : (this.width =
          i.fixedWidth, l = this.width - h.left - h.right, l < o.width && (l = o.width)), i.fixedHeight ===
          0 ? this.height = o.height + h.top + h.bottom : this.height = i.fixedHeight;
          var f = this.width, d = this.height;
          this.updateDisplayOrigin(), f *= r, d *= r, f = Math.max(f, 1), d = Math.max(d, 1), e.width !==
          f || e.height !== d ? (e.width = f, e.height = d, this.frame.setSize(f, d), i.syncFont(e, t),
          i.rtl && (t.direction = "rtl")) : t.clearRect(0, 0, f, d), t.save(), t.scale(r, r), i.backgroundColor &&
          (t.fillStyle = i.backgroundColor, t.fillRect(0, 0, f, d)), i.syncStyle(e, t), t.translate(
          h.left, h.top);
          for (var c, p, v = 0; v < o.lines; v++) {
            if (c = i.strokeThickness / 2, p = i.strokeThickness / 2 + v * o.lineHeight + s.ascent, v >
            0 && (p += o.lineSpacing * v), i.rtl) c = f - c - h.left - h.right;
            else if (i.align === "right") c += l - o.lineWidths[v];
            else if (i.align === "center") c += (l - o.lineWidths[v]) / 2;
            else if (i.align === "justify") {
              var m = 0.85;
              if (o.lineWidths[v] / o.width >= m) {
                var g = o.width - o.lineWidths[v], x = t.measureText(" ").width, E = a[v].trim(), T15 = E.
                split(" ");
                g += (a[v].length - E.length) * x;
                for (var w = Math.floor(g / x), y = 0; w > 0; ) T15[y] += " ", y = (y + 1) % (T15.length -
                1 || 1), --w;
                a[v] = T15.join(" ");
              }
            }
            this.autoRound && (c = Math.round(c), p = Math.round(p));
            var A10 = this.letterSpacing;
            if (i.strokeThickness && A10 === 0 && (i.syncShadow(t, i.shadowStroke), t.strokeText(a[v],
            c, p)), i.color) if (i.syncShadow(t, i.shadowFill), A10 !== 0) for (var S14 = 0, _ = a[v].
            split(""), q = 0; q < _.length; q++) i.strokeThickness && (i.syncShadow(t, i.shadowStroke),
            t.strokeText(_[q], c + S14, p), i.syncShadow(t, i.shadowFill)), t.fillText(_[q], c + S14,
            p), S14 += t.measureText(_[q]).width + A10;
            else t.fillText(a[v], c, p);
          }
          t.restore(), this.renderer && this.renderer.gl && (this.frame.source.glTexture = this.renderer.
          canvasToTexture(e, this.frame.source.glTexture, true));
          var P = this.input;
          return P && !P.customHitArea && (P.hitArea.width = this.width, P.hitArea.height = this.height),
          this;
        }, getTextMetrics: function() {
          return this.style.getTextMetrics();
        }, text: { get: function() {
          return this._text;
        }, set: function(e) {
          this.setText(e);
        } }, toJSON: function() {
          var e = je.ToJSON(this), t = { autoRound: this.autoRound, text: this._text, style: this.style.
          toJSON(), padding: { left: this.padding.left, right: this.padding.right, top: this.padding.
          top, bottom: this.padding.bottom } };
          return e.data = t, e;
        }, preDestroy: function() {
          rve(this.canvas), uk.remove(this.canvas);
          var e = this.texture;
          e && e.destroy();
        } });
        fk.exports = ove;
      });
      ck = u((e2e, dk) => {
        var hve = function(e, t, i, r) {
          i.addToRenderList(t);
          var s = t.list, n = s.length;
          if (n !== 0) {
            var a = t.localTransform;
            r ? (a.loadIdentity(), a.multiply(r), a.translate(t.x, t.y), a.rotate(t.rotation), a.scale(
            t.scaleX, t.scaleY)) : a.applyITRS(t.x, t.y, t.rotation, t.scaleX, t.scaleY), e.pipelines.
            preBatch(t);
            var o = t.blendMode !== -1;
            o || e.setBlendMode(0);
            for (var h = t.alpha, l = t.scrollFactorX, f = t.scrollFactorY, d = 0; d < n; d++) {
              var c = s[d];
              if (c.willRender(i)) {
                var p, v, m, g;
                if (c.alphaTopLeft !== void 0) p = c.alphaTopLeft, v = c.alphaTopRight, m = c.alphaBottomLeft,
                g = c.alphaBottomRight;
                else {
                  var x = c.alpha;
                  p = x, v = x, m = x, g = x;
                }
                var E = c.scrollFactorX, T15 = c.scrollFactorY;
                !o && c.blendMode !== e.currentBlendMode && e.setBlendMode(c.blendMode);
                var w = c.mask;
                w && w.preRenderWebGL(e, c, i);
                var y = c.type;
                y !== e.currentType && (e.newType = true, e.currentType = y), e.nextTypeMatch = d < n -
                1 ? s[d + 1].type === e.currentType : false, c.setScrollFactor(E * l, T15 * f), c.setAlpha(
                p * h, v * h, m * h, g * h), c.renderWebGL(e, c, i, a, t), c.setAlpha(p, v, m, g), c.
                setScrollFactor(E, T15), w && w.postRenderWebGL(e, i), e.newType = false;
              }
            }
            e.pipelines.postBatch(t);
          }
        };
        dk.exports = hve;
      });
      gk = u((t2e, mk) => {
        var vk = J(), pk = vk, uve = vk;
        pk = ck();
        mk.exports = { renderWebGL: pk, renderCanvas: uve };
      });
      Nh = u((i2e, yk) => {
        var re = yn(), lve = Qt(), fve = C(), hi = Ot(), uv = xs(), xk = ei(), Ek = he(), dve = gk(),
        cve = zc(), vve = Y(), Tk = new hi.TransformMatrix(), pve = new fve({ Extends: xk, Mixins: [
        hi.AlphaSingle, hi.BlendMode, hi.ComputedSize, hi.Depth, hi.Mask, hi.PostPipeline, hi.Transform,
        hi.Visible, dve], initialize: function(t, i, r, s) {
          xk.call(this, t, "Container"), this.list = [], this.exclusive = true, this.maxSize = -1, this.
          position = 0, this.localTransform = new hi.TransformMatrix(), this._sortKey = "", this._sysEvents =
          t.sys.events, this.scrollFactorX = 1, this.scrollFactorY = 1, this.initPostPipeline(), this.
          setPosition(i, r), this.setBlendMode(lve.SKIP_CHECK), s && this.add(s);
        }, originX: { get: function() {
          return 0.5;
        } }, originY: { get: function() {
          return 0.5;
        } }, displayOriginX: { get: function() {
          return this.width * 0.5;
        } }, displayOriginY: { get: function() {
          return this.height * 0.5;
        } }, setExclusive: function(e) {
          return e === void 0 && (e = true), this.exclusive = e, this;
        }, getBounds: function(e) {
          if (e === void 0 && (e = new Ek()), e.setTo(this.x, this.y, 0, 0), this.parentContainer) {
            var t = this.parentContainer.getBoundsTransformMatrix(), i = t.transformPoint(this.x, this.
            y);
            e.setTo(i.x, i.y, 0, 0);
          }
          if (this.list.length > 0) {
            var r = this.list, s = new Ek(), n = false;
            e.setEmpty();
            for (var a = 0; a < r.length; a++) {
              var o = r[a];
              o.getBounds && (o.getBounds(s), n ? cve(s, e, e) : (e.setTo(s.x, s.y, s.width, s.height),
              n = true));
            }
          }
          return e;
        }, addHandler: function(e) {
          e.once(uv.DESTROY, this.onChildDestroyed, this), this.exclusive && (e.parentContainer && e.
          parentContainer.remove(e), e.parentContainer = this, e.removeFromDisplayList(), e.addedToScene());
        }, removeHandler: function(e) {
          e.off(uv.DESTROY, this.remove, this), this.exclusive && (e.parentContainer = null, e.removedFromScene(),
          e.addToDisplayList());
        }, pointToContainer: function(e, t) {
          t === void 0 && (t = new vve()), this.parentContainer ? this.parentContainer.pointToContainer(
          e, t) : (t.x = e.x, t.y = e.y);
          var i = Tk;
          return i.applyITRS(this.x, this.y, this.rotation, this.scaleX, this.scaleY), i.invert(), i.
          transformPoint(e.x, e.y, t), t;
        }, getBoundsTransformMatrix: function() {
          return this.getWorldTransformMatrix(Tk, this.localTransform);
        }, add: function(e) {
          return re.Add(this.list, e, this.maxSize, this.addHandler, this), this;
        }, addAt: function(e, t) {
          return re.AddAt(this.list, e, t, this.maxSize, this.addHandler, this), this;
        }, getAt: function(e) {
          return this.list[e];
        }, getIndex: function(e) {
          return this.list.indexOf(e);
        }, sort: function(e, t) {
          return e ? (t === void 0 && (t = function(i, r) {
            return i[e] - r[e];
          }), re.StableSort(this.list, t), this) : this;
        }, getByName: function(e) {
          return re.GetFirst(this.list, "name", e);
        }, getRandom: function(e, t) {
          return re.GetRandom(this.list, e, t);
        }, getFirst: function(e, t, i, r) {
          return re.GetFirst(this.list, e, t, i, r);
        }, getAll: function(e, t, i, r) {
          return re.GetAll(this.list, e, t, i, r);
        }, count: function(e, t, i, r) {
          return re.CountAllMatching(this.list, e, t, i, r);
        }, swap: function(e, t) {
          return re.Swap(this.list, e, t), this;
        }, moveTo: function(e, t) {
          return re.MoveTo(this.list, e, t), this;
        }, moveAbove: function(e, t) {
          return re.MoveAbove(this.list, e, t), this;
        }, moveBelow: function(e, t) {
          return re.MoveBelow(this.list, e, t), this;
        }, remove: function(e, t) {
          var i = re.Remove(this.list, e, this.removeHandler, this);
          if (t && i) {
            Array.isArray(i) || (i = [i]);
            for (var r = 0; r < i.length; r++) i[r].destroy();
          }
          return this;
        }, removeAt: function(e, t) {
          var i = re.RemoveAt(this.list, e, this.removeHandler, this);
          return t && i && i.destroy(), this;
        }, removeBetween: function(e, t, i) {
          var r = re.RemoveBetween(this.list, e, t, this.removeHandler, this);
          if (i) for (var s = 0; s < r.length; s++) r[s].destroy();
          return this;
        }, removeAll: function(e) {
          var t = this.list;
          if (e) {
            for (var i = 0; i < t.length; i++) t[i] && t[i].scene && (t[i].off(uv.DESTROY, this.onChildDestroyed,
            this), t[i].destroy());
            this.list = [];
          } else re.RemoveBetween(t, 0, t.length, this.removeHandler, this);
          return this;
        }, bringToTop: function(e) {
          return re.BringToTop(this.list, e), this;
        }, sendToBack: function(e) {
          return re.SendToBack(this.list, e), this;
        }, moveUp: function(e) {
          return re.MoveUp(this.list, e), this;
        }, moveDown: function(e) {
          return re.MoveDown(this.list, e), this;
        }, reverse: function() {
          return this.list.reverse(), this;
        }, shuffle: function() {
          return re.Shuffle(this.list), this;
        }, replace: function(e, t, i) {
          var r = re.Replace(this.list, e, t);
          return r && (this.addHandler(t), this.removeHandler(e), i && e.destroy()), this;
        }, exists: function(e) {
          return this.list.indexOf(e) > -1;
        }, setAll: function(e, t, i, r) {
          return re.SetAll(this.list, e, t, i, r), this;
        }, each: function(e, t) {
          var i = [null], r, s = this.list.slice(), n = s.length;
          for (r = 2; r < arguments.length; r++) i.push(arguments[r]);
          for (r = 0; r < n; r++) i[0] = s[r], e.apply(t, i);
          return this;
        }, iterate: function(e, t) {
          var i = [null], r;
          for (r = 2; r < arguments.length; r++) i.push(arguments[r]);
          for (r = 0; r < this.list.length; r++) i[0] = this.list[r], e.apply(t, i);
          return this;
        }, setScrollFactor: function(e, t, i) {
          return t === void 0 && (t = e), i === void 0 && (i = false), this.scrollFactorX = e, this.
          scrollFactorY = t, i && (re.SetAll(this.list, "scrollFactorX", e), re.SetAll(this.list, "s\
crollFactorY", t)), this;
        }, length: { get: function() {
          return this.list.length;
        } }, first: { get: function() {
          return this.position = 0, this.list.length > 0 ? this.list[0] : null;
        } }, last: { get: function() {
          return this.list.length > 0 ? (this.position = this.list.length - 1, this.list[this.position]) :
          null;
        } }, next: { get: function() {
          return this.position < this.list.length ? (this.position++, this.list[this.position]) : null;
        } }, previous: { get: function() {
          return this.position > 0 ? (this.position--, this.list[this.position]) : null;
        } }, preDestroy: function() {
          this.removeAll(!!this.exclusive), this.localTransform.destroy(), this.list = [];
        }, onChildDestroyed: function(e) {
          re.Remove(this.list, e), this.exclusive && (e.parentContainer = null, e.removedFromScene());
        } });
        yk.exports = pve;
      });
      wk = u((r2e, Sk) => {
        var mve = Ah(), gve = wt(), xve = function(e, t, i, r) {
          var s = t.vertices, n = s.length;
          if (n !== 0) {
            i.addToRenderList(t);
            var a = e.pipelines.set(t.pipeline, t), o = mve(t, i, r, false).calc;
            e.pipelines.preBatch(t);
            var h = a.setGameObject(t), l = a.vertexViewF32, f = a.vertexViewU32, d = a.vertexCount *
            a.currentShader.vertexComponentCount - 1, c = i.roundPixels, p = t.tintFill, v = i.alpha *
            t.alpha, m = gve.getTintAppendFloatAlpha(t.tint, v), g = a.vertexAvailable(), x = -1;
            g < n && (x = g);
            for (var E = 0; E < n; E++) {
              var T15 = s[E];
              E === x && (a.flush(), h = a.setGameObject(t), d = 0), l[++d] = o.getXRound(T15.vx, T15.
              vy, c), l[++d] = o.getYRound(T15.vx, T15.vy, c), l[++d] = T15.u, l[++d] = T15.v, l[++d] =
              h, l[++d] = p, f[++d] = m, a.vertexCount++, a.currentBatch.count = a.vertexCount - a.currentBatch.
              start;
            }
            e.pipelines.postBatch(t);
          }
        };
        Sk.exports = xve;
      });
      _k = u((s2e, Rk) => {
        var Ck = J(), Ak = Ck, Eve = Ck;
        Ak = wk();
        Rk.exports = { renderWebGL: Ak, renderCanvas: Eve };
      });
      qk = u((n2e, Mk) => {
        var Tve = C(), yve = wt(), Pk = As(), Sve = new Tve({ Extends: Pk, initialize: function(t, i, r, s, n, a, o, h, l, f) {
          a === void 0 && (a = 16777215), o === void 0 && (o = 1), h === void 0 && (h = 0), l === void 0 &&
          (l = 0), f === void 0 && (f = 0), Pk.call(this, t, i, r), this.vx = 0, this.vy = 0, this.vz =
          0, this.nx = h, this.ny = l, this.nz = f, this.u = s, this.v = n, this.color = a, this.alpha =
          o, this.tx = 0, this.ty = 0, this.ta = 0, this.tu = s, this.tv = n;
        }, setUVs: function(e, t) {
          return this.u = e, this.v = t, this.tu = e, this.tv = t, this;
        }, scrollUV: function(e, t) {
          return this.tu += e, this.tv += t, this;
        }, scaleUV: function(e, t) {
          return this.tu = this.u * e, this.tv = this.v * t, this;
        }, transformCoordinatesLocal: function(e, t, i, r) {
          var s = this.x, n = this.y, a = this.z, o = e.val, h = s * o[0] + n * o[4] + a * o[8] + o[12],
          l = s * o[1] + n * o[5] + a * o[9] + o[13], f = s * o[2] + n * o[6] + a * o[10] + o[14], d = s *
          o[3] + n * o[7] + a * o[11] + o[15];
          this.vx = h / d * t, this.vy = -(l / d) * i, r <= 0 ? this.vz = f / d : this.vz = -(f / d);
        }, resize: function(e, t, i, r, s, n) {
          return this.x = e, this.y = t, this.vx = this.x * i, this.vy = -this.y * r, this.vz = 0, s <
          0.5 ? this.vx += i * (0.5 - s) : s > 0.5 && (this.vx -= i * (s - 0.5)), n < 0.5 ? this.vy +=
          r * (0.5 - n) : n > 0.5 && (this.vy -= r * (n - 0.5)), this;
        }, update: function(e, t, i, r, s, n, a, o) {
          var h = this.vx * e + this.vy * i + s, l = this.vx * t + this.vy * r + n;
          return a && (h = Math.round(h), l = Math.round(l)), this.tx = h, this.ty = l, this.ta = this.
          alpha * o, this;
        }, load: function(e, t, i, r, s) {
          return e[++i] = this.tx, e[++i] = this.ty, e[++i] = this.tu, e[++i] = this.tv, e[++i] = r,
          e[++i] = s, t[++i] = yve.getTintAppendFloatAlpha(this.color, this.ta), i;
        } });
        Mk.exports = Sve;
      });
      Ih = u((a2e, bk) => {
        var wve = C(), Gt = Ot(), Fk = ei(), Cve = _k(), Ave = qk(), Rve = new wve({ Extends: Fk, Mixins: [
        Gt.AlphaSingle, Gt.BlendMode, Gt.Depth, Gt.GetBounds, Gt.Mask, Gt.Origin, Gt.Pipeline, Gt.PostPipeline,
        Gt.ScrollFactor, Gt.Texture, Gt.Transform, Gt.Visible, Cve], initialize: function(t, i, r, s, n, a, o, h, l, f, d) {
          Fk.call(this, t, "NineSlice"), this._width, this._height, this._originX = 0.5, this._originY =
          0.5, this._sizeComponent = true, this.vertices = [], this.leftWidth, this.rightWidth, this.
          topHeight, this.bottomHeight, this.tint = 16777215, this.tintFill = false;
          var c = t.textures.getFrame(s, n);
          this.is3Slice = !f && !d, c && c.scale9 && (this.is3Slice = c.is3Slice);
          for (var p = this.is3Slice ? 18 : 54, v = 0; v < p; v++) this.vertices.push(new Ave());
          this.setPosition(i, r), this.setTexture(s, n), this.setSlices(a, o, h, l, f, d, false), this.
          updateDisplayOrigin(), this.initPipeline(), this.initPostPipeline();
        }, setSlices: function(e, t, i, r, s, n, a) {
          i === void 0 && (i = 10), r === void 0 && (r = 10), s === void 0 && (s = 0), n === void 0 &&
          (n = 0), a === void 0 && (a = false);
          var o = this.frame, h = false;
          if (this.is3Slice && a && s !== 0 && n !== 0 && (h = true), h) console.warn("Cannot change\
 9 slice to 3 slice");
          else {
            if (o && o.scale9 && !a) {
              var l = o.data.scale9Borders, f = l.x, d = l.y;
              i = f, r = o.width - l.w - f, s = d, n = o.height - l.h - d, e === void 0 && (e = o.width),
              t === void 0 && (t = o.height);
            } else e === void 0 && (e = 256), t === void 0 && (t = 256);
            this._width = e, this._height = t, this.leftWidth = i, this.rightWidth = r, this.topHeight =
            s, this.bottomHeight = n, this.is3Slice && (t = o.height, this._height = t, this.topHeight =
            t, this.bottomHeight = 0), this.updateVertices(), this.updateUVs();
          }
          return this;
        }, updateUVs: function() {
          var e = this.leftWidth, t = this.rightWidth, i = this.topHeight, r = this.bottomHeight, s = this.
          frame.width, n = this.frame.height;
          this.updateQuadUVs(0, 0, 0, e / s, i / n), this.updateQuadUVs(6, e / s, 0, 1 - t / s, i / n),
          this.updateQuadUVs(12, 1 - t / s, 0, 1, i / n), this.is3Slice || (this.updateQuadUVs(18, 0,
          i / n, e / s, 1 - r / n), this.updateQuadUVs(24, e / s, i / n, 1 - t / s, 1 - r / n), this.
          updateQuadUVs(30, 1 - t / s, i / n, 1, 1 - r / n), this.updateQuadUVs(36, 0, 1 - r / n, e /
          s, 1), this.updateQuadUVs(42, e / s, 1 - r / n, 1 - t / s, 1), this.updateQuadUVs(48, 1 - t /
          s, 1 - r / n, 1, 1));
        }, updateVertices: function() {
          var e = this.leftWidth, t = this.rightWidth, i = this.topHeight, r = this.bottomHeight, s = this.
          width, n = this.height;
          this.updateQuad(0, -0.5, 0.5, -0.5 + e / s, 0.5 - i / n), this.updateQuad(6, -0.5 + e / s,
          0.5, 0.5 - t / s, 0.5 - i / n), this.updateQuad(12, 0.5 - t / s, 0.5, 0.5, 0.5 - i / n), this.
          is3Slice || (this.updateQuad(18, -0.5, 0.5 - i / n, -0.5 + e / s, -0.5 + r / n), this.updateQuad(
          24, -0.5 + e / s, 0.5 - i / n, 0.5 - t / s, -0.5 + r / n), this.updateQuad(30, 0.5 - t / s,
          0.5 - i / n, 0.5, -0.5 + r / n), this.updateQuad(36, -0.5, -0.5 + r / n, -0.5 + e / s, -0.5),
          this.updateQuad(42, -0.5 + e / s, -0.5 + r / n, 0.5 - t / s, -0.5), this.updateQuad(48, 0.5 -
          t / s, -0.5 + r / n, 0.5, -0.5));
        }, updateQuad: function(e, t, i, r, s) {
          var n = this.width, a = this.height, o = this.originX, h = this.originY, l = this.vertices;
          l[e + 0].resize(t, i, n, a, o, h), l[e + 1].resize(t, s, n, a, o, h), l[e + 2].resize(r, i,
          n, a, o, h), l[e + 3].resize(t, s, n, a, o, h), l[e + 4].resize(r, s, n, a, o, h), l[e + 5].
          resize(r, i, n, a, o, h);
        }, updateQuadUVs: function(e, t, i, r, s) {
          var n = this.vertices, a = this.frame, o = a.u0, h = a.v0, l = a.u1, f = a.v1;
          if (o !== 0 || l !== 1) {
            var d = l - o;
            t = o + t * d, r = o + r * d;
          }
          if (h !== 0 || f !== 1) {
            var c = f - h;
            i = h + i * c, s = h + s * c;
          }
          n[e + 0].setUVs(t, i), n[e + 1].setUVs(t, s), n[e + 2].setUVs(r, i), n[e + 3].setUVs(t, s),
          n[e + 4].setUVs(r, s), n[e + 5].setUVs(r, i);
        }, clearTint: function() {
          return this.setTint(16777215), this;
        }, setTint: function(e) {
          return e === void 0 && (e = 16777215), this.tint = e, this.tintFill = false, this;
        }, setTintFill: function(e) {
          return this.setTint(e), this.tintFill = true, this;
        }, isTinted: { get: function() {
          return this.tint !== 16777215;
        } }, width: { get: function() {
          return this._width;
        }, set: function(e) {
          this._width = Math.max(e, this.leftWidth + this.rightWidth), this.updateVertices();
        } }, height: { get: function() {
          return this._height;
        }, set: function(e) {
          this.is3Slice || (this._height = Math.max(e, this.topHeight + this.bottomHeight), this.updateVertices());
        } }, displayWidth: { get: function() {
          return this.scaleX * this.width;
        }, set: function(e) {
          this.scaleX = e / this.width;
        } }, displayHeight: { get: function() {
          return this.scaleY * this.height;
        }, set: function(e) {
          this.scaleY = e / this.height;
        } }, setSize: function(e, t) {
          this.width = e, this.height = t, this.updateDisplayOrigin();
          var i = this.input;
          return i && !i.customHitArea && (i.hitArea.width = this.width, i.hitArea.height = this.height),
          this;
        }, setDisplaySize: function(e, t) {
          return this.displayWidth = e, this.displayHeight = t, this;
        }, originX: { get: function() {
          return this._originX;
        }, set: function(e) {
          this._originX = e, this.updateVertices();
        } }, originY: { get: function() {
          return this._originY;
        }, set: function(e) {
          this._originY = e, this.updateVertices();
        } }, setOrigin: function(e, t) {
          return e === void 0 && (e = 0.5), t === void 0 && (t = e), this._originX = e, this._originY =
          t, this.updateVertices(), this.updateDisplayOrigin();
        }, setSizeToFrame: function() {
          if (this.is3Slice) {
            var e = this.frame.height;
            this._height = e, this.topHeight = e, this.bottomHeight = 0;
          }
          return this.updateUVs(), this;
        }, preDestroy: function() {
          this.vertices = [];
        } });
        bk.exports = Rve;
      });
      Lk = u(() => {
        var _ve = wh(), Pve = Ne();
        Pve.register("group", function(e, t) {
          return this.updateList.add(new _ve(this.scene, e, t));
        });
      });
      Ok = u(() => {
        var Mve = _h(), qve = Ne();
        qve.register("graphics", function(e) {
          return this.displayList.add(new Mve(this.scene, e));
        });
      });
      Dk = u(() => {
        var Fve = ta(), bve = Ne();
        bve.register("image", function(e, t, i, r) {
          return this.displayList.add(new Fve(this.scene, e, t, i, r));
        });
      });
      Nk = u(() => {
        var Lve = Ne(), Ove = la();
        Lve.register("sprite", function(e, t, i, r) {
          return this.displayList.add(new Ove(this.scene, e, t, i, r));
        });
      });
      Ik = u(() => {
        var Dve = Ne(), Nve = Lh();
        Dve.register("particles", function(e, t, i, r) {
          return e !== void 0 && typeof e == "string" && console.warn("ParticleEmitterManager was re\
moved in Phaser 3.60. See documentation for details"), this.displayList.add(new Nve(this.scene, e, t,
          i, r));
        });
      });
      Bk = u(() => {
        var Ive = Dh(), Bve = Ne();
        Bve.register("text", function(e, t, i, r) {
          return this.displayList.add(new Ive(this.scene, e, t, i, r));
        });
      });
      Gk = u(() => {
        var Gve = Nh(), Uve = Ne();
        Uve.register("container", function(e, t, i) {
          return this.displayList.add(new Gve(this.scene, e, t, i));
        });
      });
      Uk = u(() => {
        var zve = Mn(), kve = Ne();
        kve.register("zone", function(e, t, i, r) {
          return this.displayList.add(new zve(this.scene, e, t, i, r));
        });
      });
      zk = u(() => {
        var Xve = Ih(), Vve = Ne();
        Vve.register("nineslice", function(e, t, i, r, s, n, a, o, h, l) {
          return this.displayList.add(new Xve(this.scene, e, t, i, r, s, n, a, o, h, l));
        });
      });
      kk = u(() => {
        var Yve = gt(), Wve = wh();
        Yve.register("group", function(e) {
          return new Wve(this.scene, null, e);
        });
      });
      Xk = u(() => {
        var Hve = gt(), Kve = _h();
        Hve.register("graphics", function(e, t) {
          e === void 0 && (e = {}), t !== void 0 && (e.add = t);
          var i = new Kve(this.scene, e);
          return e.add && this.scene.sys.displayList.add(i), i;
        });
      });
      Yk = u(() => {
        var Zve = dr(), Qve = gt(), Vk = ot(), Jve = ta();
        Qve.register("image", function(e, t) {
          e === void 0 && (e = {});
          var i = Vk(e, "key", null), r = Vk(e, "frame", null), s = new Jve(this.scene, 0, 0, i, r);
          return t !== void 0 && (e.add = t), Zve(this.scene, s, e), s;
        });
      });
      Hk = u((F2e, Wk) => {
        var Ni = ot(), $ve = function(e, t) {
          var i = Ni(t, "anims", null);
          if (i === null) return e;
          if (typeof i == "string") e.anims.play(i);
          else if (typeof i == "object") {
            var r = e.anims, s = Ni(i, "key", void 0);
            if (s) {
              var n = Ni(i, "startFrame", void 0), a = Ni(i, "delay", 0), o = Ni(i, "repeat", 0), h = Ni(
              i, "repeatDelay", 0), l = Ni(i, "yoyo", false), f = Ni(i, "play", false), d = Ni(i, "d\
elayedPlay", 0), c = { key: s, delay: a, repeat: o, repeatDelay: h, yoyo: l, startFrame: n };
              f ? r.play(c) : d > 0 ? r.playAfterDelay(c, d) : r.load(c);
            }
          }
          return e;
        };
        Wk.exports = $ve;
      });
      Zk = u(() => {
        var jve = dr(), epe = Hk(), tpe = gt(), Kk = ot(), ipe = la();
        tpe.register("sprite", function(e, t) {
          e === void 0 && (e = {});
          var i = Kk(e, "key", null), r = Kk(e, "frame", null), s = new ipe(this.scene, 0, 0, i, r);
          return t !== void 0 && (e.add = t), jve(this.scene, s, e), epe(s, e), s;
        });
      });
      Qk = u(() => {
        var rpe = dr(), spe = gt(), npe = ot(), ape = B(), ope = Lh();
        spe.register("particles", function(e, t) {
          e === void 0 && (e = {});
          var i = npe(e, "key", null), r = ape(e, "config", null), s = new ope(this.scene, 0, 0, i);
          return t !== void 0 && (e.add = t), rpe(this.scene, s, e), r && s.setConfig(r), s;
        });
      });
      Jk = u(() => {
        var hpe = dr(), upe = gt(), ma = ot(), lpe = Dh();
        upe.register("text", function(e, t) {
          e === void 0 && (e = {});
          var i = ma(e, "text", ""), r = ma(e, "style", null), s = ma(e, "padding", null);
          s !== null && (r.padding = s);
          var n = new lpe(this.scene, 0, 0, i, r);
          return t !== void 0 && (e.add = t), hpe(this.scene, n, e), n.autoRound = ma(e, "autoRound",
          true), n.resolution = ma(e, "resolution", 1), n;
        });
      });
      jk = u(() => {
        var fpe = dr(), dpe = Nh(), cpe = gt(), $k = ot(), vpe = B();
        cpe.register("container", function(e, t) {
          e === void 0 && (e = {});
          var i = $k(e, "x", 0), r = $k(e, "y", 0), s = vpe(e, "children", null), n = new dpe(this.scene,
          i, r, s);
          return t !== void 0 && (e.add = t), fpe(this.scene, n, e), n;
        });
      });
      eX = u(() => {
        var ppe = gt(), Bh = ot(), mpe = Mn();
        ppe.register("zone", function(e) {
          var t = Bh(e, "x", 0), i = Bh(e, "y", 0), r = Bh(e, "width", 1), s = Bh(e, "height", r);
          return new mpe(this.scene, t, i, r, s);
        });
      });
      iX = u(() => {
        var gpe = dr(), xpe = gt(), tX = ot(), $s = H(), Epe = Ih();
        xpe.register("nineslice", function(e, t) {
          e === void 0 && (e = {});
          var i = tX(e, "key", null), r = tX(e, "frame", null), s = $s(e, "width", 256), n = $s(e, "\
height", 256), a = $s(e, "leftWidth", 10), o = $s(e, "rightWidth", 10), h = $s(e, "topHeight", 0), l = $s(
          e, "bottomHeight", 0), f = new Epe(this.scene, 0, 0, i, r, s, n, a, o, h, l);
          return t !== void 0 && (e.add = t), gpe(this.scene, f, e), f;
        });
      });
      lv = u((V2e, rX) => {
        var Tpe = function(e, t) {
          return function(i, r, s, n) {
            var a = e.getPixelAlpha(r, s, n.texture.key, n.frame.name);
            return a && a >= t;
          };
        };
        rX.exports = Tpe;
      });
      fv = u((Y2e, sX) => {
        var ype = function(e, t, i) {
          return { gameObject: e, enabled: true, draggable: false, dropZone: false, cursor: false, target: null,
          camera: null, hitArea: t, hitAreaCallback: i, hitAreaDebug: null, customHitArea: false, localX: 0,
          localY: 0, dragState: 0, dragStartX: 0, dragStartY: 0, dragStartXGlobal: 0, dragStartYGlobal: 0,
          dragStartCamera: null, dragX: 0, dragY: 0 };
        };
        sX.exports = ype;
      });
      dv = u((W2e, nX) => {
        var Spe = C(), wpe = new Spe({ initialize: function(t, i) {
          this.pad = t, this.events = t.events, this.index = i, this.value = 0, this.threshold = 0.1;
        }, update: function(e) {
          this.value = e;
        }, getValue: function() {
          return Math.abs(this.value) < this.threshold ? 0 : this.value;
        }, destroy: function() {
          this.pad = null, this.events = null;
        } });
        nX.exports = wpe;
      });
      oX = u((H2e, aX) => {
        aX.exports = "down";
      });
      uX = u((K2e, hX) => {
        hX.exports = "up";
      });
      fX = u((Z2e, lX) => {
        lX.exports = "connected";
      });
      cX = u((Q2e, dX) => {
        dX.exports = "disconnected";
      });
      pX = u((J2e, vX) => {
        vX.exports = "down";
      });
      gX = u(($2e, mX) => {
        mX.exports = "up";
      });
      Gh = u((j2e, xX) => {
        xX.exports = { BUTTON_DOWN: oX(), BUTTON_UP: uX(), CONNECTED: fX(), DISCONNECTED: cX(), GAMEPAD_BUTTON_DOWN: pX(),
        GAMEPAD_BUTTON_UP: gX() };
      });
      cv = u((eOe, EX) => {
        var Cpe = C(), Uh = Gh(), Ape = new Cpe({ initialize: function(t, i) {
          this.pad = t, this.events = t.manager, this.index = i, this.value = 0, this.threshold = 1,
          this.pressed = false;
        }, update: function(e) {
          this.value = e;
          var t = this.pad, i = this.index;
          e >= this.threshold ? this.pressed || (this.pressed = true, this.events.emit(Uh.BUTTON_DOWN,
          t, this, e), this.pad.emit(Uh.GAMEPAD_BUTTON_DOWN, i, e, this)) : this.pressed && (this.pressed =
          false, this.events.emit(Uh.BUTTON_UP, t, this, e), this.pad.emit(Uh.GAMEPAD_BUTTON_UP, i, e,
          this));
        }, destroy: function() {
          this.pad = null, this.events = null;
        } });
        EX.exports = Ape;
      });
      vv = u((tOe, SX) => {
        var Rpe = dv(), _pe = cv(), Ppe = C(), TX = Z(), yX = Y(), Mpe = new Ppe({ Extends: TX, initialize: function(t, i) {
          TX.call(this), this.manager = t, this.pad = i, this.id = i.id, this.index = i.index;
          for (var r = [], s = 0; s < i.buttons.length; s++) r.push(new _pe(this, s));
          this.buttons = r;
          var n = [];
          for (s = 0; s < i.axes.length; s++) n.push(new Rpe(this, s));
          this.axes = n, this.vibration = i.vibrationActuator;
          var a = { value: 0, pressed: false };
          this._LCLeft = r[14] ? r[14] : a, this._LCRight = r[15] ? r[15] : a, this._LCTop = r[12] ?
          r[12] : a, this._LCBottom = r[13] ? r[13] : a, this._RCLeft = r[2] ? r[2] : a, this._RCRight =
          r[1] ? r[1] : a, this._RCTop = r[3] ? r[3] : a, this._RCBottom = r[0] ? r[0] : a, this._FBLeftTop =
          r[4] ? r[4] : a, this._FBLeftBottom = r[6] ? r[6] : a, this._FBRightTop = r[5] ? r[5] : a,
          this._FBRightBottom = r[7] ? r[7] : a;
          var o = { value: 0 };
          this._HAxisLeft = n[0] ? n[0] : o, this._VAxisLeft = n[1] ? n[1] : o, this._HAxisRight = n[2] ?
          n[2] : o, this._VAxisRight = n[3] ? n[3] : o, this.leftStick = new yX(), this.rightStick =
          new yX(), this._created = performance.now();
        }, getAxisTotal: function() {
          return this.axes.length;
        }, getAxisValue: function(e) {
          return this.axes[e].getValue();
        }, setAxisThreshold: function(e) {
          for (var t = 0; t < this.axes.length; t++) this.axes[t].threshold = e;
        }, getButtonTotal: function() {
          return this.buttons.length;
        }, getButtonValue: function(e) {
          return this.buttons[e].value;
        }, isButtonDown: function(e) {
          return this.buttons[e].pressed;
        }, update: function(e) {
          if (!(e.timestamp < this._created)) {
            var t, i = this.buttons, r = e.buttons, s = i.length;
            for (t = 0; t < s; t++) i[t].update(r[t].value);
            var n = this.axes, a = e.axes;
            for (s = n.length, t = 0; t < s; t++) n[t].update(a[t]);
            s >= 2 && (this.leftStick.set(n[0].getValue(), n[1].getValue()), s >= 4 && this.rightStick.
            set(n[2].getValue(), n[3].getValue()));
          }
        }, destroy: function() {
          this.removeAllListeners(), this.manager = null, this.pad = null;
          var e;
          for (e = 0; e < this.buttons.length; e++) this.buttons[e].destroy();
          for (e = 0; e < this.axes.length; e++) this.axes[e].destroy();
          this.buttons = [], this.axes = [];
        }, connected: { get: function() {
          return this.pad.connected;
        } }, timestamp: { get: function() {
          return this.pad.timestamp;
        } }, left: { get: function() {
          return this._LCLeft.pressed;
        } }, right: { get: function() {
          return this._LCRight.pressed;
        } }, up: { get: function() {
          return this._LCTop.pressed;
        } }, down: { get: function() {
          return this._LCBottom.pressed;
        } }, A: { get: function() {
          return this._RCBottom.pressed;
        } }, Y: { get: function() {
          return this._RCTop.pressed;
        } }, X: { get: function() {
          return this._RCLeft.pressed;
        } }, B: { get: function() {
          return this._RCRight.pressed;
        } }, L1: { get: function() {
          return this._FBLeftTop.value;
        } }, L2: { get: function() {
          return this._FBLeftBottom.value;
        } }, R1: { get: function() {
          return this._FBRightTop.value;
        } }, R2: { get: function() {
          return this._FBRightBottom.value;
        } } });
        SX.exports = Mpe;
      });
      xa = u((iOe, wX) => {
        var qpe = H(), Ii = {}, ga = {};
        ga.register = function(e, t, i, r, s) {
          Ii[e] = { plugin: t, mapping: i, settingsKey: r, configKey: s };
        };
        ga.getPlugin = function(e) {
          return Ii[e];
        };
        ga.install = function(e) {
          var t = e.scene.sys, i = t.settings.input, r = t.game.config;
          for (var s in Ii) {
            var n = Ii[s].plugin, a = Ii[s].mapping, o = Ii[s].settingsKey, h = Ii[s].configKey;
            qpe(i, o, r[h]) && (e[a] = new n(e));
          }
        };
        ga.remove = function(e) {
          Ii.hasOwnProperty(e) && delete Ii[e];
        };
        wX.exports = ga;
      });
      qX = u((rOe, MX) => {
        var Fpe = C(), CX = Z(), AX = Gh(), RX = vv(), _X = H(), bpe = xa(), js = Mi(), PX = new Fpe(
        { Extends: CX, initialize: function(t) {
          CX.call(this), this.scene = t.scene, this.settings = this.scene.sys.settings, this.sceneInputPlugin =
          t, this.enabled = true, this.target, this.gamepads = [], this.queue = [], this.onGamepadHandler,
          this._pad1, this._pad2, this._pad3, this._pad4, t.pluginEvents.once(js.BOOT, this.boot, this),
          t.pluginEvents.on(js.START, this.start, this);
        }, boot: function() {
          var e = this.scene.sys.game, t = this.settings.input, i = e.config;
          this.enabled = _X(t, "gamepad", i.inputGamepad) && e.device.input.gamepads, this.target = _X(
          t, "gamepad.target", i.inputGamepadEventTarget), this.sceneInputPlugin.pluginEvents.once(js.
          DESTROY, this.destroy, this);
        }, start: function() {
          this.enabled && (this.startListeners(), this.refreshPads()), this.sceneInputPlugin.pluginEvents.
          once(js.SHUTDOWN, this.shutdown, this);
        }, isActive: function() {
          return this.enabled && this.scene.sys.isActive();
        }, startListeners: function() {
          var e = this, t = this.target, i = function(r) {
            r.defaultPrevented || !e.isActive() || (e.refreshPads(), e.queue.push(r));
          };
          this.onGamepadHandler = i, t.addEventListener("gamepadconnected", i, false), t.addEventListener(
          "gamepaddisconnected", i, false), this.sceneInputPlugin.pluginEvents.on(js.UPDATE, this.update,
          this);
        }, stopListeners: function() {
          this.target.removeEventListener("gamepadconnected", this.onGamepadHandler), this.target.removeEventListener(
          "gamepaddisconnected", this.onGamepadHandler), this.sceneInputPlugin.pluginEvents.off(js.UPDATE,
          this.update);
          for (var e = 0; e < this.gamepads.length; e++) this.gamepads[e].removeAllListeners();
        }, disconnectAll: function() {
          for (var e = 0; e < this.gamepads.length; e++) this.gamepads[e].pad.connected = false;
        }, refreshPads: function() {
          var e = navigator.getGamepads();
          if (!e) this.disconnectAll();
          else for (var t = this.gamepads, i = 0; i < e.length; i++) {
            var r = e[i];
            if (r) {
              var s = r.id, n = r.index, a = t[n];
              if (a) a.id !== s ? (a.destroy(), t[n] = new RX(this, r)) : a.update(r);
              else {
                var o = new RX(this, r);
                t[n] = o, this._pad1 ? this._pad2 ? this._pad3 ? this._pad4 || (this._pad4 = o) : this.
                _pad3 = o : this._pad2 = o : this._pad1 = o;
              }
            }
          }
        }, getAll: function() {
          for (var e = [], t = this.gamepads, i = 0; i < t.length; i++) t[i] && e.push(t[i]);
          return e;
        }, getPad: function(e) {
          for (var t = this.gamepads, i = 0; i < t.length; i++) if (t[i] && t[i].index === e) return t[i];
        }, update: function() {
          if (this.enabled) {
            this.refreshPads();
            var e = this.queue.length;
            if (e !== 0) for (var t = this.queue.splice(0, e), i = 0; i < e; i++) {
              var r = t[i], s = this.getPad(r.gamepad.index);
              r.type === "gamepadconnected" ? this.emit(AX.CONNECTED, s, r) : r.type === "gamepaddis\
connected" && this.emit(AX.DISCONNECTED, s, r);
            }
          }
        }, shutdown: function() {
          this.stopListeners(), this.removeAllListeners();
        }, destroy: function() {
          this.shutdown();
          for (var e = 0; e < this.gamepads.length; e++) this.gamepads[e] && this.gamepads[e].destroy();
          this.gamepads = [], this.scene = null, this.settings = null, this.sceneInputPlugin = null,
          this.target = null;
        }, total: { get: function() {
          return this.gamepads.length;
        } }, pad1: { get: function() {
          return this._pad1;
        } }, pad2: { get: function() {
          return this._pad2;
        } }, pad3: { get: function() {
          return this._pad3;
        } }, pad4: { get: function() {
          return this._pad4;
        } } });
        bpe.register("GamepadPlugin", PX, "gamepad", "gamepad", "inputGamepad");
        MX.exports = PX;
      });
      bX = u((sOe, FX) => {
        FX.exports = { UP: 12, DOWN: 13, LEFT: 14, RIGHT: 15, SHARE: 8, OPTIONS: 9, PS: 16, TOUCHBAR: 17,
        X: 0, CIRCLE: 1, SQUARE: 2, TRIANGLE: 3, L1: 4, R1: 5, L2: 6, R2: 7, L3: 10, R3: 11, LEFT_STICK_H: 0,
        LEFT_STICK_V: 1, RIGHT_STICK_H: 2, RIGHT_STICK_V: 3 };
      });
      OX = u((nOe, LX) => {
        LX.exports = { UP: 12, DOWN: 13, LEFT: 14, RIGHT: 15, SELECT: 8, START: 9, B: 0, A: 1, Y: 2,
        X: 3, LEFT_SHOULDER: 4, RIGHT_SHOULDER: 5 };
      });
      NX = u((aOe, DX) => {
        DX.exports = { UP: 12, DOWN: 13, LEFT: 14, RIGHT: 15, MENU: 16, A: 0, B: 1, X: 2, Y: 3, LB: 4,
        RB: 5, LT: 6, RT: 7, BACK: 8, START: 9, LS: 10, RS: 11, LEFT_STICK_H: 0, LEFT_STICK_V: 1, RIGHT_STICK_H: 2,
        RIGHT_STICK_V: 3 };
      });
      BX = u((oOe, IX) => {
        IX.exports = { DUALSHOCK_4: bX(), SNES_USB: OX(), XBOX_360: NX() };
      });
      UX = u((hOe, GX) => {
        GX.exports = { Axis: dv(), Button: cv(), Events: Gh(), Gamepad: vv(), GamepadPlugin: qX(), Configs: BX() };
      });
      pv = u((uOe, zX) => {
        var Lpe = function(e, t, i) {
          var r = e.x3 - e.x1, s = e.y3 - e.y1, n = e.x2 - e.x1, a = e.y2 - e.y1, o = t - e.x1, h = i -
          e.y1, l = r * r + s * s, f = r * n + s * a, d = r * o + s * h, c = n * n + a * a, p = n * o +
          a * h, v = l * c - f * f, m = v === 0 ? 0 : 1 / v, g = (c * d - f * p) * m, x = (l * p - f *
          d) * m;
          return g >= 0 && x >= 0 && g + x < 1;
        };
        zX.exports = Lpe;
      });
      XX = u((lOe, kX) => {
        var Ope = ae(), mv = cs(), Dpe = function(e, t, i) {
          i === void 0 && (i = new Ope());
          var r = e.getLineA(), s = e.getLineB(), n = e.getLineC();
          if (t <= 0 || t >= 1) return i.x = r.x1, i.y = r.y1, i;
          var a = mv(r), o = mv(s), h = mv(n), l = a + o + h, f = l * t, d = 0;
          return f < a ? (d = f / a, i.x = r.x1 + (r.x2 - r.x1) * d, i.y = r.y1 + (r.y2 - r.y1) * d) :
          f > a + o ? (f -= a + o, d = f / h, i.x = n.x1 + (n.x2 - n.x1) * d, i.y = n.y1 + (n.y2 - n.
          y1) * d) : (f -= a, d = f / o, i.x = s.x1 + (s.x2 - s.x1) * d, i.y = s.y1 + (s.y2 - s.y1) *
          d), i;
        };
        kX.exports = Dpe;
      });
      YX = u((fOe, VX) => {
        var gv = cs(), Npe = ae(), Ipe = function(e, t, i, r) {
          r === void 0 && (r = []);
          var s = e.getLineA(), n = e.getLineB(), a = e.getLineC(), o = gv(s), h = gv(n), l = gv(a),
          f = o + h + l;
          !t && i > 0 && (t = f / i);
          for (var d = 0; d < t; d++) {
            var c = f * (d / t), p = 0, v = new Npe();
            c < o ? (p = c / o, v.x = s.x1 + (s.x2 - s.x1) * p, v.y = s.y1 + (s.y2 - s.y1) * p) : c >
            o + h ? (c -= o + h, p = c / l, v.x = a.x1 + (a.x2 - a.x1) * p, v.y = a.y1 + (a.y2 - a.y1) *
            p) : (c -= o, p = c / h, v.x = n.x1 + (n.x2 - n.x1) * p, v.y = n.y1 + (n.y2 - n.y1) * p),
            r.push(v);
          }
          return r;
        };
        VX.exports = Ipe;
      });
      HX = u((dOe, WX) => {
        var Bpe = C(), Gpe = pv(), Upe = XX(), zpe = YX(), kpe = ki(), xv = wn(), Xpe = Fl(), Vpe = new Bpe(
        { initialize: function(t, i, r, s, n, a) {
          t === void 0 && (t = 0), i === void 0 && (i = 0), r === void 0 && (r = 0), s === void 0 &&
          (s = 0), n === void 0 && (n = 0), a === void 0 && (a = 0), this.type = kpe.TRIANGLE, this.
          x1 = t, this.y1 = i, this.x2 = r, this.y2 = s, this.x3 = n, this.y3 = a;
        }, contains: function(e, t) {
          return Gpe(this, e, t);
        }, getPoint: function(e, t) {
          return Upe(this, e, t);
        }, getPoints: function(e, t, i) {
          return zpe(this, e, t, i);
        }, getRandomPoint: function(e) {
          return Xpe(this, e);
        }, setTo: function(e, t, i, r, s, n) {
          return e === void 0 && (e = 0), t === void 0 && (t = 0), i === void 0 && (i = 0), r === void 0 &&
          (r = 0), s === void 0 && (s = 0), n === void 0 && (n = 0), this.x1 = e, this.y1 = t, this.
          x2 = i, this.y2 = r, this.x3 = s, this.y3 = n, this;
        }, getLineA: function(e) {
          return e === void 0 && (e = new xv()), e.setTo(this.x1, this.y1, this.x2, this.y2), e;
        }, getLineB: function(e) {
          return e === void 0 && (e = new xv()), e.setTo(this.x2, this.y2, this.x3, this.y3), e;
        }, getLineC: function(e) {
          return e === void 0 && (e = new xv()), e.setTo(this.x3, this.y3, this.x1, this.y1), e;
        }, left: { get: function() {
          return Math.min(this.x1, this.x2, this.x3);
        }, set: function(e) {
          var t = 0;
          this.x1 <= this.x2 && this.x1 <= this.x3 ? t = this.x1 - e : this.x2 <= this.x1 && this.x2 <=
          this.x3 ? t = this.x2 - e : t = this.x3 - e, this.x1 -= t, this.x2 -= t, this.x3 -= t;
        } }, right: { get: function() {
          return Math.max(this.x1, this.x2, this.x3);
        }, set: function(e) {
          var t = 0;
          this.x1 >= this.x2 && this.x1 >= this.x3 ? t = this.x1 - e : this.x2 >= this.x1 && this.x2 >=
          this.x3 ? t = this.x2 - e : t = this.x3 - e, this.x1 -= t, this.x2 -= t, this.x3 -= t;
        } }, top: { get: function() {
          return Math.min(this.y1, this.y2, this.y3);
        }, set: function(e) {
          var t = 0;
          this.y1 <= this.y2 && this.y1 <= this.y3 ? t = this.y1 - e : this.y2 <= this.y1 && this.y2 <=
          this.y3 ? t = this.y2 - e : t = this.y3 - e, this.y1 -= t, this.y2 -= t, this.y3 -= t;
        } }, bottom: { get: function() {
          return Math.max(this.y1, this.y2, this.y3);
        }, set: function(e) {
          var t = 0;
          this.y1 >= this.y2 && this.y1 >= this.y3 ? t = this.y1 - e : this.y2 >= this.y1 && this.y2 >=
          this.y3 ? t = this.y2 - e : t = this.y3 - e, this.y1 -= t, this.y2 -= t, this.y3 -= t;
        } } });
        WX.exports = Vpe;
      });
      jX = u((cOe, $X) => {
        var Ype = vn(), Wpe = Tr(), Hpe = C(), vr = eh(), KX = fv(), Kpe = lv(), Zpe = Nn(), Qpe = Wc(),
        Jpe = Vc(), D8 = Mi(), Ev = Z(), pr = B(), en = ki(), $pe = xa(), jpe = lt(), eme = rt(), ZX = he(),
        QX = Ar(), xt = qe(), tme = HX(), ime = pv(), JX = new Hpe({ Extends: Ev, initialize: function(t) {
          Ev.call(this), this.scene = t, this.systems = t.sys, this.settings = t.sys.settings, this.
          manager = t.sys.game.input, this.pluginEvents = new Ev(), this.enabled = true, this.displayList,
          this.cameras, $pe.install(this), this.mouse = this.manager.mouse, this.topOnly = true, this.
          pollRate = -1, this._pollTimer = 0;
          var i = { cancelled: false };
          this._eventContainer = { stopPropagation: function() {
            i.cancelled = true;
          } }, this._eventData = i, this.dragDistanceThreshold = 0, this.dragTimeThreshold = 0, this.
          _temp = [], this._tempZones = [], this._list = [], this._pendingInsertion = [], this._pendingRemoval =
          [], this._draggable = [], this._drag = { 0: [], 1: [], 2: [], 3: [], 4: [], 5: [], 6: [], 7: [],
          8: [], 9: [], 10: [] }, this._dragState = [], this._over = { 0: [], 1: [], 2: [], 3: [], 4: [],
          5: [], 6: [], 7: [], 8: [], 9: [], 10: [] }, this._validTypes = ["onDown", "onUp", "onOver",
          "onOut", "onMove", "onDragStart", "onDrag", "onDragEnd", "onDragEnter", "onDragLeave", "on\
DragOver", "onDrop"], this._updatedThisFrame = false, t.sys.events.once(xt.BOOT, this.boot, this), t.
          sys.events.on(xt.START, this.start, this);
        }, boot: function() {
          this.cameras = this.systems.cameras, this.displayList = this.systems.displayList, this.systems.
          events.once(xt.DESTROY, this.destroy, this), this.pluginEvents.emit(D8.BOOT);
        }, start: function() {
          var e = this.systems.events;
          e.on(xt.TRANSITION_START, this.transitionIn, this), e.on(xt.TRANSITION_OUT, this.transitionOut,
          this), e.on(xt.TRANSITION_COMPLETE, this.transitionComplete, this), e.on(xt.PRE_UPDATE, this.
          preUpdate, this), e.once(xt.SHUTDOWN, this.shutdown, this), this.manager.events.on(D8.GAME_OUT,
          this.onGameOut, this), this.manager.events.on(D8.GAME_OVER, this.onGameOver, this), this.enabled =
          true, this._dragState = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], this.pluginEvents.emit(D8.START);
        }, onGameOver: function(e) {
          this.isActive() && this.emit(D8.GAME_OVER, e.timeStamp, e);
        }, onGameOut: function(e) {
          this.isActive() && this.emit(D8.GAME_OUT, e.timeStamp, e);
        }, preUpdate: function() {
          this.pluginEvents.emit(D8.PRE_UPDATE);
          var e = this._pendingRemoval, t = this._pendingInsertion, i = e.length, r = t.length;
          if (!(i === 0 && r === 0)) {
            for (var s = this._list, n = 0; n < i; n++) {
              var a = e[n], o = s.indexOf(a);
              o > -1 && (s.splice(o, 1), this.clear(a, true));
            }
            this._pendingRemoval.length = 0, this._list = s.concat(t.splice(0));
          }
        }, isActive: function() {
          return this.manager && this.manager.enabled && this.enabled && this.scene.sys.canInput();
        }, setCursor: function(e) {
          this.manager && this.manager.setCursor(e);
        }, resetCursor: function() {
          this.manager && this.manager.resetCursor(null, true);
        }, updatePoll: function(e, t) {
          if (!this.isActive()) return false;
          if (this.pluginEvents.emit(D8.UPDATE, e, t), this._updatedThisFrame) return this._updatedThisFrame =
          false, false;
          var i, r = this.manager, s = r.pointers;
          for (i = 0; i < s.length; i++) s[i].updateMotion();
          if (this._list.length === 0) return false;
          var n = this.pollRate;
          if (n === -1) return false;
          if (n > 0) if (this._pollTimer -= t, this._pollTimer < 0) this._pollTimer = this.pollRate;
          else return false;
          var a = false;
          for (i = 0; i < s.length; i++) {
            var o = 0, h = s[i];
            this._tempZones = [], this._temp = this.hitTestPointer(h), this.sortGameObjects(this._temp,
            h), this.sortDropZones(this._tempZones), this.topOnly && (this._temp.length && this._temp.
            splice(1), this._tempZones.length && this._tempZones.splice(1)), o += this.processOverOutEvents(
            h), this.getDragState(h) === 2 && this.processDragThresholdEvent(h, e), o > 0 && (a = true);
          }
          return a;
        }, update: function(e, t) {
          if (!this.isActive()) return false;
          for (var i = false, r = 0; r < t.length; r++) {
            var s = 0, n = t[r];
            switch (this._tempZones = [], this._temp = this.hitTestPointer(n), this.sortGameObjects(
            this._temp, n), this.sortDropZones(this._tempZones), this.topOnly && (this._temp.length &&
            this._temp.splice(1), this._tempZones.length && this._tempZones.splice(1)), e) {
              case vr.MOUSE_DOWN:
                s += this.processDragDownEvent(n), s += this.processDownEvents(n), s += this.processOverOutEvents(
                n);
                break;
              case vr.MOUSE_UP:
                s += this.processDragUpEvent(n), s += this.processUpEvents(n), s += this.processOverOutEvents(
                n);
                break;
              case vr.TOUCH_START:
                s += this.processDragDownEvent(n), s += this.processDownEvents(n), s += this.processOverEvents(
                n);
                break;
              case vr.TOUCH_END:
              case vr.TOUCH_CANCEL:
                s += this.processDragUpEvent(n), s += this.processUpEvents(n), s += this.processOutEvents(
                n);
                break;
              case vr.MOUSE_MOVE:
              case vr.TOUCH_MOVE:
                s += this.processDragMoveEvent(n), s += this.processMoveEvents(n), s += this.processOverOutEvents(
                n);
                break;
              case vr.MOUSE_WHEEL:
                s += this.processWheelEvent(n);
                break;
            }
            s > 0 && (i = true);
          }
          return this._updatedThisFrame = true, i;
        }, clear: function(e, t) {
          t === void 0 && (t = false), this.disable(e);
          var i = e.input;
          i && (this.removeDebug(e), this.manager.resetCursor(i), i.gameObject = void 0, i.target = void 0,
          i.hitArea = void 0, i.hitAreaCallback = void 0, i.callbackContext = void 0, e.input = null),
          t || this.queueForRemoval(e);
          var r = this._draggable.indexOf(e);
          return r > -1 && this._draggable.splice(r, 1), e;
        }, disable: function(e, t) {
          t === void 0 && (t = false);
          var i = e.input;
          i && (i.enabled = false, i.dragState = 0);
          for (var r = this._drag, s = this._over, n = this.manager, a = 0, o; a < n.pointers.length; a++)
           o = r[a].indexOf(e), o > -1 && r[a].splice(o, 1), o = s[a].indexOf(e), o > -1 && s[a].splice(
          o, 1);
          return t && this.resetCursor(), this;
        }, enable: function(e, t, i, r) {
          return r === void 0 && (r = false), e.input ? e.input.enabled = true : this.setHitArea(e, t,
          i), e.input && r && !e.input.dropZone && (e.input.dropZone = r), this;
        }, hitTestPointer: function(e) {
          for (var t = this.cameras.getCamerasBelowPointer(e), i = 0; i < t.length; i++) {
            for (var r = t[i], s = this.manager.hitTest(e, this._list, r), n = 0; n < s.length; n++) {
              var a = s[n];
              a.input.dropZone && this._tempZones.push(a);
            }
            if (s.length > 0) return e.camera = r, s;
          }
          return e.camera = t[0], [];
        }, processDownEvents: function(e) {
          var t = 0, i = this._temp, r = this._eventData, s = this._eventContainer;
          r.cancelled = false;
          for (var n = 0; n < i.length; n++) {
            var a = i[n];
            if (!(!a.input || !a.input.enabled) && (t++, a.emit(D8.GAMEOBJECT_POINTER_DOWN, e, a.input.
            localX, a.input.localY, s), r.cancelled || !this.isActive() || a.input && a.input.enabled &&
            (this.emit(D8.GAMEOBJECT_DOWN, e, a, s), r.cancelled || !this.isActive()))) break;
          }
          return !r.cancelled && this.isActive() && (e.downElement === this.manager.game.canvas ? this.
          emit(D8.POINTER_DOWN, e, i) : this.emit(D8.POINTER_DOWN_OUTSIDE, e)), t;
        }, getDragState: function(e) {
          return this._dragState[e.id];
        }, setDragState: function(e, t) {
          this._dragState[e.id] = t;
        }, processDragThresholdEvent: function(e, t) {
          var i = false, r = this.dragTimeThreshold, s = this.dragDistanceThreshold;
          if ((s > 0 && Zpe(e.x, e.y, e.downX, e.downY) >= s || r > 0 && t >= e.downTime + r) && (i =
          true), i) return this.setDragState(e, 3), this.processDragStartList(e);
        }, processDragStartList: function(e) {
          if (this.getDragState(e) !== 3) return 0;
          var t = this._drag[e.id];
          t.length > 1 && (t = t.slice(0));
          for (var i = 0; i < t.length; i++) {
            var r = t[i], s = r.input;
            s.dragState = 2, s.dragStartX = r.x, s.dragStartY = r.y, s.dragStartXGlobal = e.worldX, s.
            dragStartYGlobal = e.worldY, s.dragStartCamera = e.camera, s.dragX = s.dragStartXGlobal -
            s.dragStartX, s.dragY = s.dragStartYGlobal - s.dragStartY, r.emit(D8.GAMEOBJECT_DRAG_START,
            e, s.dragX, s.dragY), this.emit(D8.DRAG_START, e, r);
          }
          return this.setDragState(e, 4), t.length;
        }, processDragDownEvent: function(e) {
          var t = this._temp;
          if (this._draggable.length === 0 || t.length === 0 || !e.primaryDown || this.getDragState(
          e) !== 0) return 0;
          this.setDragState(e, 1);
          for (var i = [], r = 0; r < t.length; r++) {
            var s = t[r];
            s.input.draggable && s.input.dragState === 0 && i.push(s);
          }
          return i.length === 0 ? (this.setDragState(e, 0), 0) : (i.length > 1 && (this.sortGameObjects(
          i, e), this.topOnly && i.splice(1)), this._drag[e.id] = i, this.dragDistanceThreshold === 0 &&
          this.dragTimeThreshold === 0 ? (this.setDragState(e, 3), this.processDragStartList(e)) : (this.
          setDragState(e, 2), 0));
        }, processDragMoveEvent: function(e) {
          if (this.getDragState(e) === 2 && this.processDragThresholdEvent(e, this.manager.game.loop.
          now), this.getDragState(e) !== 4) return 0;
          var t = this._tempZones, i = this._drag[e.id];
          i.length > 1 && (i = i.slice(0));
          for (var r = 0; r < i.length; r++) {
            var s = i[r], n = s.input, a = n.target;
            if (a) {
              var o = t.indexOf(a);
              o === 0 ? (s.emit(D8.GAMEOBJECT_DRAG_OVER, e, a), this.emit(D8.DRAG_OVER, e, s, a)) : o >
              0 ? (s.emit(D8.GAMEOBJECT_DRAG_LEAVE, e, a), this.emit(D8.DRAG_LEAVE, e, s, a), n.target =
              t[0], a = n.target, s.emit(D8.GAMEOBJECT_DRAG_ENTER, e, a), this.emit(D8.DRAG_ENTER, e,
              s, a)) : (s.emit(D8.GAMEOBJECT_DRAG_LEAVE, e, a), this.emit(D8.DRAG_LEAVE, e, s, a), t[0] ?
              (n.target = t[0], a = n.target, s.emit(D8.GAMEOBJECT_DRAG_ENTER, e, a), this.emit(D8.DRAG_ENTER,
              e, s, a)) : n.target = null);
            } else !a && t[0] && (n.target = t[0], a = n.target, s.emit(D8.GAMEOBJECT_DRAG_ENTER, e,
            a), this.emit(D8.DRAG_ENTER, e, s, a));
            var h, l, f = e.positionToCamera(n.dragStartCamera);
            if (!s.parentContainer) h = f.x - n.dragX, l = f.y - n.dragY;
            else {
              var d = f.x - n.dragStartXGlobal, c = f.y - n.dragStartYGlobal, p = s.getParentRotation(),
              v = d * Math.cos(p) + c * Math.sin(p), m = c * Math.cos(p) - d * Math.sin(p);
              v *= 1 / s.parentContainer.scaleX, m *= 1 / s.parentContainer.scaleY, h = v + n.dragStartX,
              l = m + n.dragStartY;
            }
            s.emit(D8.GAMEOBJECT_DRAG, e, h, l), this.emit(D8.DRAG, e, s, h, l);
          }
          return i.length;
        }, processDragUpEvent: function(e) {
          var t = this._drag[e.id];
          t.length > 1 && (t = t.slice(0));
          for (var i = 0; i < t.length; i++) {
            var r = t[i], s = r.input;
            if (s && s.dragState === 2) {
              s.dragState = 0, s.dragX = s.localX - r.displayOriginX, s.dragY = s.localY - r.displayOriginY,
              s.dragStartCamera = null;
              var n = false, a = s.target;
              a && (r.emit(D8.GAMEOBJECT_DROP, e, a), this.emit(D8.DROP, e, r, a), s.target = null, n =
              true), r.input && r.input.enabled && (r.emit(D8.GAMEOBJECT_DRAG_END, e, s.dragX, s.dragY,
              n), this.emit(D8.DRAG_END, e, r, n));
            }
          }
          return this.setDragState(e, 0), t.splice(0), 0;
        }, processMoveEvents: function(e) {
          var t = 0, i = this._temp, r = this._eventData, s = this._eventContainer;
          r.cancelled = false;
          for (var n = 0; n < i.length; n++) {
            var a = i[n];
            if (!(!a.input || !a.input.enabled) && (t++, a.emit(D8.GAMEOBJECT_POINTER_MOVE, e, a.input.
            localX, a.input.localY, s), r.cancelled || !this.isActive() || a.input && a.input.enabled &&
            (this.emit(D8.GAMEOBJECT_MOVE, e, a, s), r.cancelled || !this.isActive() || this.topOnly)))
             break;
          }
          return !r.cancelled && this.isActive() && this.emit(D8.POINTER_MOVE, e, i), t;
        }, processWheelEvent: function(e) {
          var t = 0, i = this._temp, r = this._eventData, s = this._eventContainer;
          r.cancelled = false;
          for (var n = e.deltaX, a = e.deltaY, o = e.deltaZ, h = 0; h < i.length; h++) {
            var l = i[h];
            if (!(!l.input || !l.input.enabled) && (t++, l.emit(D8.GAMEOBJECT_POINTER_WHEEL, e, n, a,
            o, s), r.cancelled || !this.isActive() || l.input && l.input.enabled && (this.emit(D8.GAMEOBJECT_WHEEL,
            e, l, n, a, o, s), r.cancelled || !this.isActive()))) break;
          }
          return !r.cancelled && this.isActive() && this.emit(D8.POINTER_WHEEL, e, i, n, a, o), t;
        }, processOverEvents: function(e) {
          var t = this._temp, i = 0, r = t.length, s = [];
          if (r > 0) {
            var n = this.manager, a = this._eventData, o = this._eventContainer;
            a.cancelled = false;
            for (var h = 0; h < r; h++) {
              var l = t[h];
              if (!(!l.input || !l.input.enabled) && (s.push(l), n.setCursor(l.input), l.emit(D8.GAMEOBJECT_POINTER_OVER,
              e, l.input.localX, l.input.localY, o), i++, a.cancelled || !this.isActive() || l.input &&
              l.input.enabled && (this.emit(D8.GAMEOBJECT_OVER, e, l, o), a.cancelled || !this.isActive())))
               break;
            }
            !a.cancelled && this.isActive() && this.emit(D8.POINTER_OVER, e, s);
          }
          return this._over[e.id] = s, i;
        }, processOutEvents: function(e) {
          var t = this._over[e.id], i = 0, r = t.length;
          if (r > 0) {
            var s = this.manager, n = this._eventData, a = this._eventContainer;
            n.cancelled = false, this.sortGameObjects(t, e);
            for (var o = 0; o < r; o++) {
              var h = t[o];
              if (h = t[o], !(!h.input || !h.input.enabled) && (s.resetCursor(h.input), h.emit(D8.GAMEOBJECT_POINTER_OUT,
              e, a), i++, n.cancelled || !this.isActive() || h.input && h.input.enabled && (this.emit(
              D8.GAMEOBJECT_OUT, e, h, a), n.cancelled || !this.isActive()))) break;
            }
            !n.cancelled && this.isActive() && this.emit(D8.POINTER_OUT, e, t), this._over[e.id] = [];
          }
          return i;
        }, processOverOutEvents: function(e) {
          var t = this._temp, i, r, s = [], n = [], a = [], o = this._over[e.id], h = this._drag[e.id],
          l = this.manager;
          for (i = 0; i < o.length; i++) r = o[i], t.indexOf(r) === -1 && h.indexOf(r) === -1 ? s.push(
          r) : a.push(r);
          for (i = 0; i < t.length; i++) r = t[i], o.indexOf(r) === -1 && n.push(r);
          var f = s.length, d = 0, c = this._eventData, p = this._eventContainer;
          if (c.cancelled = false, f > 0) {
            for (this.sortGameObjects(s, e), i = 0; i < f && (r = s[i], !(!(!r.input || !r.input.enabled) &&
            (l.resetCursor(r.input), r.emit(D8.GAMEOBJECT_POINTER_OUT, e, p), d++, c.cancelled || !this.
            isActive() || r.input && r.input.enabled && (this.emit(D8.GAMEOBJECT_OUT, e, r, p), c.cancelled ||
            !this.isActive())))); i++) ;
            (!c.cancelled || this.isActive()) && this.emit(D8.POINTER_OUT, e, s);
          }
          if (f = n.length, c.cancelled = false, f > 0) {
            for (this.sortGameObjects(n, e), i = 0; i < f && (r = n[i], !(!(!r.input || !r.input.enabled) &&
            (l.setCursor(r.input), r.emit(D8.GAMEOBJECT_POINTER_OVER, e, r.input.localX, r.input.localY,
            p), d++, c.cancelled || !this.isActive() || r.input && r.input.enabled && (this.emit(D8.
            GAMEOBJECT_OVER, e, r, p), c.cancelled || !this.isActive())))); i++) ;
            !c.cancelled && this.isActive() && this.emit(D8.POINTER_OVER, e, n);
          }
          return o = a.concat(n), this._over[e.id] = this.sortGameObjects(o, e), d;
        }, processUpEvents: function(e) {
          var t = this._temp, i = this._eventData, r = this._eventContainer;
          i.cancelled = false;
          for (var s = 0; s < t.length; s++) {
            var n = t[s];
            if (!(!n.input || !n.input.enabled) && (n.emit(D8.GAMEOBJECT_POINTER_UP, e, n.input.localX,
            n.input.localY, r), i.cancelled || !this.isActive() || n.input && n.input.enabled && (this.
            emit(D8.GAMEOBJECT_UP, e, n, r), i.cancelled || !this.isActive()))) break;
          }
          return !i.cancelled && this.isActive() && (e.upElement === this.manager.game.canvas ? this.
          emit(D8.POINTER_UP, e, t) : this.emit(D8.POINTER_UP_OUTSIDE, e)), t.length;
        }, forceDownState: function(e, t) {
          this.forceState(e, t, D8.GAMEOBJECT_POINTER_DOWN, D8.GAMEOBJECT_DOWN, false);
        }, forceUpState: function(e, t) {
          this.forceState(e, t, D8.GAMEOBJECT_POINTER_UP, D8.GAMEOBJECT_UP, false);
        }, forceOverState: function(e, t) {
          this.forceState(e, t, D8.GAMEOBJECT_POINTER_OVER, D8.GAMEOBJECT_OVER, true);
        }, forceOutState: function(e, t) {
          this.forceState(e, t, D8.GAMEOBJECT_POINTER_OUT, D8.GAMEOBJECT_OUT, false);
        }, forceState: function(e, t, i, r, s) {
          var n = this._eventData, a = this._eventContainer;
          n.cancelled = false, t.input && t.input.enabled && (t.emit(i, e, t.input.localX, t.input.localY,
          a), s && this.setCursor(t.input), !n.cancelled && this.isActive() && t.input && t.input.enabled &&
          this.emit(r, e, t, a));
        }, queueForInsertion: function(e) {
          return this._pendingInsertion.indexOf(e) === -1 && this._list.indexOf(e) === -1 && this._pendingInsertion.
          push(e), this;
        }, queueForRemoval: function(e) {
          return this._pendingRemoval.push(e), this;
        }, setDraggable: function(e, t) {
          t === void 0 && (t = true), Array.isArray(e) || (e = [e]);
          for (var i = 0; i < e.length; i++) {
            var r = e[i];
            r.input.draggable = t;
            var s = this._draggable.indexOf(r);
            t && s === -1 ? this._draggable.push(r) : !t && s > -1 && this._draggable.splice(s, 1);
          }
          return this;
        }, makePixelPerfect: function(e) {
          e === void 0 && (e = 1);
          var t = this.systems.textures;
          return Kpe(t, e);
        }, setHitArea: function(e, t, i) {
          if (t === void 0) return this.setHitAreaFromTexture(e);
          Array.isArray(e) || (e = [e]);
          var r = false, s = false, n = false, a = false, o = false, h = true;
          if (jpe(t) && Object.keys(t).length) {
            var l = t, f = e.some(function(m) {
              return m.hasOwnProperty("faces");
            });
            if (!f) {
              t = pr(l, "hitArea", null), i = pr(l, "hitAreaCallback", null), o = pr(l, "pixelPerfec\
t", false);
              var d = pr(l, "alphaTolerance", 1);
              o && (t = {}, i = this.makePixelPerfect(d));
            }
            r = pr(l, "draggable", false), s = pr(l, "dropZone", false), n = pr(l, "cursor", false),
            a = pr(l, "useHandCursor", false), (!t || !i) && (this.setHitAreaFromTexture(e), h = false);
          } else typeof t == "function" && !i && (i = t, t = {});
          for (var c = 0; c < e.length; c++) {
            var p = e[c];
            if (o && p.type === "Container") {
              console.warn("Cannot pixelPerfect test a Container. Use a custom callback.");
              continue;
            }
            var v = p.input ? p.input : KX(p, t, i);
            v.customHitArea = h, v.dropZone = s, v.cursor = a ? "pointer" : n, p.input = v, r && this.
            setDraggable(p), this.queueForInsertion(p);
          }
          return this;
        }, setHitAreaCircle: function(e, t, i, r, s) {
          s === void 0 && (s = Wpe);
          var n = new Ype(t, i, r);
          return this.setHitArea(e, n, s);
        }, setHitAreaEllipse: function(e, t, i, r, s, n) {
          n === void 0 && (n = Jpe);
          var a = new Qpe(t, i, r, s);
          return this.setHitArea(e, a, n);
        }, setHitAreaFromTexture: function(e, t) {
          t === void 0 && (t = QX), Array.isArray(e) || (e = [e]);
          for (var i = 0; i < e.length; i++) {
            var r = e[i], s = r.frame, n = 0, a = 0;
            if (r.width ? (n = r.width, a = r.height) : s && (n = s.realWidth, a = s.realHeight), r.
            type === "Container" && (n === 0 || a === 0)) {
              console.warn("Container.setInteractive must specify a Shape or call setSize() first");
              continue;
            }
            n !== 0 && a !== 0 && (r.input = KX(r, new ZX(0, 0, n, a), t), this.queueForInsertion(r));
          }
          return this;
        }, setHitAreaRectangle: function(e, t, i, r, s, n) {
          n === void 0 && (n = QX);
          var a = new ZX(t, i, r, s);
          return this.setHitArea(e, a, n);
        }, setHitAreaTriangle: function(e, t, i, r, s, n, a, o) {
          o === void 0 && (o = ime);
          var h = new tme(t, i, r, s, n, a);
          return this.setHitArea(e, h, o);
        }, enableDebug: function(e, t) {
          t === void 0 && (t = 65280);
          var i = e.input;
          if (!i || !i.hitArea) return this;
          var r = i.hitArea, s = r.type, n = i.hitAreaDebug, a = this.systems.add, o = this.systems.
          updateList;
          n && (o.remove(n), n.destroy(), n = null);
          var h = 0, l = 0;
          switch (s) {
            case en.CIRCLE:
              n = a.arc(0, 0, r.radius), h = r.x - r.radius, l = r.y - r.radius;
              break;
            case en.ELLIPSE:
              n = a.ellipse(0, 0, r.width, r.height), h = r.x - r.width / 2, l = r.y - r.height / 2;
              break;
            case en.LINE:
              n = a.line(0, 0, r.x1, r.y1, r.x2, r.y2);
              break;
            case en.POLYGON:
              n = a.polygon(0, 0, r.points);
              break;
            case en.RECTANGLE:
              n = a.rectangle(0, 0, r.width, r.height), h = r.x, l = r.y;
              break;
            case en.TRIANGLE:
              n = a.triangle(0, 0, r.x1, r.y1, r.x2, r.y2, r.x3, r.y3);
              break;
          }
          return n && (n.isFilled = false, n.strokeColor = t, n.preUpdate = function() {
            n.setVisible(e.visible), n.setStrokeStyle(1 / e.scale, n.strokeColor), n.setDisplayOrigin(
            e.displayOriginX, e.displayOriginY);
            var f = e.x, d = e.y, c = e.rotation, p = e.scaleX, v = e.scaleY;
            if (e.parentContainer) {
              var m = e.getWorldTransformMatrix();
              f = m.tx, d = m.ty, c = m.rotation, p = m.scaleX, v = m.scaleY;
            }
            n.setRotation(c), n.setScale(p, v), n.setPosition(f + h * p, d + l * v), n.setScrollFactor(
            e.scrollFactorX, e.scrollFactorY), n.setDepth(e.depth);
          }, o.add(n), i.hitAreaDebug = n), this;
        }, removeDebug: function(e) {
          var t = e.input;
          if (t && t.hitAreaDebug) {
            var i = t.hitAreaDebug;
            i.destroy(), t.hitAreaDebug = null;
          }
          return this;
        }, setPollAlways: function() {
          return this.setPollRate(0);
        }, setPollOnMove: function() {
          return this.setPollRate(-1);
        }, setPollRate: function(e) {
          return this.pollRate = e, this._pollTimer = 0, this;
        }, setGlobalTopOnly: function(e) {
          return this.manager.globalTopOnly = e, this;
        }, setTopOnly: function(e) {
          return this.topOnly = e, this;
        }, sortGameObjects: function(e, t) {
          if (e.length < 2 || !t.camera) return e;
          var i = t.camera.renderList;
          return e.sort(function(r, s) {
            var n = Math.max(i.indexOf(r), 0), a = Math.max(i.indexOf(s), 0);
            return a - n;
          });
        }, sortDropZones: function(e) {
          return e.length < 2 ? e : (this.scene.sys.depthSort(), e.sort(this.sortDropZoneHandler.bind(
          this)));
        }, sortDropZoneHandler: function(e, t) {
          if (!e.parentContainer && !t.parentContainer) return this.displayList.getIndex(t) - this.displayList.
          getIndex(e);
          if (e.parentContainer === t.parentContainer) return t.parentContainer.getIndex(t) - e.parentContainer.
          getIndex(e);
          if (e.parentContainer === t) return -1;
          if (t.parentContainer === e) return 1;
          for (var i = e.getIndexList(), r = t.getIndexList(), s = Math.min(i.length, r.length), n = 0; n <
          s; n++) {
            var a = i[n], o = r[n];
            if (a !== o) return o - a;
          }
          return r.length - i.length;
          return 0;
        }, stopPropagation: function() {
          return this.manager._tempSkip = true, this;
        }, addPointer: function(e) {
          return this.manager.addPointer(e);
        }, setDefaultCursor: function(e) {
          return this.manager.setDefaultCursor(e), this;
        }, transitionIn: function() {
          this.enabled = this.settings.transitionAllowInput;
        }, transitionComplete: function() {
          this.settings.transitionAllowInput || (this.enabled = true);
        }, transitionOut: function() {
          this.enabled = this.settings.transitionAllowInput;
        }, shutdown: function() {
          this.pluginEvents.emit(D8.SHUTDOWN), this._temp.length = 0, this._list.length = 0, this._draggable.
          length = 0, this._pendingRemoval.length = 0, this._pendingInsertion.length = 0, this._dragState.
          length = 0;
          for (var e = 0; e < 10; e++) this._drag[e] = [], this._over[e] = [];
          this.removeAllListeners();
          var t = this.manager;
          t.canvas.style.cursor = t.defaultCursor;
          var i = this.systems.events;
          i.off(xt.TRANSITION_START, this.transitionIn, this), i.off(xt.TRANSITION_OUT, this.transitionOut,
          this), i.off(xt.TRANSITION_COMPLETE, this.transitionComplete, this), i.off(xt.PRE_UPDATE, this.
          preUpdate, this), t.events.off(D8.GAME_OUT, this.onGameOut, this), t.events.off(D8.GAME_OVER,
          this.onGameOver, this), i.off(xt.SHUTDOWN, this.shutdown, this);
        }, resetPointers: function() {
          for (var e = this.manager.pointers, t = 0; t < e.length; t++) e[t].reset();
        }, destroy: function() {
          this.shutdown(), this.pluginEvents.emit(D8.DESTROY), this.pluginEvents.removeAllListeners(),
          this.scene.sys.events.off(xt.START, this.start, this), this.scene = null, this.cameras = null,
          this.manager = null, this.events = null, this.mouse = null;
        }, x: { get: function() {
          return this.manager.activePointer.x;
        } }, y: { get: function() {
          return this.manager.activePointer.y;
        } }, isOver: { get: function() {
          return this.manager.isOver;
        } }, mousePointer: { get: function() {
          return this.manager.mousePointer;
        } }, activePointer: { get: function() {
          return this.manager.activePointer;
        } }, pointer1: { get: function() {
          return this.manager.pointers[1];
        } }, pointer2: { get: function() {
          return this.manager.pointers[2];
        } }, pointer3: { get: function() {
          return this.manager.pointers[3];
        } }, pointer4: { get: function() {
          return this.manager.pointers[4];
        } }, pointer5: { get: function() {
          return this.manager.pointers[5];
        } }, pointer6: { get: function() {
          return this.manager.pointers[6];
        } }, pointer7: { get: function() {
          return this.manager.pointers[7];
        } }, pointer8: { get: function() {
          return this.manager.pointers[8];
        } }, pointer9: { get: function() {
          return this.manager.pointers[9];
        } }, pointer10: { get: function() {
          return this.manager.pointers[10];
        } } });
        eme.register("InputPlugin", JX, "input");
        $X.exports = JX;
      });
      tV = u((vOe, eV) => {
        eV.exports = "keydown";
      });
      rV = u((pOe, iV) => {
        iV.exports = "keyup";
      });
      nV = u((mOe, sV) => {
        sV.exports = "keycombomatch";
      });
      oV = u((gOe, aV) => {
        aV.exports = "down";
      });
      uV = u((xOe, hV) => {
        hV.exports = "keydown-";
      });
      fV = u((EOe, lV) => {
        lV.exports = "keyup-";
      });
      cV = u((TOe, dV) => {
        dV.exports = "up";
      });
      Ea = u((yOe, vV) => {
        vV.exports = { ANY_KEY_DOWN: tV(), ANY_KEY_UP: rV(), COMBO_MATCH: nV(), DOWN: oV(), KEY_DOWN: uV(),
        KEY_UP: fV(), UP: cV() };
      });
      yv = u((SOe, mV) => {
        var rme = C(), pV = Z(), Tv = Ea(), sme = new rme({ Extends: pV, initialize: function(t, i) {
          pV.call(this), this.plugin = t, this.keyCode = i, this.originalEvent = void 0, this.enabled =
          true, this.isDown = false, this.isUp = true, this.altKey = false, this.ctrlKey = false, this.
          shiftKey = false, this.metaKey = false, this.location = 0, this.timeDown = 0, this.duration =
          0, this.timeUp = 0, this.emitOnRepeat = false, this.repeats = 0, this._justDown = false, this.
          _justUp = false, this._tick = -1;
        }, setEmitOnRepeat: function(e) {
          return this.emitOnRepeat = e, this;
        }, onDown: function(e) {
          this.originalEvent = e, this.enabled && (this.altKey = e.altKey, this.ctrlKey = e.ctrlKey,
          this.shiftKey = e.shiftKey, this.metaKey = e.metaKey, this.location = e.location, this.repeats++,
          this.isDown ? this.emitOnRepeat && this.emit(Tv.DOWN, this, e) : (this.isDown = true, this.
          isUp = false, this.timeDown = e.timeStamp, this.duration = 0, this._justDown = true, this.
          _justUp = false, this.emit(Tv.DOWN, this, e)));
        }, onUp: function(e) {
          this.originalEvent = e, this.enabled && (this.isDown = false, this.isUp = true, this.timeUp =
          e.timeStamp, this.duration = this.timeUp - this.timeDown, this.repeats = 0, this._justDown =
          false, this._justUp = true, this._tick = -1, this.emit(Tv.UP, this, e));
        }, reset: function() {
          return this.isDown = false, this.isUp = true, this.altKey = false, this.ctrlKey = false, this.
          shiftKey = false, this.metaKey = false, this.timeDown = 0, this.duration = 0, this.timeUp =
          0, this.repeats = 0, this._justDown = false, this._justUp = false, this._tick = -1, this;
        }, getDuration: function() {
          return this.isDown ? this.plugin.game.loop.time - this.timeDown : 0;
        }, destroy: function() {
          this.removeAllListeners(), this.originalEvent = null, this.plugin = null;
        } });
        mV.exports = sme;
      });
      Sv = u((wOe, gV) => {
        var nme = function(e, t) {
          return t.timeLastMatched = e.timeStamp, t.index++, t.index === t.size ? true : (t.current =
          t.keyCodes[t.index], false);
        };
        gV.exports = nme;
      });
      wv = u((COe, EV) => {
        var xV = Sv(), ame = function(e, t) {
          if (t.matched) return true;
          var i = false, r = false;
          if (e.keyCode === t.current) if (t.index > 0 && t.maxKeyDelay > 0) {
            var s = t.timeLastMatched + t.maxKeyDelay;
            e.timeStamp <= s && (r = true, i = xV(e, t));
          } else r = true, i = xV(e, t);
          return !r && t.resetOnWrongKey && (t.index = 0, t.current = t.keyCodes[0]), i && (t.timeLastMatched =
          e.timeStamp, t.matched = true, t.timeMatched = e.timeStamp), i;
        };
        EV.exports = ame;
      });
      Cv = u((AOe, TV) => {
        var ome = function(e) {
          return e.current = e.keyCodes[0], e.index = 0, e.timeLastMatched = 0, e.matched = false, e.
          timeMatched = 0, e;
        };
        TV.exports = ome;
      });
      Rv = u((ROe, yV) => {
        var hme = C(), Av = Ea(), zh = B(), ume = wv(), lme = Cv(), fme = new hme({ initialize: function(t, i, r) {
          if (r === void 0 && (r = {}), i.length < 2) return false;
          this.manager = t, this.enabled = true, this.keyCodes = [];
          for (var s = 0; s < i.length; s++) {
            var n = i[s];
            typeof n == "string" ? this.keyCodes.push(n.toUpperCase().charCodeAt(0)) : typeof n == "\
number" ? this.keyCodes.push(n) : n.hasOwnProperty("keyCode") && this.keyCodes.push(n.keyCode);
          }
          this.current = this.keyCodes[0], this.index = 0, this.size = this.keyCodes.length, this.timeLastMatched =
          0, this.matched = false, this.timeMatched = 0, this.resetOnWrongKey = zh(r, "resetOnWrongK\
ey", true), this.maxKeyDelay = zh(r, "maxKeyDelay", 0), this.resetOnMatch = zh(r, "resetOnMatch", false),
          this.deleteOnMatch = zh(r, "deleteOnMatch", false);
          var a = this, o = function(h) {
            if (!(a.matched || !a.enabled)) {
              var l = ume(h, a);
              l && (a.manager.emit(Av.COMBO_MATCH, a, h), a.resetOnMatch ? lme(a) : a.deleteOnMatch &&
              a.destroy());
            }
          };
          this.onKeyDown = o, this.manager.on(Av.ANY_KEY_DOWN, this.onKeyDown);
        }, progress: { get: function() {
          return this.index / this.size;
        } }, destroy: function() {
          this.enabled = false, this.keyCodes = [], this.manager.off(Av.ANY_KEY_DOWN, this.onKeyDown),
          this.manager = null;
        } });
        yV.exports = fme;
      });
      AV = u((_Oe, CV) => {
        var SV = Jn(), wV = {};
        for (_v in SV) wV[SV[_v]] = _v;
        var _v;
        CV.exports = wV;
      });
      FV = u((POe, qV) => {
        var dme = C(), RV = Z(), kh = Ea(), _V = Ye(), PV = H(), tn = Mi(), cme = xa(), Pv = yv(), mr = Jn(),
        vme = Rv(), Xh = AV(), Vh = qe(), pme = Un(), MV = new dme({ Extends: RV, initialize: function(t) {
          RV.call(this), this.game = t.systems.game, this.scene = t.scene, this.settings = this.scene.
          sys.settings, this.sceneInputPlugin = t, this.manager = t.manager.keyboard, this.enabled =
          true, this.keys = [], this.combos = [], this.prevCode = null, this.prevTime = 0, this.prevType =
          null, t.pluginEvents.once(tn.BOOT, this.boot, this), t.pluginEvents.on(tn.START, this.start,
          this);
        }, boot: function() {
          var e = this.settings.input;
          this.enabled = PV(e, "keyboard", true);
          var t = PV(e, "keyboard.capture", null);
          t && this.addCaptures(t), this.sceneInputPlugin.pluginEvents.once(tn.DESTROY, this.destroy,
          this);
        }, start: function() {
          this.sceneInputPlugin.manager.events.on(tn.MANAGER_PROCESS, this.update, this), this.sceneInputPlugin.
          pluginEvents.once(tn.SHUTDOWN, this.shutdown, this), this.game.events.on(_V.BLUR, this.resetKeys,
          this), this.scene.sys.events.on(Vh.PAUSE, this.resetKeys, this), this.scene.sys.events.on(
          Vh.SLEEP, this.resetKeys, this);
        }, isActive: function() {
          return this.enabled && this.scene.sys.canInput();
        }, addCapture: function(e) {
          return this.manager.addCapture(e), this;
        }, removeCapture: function(e) {
          return this.manager.removeCapture(e), this;
        }, getCaptures: function() {
          return this.manager.captures;
        }, enableGlobalCapture: function() {
          return this.manager.preventDefault = true, this;
        }, disableGlobalCapture: function() {
          return this.manager.preventDefault = false, this;
        }, clearCaptures: function() {
          return this.manager.clearCaptures(), this;
        }, createCursorKeys: function() {
          return this.addKeys({ up: mr.UP, down: mr.DOWN, left: mr.LEFT, right: mr.RIGHT, space: mr.
          SPACE, shift: mr.SHIFT });
        }, addKeys: function(e, t, i) {
          t === void 0 && (t = true), i === void 0 && (i = false);
          var r = {};
          if (typeof e == "string") {
            e = e.split(",");
            for (var s = 0; s < e.length; s++) {
              var n = e[s].trim();
              n && (r[n] = this.addKey(n, t, i));
            }
          } else for (var a in e) r[a] = this.addKey(e[a], t, i);
          return r;
        }, addKey: function(e, t, i) {
          t === void 0 && (t = true), i === void 0 && (i = false);
          var r = this.keys;
          if (e instanceof Pv) {
            var s = r.indexOf(e);
            return s > -1 ? r[s] = e : r[e.keyCode] = e, t && this.addCapture(e.keyCode), e.setEmitOnRepeat(
            i), e;
          }
          return typeof e == "string" && (e = mr[e.toUpperCase()]), r[e] || (r[e] = new Pv(this, e),
          t && this.addCapture(e), r[e].setEmitOnRepeat(i)), r[e];
        }, removeKey: function(e, t, i) {
          t === void 0 && (t = false), i === void 0 && (i = false);
          var r = this.keys, s;
          if (e instanceof Pv) {
            var n = r.indexOf(e);
            n > -1 && (s = this.keys[n], this.keys[n] = void 0);
          } else typeof e == "string" && (e = mr[e.toUpperCase()]);
          return r[e] && (s = r[e], r[e] = void 0), s && (s.plugin = null, i && this.removeCapture(s.
          keyCode), t && s.destroy()), this;
        }, removeAllKeys: function(e, t) {
          e === void 0 && (e = false), t === void 0 && (t = false);
          for (var i = this.keys, r = 0; r < i.length; r++) {
            var s = i[r];
            s && (i[r] = void 0, t && this.removeCapture(s.keyCode), e && s.destroy());
          }
          return this;
        }, createCombo: function(e, t) {
          return new vme(this, e, t);
        }, checkDown: function(e, t) {
          if (t === void 0 && (t = 0), this.enabled && e.isDown) {
            var i = pme(this.time - e.timeDown, t);
            if (i > e._tick) return e._tick = i, true;
          }
          return false;
        }, update: function() {
          var e = this.manager.queue, t = e.length;
          if (!(!this.isActive() || t === 0)) for (var i = this.keys, r = 0; r < t; r++) {
            var s = e[r], n = s.keyCode, a = i[n], o = false;
            s.cancelled === void 0 && (s.cancelled = 0, s.stopImmediatePropagation = function() {
              s.cancelled = 1;
            }, s.stopPropagation = function() {
              s.cancelled = -1;
            }), s.cancelled !== -1 && (n === this.prevCode && s.timeStamp === this.prevTime && s.type ===
            this.prevType || (this.prevCode = n, this.prevTime = s.timeStamp, this.prevType = s.type,
            s.type === "keydown" ? (a && (o = a.isDown, a.onDown(s)), !s.cancelled && (!a || !o) && (Xh[n] &&
            this.emit(kh.KEY_DOWN + Xh[n], s), s.cancelled || this.emit(kh.ANY_KEY_DOWN, s))) : (a &&
            a.onUp(s), s.cancelled || (Xh[n] && this.emit(kh.KEY_UP + Xh[n], s), s.cancelled || this.
            emit(kh.ANY_KEY_UP, s))), s.cancelled === 1 && (s.cancelled = 0)));
          }
        }, resetKeys: function() {
          for (var e = this.keys, t = 0; t < e.length; t++) e[t] && e[t].reset();
          return this;
        }, shutdown: function() {
          this.removeAllKeys(true), this.removeAllListeners(), this.sceneInputPlugin.manager.events.
          off(tn.MANAGER_PROCESS, this.update, this), this.game.events.off(_V.BLUR, this.resetKeys),
          this.scene.sys.events.off(Vh.PAUSE, this.resetKeys, this), this.scene.sys.events.off(Vh.SLEEP,
          this.resetKeys, this), this.queue = [];
        }, destroy: function() {
          this.shutdown();
          for (var e = this.keys, t = 0; t < e.length; t++) e[t] && e[t].destroy();
          this.keys = [], this.combos = [], this.queue = [], this.scene = null, this.settings = null,
          this.sceneInputPlugin = null, this.manager = null;
        }, time: { get: function() {
          return this.sceneInputPlugin.manager.time;
        } } });
        cme.register("KeyboardPlugin", MV, "keyboard", "keyboard", "inputKeyboard");
        qV.exports = MV;
      });
      LV = u((MOe, bV) => {
        var mme = function(e) {
          return e._justDown ? (e._justDown = false, true) : false;
        };
        bV.exports = mme;
      });
      DV = u((qOe, OV) => {
        var gme = function(e) {
          return e._justUp ? (e._justUp = false, true) : false;
        };
        OV.exports = gme;
      });
      IV = u((FOe, NV) => {
        var xme = function(e, t) {
          t === void 0 && (t = 50);
          var i = e.plugin.game.loop.time - e.timeDown;
          return e.isDown && i < t;
        };
        NV.exports = xme;
      });
      GV = u((bOe, BV) => {
        var Eme = function(e, t) {
          t === void 0 && (t = 50);
          var i = e.plugin.game.loop.time - e.timeUp;
          return e.isUp && i < t;
        };
        BV.exports = Eme;
      });
      zV = u((LOe, UV) => {
        UV.exports = { Events: Ea(), KeyboardManager: Qd(), KeyboardPlugin: FV(), Key: yv(), KeyCodes: Jn(),
        KeyCombo: Rv(), AdvanceKeyCombo: Sv(), ProcessKeyCombo: wv(), ResetKeyCombo: Cv(), JustDown: LV(),
        JustUp: DV(), DownDuration: IV(), UpDuration: GV() };
      });
      XV = u((OOe, kV) => {
        kV.exports = { MouseManager: Jd() };
      });
      YV = u((DOe, VV) => {
        VV.exports = { TouchManager: ec() };
      });
      HV = u((NOe, WV) => {
        var Tme = eh(), yme = Xe(), Mv = { CreatePixelPerfectHandler: lv(), CreateInteractiveObject: fv(),
        Events: Mi(), Gamepad: UX(), InputManager: tc(), InputPlugin: jX(), InputPluginCache: xa(), Keyboard: zV(),
        Mouse: XV(), Pointer: jd(), Touch: YV() };
        Mv = yme(false, Mv, Tme);
        WV.exports = Mv;
      });
      Kr = u((IOe, KV) => {
        var Sme = { LOADER_IDLE: 0, LOADER_LOADING: 1, LOADER_PROCESSING: 2, LOADER_COMPLETE: 3, LOADER_SHUTDOWN: 4,
        LOADER_DESTROYED: 5, FILE_PENDING: 10, FILE_LOADING: 11, FILE_LOADED: 12, FILE_FAILED: 13, FILE_PROCESSING: 14,
        FILE_ERRORED: 16, FILE_COMPLETE: 17, FILE_DESTROYED: 18, FILE_POPULATED: 19, FILE_PENDING_DESTROY: 20 };
        KV.exports = Sme;
      });
      Ta = u((BOe, ZV) => {
        var wme = function(e, t) {
          return e.url ? e.url.match(/^(?:blob:|data:|capacitor:\/\/|http:\/\/|https:\/\/|\/\/)/) ? e.
          url : t + e.url : false;
        };
        ZV.exports = wme;
      });
      ya = u((GOe, QV) => {
        var Cme = function(e, t, i, r, s, n) {
          return e === void 0 && (e = ""), t === void 0 && (t = true), i === void 0 && (i = ""), r ===
          void 0 && (r = ""), s === void 0 && (s = 0), n === void 0 && (n = false), { responseType: e,
          async: t, user: i, password: r, timeout: s, headers: void 0, header: void 0, headerValue: void 0,
          requestedWith: false, overrideMimeType: void 0, withCredentials: n };
        };
        QV.exports = Cme;
      });
      Yh = u((UOe, JV) => {
        var Ame = Xe(), Rme = ya(), _me = function(e, t) {
          var i = e === void 0 ? Rme() : Ame({}, e);
          if (t) for (var r in t) t[r] !== void 0 && (i[r] = t[r]);
          return i;
        };
        JV.exports = _me;
      });
      qv = u((zOe, $V) => {
        var Pme = Yh(), Mme = function(e, t) {
          var i = Pme(t, e.xhrSettings);
          if (e.base64) {
            var r = e.url.split(";base64,").pop() || e.url.split(",").pop(), s = { responseText: atob(
            r) };
            e.onBase64Load(s);
            return;
          }
          var n = new XMLHttpRequest();
          if (n.open("GET", e.src, i.async, i.user, i.password), n.responseType = e.xhrSettings.responseType,
          n.timeout = i.timeout, i.headers) for (var a in i.headers) n.setRequestHeader(a, i.headers[a]);
          return i.header && i.headerValue && n.setRequestHeader(i.header, i.headerValue), i.requestedWith &&
          n.setRequestHeader("X-Requested-With", i.requestedWith), i.overrideMimeType && n.overrideMimeType(
          i.overrideMimeType), i.withCredentials && (n.withCredentials = true), n.onload = e.onLoad.
          bind(e, n), n.onerror = e.onError.bind(e, n), n.onprogress = e.onProgress.bind(e), n.ontimeout =
          e.onError.bind(e, n), n.send(), n;
        };
        $V.exports = Mme;
      });
      rn = u((kOe, jV) => {
        var qme = C(), Kt = Kr(), Wh = zr(), ui = B(), Fme = Ta(), bme = Yh(), Lme = qv(), Ome = ya(),
        Fv = new qme({ initialize: function(t, i) {
          if (this.loader = t, this.cache = ui(i, "cache", false), this.type = ui(i, "type", false),
          !this.type) throw new Error("Invalid File type: " + this.type);
          this.key = ui(i, "key", false);
          var r = this.key;
          if (t.prefix && t.prefix !== "" && (this.key = t.prefix + r), !this.key) throw new Error("\
Invalid File key: " + this.key);
          var s = ui(i, "url");
          s === void 0 ? s = t.path + r + "." + ui(i, "extension", "") : typeof s == "string" && !s.
          match(/^(?:blob:|data:|capacitor:\/\/|http:\/\/|https:\/\/|\/\/)/) && (s = t.path + s), this.
          url = s, this.src = "", this.xhrSettings = Ome(ui(i, "responseType", void 0)), ui(i, "xhrS\
ettings", false) && (this.xhrSettings = bme(this.xhrSettings, ui(i, "xhrSettings", {}))), this.xhrLoader =
          null, this.state = typeof this.url == "function" ? Kt.FILE_POPULATED : Kt.FILE_PENDING, this.
          bytesTotal = 0, this.bytesLoaded = -1, this.percentComplete = -1, this.crossOrigin = void 0,
          this.data = void 0, this.config = ui(i, "config", {}), this.multiFile, this.linkFile, this.
          base64 = typeof s == "string" && s.indexOf("data:") === 0, this.retryAttempts = ui(i, "max\
Retries", t.maxRetries);
        }, setLink: function(e) {
          this.linkFile = e, e.linkFile = this;
        }, resetXHR: function() {
          this.xhrLoader && (this.xhrLoader.onload = void 0, this.xhrLoader.onerror = void 0, this.xhrLoader.
          onprogress = void 0);
        }, load: function() {
          if (this.state === Kt.FILE_POPULATED) this.loader.nextFile(this, true);
          else {
            if (this.state = Kt.FILE_LOADING, this.src = Fme(this, this.loader.baseURL), !this.src) throw new Error(
            "URL Error in File: " + this.key + " from: " + this.url);
            this.src.indexOf("data:") === 0 && (this.base64 = true), this.xhrLoader = Lme(this, this.
            loader.xhr);
          }
        }, onLoad: function(e, t) {
          var i = e.responseURL && this.loader.localSchemes.some(function(n) {
            return e.responseURL.indexOf(n) === 0;
          }), r = i && t.target.status === 0, s = !(t.target && t.target.status !== 200) || r;
          e.readyState === 4 && e.status >= 400 && e.status <= 599 && (s = false), this.state = Kt.FILE_LOADED,
          this.resetXHR(), this.loader.nextFile(this, s);
        }, onBase64Load: function(e) {
          this.xhrLoader = e, this.state = Kt.FILE_LOADED, this.percentComplete = 1, this.loader.emit(
          Wh.FILE_PROGRESS, this, this.percentComplete), this.loader.nextFile(this, true);
        }, onError: function() {
          this.resetXHR(), this.retryAttempts > 0 ? (this.retryAttempts--, this.load()) : this.loader.
          nextFile(this, false);
        }, onProgress: function(e) {
          e.lengthComputable && (this.bytesLoaded = e.loaded, this.bytesTotal = e.total, this.percentComplete =
          Math.min(this.bytesLoaded / this.bytesTotal, 1), this.loader.emit(Wh.FILE_PROGRESS, this, this.
          percentComplete));
        }, onProcess: function() {
          this.state = Kt.FILE_PROCESSING, this.onProcessComplete();
        }, onProcessComplete: function() {
          this.state = Kt.FILE_COMPLETE, this.multiFile && this.multiFile.onFileComplete(this), this.
          loader.fileProcessComplete(this);
        }, onProcessError: function() {
          console.error('Failed to process file: %s "%s"', this.type, this.key), this.state = Kt.FILE_ERRORED,
          this.multiFile && this.multiFile.onFileFailed(this), this.loader.fileProcessComplete(this);
        }, hasCacheConflict: function() {
          return this.cache && this.cache.exists(this.key);
        }, addToCache: function() {
          this.cache && this.data && this.cache.add(this.key, this.data);
        }, pendingDestroy: function(e) {
          if (this.state !== Kt.FILE_PENDING_DESTROY) {
            e === void 0 && (e = this.data);
            var t = this.key, i = this.type;
            this.loader.emit(Wh.FILE_COMPLETE, t, i, e), this.loader.emit(Wh.FILE_KEY_COMPLETE + i +
            "-" + t, t, i, e), this.loader.flagForRemoval(this), this.state = Kt.FILE_PENDING_DESTROY;
          }
        }, destroy: function() {
          this.loader = null, this.cache = null, this.xhrSettings = null, this.multiFile = null, this.
          linkFile = null, this.data = null;
        } });
        Fv.createObjectURL = function(e, t, i) {
          if (typeof URL == "function") e.src = URL.createObjectURL(t);
          else {
            var r = new FileReader();
            r.onload = function() {
              e.removeAttribute("crossOrigin"), e.src = "data:" + (t.type || i) + ";base64," + r.result.
              split(",")[1];
            }, r.onerror = e.onerror, r.readAsDataURL(t);
          }
        };
        Fv.revokeObjectURL = function(e) {
          typeof URL == "function" && URL.revokeObjectURL(e.src);
        };
        jV.exports = Fv;
      });
      rY = u((XOe, iY) => {
        var Dme = C(), Nme = zr(), eY = rn(), tY = B(), Ime = Ta(), Bme = lt(), Gme = new Dme({ Extends: eY,
        initialize: function(t, i, r, s) {
          if (Bme(i)) {
            var n = i;
            i = tY(n, "key"), s = tY(n, "config", s);
          }
          var a = { type: "audio", cache: t.cacheManager.audio, extension: r.type, key: i, url: r.url,
          config: s };
          eY.call(this, t, a), this.locked = "ontouchstart" in window, this.loaded = false, this.filesLoaded =
          0, this.filesTotal = 0;
        }, onLoad: function() {
          this.loaded || (this.loaded = true, this.loader.nextFile(this, true));
        }, onError: function() {
          for (var e = 0; e < this.data.length; e++) {
            var t = this.data[e];
            t.oncanplaythrough = null, t.onerror = null;
          }
          this.loader.nextFile(this, false);
        }, onProgress: function(e) {
          var t = e.target;
          t.oncanplaythrough = null, t.onerror = null, this.filesLoaded++, this.percentComplete = Math.
          min(this.filesLoaded / this.filesTotal, 1), this.loader.emit(Nme.FILE_PROGRESS, this, this.
          percentComplete), this.filesLoaded === this.filesTotal && this.onLoad();
        }, load: function() {
          this.data = [];
          var e = this.config && this.config.instances || 1;
          this.filesTotal = e, this.filesLoaded = 0, this.percentComplete = 0;
          for (var t = 0; t < e; t++) {
            var i = new Audio();
            i.dataset || (i.dataset = {}), i.dataset.name = this.key + ("0" + t).slice(-2), i.dataset.
            used = "false", this.locked ? i.dataset.locked = "true" : (i.dataset.locked = "false", i.
            preload = "auto", i.oncanplaythrough = this.onProgress.bind(this), i.onerror = this.onError.
            bind(this)), this.data.push(i);
          }
          for (t = 0; t < this.data.length; t++) i = this.data[t], i.src = Ime(this, this.loader.baseURL),
          this.locked || i.load();
          this.locked && setTimeout(this.onLoad.bind(this));
        } });
        iY.exports = Gme;
      });
      oY = u((VOe, aY) => {
        var Ume = C(), zme = Kr(), sY = rn(), kme = Fi(), Zr = B(), Xme = rY(), nY = lt(), Qr = new Ume(
        { Extends: sY, initialize: function(t, i, r, s, n) {
          if (nY(i)) {
            var a = i;
            i = Zr(a, "key"), s = Zr(a, "xhrSettings"), n = Zr(a, "context", n);
          }
          var o = { type: "audio", cache: t.cacheManager.audio, extension: r.type, responseType: "ar\
raybuffer", key: i, url: r.url, xhrSettings: s, config: { context: n } };
          sY.call(this, t, o);
        }, onProcess: function() {
          this.state = zme.FILE_PROCESSING;
          var e = this;
          this.config.context.decodeAudioData(this.xhrLoader.response, function(t) {
            e.data = t, e.onProcessComplete();
          }, function(t) {
            console.error("Error decoding audio: " + e.key + " - ", t ? t.message : null), e.onProcessError();
          }), this.config.context = null;
        } });
        Qr.create = function(e, t, i, r, s) {
          var n = e.systems.game, a = n.config.audio, o = n.device.audio;
          nY(t) && (i = Zr(t, "url", []), r = Zr(t, "config", {}));
          var h = Qr.getAudioURL(n, i);
          return h ? o.webAudio && !a.disableWebAudio ? new Qr(e, t, h, s, n.sound.context) : new Xme(
          e, t, h, r) : (console.warn('No audio URLs for "%s" can play on this device', t), null);
        };
        Qr.getAudioURL = function(e, t) {
          Array.isArray(t) || (t = [t]);
          for (var i = 0; i < t.length; i++) {
            var r = Zr(t[i], "url", t[i]);
            if (r.indexOf("blob:") === 0 || r.indexOf("data:") === 0) return { url: r, type: "" };
            var s = r.match(/\.([a-zA-Z0-9]+)($|\?)/);
            if (s = Zr(t[i], "type", s ? s[1] : "").toLowerCase(), e.device.audio[s]) return { url: r,
            type: s };
          }
          return null;
        };
        kme.register("audio", function(e, t, i, r) {
          var s = this.systems.game, n = s.config.audio, a = s.device.audio;
          if (n.noAudio || !a.webAudio && !a.audioData) return this;
          var o;
          if (Array.isArray(e)) for (var h = 0; h < e.length; h++) o = Qr.create(this, e[h]), o && this.
          addFile(o);
          else o = Qr.create(this, e, t, i, r), o && this.addFile(o);
          return this;
        });
        aY.exports = Qr;
      });
      Hh = u((YOe, hY) => {
        var Vme = C(), sn = Kr(), Sa = rn(), Yme = Fi(), nn = B(), Wme = lt(), Hme = Ta(), bv = new Vme(
        { Extends: Sa, initialize: function e(t, i, r, s, n) {
          var a = "png", o;
          if (Wme(i)) {
            var h = i;
            i = nn(h, "key"), r = nn(h, "url"), o = nn(h, "normalMap"), s = nn(h, "xhrSettings"), a =
            nn(h, "extension", a), n = nn(h, "frameConfig");
          }
          Array.isArray(r) && (o = r[1], r = r[0]);
          var l = { type: "image", cache: t.textureManager, extension: a, responseType: "blob", key: i,
          url: r, xhrSettings: s, config: n };
          if (Sa.call(this, t, l), o) {
            var f = new e(t, this.key, o, s, n);
            f.type = "normalMap", this.setLink(f), t.addFile(f);
          }
          this.useImageElementLoad = t.imageLoadType === "HTMLImageElement" || this.base64, this.useImageElementLoad &&
          (this.load = this.loadImage, this.onProcess = this.onProcessImage);
        }, onProcess: function() {
          this.state = sn.FILE_PROCESSING, this.data = new Image(), this.data.crossOrigin = this.crossOrigin;
          var e = this;
          this.data.onload = function() {
            Sa.revokeObjectURL(e.data), e.onProcessComplete();
          }, this.data.onerror = function() {
            Sa.revokeObjectURL(e.data), e.onProcessError();
          }, Sa.createObjectURL(this.data, this.xhrLoader.response, "image/png");
        }, onProcessImage: function() {
          var e = this.state;
          this.state = sn.FILE_PROCESSING, e === sn.FILE_LOADED ? this.onProcessComplete() : this.onProcessError();
        }, loadImage: function() {
          this.state = sn.FILE_LOADING, this.src = Hme(this, this.loader.baseURL), this.data = new Image(),
          this.data.crossOrigin = this.crossOrigin;
          var e = this;
          this.data.onload = function() {
            e.state = sn.FILE_LOADED, e.loader.nextFile(e, true);
          }, this.data.onerror = function() {
            e.loader.nextFile(e, false);
          }, this.data.src = this.src;
        }, addToCache: function() {
          var e = this.linkFile;
          e ? e.state >= sn.FILE_COMPLETE && (e.type === "spritesheet" ? e.addToCache() : this.type ===
          "normalMap" ? this.cache.addImage(this.key, e.data, this.data) : this.cache.addImage(this.
          key, this.data, e.data)) : this.cache.addImage(this.key, this.data);
        } });
        Yme.register("image", function(e, t, i) {
          if (Array.isArray(e)) for (var r = 0; r < e.length; r++) this.addFile(new bv(this, e[r]));
          else this.addFile(new bv(this, e, t, i));
          return this;
        });
        hY.exports = bv;
      });
      Dv = u((WOe, dY) => {
        var Kme = C(), Lv = Kr(), uY = rn(), Zme = Fi(), wa = B(), lY = H(), fY = lt(), Ov = new Kme(
        { Extends: uY, initialize: function(t, i, r, s, n) {
          var a = "json";
          if (fY(i)) {
            var o = i;
            i = wa(o, "key"), r = wa(o, "url"), s = wa(o, "xhrSettings"), a = wa(o, "extension", a),
            n = wa(o, "dataKey", n);
          }
          var h = { type: "json", cache: t.cacheManager.json, extension: a, responseType: "text", key: i,
          url: r, xhrSettings: s, config: n };
          uY.call(this, t, h), fY(r) && (n ? this.data = lY(r, n) : this.data = r, this.state = Lv.FILE_POPULATED);
        }, onProcess: function() {
          if (this.state !== Lv.FILE_POPULATED) {
            this.state = Lv.FILE_PROCESSING;
            try {
              var e = JSON.parse(this.xhrLoader.responseText);
            } catch (i) {
              throw this.onProcessError(), i;
            }
            var t = this.config;
            typeof t == "string" ? this.data = lY(e, t, e) : this.data = e;
          }
          this.onProcessComplete();
        } });
        Zme.register("json", function(e, t, i, r) {
          if (Array.isArray(e)) for (var s = 0; s < e.length; s++) this.addFile(new Ov(this, e[s]));
          else this.addFile(new Ov(this, e, t, r, i));
          return this;
        });
        dY.exports = Ov;
      });
      Iv = u((HOe, vY) => {
        var Qme = C(), Nv = Kr(), cY = zr(), Jme = new Qme({ initialize: function(t, i, r, s) {
          var n = [];
          s.forEach(function(h) {
            h && n.push(h);
          }), this.loader = t, this.type = i, this.key = r;
          var a = this.key;
          t.prefix && t.prefix !== "" && (this.key = t.prefix + a), this.multiKeyIndex = t.multiKeyIndex++,
          this.files = n, this.state = Nv.FILE_PENDING, this.complete = false, this.pending = n.length,
          this.failed = 0, this.config = {}, this.baseURL = t.baseURL, this.path = t.path, this.prefix =
          t.prefix;
          for (var o = 0; o < n.length; o++) n[o].multiFile = this;
        }, isReadyToProcess: function() {
          return this.pending === 0 && this.failed === 0 && !this.complete;
        }, addToMultiFile: function(e) {
          return this.files.push(e), e.multiFile = this, this.pending++, this.complete = false, this;
        }, onFileComplete: function(e) {
          var t = this.files.indexOf(e);
          t !== -1 && this.pending--;
        }, onFileFailed: function(e) {
          var t = this.files.indexOf(e);
          t !== -1 && (this.failed++, console.error('File failed: %s "%s" (via %s "%s")', this.type,
          this.key, e.type, e.key));
        }, pendingDestroy: function() {
          if (this.state !== Nv.FILE_PENDING_DESTROY) {
            var e = this.key, t = this.type;
            this.loader.emit(cY.FILE_COMPLETE, e, t), this.loader.emit(cY.FILE_KEY_COMPLETE + t + "-" +
            e, e, t), this.loader.flagForRemoval(this);
            for (var i = 0; i < this.files.length; i++) this.files[i].pendingDestroy();
            this.state = Nv.FILE_PENDING_DESTROY;
          }
        }, destroy: function() {
          this.loader = null, this.files = null, this.config = null;
        } });
        vY.exports = Jme;
      });
      xY = u((KOe, gY) => {
        var $me = C(), jme = Fi(), gr = B(), pY = Hh(), ege = lt(), mY = Dv(), Bv = Iv(), Gv = new $me(
        { Extends: Bv, initialize: function(t, i, r, s, n, a) {
          var o, h;
          if (ege(i)) {
            var l = i;
            i = gr(l, "key"), o = new pY(t, { key: i, url: gr(l, "textureURL"), extension: gr(l, "te\
xtureExtension", "png"), normalMap: gr(l, "normalMap"), xhrSettings: gr(l, "textureXhrSettings") }),
            h = new mY(t, { key: i, url: gr(l, "atlasURL"), extension: gr(l, "atlasExtension", "json"),
            xhrSettings: gr(l, "atlasXhrSettings") });
          } else o = new pY(t, i, r, n), h = new mY(t, i, s, a);
          o.linkFile ? Bv.call(this, t, "atlasjson", i, [o, h, o.linkFile]) : Bv.call(this, t, "atla\
sjson", i, [o, h]);
        }, addToCache: function() {
          if (this.isReadyToProcess()) {
            var e = this.files[0], t = this.files[1], i = this.files[2] ? this.files[2].data : null;
            this.loader.textureManager.addAtlas(e.key, e.data, t.data, i), this.complete = true;
          }
        } });
        jme.register("atlas", function(e, t, i, r, s) {
          var n;
          if (Array.isArray(e)) for (var a = 0; a < e.length; a++) n = new Gv(this, e[a]), this.addFile(
          n.files);
          else n = new Gv(this, e, t, i, r, s), this.addFile(n.files);
          return this;
        });
        gY.exports = Gv;
      });
      SY = u((ZOe, yY) => {
        var tge = C(), ige = Fi(), Ut = B(), EY = Hh(), rge = lt(), sge = Dv(), TY = Iv(), Uv = new tge(
        { Extends: TY, initialize: function(t, i, r, s, n, a, o) {
          if (rge(i)) {
            var h = i;
            i = Ut(h, "key"), Ut(h, "url", false) ? r = Ut(h, "url") : r = Ut(h, "atlasURL"), a = Ut(
            h, "xhrSettings"), s = Ut(h, "path"), n = Ut(h, "baseURL"), o = Ut(h, "textureXhrSetting\
s");
          }
          var l = new sge(t, i, r, a);
          TY.call(this, t, "multiatlas", i, [l]), this.config.path = s, this.config.baseURL = n, this.
          config.textureXhrSettings = o;
        }, onFileComplete: function(e) {
          var t = this.files.indexOf(e);
          if (t !== -1 && (this.pending--, e.type === "json" && e.data.hasOwnProperty("textures"))) {
            var i = e.data.textures, r = this.config, s = this.loader, n = s.baseURL, a = s.path, o = s.
            prefix, h = Ut(r, "baseURL", this.baseURL), l = Ut(r, "path", this.path), f = Ut(r, "pre\
fix", this.prefix), d = Ut(r, "textureXhrSettings");
            s.setBaseURL(h), s.setPath(l), s.setPrefix(f);
            for (var c = 0; c < i.length; c++) {
              var p = i[c].image, v = "MA" + this.multiKeyIndex + "_" + p, m = new EY(s, v, p, d);
              if (this.addToMultiFile(m), s.addFile(m), i[c].normalMap) {
                var g = new EY(s, v, i[c].normalMap, d);
                g.type = "normalMap", m.setLink(g), this.addToMultiFile(g), s.addFile(g);
              }
            }
            s.setBaseURL(n), s.setPath(a), s.setPrefix(o);
          }
        }, addToCache: function() {
          if (this.isReadyToProcess()) {
            for (var e = this.files[0], t = [], i = [], r = [], s = 1; s < this.files.length; s++) {
              var n = this.files[s];
              if (n.type !== "normalMap") for (var a = n.key.indexOf("_"), o = n.key.substr(a + 1), h = n.
              data, l = 0; l < e.data.textures.length; l++) {
                var f = e.data.textures[l];
                if (f.image === o) {
                  i.push(h), t.push(f), n.linkFile && r.push(n.linkFile.data);
                  break;
                }
              }
            }
            r.length === 0 && (r = void 0), this.loader.textureManager.addAtlasJSONArray(this.key, i,
            t, r), this.complete = true;
          }
        } });
        ige.register("multiatlas", function(e, t, i, r, s) {
          var n;
          if (Array.isArray(e)) for (var a = 0; a < e.length; a++) n = new Uv(this, e[a]), this.addFile(
          n.files);
          else n = new Uv(this, e, t, i, r, s), this.addFile(n.files);
          return this;
        });
        yY.exports = Uv;
      });
      RY = u((QOe, AY) => {
        var nge = C(), ut = Kr(), Kh = Sh(), wY = Z(), Jr = zr(), age = Fi(), se = B(), oge = H(), hge = lt(),
        uge = rt(), li = qe(), lge = ya(), CY = new nge({ Extends: wY, initialize: function(t) {
          wY.call(this);
          var i = t.sys.game.config, r = t.sys.settings.loader;
          this.scene = t, this.systems = t.sys, this.cacheManager = t.sys.cache, this.textureManager =
          t.sys.textures, this.sceneManager = t.sys.game.scene, age.install(this), this.prefix = "",
          this.path = "", this.baseURL = "", this.setBaseURL(se(r, "baseURL", i.loaderBaseURL)), this.
          setPath(se(r, "path", i.loaderPath)), this.setPrefix(se(r, "prefix", i.loaderPrefix)), this.
          maxParallelDownloads = se(r, "maxParallelDownloads", i.loaderMaxParallelDownloads), this.xhr =
          lge(se(r, "responseType", i.loaderResponseType), se(r, "async", i.loaderAsync), se(r, "use\
r", i.loaderUser), se(r, "password", i.loaderPassword), se(r, "timeout", i.loaderTimeout), se(r, "wi\
thCredentials", i.loaderWithCredentials)), this.crossOrigin = se(r, "crossOrigin", i.loaderCrossOrigin),
          this.imageLoadType = se(r, "imageLoadType", i.loaderImageLoadType), this.localSchemes = se(
          r, "localScheme", i.loaderLocalScheme), this.totalToLoad = 0, this.progress = 0, this.list =
          new Kh(), this.inflight = new Kh(), this.queue = new Kh(), this._deleteQueue = new Kh(), this.
          totalFailed = 0, this.totalComplete = 0, this.state = ut.LOADER_IDLE, this.multiKeyIndex =
          0, this.maxRetries = se(r, "maxRetries", i.loaderMaxRetries), t.sys.events.once(li.BOOT, this.
          boot, this), t.sys.events.on(li.START, this.pluginStart, this);
        }, boot: function() {
          this.systems.events.once(li.DESTROY, this.destroy, this);
        }, pluginStart: function() {
          this.systems.events.once(li.SHUTDOWN, this.shutdown, this);
        }, setBaseURL: function(e) {
          return e === void 0 && (e = ""), e !== "" && e.substr(-1) !== "/" && (e = e.concat("/")), this.
          baseURL = e, this;
        }, setPath: function(e) {
          return e === void 0 && (e = ""), e !== "" && e.substr(-1) !== "/" && (e = e.concat("/")), this.
          path = e, this;
        }, setPrefix: function(e) {
          return e === void 0 && (e = ""), this.prefix = e, this;
        }, setCORS: function(e) {
          return this.crossOrigin = e, this;
        }, addFile: function(e) {
          Array.isArray(e) || (e = [e]);
          for (var t = 0; t < e.length; t++) {
            var i = e[t];
            this.keyExists(i) || (this.list.set(i), this.emit(Jr.ADD, i.key, i.type, this, i), this.
            isLoading() && (this.totalToLoad++, this.updateProgress()));
          }
        }, keyExists: function(e) {
          var t = e.hasCacheConflict();
          return t || this.list.iterate(function(i) {
            if (i.type === e.type && i.key === e.key) return t = true, false;
          }), !t && this.isLoading() && (this.inflight.iterate(function(i) {
            if (i.type === e.type && i.key === e.key) return t = true, false;
          }), this.queue.iterate(function(i) {
            if (i.type === e.type && i.key === e.key) return t = true, false;
          })), t;
        }, addPack: function(e, t) {
          if (typeof t == "string") {
            var i = oge(e, t);
            i && (e = { packKey: i });
          }
          var r = 0, s = this.baseURL, n = this.path, a = this.prefix;
          for (var o in e) if (Object.prototype.hasOwnProperty.call(e, o)) {
            var h = e[o], l = se(h, "baseURL", s), f = se(h, "path", n), d = se(h, "prefix", a), c = se(
            h, "files", null), p = se(h, "defaultType", "void");
            if (Array.isArray(c)) {
              this.setBaseURL(l), this.setPath(f), this.setPrefix(d);
              for (var v = 0; v < c.length; v++) {
                var m = c[v], g = m.hasOwnProperty("type") ? m.type : p;
                this[g] && (this[g](m), r++);
              }
            }
          }
          return this.setBaseURL(s), this.setPath(n), this.setPrefix(a), r > 0;
        }, removePack: function(e, t) {
          var i = this.systems.anims, r = this.cacheManager, s = this.textureManager, n = { animation: "\
json", aseprite: "json", audio: "audio", audioSprite: "audio", binary: "binary", bitmapFont: "bitmap\
Font", css: null, glsl: "shader", html: "html", json: "json", obj: "obj", plugin: null, scenePlugin: null,
          script: null, spine: "json", text: "text", tilemapCSV: "tilemap", tilemapImpact: "tilemap",
          tilemapTiledJSON: "tilemap", video: "video", xml: "xml" }, a;
          if (hge(e)) a = e;
          else if (a = r.json.get(e), !a) {
            console.warn("Asset Pack not found in JSON cache:", e);
            return;
          }
          t && (a = { _: a[t] });
          for (var o in a) {
            var h = a[o], l = se(h, "prefix", ""), f = se(h, "files"), d = se(h, "defaultType");
            if (Array.isArray(f)) for (var c = 0; c < f.length; c++) {
              var p = f[c], v = p.hasOwnProperty("type") ? p.type : d;
              if (!v) {
                console.warn("No type:", p);
                continue;
              }
              var m = l + p.key;
              if (v === "animation" && i.remove(m), !((v === "aseprite" || v === "atlas" || v === "a\
tlasXML" || v === "htmlTexture" || v === "image" || v === "multiatlas" || v === "spritesheet" || v ===
              "svg" || v === "texture" || v === "unityAtlas") && (s.remove(m), !n[v]))) {
                if (v === "pack") {
                  this.removePack(m, p.dataKey);
                  continue;
                }
                if (v === "spine") {
                  var g = r.custom.spine.get(m);
                  if (!g) continue;
                  var x = g.prefix === void 0 ? "" : g.prefix;
                  r.custom.spine.remove(m);
                  var E = r.custom.spineTextures.get(m);
                  if (!E) continue;
                  r.custom.spineTextures.remove(m);
                  for (var T15 = 0; T15 < E.pages.length; T15++) {
                    var w = E.pages[T15], y = x + w.name, A10 = m + ":" + y;
                    s.exists(A10) ? s.remove(A10) : s.remove(y);
                  }
                }
                var S14 = n[v];
                if (S14 !== null) {
                  if (!S14) {
                    console.warn("Unknown type:", v);
                    continue;
                  }
                  var _ = r[S14];
                  _.remove(m);
                }
              }
            }
          }
        }, isLoading: function() {
          return this.state === ut.LOADER_LOADING || this.state === ut.LOADER_PROCESSING;
        }, isReady: function() {
          return this.state === ut.LOADER_IDLE || this.state === ut.LOADER_COMPLETE;
        }, start: function() {
          this.isReady() && (this.progress = 0, this.totalFailed = 0, this.totalComplete = 0, this.totalToLoad =
          this.list.size, this.emit(Jr.START, this), this.list.size === 0 ? this.loadComplete() : (this.
          state = ut.LOADER_LOADING, this.inflight.clear(), this.queue.clear(), this.updateProgress(),
          this.checkLoadQueue(), this.systems.events.on(li.UPDATE, this.update, this)));
        }, updateProgress: function() {
          this.progress = 1 - (this.list.size + this.inflight.size) / this.totalToLoad, this.emit(Jr.
          PROGRESS, this.progress);
        }, update: function() {
          this.state === ut.LOADER_LOADING && this.list.size > 0 && this.inflight.size < this.maxParallelDownloads &&
          this.checkLoadQueue();
        }, checkLoadQueue: function() {
          this.list.each(function(e) {
            if ((e.state === ut.FILE_POPULATED || e.state === ut.FILE_PENDING && this.inflight.size <
            this.maxParallelDownloads) && (this.inflight.set(e), this.list.delete(e), e.crossOrigin ||
            (e.crossOrigin = this.crossOrigin), e.load()), this.inflight.size === this.maxParallelDownloads)
             return false;
          }, this);
        }, nextFile: function(e, t) {
          this.inflight && (this.inflight.delete(e), this.updateProgress(), t ? (this.totalComplete++,
          this.queue.set(e), this.emit(Jr.FILE_LOAD, e), e.onProcess()) : (this.totalFailed++, this.
          _deleteQueue.set(e), this.emit(Jr.FILE_LOAD_ERROR, e), this.fileProcessComplete(e)));
        }, fileProcessComplete: function(e) {
          !this.scene || !this.systems || !this.systems.game || this.systems.game.pendingDestroy || (e.
          state === ut.FILE_ERRORED ? e.multiFile && e.multiFile.onFileFailed(e) : e.state === ut.FILE_COMPLETE &&
          (e.multiFile ? e.multiFile.isReadyToProcess() && (e.multiFile.addToCache(), e.multiFile.pendingDestroy()) :
          (e.addToCache(), e.pendingDestroy())), this.queue.delete(e), this.list.size === 0 && this.
          inflight.size === 0 && this.queue.size === 0 && this.loadComplete());
        }, loadComplete: function() {
          this.emit(Jr.POST_PROCESS, this), this.list.clear(), this.inflight.clear(), this.queue.clear(),
          this.progress = 1, this.state = ut.LOADER_COMPLETE, this.systems.events.off(li.UPDATE, this.
          update, this), this._deleteQueue.iterateLocal("destroy"), this._deleteQueue.clear(), this.
          emit(Jr.COMPLETE, this, this.totalComplete, this.totalFailed);
        }, flagForRemoval: function(e) {
          this._deleteQueue.set(e);
        }, saveJSON: function(e, t) {
          return this.save(JSON.stringify(e), t);
        }, save: function(e, t, i) {
          t === void 0 && (t = "file.json"), i === void 0 && (i = "application/json");
          var r = new Blob([e], { type: i }), s = URL.createObjectURL(r), n = document.createElement(
          "a");
          return n.download = t, n.textContent = "Download " + t, n.href = s, n.click(), this;
        }, reset: function() {
          this.list.clear(), this.inflight.clear(), this.queue.clear();
          var e = this.systems.game.config, t = this.systems.settings.loader;
          this.setBaseURL(se(t, "baseURL", e.loaderBaseURL)), this.setPath(se(t, "path", e.loaderPath)),
          this.setPrefix(se(t, "prefix", e.loaderPrefix)), this.state = ut.LOADER_IDLE;
        }, shutdown: function() {
          this.reset(), this.state = ut.LOADER_SHUTDOWN, this.removeAllListeners(), this.systems.events.
          off(li.UPDATE, this.update, this), this.systems.events.off(li.SHUTDOWN, this.shutdown, this);
        }, destroy: function() {
          this.shutdown(), this.state = ut.LOADER_DESTROYED, this.systems.events.off(li.UPDATE, this.
          update, this), this.systems.events.off(li.START, this.pluginStart, this), this.list = null,
          this.inflight = null, this.queue = null, this.scene = null, this.systems = null, this.textureManager =
          null, this.cacheManager = null, this.sceneManager = null;
        } });
        uge.register("Loader", CY, "load");
        AY.exports = CY;
      });
      PY = u((JOe, _Y) => {
        _Y.exports = { Canvas: Ef(), WebGL: Ed() };
      });
      qY = u(($Oe, MY) => {
        var fge = kn(), dge = Xe(), zv = { FX: No(), BitmapMaskPipeline: Rf(), Events: wf(), FXPipeline: ad(),
        LightPipeline: od(), MobilePipeline: ud(), MultiPipeline: er(), PointLightPipeline: fd(), PostFXPipeline: Ke(),
        PreFXPipeline: $f(), RopePipeline: dd(), SinglePipeline: cd(), UtilityPipeline: pd() };
        zv = dge(false, zv, fge);
        MY.exports = zv;
      });
      bY = u((jOe, FY) => {
        var cge = { WebGLAttribLocationWrapper: Ad(), WebGLBufferWrapper: Td(), WebGLProgramWrapper: yd(),
        WebGLTextureWrapper: Yo(), WebGLFramebufferWrapper: Cd(), WebGLUniformLocationWrapper: Rd() };
        FY.exports = cge;
      });
      OY = u((eDe, LY) => {
        var vge = bs(), pge = Xe(), kv = { PipelineManager: gd(), Pipelines: qY(), RenderTarget: qr(),
        Utils: wt(), WebGLPipeline: Vt(), WebGLRenderer: Pd(), WebGLShader: Cf(), Wrappers: bY() };
        kv = pge(false, kv, vge);
        LY.exports = kv;
      });
      DY = u((tDe, Xv) => {
        Xv.exports = { Events: qs(), Snapshot: PY() };
        Xv.exports.WebGL = OY();
      });
      IY = u((iDe, NY) => {
        var Zh = Xe(), Qh = ah(), Bi = { Center: ic(), Events: Ss(), Orientation: rc(), ScaleManager: oc(),
        ScaleModes: sc(), Zoom: nc() };
        Bi = Zh(false, Bi, Qh.CENTER);
        Bi = Zh(false, Bi, Qh.ORIENTATION);
        Bi = Zh(false, Bi, Qh.SCALE_MODE);
        Bi = Zh(false, Bi, Qh.ZOOM);
        NY.exports = Bi;
      });
      UY = u((rDe, GY) => {
        var mge = ne(), gge = C(), Gi = qe(), Pt = B(), xge = rt(), BY = new gge({ initialize: function(t) {
          this.scene = t, this.systems = t.sys, this.settings = t.sys.settings, this.key = t.sys.settings.
          key, this.manager = t.sys.game.scene, this.transitionProgress = 0, this._elapsed = 0, this.
          _target = null, this._duration = 0, this._onUpdate, this._onUpdateScope, this._willSleep =
          false, this._willRemove = false, t.sys.events.once(Gi.BOOT, this.boot, this), t.sys.events.
          on(Gi.START, this.pluginStart, this);
        }, boot: function() {
          this.systems.events.once(Gi.DESTROY, this.destroy, this);
        }, pluginStart: function() {
          this._target = null, this.systems.events.once(Gi.SHUTDOWN, this.shutdown, this);
        }, start: function(e, t) {
          return e === void 0 && (e = this.key), this.manager.queueOp("stop", this.key), this.manager.
          queueOp("start", e, t), this;
        }, restart: function(e) {
          var t = this.key;
          return this.manager.queueOp("stop", t), this.manager.queueOp("start", t, e), this;
        }, transition: function(e) {
          e === void 0 && (e = {});
          var t = Pt(e, "target", false), i = this.manager.getScene(t);
          if (!t || !this.checkValidTransition(i)) return false;
          var r = Pt(e, "duration", 1e3);
          this._elapsed = 0, this._target = i, this._duration = r, this._willSleep = Pt(e, "sleep", false),
          this._willRemove = Pt(e, "remove", false);
          var s = Pt(e, "onUpdate", null);
          s && (this._onUpdate = s, this._onUpdateScope = Pt(e, "onUpdateScope", this.scene));
          var n = Pt(e, "allowInput", false);
          this.settings.transitionAllowInput = n;
          var a = i.sys.settings;
          a.isTransition = true, a.transitionFrom = this.scene, a.transitionDuration = r, a.transitionAllowInput =
          n, Pt(e, "moveAbove", false) ? this.manager.moveAbove(this.key, t) : Pt(e, "moveBelow", false) &&
          this.manager.moveBelow(this.key, t), i.sys.isSleeping() ? i.sys.wake(Pt(e, "data")) : this.
          manager.start(t, Pt(e, "data"));
          var o = Pt(e, "onStart", null), h = Pt(e, "onStartScope", this.scene);
          return o && o.call(h, this.scene, i, r), this.systems.events.emit(Gi.TRANSITION_OUT, i, r),
          true;
        }, checkValidTransition: function(e) {
          return !(!e || e.sys.isActive() || e.sys.isTransitioning() || e === this.scene || this.systems.
          isTransitioning());
        }, step: function(e, t) {
          this._elapsed += t, this.transitionProgress = mge(this._elapsed / this._duration, 0, 1), this.
          _onUpdate && this._onUpdate.call(this._onUpdateScope, this.transitionProgress), this._elapsed >=
          this._duration && this.transitionComplete();
        }, transitionComplete: function() {
          var e = this._target.sys, t = this._target.sys.settings;
          e.events.emit(Gi.TRANSITION_COMPLETE, this.scene), t.isTransition = false, t.transitionFrom =
          null, this._duration = 0, this._target = null, this._onUpdate = null, this._onUpdateScope =
          null, this._willRemove ? this.manager.remove(this.key) : this._willSleep ? this.systems.sleep() :
          this.manager.stop(this.key);
        }, add: function(e, t, i, r) {
          return this.manager.add(e, t, i, r);
        }, launch: function(e, t) {
          return e && e !== this.key && this.manager.queueOp("start", e, t), this;
        }, run: function(e, t) {
          return e && e !== this.key && this.manager.queueOp("run", e, t), this;
        }, pause: function(e, t) {
          return e === void 0 && (e = this.key), this.manager.queueOp("pause", e, t), this;
        }, resume: function(e, t) {
          return e === void 0 && (e = this.key), this.manager.queueOp("resume", e, t), this;
        }, sleep: function(e, t) {
          return e === void 0 && (e = this.key), this.manager.queueOp("sleep", e, t), this;
        }, wake: function(e, t) {
          return e === void 0 && (e = this.key), this.manager.queueOp("wake", e, t), this;
        }, switch: function(e, t) {
          return e !== this.key && this.manager.queueOp("switch", this.key, e, t), this;
        }, stop: function(e, t) {
          return e === void 0 && (e = this.key), this.manager.queueOp("stop", e, t), this;
        }, setActive: function(e, t, i) {
          t === void 0 && (t = this.key);
          var r = this.manager.getScene(t);
          return r && r.sys.setActive(e, i), this;
        }, setVisible: function(e, t) {
          t === void 0 && (t = this.key);
          var i = this.manager.getScene(t);
          return i && i.sys.setVisible(e), this;
        }, isSleeping: function(e) {
          return e === void 0 && (e = this.key), this.manager.isSleeping(e);
        }, isActive: function(e) {
          return e === void 0 && (e = this.key), this.manager.isActive(e);
        }, isPaused: function(e) {
          return e === void 0 && (e = this.key), this.manager.isPaused(e);
        }, isVisible: function(e) {
          return e === void 0 && (e = this.key), this.manager.isVisible(e);
        }, swapPosition: function(e, t) {
          return t === void 0 && (t = this.key), e !== t && this.manager.swapPosition(e, t), this;
        }, moveAbove: function(e, t) {
          return t === void 0 && (t = this.key), e !== t && this.manager.moveAbove(e, t), this;
        }, moveBelow: function(e, t) {
          return t === void 0 && (t = this.key), e !== t && this.manager.moveBelow(e, t), this;
        }, remove: function(e) {
          return e === void 0 && (e = this.key), this.manager.remove(e), this;
        }, moveUp: function(e) {
          return e === void 0 && (e = this.key), this.manager.moveUp(e), this;
        }, moveDown: function(e) {
          return e === void 0 && (e = this.key), this.manager.moveDown(e), this;
        }, bringToTop: function(e) {
          return e === void 0 && (e = this.key), this.manager.bringToTop(e), this;
        }, sendToBack: function(e) {
          return e === void 0 && (e = this.key), this.manager.sendToBack(e), this;
        }, get: function(e) {
          return this.manager.getScene(e);
        }, getStatus: function(e) {
          var t = this.manager.getScene(e);
          if (t) return t.sys.getStatus();
        }, getIndex: function(e) {
          return e === void 0 && (e = this.key), this.manager.getIndex(e);
        }, shutdown: function() {
          var e = this.systems.events;
          e.off(Gi.SHUTDOWN, this.shutdown, this), e.off(Gi.TRANSITION_OUT);
        }, destroy: function() {
          this.shutdown(), this.scene.sys.events.off(Gi.START, this.start, this), this.scene = null,
          this.systems = null, this.settings = null, this.manager = null;
        } });
        xge.register("ScenePlugin", BY, "scenePlugin");
        GY.exports = BY;
      });
      kY = u((sDe, zY) => {
        var Ege = jn(), Tge = Xe(), Vv = { Events: qe(), GetPhysicsPlugins: hc(), GetScenePlugins: uc(),
        SceneManager: vc(), ScenePlugin: UY(), Settings: fc(), Systems: lh() };
        Vv = Tge(false, Vv, Ege);
        zY.exports = Vv;
      });
      VY = u((nDe, XY) => {
        XY.exports = { SoundManagerCreator: Dc(), Events: hr(), BaseSound: na(), BaseSoundManager: sa(),
        WebAudioSound: bc(), WebAudioSoundManager: Oc(), HTML5AudioSound: Ac(), HTML5AudioSoundManager: Pc(),
        NoAudioSound: Mc(), NoAudioSoundManager: qc() };
      });
      WY = u((aDe, YY) => {
        var yge = { LINEAR: 0, NEAREST: 1 };
        YY.exports = yge;
      });
      ZY = u((oDe, KY) => {
        var Sge = Xe(), HY = WY(), Yv = { CanvasTexture: xc(), DynamicTexture: Tc(), Events: Fs(), FilterMode: HY,
        Frame: Pr(), Parsers: yc(), Texture: ea(), TextureManager: wc(), TextureSource: pc() };
        Yv = Sge(false, Yv, HY);
        KY.exports = Yv;
      });
      Wv = u((hDe, QY) => {
        var wge = C(), Ui = B(), Cge = new wge({ initialize: function(t) {
          this.delay = 0, this.repeat = 0, this.repeatCount = 0, this.loop = false, this.callback, this.
          callbackScope, this.args, this.timeScale = 1, this.startAt = 0, this.elapsed = 0, this.paused =
          false, this.hasDispatched = false, this.reset(t);
        }, reset: function(e) {
          if (this.delay = Ui(e, "delay", 0), this.repeat = Ui(e, "repeat", 0), this.loop = Ui(e, "l\
oop", false), this.callback = Ui(e, "callback", void 0), this.callbackScope = Ui(e, "callbackScope",
          this), this.args = Ui(e, "args", []), this.timeScale = Ui(e, "timeScale", 1), this.startAt =
          Ui(e, "startAt", 0), this.paused = Ui(e, "paused", false), this.elapsed = this.startAt, this.
          hasDispatched = false, this.repeatCount = this.repeat === -1 || this.loop ? 999999999999 :
          this.repeat, this.delay <= 0 && this.repeatCount > 0) throw new Error("TimerEvent infinite\
 loop created via zero delay");
          return this;
        }, getProgress: function() {
          return this.elapsed / this.delay;
        }, getOverallProgress: function() {
          if (this.repeat > 0) {
            var e = this.delay + this.delay * this.repeat, t = this.elapsed + this.delay * (this.repeat -
            this.repeatCount);
            return t / e;
          } else return this.getProgress();
        }, getRepeatCount: function() {
          return this.repeatCount;
        }, getElapsed: function() {
          return this.elapsed;
        }, getElapsedSeconds: function() {
          return this.elapsed * 1e-3;
        }, getRemaining: function() {
          return this.delay - this.elapsed;
        }, getRemainingSeconds: function() {
          return this.getRemaining() * 1e-3;
        }, getOverallRemaining: function() {
          return this.delay * (1 + this.repeatCount) - this.elapsed;
        }, getOverallRemainingSeconds: function() {
          return this.getOverallRemaining() * 1e-3;
        }, remove: function(e) {
          e === void 0 && (e = false), this.elapsed = this.delay, this.hasDispatched = !e, this.repeatCount =
          0;
        }, destroy: function() {
          this.callback = void 0, this.callbackScope = void 0, this.args = [];
        } });
        QY.exports = Cge;
      });
      e4 = u((uDe, jY) => {
        var Age = C(), Rge = rt(), fi = qe(), JY = Wv(), Hv = Jt(), $Y = new Age({ initialize: function(t) {
          this.scene = t, this.systems = t.sys, this.now = 0, this.startTime = 0, this.timeScale = 1,
          this.paused = false, this._active = [], this._pendingInsertion = [], this._pendingRemoval =
          [], t.sys.events.once(fi.BOOT, this.boot, this), t.sys.events.on(fi.START, this.start, this);
        }, boot: function() {
          this.now = this.systems.game.loop.time, this.systems.events.once(fi.DESTROY, this.destroy,
          this);
        }, start: function() {
          this.startTime = this.systems.game.loop.time;
          var e = this.systems.events;
          e.on(fi.PRE_UPDATE, this.preUpdate, this), e.on(fi.UPDATE, this.update, this), e.once(fi.SHUTDOWN,
          this.shutdown, this);
        }, addEvent: function(e) {
          var t;
          if (e instanceof JY) {
            if (t = e, this.removeEvent(t), t.elapsed = t.startAt, t.hasDispatched = false, t.repeatCount =
            t.repeat === -1 || t.loop ? 999999999999 : t.repeat, t.delay <= 0 && t.repeatCount > 0) throw new Error(
            "TimerEvent infinite loop created via zero delay");
          } else t = new JY(e);
          return this._pendingInsertion.push(t), t;
        }, delayedCall: function(e, t, i, r) {
          return this.addEvent({ delay: e, callback: t, args: i, callbackScope: r });
        }, clearPendingEvents: function() {
          return this._pendingInsertion = [], this;
        }, removeEvent: function(e) {
          Array.isArray(e) || (e = [e]);
          for (var t = 0; t < e.length; t++) {
            var i = e[t];
            Hv(this._pendingRemoval, i), Hv(this._pendingInsertion, i), Hv(this._active, i);
          }
          return this;
        }, removeAllEvents: function() {
          return this._pendingRemoval = this._pendingRemoval.concat(this._active), this;
        }, preUpdate: function() {
          var e = this._pendingRemoval.length, t = this._pendingInsertion.length;
          if (!(e === 0 && t === 0)) {
            var i, r;
            for (i = 0; i < e; i++) {
              r = this._pendingRemoval[i];
              var s = this._active.indexOf(r);
              s > -1 && this._active.splice(s, 1), r.destroy();
            }
            for (i = 0; i < t; i++) r = this._pendingInsertion[i], this._active.push(r);
            this._pendingRemoval.length = 0, this._pendingInsertion.length = 0;
          }
        }, update: function(e, t) {
          if (this.now = e, !this.paused) {
            t *= this.timeScale;
            for (var i = 0; i < this._active.length; i++) {
              var r = this._active[i];
              if (!r.paused && (r.elapsed += t * r.timeScale, r.elapsed >= r.delay)) {
                var s = r.elapsed - r.delay;
                if (r.elapsed = r.delay, !r.hasDispatched && r.callback && (r.hasDispatched = true, r.
                callback.apply(r.callbackScope, r.args)), r.repeatCount > 0) {
                  if (r.repeatCount--, s >= r.delay) for (; s >= r.delay && r.repeatCount > 0; ) r.callback &&
                  r.callback.apply(r.callbackScope, r.args), s -= r.delay, r.repeatCount--;
                  r.elapsed = s, r.hasDispatched = false;
                } else r.hasDispatched && this._pendingRemoval.push(r);
              }
            }
          }
        }, shutdown: function() {
          var e;
          for (e = 0; e < this._pendingInsertion.length; e++) this._pendingInsertion[e].destroy();
          for (e = 0; e < this._active.length; e++) this._active[e].destroy();
          for (e = 0; e < this._pendingRemoval.length; e++) this._pendingRemoval[e].destroy();
          this._active.length = 0, this._pendingRemoval.length = 0, this._pendingInsertion.length = 0;
          var t = this.systems.events;
          t.off(fi.PRE_UPDATE, this.preUpdate, this), t.off(fi.UPDATE, this.update, this), t.off(fi.
          SHUTDOWN, this.shutdown, this);
        }, destroy: function() {
          this.shutdown(), this.scene.sys.events.off(fi.START, this.start, this), this.scene = null,
          this.systems = null;
        } });
        Rge.register("Clock", $Y, "time");
        jY.exports = $Y;
      });
      i4 = u((lDe, t4) => {
        t4.exports = "complete";
      });
      Kv = u((fDe, r4) => {
        r4.exports = { COMPLETE: i4() };
      });
      o4 = u((dDe, a4) => {
        var _ge = C(), s4 = Z(), Pge = Ne(), Mt = B(), an = qe(), Mge = Kv(), n4 = new _ge({ Extends: s4,
        initialize: function(t, i) {
          s4.call(this), this.scene = t, this.systems = t.sys, this.elapsed = 0, this.timeScale = 1,
          this.paused = true, this.complete = false, this.totalComplete = 0, this.loop = 0, this.iteration =
          0, this.events = [];
          var r = this.systems.events;
          r.on(an.PRE_UPDATE, this.preUpdate, this), r.on(an.UPDATE, this.update, this), r.once(an.SHUTDOWN,
          this.destroy, this), i && this.add(i);
        }, preUpdate: function(e, t) {
          this.paused || (this.elapsed += t * this.timeScale);
        }, update: function() {
          if (!(this.paused || this.complete)) {
            var e, t = this.events, i = false, r = this.systems, s;
            for (e = 0; e < t.length; e++) {
              var n = t[e];
              if (!n.complete && n.time <= this.elapsed) {
                if (n.complete = true, this.totalComplete++, s = n.target ? n.target : this, n.if &&
                !n.if.call(s, n)) continue;
                if (n.once && (i = true), n.set && n.target) for (var a in n.set) n.target[a] = n.set[a];
                this.iteration && n.repeat++, n.loop && n.repeat && n.loop.call(s), n.tween && (n.tweenInstance =
                r.tweens.add(n.tween)), n.sound && (typeof n.sound == "string" ? r.sound.play(n.sound) :
                r.sound.play(n.sound.key, n.sound.config)), n.event && this.emit(n.event, s), n.run &&
                n.run.call(s), n.stop && this.stop();
              }
            }
            if (i) for (e = 0; e < t.length; e++) t[e].complete && t[e].once && (t.splice(e, 1), e--);
            this.totalComplete >= t.length && (this.loop !== 0 && (this.loop === -1 || this.loop > this.
            iteration) ? (this.iteration++, this.reset(true)) : this.complete = true), this.complete &&
            this.emit(Mge.COMPLETE, this);
          }
        }, play: function(e) {
          return e === void 0 && (e = true), this.paused = false, this.complete = false, this.totalComplete =
          0, e && this.reset(), this;
        }, pause: function() {
          this.paused = true;
          for (var e = this.events, t = 0; t < e.length; t++) {
            var i = e[t];
            i.tweenInstance && (i.tweenInstance.paused = true);
          }
          return this;
        }, repeat: function(e) {
          return (e === void 0 || e === true) && (e = -1), e === false && (e = 0), this.loop = e, this;
        }, resume: function() {
          this.paused = false;
          for (var e = this.events, t = 0; t < e.length; t++) {
            var i = e[t];
            i.tweenInstance && (i.tweenInstance.paused = false);
          }
          return this;
        }, stop: function() {
          return this.paused = true, this.complete = true, this;
        }, reset: function(e) {
          e === void 0 && (e = false), this.elapsed = 0, e || (this.iteration = 0);
          for (var t = this.events, i = 0; i < t.length; i++) {
            var r = t[i];
            r.complete = false, e || (r.repeat = 0), r.tweenInstance && r.tweenInstance.stop();
          }
          return this.play(false);
        }, add: function(e) {
          Array.isArray(e) || (e = [e]);
          var t = this.events, i = 0;
          t.length > 0 && (i = t[t.length - 1].time);
          for (var r = 0; r < e.length; r++) {
            var s = e[r], n = Mt(s, "at", 0), a = Mt(s, "in", null);
            a !== null && (n = this.elapsed + a);
            var o = Mt(s, "from", null);
            o !== null && (n = i + o), t.push({ complete: false, time: n, repeat: 0, if: Mt(s, "if",
            null), run: Mt(s, "run", null), loop: Mt(s, "loop", null), event: Mt(s, "event", null), target: Mt(
            s, "target", null), set: Mt(s, "set", null), tween: Mt(s, "tween", null), sound: Mt(s, "\
sound", null), once: Mt(s, "once", false), stop: Mt(s, "stop", false) }), i = n;
          }
          return this.complete = false, this;
        }, clear: function() {
          for (var e = this.events, t = 0; t < e.length; t++) {
            var i = e[t];
            i.tweenInstance && i.tweenInstance.stop();
          }
          return e = [], this.elapsed = 0, this.paused = true, this;
        }, isPlaying: function() {
          return !this.paused && !this.complete;
        }, getProgress: function() {
          var e = Math.min(this.totalComplete, this.events.length);
          return e / this.events.length;
        }, destroy: function() {
          var e = this.systems.events;
          e.off(an.PRE_UPDATE, this.preUpdate, this), e.off(an.UPDATE, this.update, this), e.off(an.
          SHUTDOWN, this.destroy, this), this.clear(), this.scene = null, this.systems = null;
        } });
        Pge.register("timeline", function(e) {
          return new n4(this.scene, e);
        });
        a4.exports = n4;
      });
      u4 = u((cDe, h4) => {
        h4.exports = { Clock: e4(), Events: Kv(), Timeline: o4(), TimerEvent: Wv() };
      });
      Jh = u((vDe, l4) => {
        var qge = function(e, t, i) {
          var r;
          if (e.hasOwnProperty(t)) {
            var s = typeof e[t];
            s === "function" ? r = function(n, a, o, h, l, f) {
              return e[t](n, a, o, h, l, f);
            } : r = function() {
              return e[t];
            };
          } else typeof i == "function" ? r = i : r = function() {
            return i;
          };
          return r;
        };
        l4.exports = qge;
      });
      d4 = u((pDe, f4) => {
        f4.exports = ["callbackScope", "completeDelay", "delay", "duration", "ease", "easeParams", "\
flipX", "flipY", "hold", "interpolation", "loop", "loopDelay", "onActive", "onActiveParams", "onComp\
lete", "onCompleteParams", "onLoop", "onLoopParams", "onPause", "onPauseParams", "onRepeat", "onRepe\
atParams", "onResume", "onResumeParams", "onStart", "onStartParams", "onStop", "onStopParams", "onUp\
date", "onUpdateParams", "onYoyo", "onYoyoParams", "paused", "persist", "props", "repeat", "repeatDe\
lay", "targets", "yoyo"];
      });
      Zv = u((mDe, c4) => {
        var Fge = d4(), bge = function(e) {
          var t, i = [];
          if (e.hasOwnProperty("props")) for (t in e.props) t.substring(0, 1) !== "_" && i.push({ key: t,
          value: e.props[t] });
          else for (t in e) Fge.indexOf(t) === -1 && t.substring(0, 1) !== "_" && i.push({ key: t, value: e[t] });
          return i;
        };
        c4.exports = bge;
      });
      $h = u((gDe, v4) => {
        var Lge = H(), Oge = function(e) {
          var t = Lge(e, "targets", null);
          return t === null || (typeof t == "function" && (t = t.call()), Array.isArray(t) || (t = [
          t])), t;
        };
        v4.exports = Oge;
      });
      jh = u((xDe, x4) => {
        var Dge = ss(), Nge = ws();
        function p4(e) {
          return !!e.getActive && typeof e.getActive == "function";
        }
        function m4(e) {
          return !!e.getStart && typeof e.getStart == "function";
        }
        function g4(e) {
          return !!e.getEnd && typeof e.getEnd == "function";
        }
        function Ige(e) {
          return m4(e) || g4(e) || p4(e);
        }
        var Ca = function(e, t) {
          var i, r = function(y, A10, S14) {
            return S14;
          }, s = function(y, A10, S14) {
            return S14;
          }, n = null, a = typeof t;
          if (a === "number") r = function() {
            return t;
          };
          else if (Array.isArray(t)) s = function() {
            return t[0];
          }, r = function() {
            return t[t.length - 1];
          };
          else if (a === "string") {
            var o = t.toLowerCase(), h = o.substring(0, 6) === "random", l = o.substring(0, 3) === "\
int";
            if (h || l) {
              var f = o.indexOf("("), d = o.indexOf(")"), c = o.indexOf(",");
              if (f && d && c) {
                var p = parseFloat(o.substring(f + 1, c)), v = parseFloat(o.substring(c + 1, d));
                h ? r = function() {
                  return Nge(p, v);
                } : r = function() {
                  return Dge(p, v);
                };
              } else throw new Error("invalid random() format");
            } else {
              o = o[0];
              var m = parseFloat(t.substr(2));
              switch (o) {
                case "+":
                  r = function(y, A10, S14) {
                    return S14 + m;
                  };
                  break;
                case "-":
                  r = function(y, A10, S14) {
                    return S14 - m;
                  };
                  break;
                case "*":
                  r = function(y, A10, S14) {
                    return S14 * m;
                  };
                  break;
                case "/":
                  r = function(y, A10, S14) {
                    return S14 / m;
                  };
                  break;
                default:
                  r = function() {
                    return parseFloat(t);
                  };
              }
            }
          } else if (a === "function") r = t;
          else if (a === "object") if (Ige(t)) p4(t) && (n = t.getActive), g4(t) && (r = t.getEnd), m4(
          t) && (s = t.getStart);
          else if (t.hasOwnProperty("value")) i = Ca(e, t.value);
          else {
            var g = t.hasOwnProperty("to"), x = t.hasOwnProperty("from"), E = t.hasOwnProperty("star\
t");
            if (g && (x || E)) {
              if (i = Ca(e, t.to), E) {
                var T15 = Ca(e, t.start);
                i.getActive = T15.getEnd;
              }
              if (x) {
                var w = Ca(e, t.from);
                i.getStart = w.getEnd;
              }
            }
          }
          return i || (i = { getActive: n, getEnd: r, getStart: s }), i;
        };
        x4.exports = Ca;
      });
      T4 = u((EDe, E4) => {
        E4.exports = "active";
      });
      S4 = u((TDe, y4) => {
        y4.exports = "complete";
      });
      C4 = u((yDe, w4) => {
        w4.exports = "loop";
      });
      R4 = u((SDe, A42) => {
        A42.exports = "pause";
      });
      P4 = u((wDe, _4) => {
        _4.exports = "resume";
      });
      q4 = u((CDe, M4) => {
        M4.exports = "repeat";
      });
      b4 = u((ADe, F42) => {
        F42.exports = "start";
      });
      O4 = u((RDe, L4) => {
        L4.exports = "stop";
      });
      N4 = u((_De, D42) => {
        D42.exports = "update";
      });
      B4 = u((PDe, I4) => {
        I4.exports = "yoyo";
      });
      xr = u((MDe, G4) => {
        G4.exports = { TWEEN_ACTIVE: T4(), TWEEN_COMPLETE: S4(), TWEEN_LOOP: C4(), TWEEN_PAUSE: R4(),
        TWEEN_RESUME: P4(), TWEEN_REPEAT: q4(), TWEEN_START: b4(), TWEEN_STOP: O4(), TWEEN_UPDATE: N4(),
        TWEEN_YOYO: B4() };
      });
      jr = u((qDe, k4) => {
        var Bge = C(), U4 = Z(), $r = xr(), Ce = _r(), z4 = new Bge({ Extends: U4, initialize: function(t) {
          U4.call(this), this.parent = t, this.data = [], this.totalData = 0, this.startDelay = 0, this.
          hasStarted = false, this.timeScale = 1, this.loop = 0, this.loopDelay = 0, this.loopCounter =
          0, this.completeDelay = 0, this.countdown = 0, this.state = Ce.PENDING, this.paused = false,
          this.callbacks = { onActive: null, onComplete: null, onLoop: null, onPause: null, onRepeat: null,
          onResume: null, onStart: null, onStop: null, onUpdate: null, onYoyo: null }, this.callbackScope,
          this.persist = false;
        }, setTimeScale: function(e) {
          return this.timeScale = e, this;
        }, getTimeScale: function() {
          return this.timeScale;
        }, isPlaying: function() {
          return !this.paused && this.isActive();
        }, isPaused: function() {
          return this.paused;
        }, pause: function() {
          return this.paused || (this.paused = true, this.dispatchEvent($r.TWEEN_PAUSE, "onPause")),
          this;
        }, resume: function() {
          return this.paused && (this.paused = false, this.dispatchEvent($r.TWEEN_RESUME, "onResume")),
          this;
        }, makeActive: function() {
          this.parent.makeActive(this), this.dispatchEvent($r.TWEEN_ACTIVE, "onActive");
        }, onCompleteHandler: function() {
          this.setPendingRemoveState(), this.dispatchEvent($r.TWEEN_COMPLETE, "onComplete");
        }, complete: function(e) {
          return e === void 0 && (e = 0), e ? (this.setCompleteDelayState(), this.countdown = e) : this.
          onCompleteHandler(), this;
        }, completeAfterLoop: function(e) {
          return e === void 0 && (e = 0), this.loopCounter > e && (this.loopCounter = e), this;
        }, remove: function() {
          return this.parent && this.parent.remove(this), this;
        }, stop: function() {
          return this.parent && !this.isRemoved() && !this.isPendingRemove() && !this.isDestroyed() &&
          (this.dispatchEvent($r.TWEEN_STOP, "onStop"), this.setPendingRemoveState()), this;
        }, updateLoopCountdown: function(e) {
          this.countdown -= e, this.countdown <= 0 && (this.setActiveState(), this.dispatchEvent($r.
          TWEEN_LOOP, "onLoop"));
        }, updateStartCountdown: function(e) {
          return this.countdown -= e, this.countdown <= 0 && (this.hasStarted = true, this.setActiveState(),
          this.dispatchEvent($r.TWEEN_START, "onStart"), e = 0), e;
        }, updateCompleteDelay: function(e) {
          this.countdown -= e, this.countdown <= 0 && this.onCompleteHandler();
        }, setCallback: function(e, t, i) {
          return i === void 0 && (i = []), this.callbacks.hasOwnProperty(e) && (this.callbacks[e] = {
          func: t, params: i }), this;
        }, setPendingState: function() {
          this.state = Ce.PENDING;
        }, setActiveState: function() {
          this.state = Ce.ACTIVE, this.hasStarted = false;
        }, setLoopDelayState: function() {
          this.state = Ce.LOOP_DELAY;
        }, setCompleteDelayState: function() {
          this.state = Ce.COMPLETE_DELAY;
        }, setStartDelayState: function() {
          this.state = Ce.START_DELAY, this.countdown = this.startDelay, this.hasStarted = false;
        }, setPendingRemoveState: function() {
          this.state = Ce.PENDING_REMOVE;
        }, setRemovedState: function() {
          this.state = Ce.REMOVED;
        }, setFinishedState: function() {
          this.state = Ce.FINISHED;
        }, setDestroyedState: function() {
          this.state = Ce.DESTROYED;
        }, isPending: function() {
          return this.state === Ce.PENDING;
        }, isActive: function() {
          return this.state === Ce.ACTIVE;
        }, isLoopDelayed: function() {
          return this.state === Ce.LOOP_DELAY;
        }, isCompleteDelayed: function() {
          return this.state === Ce.COMPLETE_DELAY;
        }, isStartDelayed: function() {
          return this.state === Ce.START_DELAY;
        }, isPendingRemove: function() {
          return this.state === Ce.PENDING_REMOVE;
        }, isRemoved: function() {
          return this.state === Ce.REMOVED;
        }, isFinished: function() {
          return this.state === Ce.FINISHED;
        }, isDestroyed: function() {
          return this.state === Ce.DESTROYED;
        }, destroy: function() {
          this.data && this.data.forEach(function(e) {
            e.destroy();
          }), this.removeAllListeners(), this.callbacks = null, this.data = null, this.parent = null,
          this.setDestroyedState();
        } });
        z4.TYPES = ["onActive", "onComplete", "onLoop", "onPause", "onRepeat", "onResume", "onStart",
        "onStop", "onUpdate", "onYoyo"];
        k4.exports = z4;
      });
      Qv = u((FDe, X4) => {
        var Gge = { targets: null, delay: 0, duration: 1e3, ease: "Power0", easeParams: null, hold: 0,
        repeat: 0, repeatDelay: 0, yoyo: false, flipX: false, flipY: false, persist: false, interpolation: null };
        X4.exports = Gge;
      });
      Jv = u((bDe, Y4) => {
        var Uge = C(), V42 = xr(), Le = _r(), zge = new Uge({ initialize: function(t, i, r, s, n, a, o, h, l, f) {
          this.tween = t, this.targetIndex = i, this.duration = s <= 0 ? 0.01 : s, this.totalDuration =
          0, this.delay = 0, this.getDelay = r, this.yoyo = n, this.hold = a, this.repeat = o, this.
          repeatDelay = h, this.repeatCounter = 0, this.flipX = l, this.flipY = f, this.progress = 0,
          this.elapsed = 0, this.state = 0, this.isCountdown = false;
        }, getTarget: function() {
          return this.tween.targets[this.targetIndex];
        }, setTargetValue: function(e) {
          e === void 0 && (e = this.current), this.tween.targets[this.targetIndex][this.key] = e;
        }, setCreatedState: function() {
          this.state = Le.CREATED, this.isCountdown = false;
        }, setDelayState: function() {
          this.state = Le.DELAY, this.isCountdown = true;
        }, setPendingRenderState: function() {
          this.state = Le.PENDING_RENDER, this.isCountdown = false;
        }, setPlayingForwardState: function() {
          this.state = Le.PLAYING_FORWARD, this.isCountdown = false;
        }, setPlayingBackwardState: function() {
          this.state = Le.PLAYING_BACKWARD, this.isCountdown = false;
        }, setHoldState: function() {
          this.state = Le.HOLD_DELAY, this.isCountdown = true;
        }, setRepeatState: function() {
          this.state = Le.REPEAT_DELAY, this.isCountdown = true;
        }, setCompleteState: function() {
          this.state = Le.COMPLETE, this.isCountdown = false;
        }, isCreated: function() {
          return this.state === Le.CREATED;
        }, isDelayed: function() {
          return this.state === Le.DELAY;
        }, isPendingRender: function() {
          return this.state === Le.PENDING_RENDER;
        }, isPlayingForward: function() {
          return this.state === Le.PLAYING_FORWARD;
        }, isPlayingBackward: function() {
          return this.state === Le.PLAYING_BACKWARD;
        }, isHolding: function() {
          return this.state === Le.HOLD_DELAY;
        }, isRepeating: function() {
          return this.state === Le.REPEAT_DELAY;
        }, isComplete: function() {
          return this.state === Le.COMPLETE;
        }, setStateFromEnd: function(e) {
          this.yoyo ? this.onRepeat(e, true, true) : this.repeatCounter > 0 ? this.onRepeat(e, true,
          false) : this.setCompleteState();
        }, setStateFromStart: function(e) {
          this.repeatCounter > 0 ? this.onRepeat(e, false) : this.setCompleteState();
        }, reset: function() {
          var e = this.tween, t = e.totalTargets, i = this.targetIndex, r = e.targets[i], s = this.key;
          this.progress = 0, this.elapsed = 0, this.delay = this.getDelay(r, s, 0, i, t, e), this.repeatCounter =
          this.repeat === -1 ? Le.MAX : this.repeat, this.setPendingRenderState();
          var n = this.duration + this.hold;
          this.yoyo && (n += this.duration);
          var a = n + this.repeatDelay;
          this.totalDuration = this.delay + n, this.repeat === -1 ? (this.totalDuration += a * Le.MAX,
          e.isInfinite = true) : this.repeat > 0 && (this.totalDuration += a * this.repeat), this.totalDuration >
          e.duration && (e.duration = this.totalDuration), this.delay < e.startDelay && (e.startDelay =
          this.delay), this.delay > 0 && (this.elapsed = this.delay, this.setDelayState());
        }, onRepeat: function(e, t, i) {
          var r = this.tween, s = r.totalTargets, n = this.targetIndex, a = r.targets[n], o = this.key,
          h = o !== "texture";
          if (this.elapsed = e, this.progress = e / this.duration, this.flipX && a.toggleFlipX(), this.
          flipY && a.toggleFlipY(), h && (t || i) && (this.start = this.getStartValue(a, o, this.start,
          n, s, r)), i) {
            this.setPlayingBackwardState(), this.dispatchEvent(V42.TWEEN_YOYO, "onYoyo");
            return;
          }
          this.repeatCounter--, h && (this.end = this.getEndValue(a, o, this.start, n, s, r)), this.
          repeatDelay > 0 ? (this.elapsed = this.repeatDelay - e, h && (this.current = this.start, a[o] =
          this.current), this.setRepeatState()) : (this.setPlayingForwardState(), this.dispatchEvent(
          V42.TWEEN_REPEAT, "onRepeat"));
        }, destroy: function() {
          this.tween = null, this.getDelay = null, this.setCompleteState();
        } });
        Y4.exports = zge;
      });
      $v = u((LDe, H4) => {
        var eu = Jv(), kge = ne(), Xge = C(), W4 = xr(), Vge = new Xge({ Extends: eu, initialize: function(t, i, r, s, n, a, o, h, l, f, d, c, p, v, m, g, x) {
          eu.call(this, t, i, h, l, f, d, c, p, v, m), this.key = r, this.getActiveValue = a, this.getEndValue =
          s, this.getStartValue = n, this.ease = o, this.start = 0, this.previous = 0, this.current =
          0, this.end = 0, this.interpolation = g, this.interpolationData = x;
        }, reset: function(e) {
          eu.prototype.reset.call(this);
          var t = this.tween.targets[this.targetIndex], i = this.key;
          e && (t[i] = this.start), this.start = 0, this.previous = 0, this.current = 0, this.end = 0,
          this.getActiveValue && (t[i] = this.getActiveValue(t, i, 0));
        }, update: function(e) {
          var t = this.tween, i = t.totalTargets, r = this.targetIndex, s = t.targets[r], n = this.key;
          if (!s) return this.setCompleteState(), false;
          if (this.isCountdown && (this.elapsed -= e, this.elapsed <= 0 && (this.elapsed = 0, e = 0,
          this.isDelayed() ? this.setPendingRenderState() : this.isRepeating() ? (this.setPlayingForwardState(),
          this.dispatchEvent(W4.TWEEN_REPEAT, "onRepeat")) : this.isHolding() && this.setStateFromEnd(
          0))), this.isPendingRender()) return this.start = this.getStartValue(s, n, s[n], r, i, t),
          this.end = this.getEndValue(s, n, this.start, r, i, t), this.current = this.start, s[n] = this.
          start, this.setPlayingForwardState(), true;
          var a = this.isPlayingForward(), o = this.isPlayingBackward();
          if (a || o) {
            var h = this.elapsed, l = this.duration, f = 0, d = false;
            h += e, h >= l ? (f = h - l, h = l, d = true) : h < 0 && (h = 0);
            var c = kge(h / l, 0, 1);
            this.elapsed = h, this.progress = c, this.previous = this.current, a || (c = 1 - c);
            var p = this.ease(c);
            this.interpolation ? this.current = this.interpolation(this.interpolationData, p) : this.
            current = this.start + (this.end - this.start) * p, s[n] = this.current, d && (a ? (t.isNumberTween &&
            (this.current = this.end, s[n] = this.current), this.hold > 0 ? (this.elapsed = this.hold,
            this.setHoldState()) : this.setStateFromEnd(f)) : (t.isNumberTween && (this.current = this.
            start, s[n] = this.current), this.setStateFromStart(f))), this.dispatchEvent(W4.TWEEN_UPDATE,
            "onUpdate");
          }
          return !this.isComplete();
        }, dispatchEvent: function(e, t) {
          var i = this.tween;
          if (!i.isSeeking) {
            var r = i.targets[this.targetIndex], s = this.key, n = this.current, a = this.previous;
            i.emit(e, i, s, r, n, a);
            var o = i.callbacks[t];
            o && o.func.apply(i.callbackScope, [i, r, s, n, a].concat(o.params));
          }
        }, destroy: function() {
          eu.prototype.destroy.call(this), this.getActiveValue = null, this.getEndValue = null, this.
          getStartValue = null, this.ease = null;
        } });
        H4.exports = Vge;
      });
      jv = u((ODe, Z4) => {
        var tu = Jv(), Yge = ne(), Wge = C(), K4 = xr(), Hge = new Wge({ Extends: tu, initialize: function(t, i, r, s, n, a, o, h, l, f, d) {
          tu.call(this, t, i, n, a, false, o, h, l, f, d), this.key = "texture", this.startTexture =
          null, this.endTexture = r, this.startFrame = null, this.endFrame = s, this.yoyo = h !== 0;
        }, reset: function(e) {
          tu.prototype.reset.call(this);
          var t = this.tween.targets[this.targetIndex];
          this.startTexture || (this.startTexture = t.texture.key, this.startFrame = t.frame.name), e &&
          t.setTexture(this.startTexture, this.startFrame);
        }, update: function(e) {
          var t = this.tween, i = this.targetIndex, r = t.targets[i];
          if (!r) return this.setCompleteState(), false;
          if (this.isCountdown && (this.elapsed -= e, this.elapsed <= 0 && (this.elapsed = 0, e = 0,
          this.isDelayed() ? this.setPendingRenderState() : this.isRepeating() ? (this.setPlayingForwardState(),
          this.dispatchEvent(K4.TWEEN_REPEAT, "onRepeat")) : this.isHolding() && this.setStateFromEnd(
          0))), this.isPendingRender()) return this.startTexture && r.setTexture(this.startTexture, this.
          startFrame), this.setPlayingForwardState(), true;
          var s = this.isPlayingForward(), n = this.isPlayingBackward();
          if (s || n) {
            var a = this.elapsed, o = this.duration, h = 0, l = false;
            a += e, a >= o ? (h = a - o, a = o, l = true) : a < 0 && (a = 0);
            var f = Yge(a / o, 0, 1);
            this.elapsed = a, this.progress = f, l && (s ? (r.setTexture(this.endTexture, this.endFrame),
            this.hold > 0 ? (this.elapsed = this.hold, this.setHoldState()) : this.setStateFromEnd(h)) :
            (r.setTexture(this.startTexture, this.startFrame), this.setStateFromStart(h))), this.dispatchEvent(
            K4.TWEEN_UPDATE, "onUpdate");
          }
          return !this.isComplete();
        }, dispatchEvent: function(e, t) {
          var i = this.tween;
          if (!i.isSeeking) {
            var r = i.targets[this.targetIndex], s = this.key;
            i.emit(e, i, s, r);
            var n = i.callbacks[t];
            n && n.func.apply(i.callbackScope, [i, r, s].concat(n.params));
          }
        }, destroy: function() {
          tu.prototype.destroy.call(this), this.startTexture = null, this.endTexture = null, this.startFrame =
          null, this.endFrame = null;
        } });
        Z4.exports = Hge;
      });
      Aa = u((DDe, Q4) => {
        var iu = jr(), Kge = C(), ru = xr(), Zge = gt(), Qge = Ne(), Jge = le(), on = _r(), $ge = $v(),
        jge = jv(), e0e = new Kge({ Extends: iu, initialize: function(t, i) {
          iu.call(this, t), this.targets = i, this.totalTargets = i.length, this.isSeeking = false, this.
          isInfinite = false, this.elapsed = 0, this.totalElapsed = 0, this.duration = 0, this.progress =
          0, this.totalDuration = 0, this.totalProgress = 0, this.isNumberTween = false;
        }, add: function(e, t, i, r, s, n, a, o, h, l, f, d, c, p, v, m) {
          var g = new $ge(this, e, t, i, r, s, n, a, o, h, l, f, d, c, p, v, m);
          return this.totalData = this.data.push(g), g;
        }, addFrame: function(e, t, i, r, s, n, a, o, h, l) {
          var f = new jge(this, e, t, i, r, s, n, a, o, h, l);
          return this.totalData = this.data.push(f), f;
        }, getValue: function(e) {
          e === void 0 && (e = 0);
          var t = null;
          return this.data && (t = this.data[e].current), t;
        }, hasTarget: function(e) {
          return this.targets && this.targets.indexOf(e) !== -1;
        }, updateTo: function(e, t, i) {
          if (i === void 0 && (i = false), e !== "texture") for (var r = 0; r < this.totalData; r++) {
            var s = this.data[r];
            s.key === e && (s.isPlayingForward() || s.isPlayingBackward()) && (s.end = t, i && (s.start =
            s.current));
          }
          return this;
        }, restart: function() {
          switch (this.state) {
            case on.REMOVED:
            case on.FINISHED:
              this.seek(), this.parent.makeActive(this);
              break;
            case on.PENDING:
            case on.PENDING_REMOVE:
              this.parent.reset(this);
              break;
            case on.DESTROYED:
              console.warn("Cannot restart destroyed Tween", this);
              break;
            default:
              this.seek();
              break;
          }
          return this.paused = false, this.hasStarted = false, this;
        }, nextState: function() {
          if (this.loopCounter > 0) this.elapsed = 0, this.progress = 0, this.loopCounter--, this.initTweenData(
          true), this.loopDelay > 0 ? (this.countdown = this.loopDelay, this.setLoopDelayState()) : (this.
          setActiveState(), this.dispatchEvent(ru.TWEEN_LOOP, "onLoop"));
          else if (this.completeDelay > 0) this.countdown = this.completeDelay, this.setCompleteDelayState();
          else return this.onCompleteHandler(), true;
          return false;
        }, onCompleteHandler: function() {
          this.progress = 1, this.totalProgress = 1, iu.prototype.onCompleteHandler.call(this);
        }, play: function() {
          return this.isDestroyed() ? (console.warn("Cannot play destroyed Tween", this), this) : ((this.
          isPendingRemove() || this.isFinished()) && this.seek(), this.paused = false, this.setActiveState(),
          this);
        }, seek: function(e, t, i) {
          if (e === void 0 && (e = 0), t === void 0 && (t = 16.6), i === void 0 && (i = false), this.
          isDestroyed()) return console.warn("Cannot seek destroyed Tween", this), this;
          i || (this.isSeeking = true), this.reset(true), this.initTweenData(true), this.setActiveState(),
          this.dispatchEvent(ru.TWEEN_ACTIVE, "onActive");
          var r = this.paused;
          if (this.paused = false, e > 0) {
            for (var s = Math.floor(e / t), n = e - s * t, a = 0; a < s; a++) this.update(t);
            n > 0 && this.update(n);
          }
          return this.paused = r, this.isSeeking = false, this;
        }, initTweenData: function(e) {
          e === void 0 && (e = false), this.duration = 0, this.startDelay = Jge.MAX_SAFE_INTEGER;
          for (var t = this.data, i = 0; i < this.totalData; i++) t[i].reset(e);
          this.duration = Math.max(this.duration, 0.01);
          var r = this.duration, s = this.completeDelay, n = this.loopCounter, a = this.loopDelay;
          n > 0 ? this.totalDuration = r + s + (r + a) * n : this.totalDuration = r + s;
        }, reset: function(e) {
          return e === void 0 && (e = false), this.elapsed = 0, this.totalElapsed = 0, this.progress =
          0, this.totalProgress = 0, this.loopCounter = this.loop, this.loop === -1 && (this.isInfinite =
          true, this.loopCounter = on.MAX), e || (this.initTweenData(), this.setActiveState(), this.
          dispatchEvent(ru.TWEEN_ACTIVE, "onActive")), this;
        }, update: function(e) {
          if (this.isPendingRemove() || this.isDestroyed()) return this.persist ? (this.setFinishedState(),
          false) : true;
          if (this.paused || this.isFinished()) return false;
          if (e *= this.timeScale * this.parent.timeScale, this.isLoopDelayed()) return this.updateLoopCountdown(
          e), false;
          if (this.isCompleteDelayed()) return this.updateCompleteDelay(e), false;
          this.hasStarted || (this.startDelay -= e, this.startDelay <= 0 && (this.hasStarted = true,
          this.dispatchEvent(ru.TWEEN_START, "onStart"), e = 0));
          var t = false;
          if (this.isActive()) for (var i = this.data, r = 0; r < this.totalData; r++) i[r].update(e) &&
          (t = true);
          this.elapsed += e, this.progress = Math.min(this.elapsed / this.duration, 1), this.totalElapsed +=
          e, this.totalProgress = Math.min(this.totalElapsed / this.totalDuration, 1), t || this.nextState();
          var s = this.isPendingRemove();
          return s && this.persist && (this.setFinishedState(), s = false), s;
        }, forward: function(e) {
          return this.update(e), this;
        }, rewind: function(e) {
          return this.update(-e), this;
        }, dispatchEvent: function(e, t) {
          if (!this.isSeeking) {
            if (this.emit(e, this, this.targets), !this.callbacks) return;
            var i = this.callbacks[t];
            i && i.func.apply(this.callbackScope, [this, this.targets].concat(i.params));
          }
        }, destroy: function() {
          iu.prototype.destroy.call(this), this.targets = null;
        } });
        Qge.register("tween", function(e) {
          return this.scene.sys.tweens.add(e);
        });
        Zge.register("tween", function(e) {
          return this.scene.sys.tweens.create(e);
        });
        Q4.exports = e0e;
      });
      rp = u((NDe, j4) => {
        var t0e = jr(), J4 = Qv(), ep = ot(), tp = ps(), i0e = Zi(), Zt = B(), r0e = Jh(), ip = H(),
        s0e = jh(), n0e = va(), $4 = Aa(), a0e = function(e, t, i) {
          if (t instanceof $4) return t.parent = e, t;
          i === void 0 ? i = J4 : i = n0e(J4, i);
          var r = Zt(t, "from", 0), s = Zt(t, "to", 1), n = [{ value: r }], a = Zt(t, "delay", i.delay),
          o = Zt(t, "easeParams", i.easeParams), h = Zt(t, "ease", i.ease), l = s0e("value", s), f = new $4(
          e, n), d = f.add(0, "value", l.getEnd, l.getStart, l.getActive, i0e(Zt(t, "ease", h), Zt(t,
          "easeParams", o)), r0e(t, "delay", a), Zt(t, "duration", i.duration), tp(t, "yoyo", i.yoyo),
          Zt(t, "hold", i.hold), Zt(t, "repeat", i.repeat), Zt(t, "repeatDelay", i.repeatDelay), false,
          false);
          d.start = r, d.current = r, f.completeDelay = ep(t, "completeDelay", 0), f.loop = Math.round(
          ep(t, "loop", 0)), f.loopDelay = Math.round(ep(t, "loopDelay", 0)), f.paused = tp(t, "paus\
ed", false), f.persist = tp(t, "persist", false), f.isNumberTween = true, f.callbackScope = ip(t, "c\
allbackScope", f);
          for (var c = t0e.TYPES, p = 0; p < c.length; p++) {
            var v = c[p], m = ip(t, v, false);
            if (m) {
              var g = ip(t, v + "Params", []);
              f.setCallback(v, m, g);
            }
          }
          return f;
        };
        j4.exports = a0e;
      });
      sp = u((IDe, eW) => {
        var o0e = Zi(), su = H(), h0e = le(), u0e = function(e, t) {
          t === void 0 && (t = {});
          var i, r = su(t, "start", 0), s = su(t, "ease", null), n = su(t, "grid", null), a = su(t, "\
from", 0), o = a === "first", h = a === "center", l = a === "last", f = typeof a == "number", d = Array.
          isArray(e), c = parseFloat(d ? e[0] : e), p = d ? parseFloat(e[1]) : 0, v = Math.max(c, p);
          if (d && (r += c), n) {
            var m = n[0], g = n[1], x = 0, E = 0, T15 = 0, w = 0, y = [];
            l ? (x = m - 1, E = g - 1) : f ? (x = a % m, E = Math.floor(a / m)) : h && (x = (m - 1) /
            2, E = (g - 1) / 2);
            for (var A10 = h0e.MIN_SAFE_INTEGER, S14 = 0; S14 < g; S14++) {
              y[S14] = [];
              for (var _ = 0; _ < m; _++) {
                T15 = x - _, w = E - S14;
                var q = Math.sqrt(T15 * T15 + w * w);
                q > A10 && (A10 = q), y[S14][_] = q;
              }
            }
          }
          var P = s ? o0e(s) : null;
          return n ? i = function(L, N5, O19, M) {
            var F8 = 0, b = M % m, G = Math.floor(M / m);
            b >= 0 && b < m && G >= 0 && G < g && (F8 = y[G][b]);
            var I;
            if (d) {
              var W = p - c;
              P ? I = F8 / A10 * W * P(F8 / A10) : I = F8 / A10 * W;
            } else P ? I = F8 * c * P(F8 / A10) : I = F8 * c;
            return I + r;
          } : i = function(L, N5, O19, M, F8) {
            F8--;
            var b;
            o ? b = M : h ? b = Math.abs(F8 / 2 - M) : l ? b = F8 - M : f && (b = Math.abs(a - M));
            var G;
            if (d) {
              var I;
              h ? I = (p - c) / F8 * (b * 2) : I = (p - c) / F8 * b, P ? G = I * P(b / F8) : G = I;
            } else P ? G = F8 * v * P(b / F8) : G = b * c;
            return G + r;
          }, i;
        };
        eW.exports = u0e;
      });
      nu = u((BDe, nW) => {
        var l0e = jr(), tW = Qv(), np = ot(), di = ps(), f0e = Zi(), Ee = B(), d0e = fa(), iW = Jh(),
        c0e = Zv(), v0e = $h(), rW = H(), p0e = jh(), m0e = va(), sW = Aa(), g0e = function(e, t, i) {
          if (t instanceof sW) return t.parent = e, t;
          i === void 0 ? i = tW : i = m0e(tW, i);
          var r = v0e(t);
          !r && i.targets && (r = i.targets);
          for (var s = c0e(t), n = Ee(t, "delay", i.delay), a = Ee(t, "duration", i.duration), o = Ee(
          t, "easeParams", i.easeParams), h = Ee(t, "ease", i.ease), l = Ee(t, "hold", i.hold), f = Ee(
          t, "repeat", i.repeat), d = Ee(t, "repeatDelay", i.repeatDelay), c = di(t, "yoyo", i.yoyo),
          p = di(t, "flipX", i.flipX), v = di(t, "flipY", i.flipY), m = Ee(t, "interpolation", i.interpolation),
          g = function(L, N5, O19, M) {
            if (O19 === "texture") {
              var F8 = M, b = void 0;
              Array.isArray(M) ? (F8 = M[0], b = M[1]) : M.hasOwnProperty("value") ? (F8 = M.value, Array.
              isArray(M.value) ? (F8 = M.value[0], b = M.value[1]) : typeof M.value == "string" && (F8 =
              M.value)) : typeof M == "string" && (F8 = M), L.addFrame(N5, F8, b, iW(M, "delay", n),
              Ee(M, "duration", a), Ee(M, "hold", l), Ee(M, "repeat", f), Ee(M, "repeatDelay", d), di(
              M, "flipX", p), di(M, "flipY", v));
            } else {
              var G = p0e(O19, M), I = d0e(Ee(M, "interpolation", m));
              L.add(N5, O19, G.getEnd, G.getStart, G.getActive, f0e(Ee(M, "ease", h), Ee(M, "easePar\
ams", o)), iW(M, "delay", n), Ee(M, "duration", a), di(M, "yoyo", c), Ee(M, "hold", l), Ee(M, "repea\
t", f), Ee(M, "repeatDelay", d), di(M, "flipX", p), di(M, "flipY", v), I, I ? M : null);
            }
          }, x = new sW(e, r), E = 0; E < s.length; E++) for (var T15 = s[E].key, w = s[E].value, y = 0; y <
          r.length; y++) T15 === "scale" && !r[y].hasOwnProperty("scale") ? (g(x, y, "scaleX", w), g(
          x, y, "scaleY", w)) : g(x, y, T15, w);
          x.completeDelay = np(t, "completeDelay", 0), x.loop = Math.round(np(t, "loop", 0)), x.loopDelay =
          Math.round(np(t, "loopDelay", 0)), x.paused = di(t, "paused", false), x.persist = di(t, "p\
ersist", false), x.callbackScope = Ee(t, "callbackScope", x);
          for (var A10 = l0e.TYPES, S14 = 0; S14 < A10.length; S14++) {
            var _ = A10[S14], q = rW(t, _, false);
            if (q) {
              var P = rW(t, _ + "Params", []);
              x.setCallback(_, q, P);
            }
          }
          return x;
        };
        nW.exports = g0e;
      });
      oW = u((GDe, aW) => {
        aW.exports = { GetBoolean: ps(), GetEaseFunction: Zi(), GetInterpolationFunction: fa(), GetNewValue: Jh(),
        GetProps: Zv(), GetTargets: $h(), GetValueOp: jh(), NumberTweenBuilder: rp(), StaggerBuilder: sp(),
        TweenBuilder: nu() };
      });
      au = u((UDe, uW) => {
        var x0e = Jt(), ap = jr(), E0e = C(), hW = xr(), T0e = gt(), y0e = Ne(), S0e = _r(), w0e = new E0e(
        { Extends: ap, initialize: function(t) {
          ap.call(this, t), this.currentTween = null, this.currentIndex = 0;
        }, init: function() {
          return this.loopCounter = this.loop === -1 ? S0e.MAX : this.loop, this.setCurrentTween(0),
          this.startDelay > 0 && !this.isStartDelayed() ? this.setStartDelayState() : this.setActiveState(),
          this;
        }, add: function(e) {
          var t = this.parent.create(e);
          Array.isArray(t) || (t = [t]);
          for (var i = this.data, r = 0; r < t.length; r++) {
            var s = t[r];
            s.parent = this, i.push(s.reset());
          }
          return this.totalData = i.length, this;
        }, remove: function(e) {
          return x0e(this.data, e), e.setRemovedState(), e === this.currentTween && this.nextTween(),
          this.totalData = this.data.length, this;
        }, hasTarget: function(e) {
          for (var t = this.data, i = 0; i < this.totalData; i++) if (t[i].hasTarget(e)) return true;
          return false;
        }, restart: function() {
          return this.isDestroyed() ? (console.warn("Cannot restart destroyed TweenChain", this), this) :
          (this.isRemoved() && this.parent.makeActive(this), this.resetTweens(), this.paused = false,
          this.init());
        }, reset: function(e) {
          return e.seek(), e.setActiveState(), this;
        }, makeActive: function(e) {
          return e.reset(), e.setActiveState(), this;
        }, nextState: function() {
          if (this.loopCounter > 0) this.loopCounter--, this.resetTweens(), this.loopDelay > 0 ? (this.
          countdown = this.loopDelay, this.setLoopDelayState()) : (this.setActiveState(), this.dispatchEvent(
          hW.TWEEN_LOOP, "onLoop"));
          else if (this.completeDelay > 0) this.countdown = this.completeDelay, this.setCompleteDelayState();
          else return this.onCompleteHandler(), true;
          return false;
        }, play: function() {
          return this.isDestroyed() ? (console.warn("Cannot play destroyed TweenChain", this), this) :
          ((this.isPendingRemove() || this.isPending()) && this.resetTweens(), this.paused = false, this.
          startDelay > 0 && !this.isStartDelayed() ? this.setStartDelayState() : this.setActiveState(),
          this);
        }, resetTweens: function() {
          for (var e = this.data, t = this.totalData, i = 0; i < t; i++) e[i].reset(false);
          this.setCurrentTween(0);
        }, update: function(e) {
          if (this.isPendingRemove() || this.isDestroyed()) return true;
          if (this.isFinished() || this.paused) return false;
          if (e *= this.parent.timeScale, this.isLoopDelayed()) return this.updateLoopCountdown(e), false;
          if (this.isCompleteDelayed()) return this.updateCompleteDelay(e), false;
          this.hasStarted || (this.startDelay -= e, this.startDelay <= 0 && (this.hasStarted = true,
          this.dispatchEvent(hW.TWEEN_START, "onStart"), e = 0));
          var t = false;
          return this.isActive() && this.currentTween && (this.currentTween.update(e) && this.nextTween() &&
          this.nextState(), t = this.isPendingRemove(), t && this.persist && (this.setFinishedState(),
          t = false)), t;
        }, nextTween: function() {
          return this.currentIndex++, this.currentIndex === this.totalData ? true : (this.setCurrentTween(
          this.currentIndex), false);
        }, setCurrentTween: function(e) {
          this.currentIndex = e, this.currentTween = this.data[e], this.currentTween.setActiveState();
        }, dispatchEvent: function(e, t) {
          this.emit(e, this);
          var i = this.callbacks[t];
          i && i.func.apply(this.callbackScope, [this].concat(i.params));
        }, destroy: function() {
          ap.prototype.destroy.call(this), this.currentTween = null;
        } });
        y0e.register("tweenchain", function(e) {
          return this.scene.sys.tweens.chain(e);
        });
        T0e.register("tweenchain", function(e) {
          return this.scene.sys.tweens.create(e);
        });
        uW.exports = w0e;
      });
      cW = u((zDe, dW) => {
        var C0e = jr(), op = ot(), lW = ps(), A0e = $h(), es = H(), R0e = nu(), fW = au(), _0e = function(e, t) {
          if (t instanceof fW) return t.parent = e, t;
          var i = new fW(e);
          i.startDelay = es(t, "delay", 0), i.completeDelay = op(t, "completeDelay", 0), i.loop = Math.
          round(op(t, "loop", es(t, "repeat", 0))), i.loopDelay = Math.round(op(t, "loopDelay", es(t,
          "repeatDelay", 0))), i.paused = lW(t, "paused", false), i.persist = lW(t, "persist", false),
          i.callbackScope = es(t, "callbackScope", i);
          var r, s = C0e.TYPES;
          for (r = 0; r < s.length; r++) {
            var n = s[r], a = es(t, n, false);
            if (a) {
              var o = es(t, n + "Params", []);
              i.setCallback(n, a, o);
            }
          }
          var h = es(t, "tweens", null);
          if (Array.isArray(h)) {
            var l = [], f = A0e(t), d = void 0;
            for (f && (d = { targets: f }), r = 0; r < h.length; r++) l.push(R0e(i, h[r], d));
            i.add(l);
          }
          return i;
        };
        dW.exports = _0e;
      });
      mW = u((kDe, pW) => {
        var P0e = Jt(), M0e = C(), q0e = Wu(), F0e = rp(), b0e = rt(), Er = qe(), L0e = sp(), hp = Aa(),
        up = nu(), lp = au(), ou = cW(), vW = new M0e({ initialize: function(t) {
          this.scene = t, this.events = t.sys.events, this.timeScale = 1, this.paused = false, this.
          processing = false, this.tweens = [], this.time = 0, this.startTime = 0, this.nextTime = 0,
          this.prevTime = 0, this.maxLag = 500, this.lagSkip = 33, this.gap = 1e3 / 240, this.events.
          once(Er.BOOT, this.boot, this), this.events.on(Er.START, this.start, this);
        }, boot: function() {
          this.events.once(Er.DESTROY, this.destroy, this);
        }, start: function() {
          this.timeScale = 1, this.paused = false, this.startTime = Date.now(), this.prevTime = this.
          startTime, this.nextTime = this.gap, this.events.on(Er.UPDATE, this.update, this), this.events.
          once(Er.SHUTDOWN, this.shutdown, this);
        }, create: function(e) {
          Array.isArray(e) || (e = [e]);
          for (var t = [], i = 0; i < e.length; i++) {
            var r = e[i];
            r instanceof hp || r instanceof lp ? t.push(r) : Array.isArray(r.tweens) ? t.push(ou(this,
            r)) : t.push(up(this, r));
          }
          return t.length === 1 ? t[0] : t;
        }, add: function(e) {
          var t = e, i = this.tweens;
          return t instanceof hp || t instanceof lp || (Array.isArray(t.tweens) ? t = ou(this, t) : t =
          up(this, t)), i.push(t.reset()), t;
        }, addMultiple: function(e) {
          for (var t, i = [], r = this.tweens, s = 0; s < e.length; s++) t = e[s], t instanceof hp ||
          t instanceof lp || (Array.isArray(t.tweens) ? t = ou(this, t) : t = up(this, t)), r.push(t.
          reset()), i.push(t);
          return i;
        }, chain: function(e) {
          var t = ou(this, e);
          return this.tweens.push(t.init()), t;
        }, getChainedTweens: function(e) {
          return e.getChainedTweens();
        }, has: function(e) {
          return this.tweens.indexOf(e) > -1;
        }, existing: function(e) {
          return this.has(e) || this.tweens.push(e.reset()), this;
        }, addCounter: function(e) {
          var t = F0e(this, e);
          return this.tweens.push(t.reset()), t;
        }, stagger: function(e, t) {
          return L0e(e, t);
        }, setLagSmooth: function(e, t) {
          return e === void 0 && (e = 1 / 1e-8), t === void 0 && (t = 0), this.maxLag = e, this.lagSkip =
          Math.min(t, this.maxLag), this;
        }, setFps: function(e) {
          return e === void 0 && (e = 240), this.gap = 1e3 / e, this.nextTime = this.time * 1e3 + this.
          gap, this;
        }, getDelta: function(e) {
          var t = Date.now() - this.prevTime;
          t > this.maxLag && (this.startTime += t - this.lagSkip), this.prevTime += t;
          var i = this.prevTime - this.startTime, r = i - this.nextTime, s = i - this.time * 1e3;
          return r > 0 || e ? (i /= 1e3, this.time = i, this.nextTime += r + (r >= this.gap ? 4 : this.
          gap - r)) : s = 0, s;
        }, tick: function() {
          return this.step(true), this;
        }, update: function() {
          this.paused || this.step(false);
        }, step: function(e) {
          e === void 0 && (e = false);
          var t = this.getDelta(e);
          if (!(t <= 0)) {
            this.processing = true;
            var i, r, s = [], n = this.tweens;
            for (i = 0; i < n.length; i++) r = n[i], r.update(t) && s.push(r);
            var a = s.length;
            if (a && n.length > 0) {
              for (i = 0; i < a; i++) {
                r = s[i];
                var o = n.indexOf(r);
                o > -1 && (r.isPendingRemove() || r.isDestroyed()) && (n.splice(o, 1), r.destroy());
              }
              s.length = 0;
            }
            this.processing = false;
          }
        }, remove: function(e) {
          return this.processing ? e.setPendingRemoveState() : (P0e(this.tweens, e), e.setRemovedState()),
          this;
        }, reset: function(e) {
          return this.existing(e), e.seek(), e.setActiveState(), this;
        }, makeActive: function(e) {
          return this.existing(e), e.setActiveState(), this;
        }, each: function(e, t) {
          var i, r = [null];
          for (i = 1; i < arguments.length; i++) r.push(arguments[i]);
          return this.tweens.forEach(function(s) {
            r[0] = s, e.apply(t, r);
          }), this;
        }, getTweens: function() {
          return this.tweens.slice();
        }, getTweensOf: function(e) {
          var t = [], i = this.tweens;
          Array.isArray(e) ? e = q0e(e) : e = [e];
          for (var r = e.length, s = 0; s < i.length; s++) for (var n = i[s], a = 0; a < r; a++) !n.
          isDestroyed() && n.hasTarget(e[a]) && t.push(n);
          return t;
        }, getGlobalTimeScale: function() {
          return this.timeScale;
        }, setGlobalTimeScale: function(e) {
          return this.timeScale = e, this;
        }, isTweening: function(e) {
          for (var t = this.tweens, i, r = 0; r < t.length; r++) if (i = t[r], i.isPlaying() && i.hasTarget(
          e)) return true;
          return false;
        }, killAll: function() {
          for (var e = this.processing ? this.getTweens() : this.tweens, t = 0; t < e.length; t++) e[t].
          destroy();
          return this.processing || (e.length = 0), this;
        }, killTweensOf: function(e) {
          for (var t = this.getTweensOf(e), i = 0; i < t.length; i++) t[i].destroy();
          return this;
        }, pauseAll: function() {
          return this.paused = true, this;
        }, resumeAll: function() {
          return this.paused = false, this;
        }, shutdown: function() {
          this.killAll(), this.tweens = [], this.events.off(Er.UPDATE, this.update, this), this.events.
          off(Er.SHUTDOWN, this.shutdown, this);
        }, destroy: function() {
          this.shutdown(), this.events.off(Er.START, this.start, this), this.scene = null, this.events =
          null;
        } });
        b0e.register("TweenManager", vW, "tweens");
        pW.exports = vW;
      });
      xW = u((XDe, gW) => {
        var O0e = { States: _r(), Builders: oW(), Events: xr(), TweenManager: mW(), Tween: Aa(), TweenData: $v(),
        TweenFrameData: jv(), BaseTween: jr(), TweenChain: au() };
        gW.exports = O0e;
      });
      TW = u((VDe, EW) => {
        var hu = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", D0e = function(e, t) {
          for (var i = new Uint8Array(e), r = i.length, s = t ? "data:" + t + ";base64," : "", n = 0; n <
          r; n += 3) s += hu[i[n] >> 2], s += hu[(i[n] & 3) << 4 | i[n + 1] >> 4], s += hu[(i[n + 1] &
          15) << 2 | i[n + 2] >> 6], s += hu[i[n + 2] & 63];
          return r % 3 === 2 ? s = s.substring(0, s.length - 1) + "=" : r % 3 === 1 && (s = s.substring(
          0, s.length - 2) + "=="), s;
        };
        EW.exports = D0e;
      });
      SW = u((YDe, yW) => {
        yW.exports = { ArrayBufferToBase64: TW(), Base64ToArrayBuffer: Fc() };
      });
      CW = u((WDe, wW) => {
        var N0e = H(), I0e = ne(), B0e = function(e, t, i, r, s) {
          s === void 0 && (s = i);
          var n = N0e(e, t, s);
          return I0e(n, i, r);
        };
        wW.exports = B0e;
      });
      RW = u((HDe, AW) => {
        var G0e = function(e, t) {
          for (var i = 0; i < t.length; i++) if (!e.hasOwnProperty(t[i])) return false;
          return true;
        };
        AW.exports = G0e;
      });
      PW = u((KDe, _W) => {
        var U0e = ua(), z0e = function(e, t) {
          for (var i = {}, r = 0; r < t.length; r++) {
            var s = t[r];
            U0e(e, s) && (i[s] = e[s]);
          }
          return i;
        };
        _W.exports = z0e;
      });
      qW = u((ZDe, MW) => {
        var k0e = function(e, t, i) {
          if (!e || typeof e == "number") return false;
          if (e.hasOwnProperty(t)) return e[t] = i, true;
          if (t.indexOf(".") !== -1) {
            for (var r = t.split("."), s = e, n = e, a = 0; a < r.length; a++) if (s.hasOwnProperty(
            r[a])) n = s, s = s[r[a]];
            else return false;
            return n[r[r.length - 1]] = i, true;
          }
          return false;
        };
        MW.exports = k0e;
      });
      bW = u((QDe, FW) => {
        FW.exports = { Clone: kr(), DeepCopy: An(), Extend: Xe(), GetAdvancedValue: ot(), GetFastValue: B(),
        GetMinMaxValue: CW(), GetValue: H(), HasAll: RW(), HasAny: nv(), HasValue: ua(), IsPlainObject: lt(),
        Merge: lc(), MergeRight: va(), Pick: PW(), SetValue: qW() };
      });
      OW = u((JDe, LW) => {
        var X0e = function(e, t) {
          return e.replace(/%([0-9]+)/g, function(i, r) {
            return t[Number(r) - 1];
          });
        };
        LW.exports = X0e;
      });
      NW = u(($De, DW) => {
        var V0e = function(e, t) {
          return t === 0 ? e.slice(1) : e.slice(0, t) + e.slice(t + 1);
        };
        DW.exports = V0e;
      });
      BW = u((jDe, IW) => {
        var Y0e = function(e) {
          return e.split("").reverse().join("");
        };
        IW.exports = Y0e;
      });
      UW = u((eNe, GW) => {
        GW.exports = { Format: OW(), Pad: La(), RemoveAt: NW(), Reverse: BW(), UppercaseFirst: lo(),
        UUID: hv() };
      });
      kW = u((tNe, zW) => {
        var W0e = function() {
          return null;
        };
        zW.exports = W0e;
      });
      VW = u((iNe, XW) => {
        XW.exports = { Array: yn(), Base64: SW(), Objects: bW(), String: UW(), NOOP: J(), NULL: kW() };
      });
      Z0e = u((rNe, YW) => {
        var H0e = qt(), K0e = Xe(), uu = { Animations: km(), Actions: bl(), Cache: HA(), Cameras: { Scene2D: Y_() },
        Core: s2(), Class: C(), Curves: O2(), Data: G2(), Display: { Align: Y2(), Masks: H2() }, Events: j2(),
        Game: RG(), Geom: { Circle: WG(), Line: IU(), Rectangle: kz() }, GameObjects: { Events: xs(),
        DisplayList: Zz(), GameObjectCreator: gt(), GameObjectFactory: Ne(), UpdateList: h3(), Components: Ot(),
        BuildGameObject: dr(), GameObject: ei(), Group: wh(), Graphics: _h(), Image: ta(), Sprite: la(),
        Particles: Y5(), Text: Dh(), Container: Nh(), Zone: Mn(), NineSlice: Ih(), Factories: { Group: Lk(),
        Graphics: Ok(), Image: Dk(), Sprite: Nk(), Particles: Ik(), Text: Bk(), Container: Gk(), Zone: Uk(),
        NineSlice: zk() }, Creators: { Group: kk(), Graphics: Xk(), Image: Yk(), Sprite: Zk(), Particles: Qk(),
        Text: Jk(), Container: jk(), Zone: eX(), NineSlice: iX() } }, Input: HV(), Loader: { Events: zr(),
        FileTypes: { AudioFile: oY(), ImageFile: Hh(), AtlasJSONFile: xY(), MultiAtlasFile: SY() }, File: rn(),
        FileTypesManager: Fi(), GetURL: Ta(), LoaderPlugin: RY(), MergeXHRSettings: Yh(), XHRLoader: qv(),
        XHRSettings: ya() }, Math: Ao(), Renderer: DY(), Scale: IY(), ScaleModes: Ma(), Scene: dc(),
        Scenes: kY(), Structs: { List: Th(), Map: rs(), ProcessQueue: kc(), Set: Sh(), Size: ac() },
        Sound: VY(), Textures: ZY(), Time: u4(), Tweens: xW(), Utils: VW() };
        uu = K0e(false, uu, H0e);
        YW.exports = uu;
        window.Phaser = uu;
      });
      phaser_custom_min_default = Z0e();
    }
  });

  // node_modules/bezier-easing/src/index.js
  var require_src = __commonJS({
    "node_modules/bezier-easing/src/index.js"(exports, module) {
      init_phaser_custom_min();
      var NEWTON_ITERATIONS = 4;
      var NEWTON_MIN_SLOPE = 1e-3;
      var SUBDIVISION_PRECISION = 1e-7;
      var SUBDIVISION_MAX_ITERATIONS = 10;
      var kSplineTableSize = 11;
      var kSampleStepSize = 1 / (kSplineTableSize - 1);
      var float32ArraySupported = typeof Float32Array === "function";
      function A10(aA1, aA2) {
        return 1 - 3 * aA2 + 3 * aA1;
      }
      function B7(aA1, aA2) {
        return 3 * aA2 - 6 * aA1;
      }
      function C2(aA1) {
        return 3 * aA1;
      }
      function calcBezier(aT, aA1, aA2) {
        return ((A10(aA1, aA2) * aT + B7(aA1, aA2)) * aT + C2(aA1)) * aT;
      }
      function getSlope(aT, aA1, aA2) {
        return 3 * A10(aA1, aA2) * aT * aT + 2 * B7(aA1, aA2) * aT + C2(aA1);
      }
      function binarySubdivide(aX, aA2, aB, mX1, mX2) {
        var currentX, currentT, i = 0;
        do {
          currentT = aA2 + (aB - aA2) / 2;
          currentX = calcBezier(currentT, mX1, mX2) - aX;
          if (currentX > 0) {
            aB = currentT;
          } else {
            aA2 = currentT;
          }
        } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);
        return currentT;
      }
      function newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {
        for (var i = 0; i < NEWTON_ITERATIONS; ++i) {
          var currentSlope = getSlope(aGuessT, mX1, mX2);
          if (currentSlope === 0) {
            return aGuessT;
          }
          var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
          aGuessT -= currentX / currentSlope;
        }
        return aGuessT;
      }
      function LinearEasing(x) {
        return x;
      }
      module.exports = function bezier(mX1, mY1, mX2, mY2) {
        if (!(0 <= mX1 && mX1 <= 1 && 0 <= mX2 && mX2 <= 1)) {
          throw new Error("bezier x values must be in [0, 1] range");
        }
        if (mX1 === mY1 && mX2 === mY2) {
          return LinearEasing;
        }
        var sampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);
        for (var i = 0; i < kSplineTableSize; ++i) {
          sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);
        }
        function getTForX(aX) {
          var intervalStart = 0;
          var currentSample = 1;
          var lastSample = kSplineTableSize - 1;
          for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {
            intervalStart += kSampleStepSize;
          }
          --currentSample;
          var dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);
          var guessForT = intervalStart + dist * kSampleStepSize;
          var initialSlope = getSlope(guessForT, mX1, mX2);
          if (initialSlope >= NEWTON_MIN_SLOPE) {
            return newtonRaphsonIterate(aX, guessForT, mX1, mX2);
          } else if (initialSlope === 0) {
            return guessForT;
          } else {
            return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
          }
        }
        return function BezierEasing3(x) {
          if (x === 0) {
            return 0;
          }
          if (x === 1) {
            return 1;
          }
          return calcBezier(getTForX(x), mY1, mY2);
        };
      };
    }
  });

  // src/game/gameplay/levels/levels.json
  var require_levels = __commonJS({
    "src/game/gameplay/levels/levels.json"(exports, module) {
      module.exports = "./assets/levels.json";
    }
  });

  // src/index.ts
  init_phaser_custom_min();

  // src/systems/LuderSystem.ts
  init_phaser_custom_min();

  // src/constants/SceneKeys.ts
  init_phaser_custom_min();
  var SceneKeys = {
    BOOT_SCENE: "BootScene",
    LOAD_SCENE: "LoadScene",
    GAME_SCENE: "GameScene",
    GLOBAL_SCENE: "GlobalScene",
    DASHBOARD_SCENE: "DashboardScene",
    RESULT_MATCH_SCENE: "ChallengeResultScene",
    // ! Test
    TEST_LAYOUT_SCENE: "TestLayoutScene"
  };
  var SceneKeys_default = SceneKeys;

  // src/systems/AdsManager.ts
  init_phaser_custom_min();

  // src/constants/GameEvents.ts
  init_phaser_custom_min();
  var GameEvents = {
    VIEW_RESIZED: "view-resized",
    REQUEST_VIEW_RESIZE: "request-view-resize",
    LAYOUT_CHANGED: "layout-changed",
    // L10n
    PRELOAD_LANGUAGE: "preload-language",
    CHOOSE_LANGUAGE: "choose-language",
    LOCALIZE_APPLIED: "localize-applied",
    COINS_CHANGED: "coins-changed",
    DESTROY_SCREENS: "destroy-screens"
  };
  var GameEvents_default = GameEvents;

  // src/constants/GameWorld.ts
  init_phaser_custom_min();
  var GameWorld = {
    Layout: {
      Portrait: "portrait",
      Landscape: "landscape"
    },
    // ! Please update design size for your game
    DesignSize: {
      Portrait: {
        // 1x 375
        // 2x 750
        WIDTH: 750,
        // 1x 667
        // 2x 1334
        HEIGHT: 1334
      },
      Landscape: {
        // 1x 760
        // 2x 1520
        // 1976
        WIDTH: 1520,
        // 1x 500
        // 2x 1000
        // 1300
        HEIGHT: 1e3
      },
      // ? This is resolution of assets
      Resolution: 2,
      DesignScale: {
        Portrait: 1,
        Landscape: 1.3
      }
    },
    // * This ratio is only optimize for this game, not for all game
    // ? Target all popup in game will fit to this ratio
    AcceptPortraitRatio: 0.72,
    // Default is 'auto', or 'portrait' or 'landscape'
    // ? If 'auto', the game will be auto detect layout by device orientation
    PRIMARY_LAYOUT: "auto",
    // Default is false
    // ? This mean portrait layout will be fill to screen size
    FULL_PORTRAIT_SIZE: true,
    // Default is false
    // ? This mean landscape layout will be fill to screen size
    FULL_LANDSCAPE_SIZE: true
  };
  var GameWorld_default = GameWorld;

  // src/utils/AdsUtils.ts
  init_phaser_custom_min();

  // src/utils/AudioUtils.ts
  init_phaser_custom_min();

  // src/constants/GameSettings.ts
  init_phaser_custom_min();
  var GameSettings = {
    StartScore: 0,
    DefuseItemGuideLevel: 11,
    RocketItemGuideLevel: 16,
    SuperRocketGuideLevel: 17,
    FinalGuideLevel: 17,
    BaseScore: 10,
    DelayStart: 500,
    DelayLevelUp: 1500,
    DelayEndGame: 1500,
    MaxRescueCount: 1,
    RescueGamePopupTimeout: 5,
    RewardItemResultPopupRatio: 0.16,
    BombCountDownTime: 9e4,
    StartItems: {
      ItemHint: 8,
      ItemRocket: 3,
      ItemShuffle: 5,
      ItemBombDefuse: 2,
      ItemSuperRocket: 0
    },
    DailyRewardItems: {
      ItemHint: 2,
      ItemRocket: 2,
      ItemShuffle: 2,
      ItemBombDefuse: 2
    },
    SuperRocketConfig: {
      DestroyPairCount: 7,
      GameRechargeCount: 2
    },
    DefaultTheme: "cake",
    Themes: ["fruit", "cake", "bird", "candy", "flower", "umbrella", "food", "butterfly"],
    EnableVibrate: true,
    Sound: {
      Music: {
        DefaultVolume: 0.6,
        MinVolume: 0.1
      }
    }
  };
  var GameSettings_default = GameSettings;

  // src/game/components/audio/AudioManager.ts
  init_phaser_custom_min();

  // src/utils/SceneUtils.ts
  init_phaser_custom_min();

  // src/game/constants/resources/sprites.ts
  init_phaser_custom_min();
  var {
    Utils: { Device: D }
  } = Ludex;
  var imageScale = Math.min(D.pixelRatio(), 2);
  var SPRITES = {
    TUTORIAL: {
      KEY: "tutorial-resources",
      TEXTURE: `./assets/textures/${imageScale}x/tutorial-resources.png`,
      JSON: `./assets/textures/${imageScale}x/tutorial-resources.json`,
      TEXTURE_32_BIT: `./assets/textures/${imageScale}x/tutorial-resources-32bit.png`,
      FRAME: {
        HAND: "hand",
        BLANK: "blank",
        BOMB: "bomb",
        GUIDE_TILE1: "guide-tile1",
        GUIDE_TILE2: "guide-tile2",
        GUIDE_TILE3: "guide-tile3",
        GUIDE_TILE4: "guide-tile4",
        GUIDE_TILE5: "guide-tile5",
        LEAF_LEFT: "leaf-left",
        LEAF_RIGHT: "leaf-right",
        ROCKET: "rocket",
        TEXT_FAILED: "text-failed",
        TEXT_GOOD: "text-good",
        TILE_BG: "tile-bg",
        CROSS_WRONG: "cross-wrong",
        DOT_WRONG: "dot-wrong",
        LINE_WRONG: "line-wrong",
        BOTTOM_PANEL: "bottom-panel",
        TOP_PANEL: "top-panel",
        MIDDLE_PANEL: "middle-panel",
        CIRCLE_HIGHLIGHT: "circle-highlight"
      }
    },
    DEFAULT: {
      KEY: "default-resources",
      TEXTURE: `./assets/textures/${imageScale}x/default-resources.png`,
      JSON: `./assets/textures/${imageScale}x/default-resources.json`,
      TEXTURE_32_BIT: `./assets/textures/${imageScale}x/default-resources-32bit.png`,
      FRAME: {
        BLANK: "blank",
        // Preloader
        PRELOADER: "preloader/loading",
        // Logo
        LOGO_GIFT: "logo/gift",
        LOGO_GIFT_ADS: "logo/gift-ad",
        LOGO_GIFT_WHITE: "logo/gift_white",
        // Popup
        POPUP: "popup/popup",
        // Progress
        PROGRESS_CIRCLE_BG: "progress/circle-background",
        PROGRESS_CIRCLE: "progress/progress-circle",
        // Icons
        ICON_ADS: "icons/ads",
        ICON_LOSE: "icons/lose",
        ICON_BOMB: "icons/bomb",
        ICON_CLOCK: "icons/clock",
        ICON_HOME: "icons/home",
        ICON_REPLAY: "icons/replay",
        ICON_INVITE: "icons/invite",
        ICON_CONTINUE: "icons/continue",
        ICON_MUSIC_ON: "icons/music-on",
        ICON_MUSIC_OFF: "icons/music-off",
        ICON_SOUND_ON: "icons/sound-on",
        ICON_SOUND_OFF: "icons/sound-off",
        ICON_VIBRATE_ON: "icons/vibrate-on",
        ICON_VIBRATE_OFF: "icons/vibrate-off",
        ICON_TIMEOUT_CLOCK: "icons/timeout-clock",
        ICON_X: "icons/x",
        ICON_SHARE: "icons/share",
        ICON_INFO_DOT: "icons/info-dot",
        // Buttons
        BUTTON_CLOSE: "buttons/close",
        BUTTON_FRAME: "buttons/frame",
        BUTTON_BLUE: "buttons/blue",
        BUTTON_GREEN: "buttons/green",
        BUTTON_ORANGE: "buttons/orange",
        BUTTON_YELLOW: "buttons/yellow",
        BUTTON_GREEN_SMALL: "buttons/green-small",
        BUTTON_GREEN_SMALL_BG: "buttons/green-small-bg",
        BUTTON_RED_CIRCLE: "buttons/red-circle",
        BUTTON_YELLOW_CIRCLE: "buttons/yellow-circle",
        // Texts
        BOOM: "texts/boom",
        ROCKET: "texts/rocket",
        VICTORY: "texts/victory",
        X2: "texts/x2",
        FAILED_TEXT: "texts/text-failed",
        CONTINUE_TEXT: "texts/text-continue",
        PAUSE_TEXT: "texts/text-pause",
        SETTINGS_TEXT: "texts/text-settings",
        // Arts
        ART_BG_LIGHT: "art/bg-light",
        ART_WHITE_GLOW: "art/white-glow",
        ART_YELLOW_GLOW: "art/yellow-glow",
        // RESULT SCREEN
        RESULT_RIBBON: "result-screen/ribbon",
        RESULT_STAR: "result-screen/star",
        RESULT_VICTORY_TEXT: "result-screen/victory-text",
        // LOADING SCREEN
        LOADING_SCREEN_TILE_BG: "loading-screen/tile-bg",
        LOADING_SCREEN_TILE_ICON_1: "loading-screen/tile-1",
        LOADING_SCREEN_TILE_ICON_2: "loading-screen/tile-2",
        LOADING_SCREEN_TILE_ICON_3: "loading-screen/tile-3",
        LOADING_SCREEN_TILE_ICON_4: "loading-screen/tile-4",
        LOADING_SCREEN_TILE_ICON_5: "loading-screen/tile-5"
      }
    },
    EFFECTS: {
      KEY: "effects-resources",
      PATH: `./assets/textures/${imageScale}x/`,
      JSON: `./assets/textures/${imageScale}x/effects-resources.json`,
      TEXTURES_32BIT: `./assets/textures/${imageScale}x/effects-resources-32bit-0.png`,
      FRAME: {
        BLANK: "blank",
        CAPTURE_PATH_START: "capture-path/capture-path-start",
        CAPTURE_PATH_MIDDLE: "capture-path/capture-path-middle",
        CAPTURE_PATH_END: "capture-path/capture-path-end",
        POLISH_EFFECT: "polish-effect/polish-effect-",
        ROCKET_TAIL: "rocket-tail-effect/fire-explosive-",
        COMBO_EFFECT_PARTICLE: "combo-effect/combo-particle",
        WHITE_SMOKE: "big-rocket-tail-effect/white-smoke",
        YELLOW_SMOKE: "big-rocket-tail-effect/yellow-smoke",
        // FX
        FX_COMET: "comet",
        FX_COMET_DARK: "comet-dark",
        FX_SPARK: "spark",
        FX_CIRCLE: "circle",
        FX_HINT_GLOW: "hint-glow",
        FX_STAR_WHITE: "star-white",
        FX_STAR_YELLOW: "star-yellow",
        FX_STAR_YELLOW_DARK: "star-yellow-dark",
        // Text
        TEXT_GOOD: "texts/good",
        TEXT_GOOD_LIGHT: "texts/good-light",
        TEXT_GREAT: "texts/great",
        TEXT_GREAT_LIGHT: "texts/great-light",
        TEXT_EXCELLENT: "texts/excellent",
        TEXT_EXCELLENT_LIGHT: "texts/excellent-light",
        TEXT_UNBELIEVABLE: "texts/unbelievable",
        TEXT_UNBELIEVABLE_LIGHT: "texts/unbelievable-light",
        // Confetti
        FX_CONFETTI_SMALL_1: "confetti/small-1",
        FX_CONFETTI_SMALL_2: "confetti/small-2",
        FX_CONFETTI_SMALL_3: "confetti/small-3",
        FX_CONFETTI_SMALL_4: "confetti/small-4",
        FX_CONFETTI_HEXAGON: "confetti/hexagon-",
        EFFECT_BOMB_DEFUSE: "bomb-defuse/bomb-defuse-",
        EFFECT_BOMB_EXPLOSION: "bomb-explosion/bomb-explosion-",
        EFFECT_ROCKET_EXPLOSION: "rocket-explosion/rocket-explosion-",
        FX_HIGHLIGHT: "fx-items/highlight",
        ANIMATION_STAR_X: "star-x/star-",
        ANIMATION_STAR_Y: "star-y/star-",
        PREFIX_ANIMATION_RIBBON_CONFETTI_A: "ribbon/falling-confetti/confetti-a/confetti-a-",
        PREFIX_ANIMATION_RIBBON_CONFETTI_B: "ribbon/falling-confetti/confetti-b/confetti-b-",
        PREFIX_ANIMATION_RIBBON_CONFETTI_C: "ribbon/falling-confetti/confetti-c/confetti-c-",
        PREFIX_ANIMATION_RIBBON_CONFETTI_D: "ribbon/falling-confetti/confetti-d/confetti-d-"
      }
    },
    GAMEPLAY: {
      KEY: "gameplay-resources",
      PATH: `./assets/textures/${imageScale}x/`,
      JSON: `./assets/textures/${imageScale}x/gameplay-resources.json`,
      FRAME: {
        BLANK: "blank",
        // Layout
        LAYOUT_HEADER: "layout/header",
        LAYOUT_FOOTER: "layout/footer",
        LAYOUT_FOOTER_TOP: "layout/block-footer-top",
        LAYOUT_FOOTER_BOTTOM: "layout/block-footer-bottom",
        LAYOUT_HEADER_LANDSCAPE: "layout/landscape-header",
        // Buttons
        BUTTON_WOOD_SMALL: "buttons/wood-small",
        BUTTON_YELLOW_CIRCLE: "buttons/yellow-circle",
        // Timer
        TIMER_BG: "timer/bg",
        // Dev tools
        DEV_TOOL_ARROW: "dev-tool/arrow",
        DEV_TOOL_RESET: "dev-tool/reset",
        DEV_TOOL_BOMB: "dev-tool/bomb",
        DEV_TOOL_CLOCK: "dev-tool/clock",
        DEV_TOOL_HAND: "dev-tool/hand",
        DEV_TOOL_NEW_GAME: "dev-tool/new-game",
        // Progress
        PROGRESS_BAR_LEFT: "progress/bar-left",
        PROGRESS_BAR_MID: "progress/bar-mid",
        PROGRESS_BAR_RIGHT: "progress/bar-right",
        PROGRESS_STAR: "progress/bar-star",
        PROGRESS_BG_COMBO: "progress/bg-combo",
        PROGRESS_BAR_COMBO: "progress/bar-combo",
        // Items
        ITEM_SHUFFLE: "items/shuffle",
        HINT_ITEM: "items/hint",
        ROCKET_ITEM: "items/rocket",
        SUPER_ROCKET_ITEM: "items/super-rocket",
        DEFUSE_ITEM: "items/defuse",
        ITEM_SHARE: "items/share",
        ITEM_BG_ITEM: "items/bg-item",
        ITEM_BG_AMOUNT: "items/bg-amount",
        ITEM_SHUFFLE_LOCK: "items/shuffle-lock",
        ITEM_HINT_LOCK: "items/hint-lock",
        ITEM_ROCKET_LOCK: "items/rocket-lock",
        ITEM_SUPER_ROCKET_LOCK: "items/super-rocket-lock",
        ITEM_DEFUSE_LOCK: "items/defuse-lock",
        ITEM_BG_LOCK: "items/bg-item-lock",
        NOTE_LOCK: "items/note-lock",
        NOTE_INVITE: "items/note-invite",
        NOTE_FREE: "items/note-free",
        SUPER_ROCKET_NOTIFICATION: "items/super-rocket-notification",
        // Effects
        BOTTOM_TILE_FRAGMENT: "effect/bottom-tile-fragment",
        LEF_TILE_FRAGMENT: "effect/left-tile-fragment",
        RIGHT_TILE_FRAGMENT: "effect/right-tile-fragment",
        TOP_TILE_FRAGMENT: "effect/top-tile-fragment",
        EFFECT_SPARK: "effect/spark",
        EFFECT_LONG_ROCKET: "effect/long-rocket",
        EFFECT_SHORT_ROCKET: "effect/short-rocket",
        EFFECT_LONG_YELLOW_ROCKET: "effect/long-yellow-rocket",
        EFFECT_SHORT_YELLOW_ROCKET: "effect/short-yellow-rocket",
        EFFECT_CIRCLE: "effect/circle",
        EFFECT_TRAIL_STAR: "effect/trail-star",
        EFFECT_TILE_ROCKET: "effect/tile-rocket",
        EFFECT_TILE_HIGHLIGHT: "effect/tile-highlight/highlight-",
        EFFECT_TILE_OUTLINE: "effect/tile-select-bg",
        HINT_LINE_DOT: "effect/hint-line-dot",
        // Icons
        ICON_CLOCK: "icons/clock",
        ICON_BOMB: "icons/bomb",
        ICON_STAR_BIG: "icons/star-big",
        ICON_PAUSE: "icons/pause",
        ICON_COIN: "icons/coin",
        // Tiles
        TILE_BOMB: "blank",
        TILE_ROCKET: "tiles/rocket",
        TILE_BG: "tiles/tile-bg",
        TILE_BUTTERFLY_BODY: "tiles/butterfly-body"
      }
    },
    CHALLENGE: {
      KEY: "challenge-friends-resources",
      JSON: `./assets/textures/${imageScale}x/challenge-friends-resources.json`,
      TEXTURE: `./assets/textures/${imageScale}x/challenge-friends-resources.png`,
      TEXTURE_32_BIT: `./assets/textures/${imageScale}x/challenge-friends-resources-32bit.png`,
      FRAME: {
        BLANK: "blank",
        // Layout
        POPUP: "popup",
        SCORE_PANEL: "score-panel",
        CROWN: "crown",
        AVATAR: "avatar",
        AVATAR_FRAME: "avatar-frame",
        AVATAR_BIG: "big-avatar",
        AVATAR_BIG_FRAME: "big-avatar-frame",
        // Texts
        WIN: "texts/win",
        LOSE: "texts/lose",
        DRAW: "texts/draw",
        WAITING: "texts/waiting",
        VS: "texts/vs",
        // Icons
        ICON_HOME: "icons/home",
        ICON_INVITE: "icons/invite",
        ICON_CONTINUE: "icons/continue",
        ICON_REPLAY: "icons/replay"
      }
    },
    JOURNEY: {
      KEY: "journey-resources",
      TEXTURE: `./assets/textures/${imageScale}x/journey-resources.png`,
      JSON: `./assets/textures/${imageScale}x/journey-resources.json`,
      TEXTURE_32_BIT: `./assets/textures/${imageScale}x/journey-resources-32bit.png`,
      FRAME: {
        BLANK: "blank",
        GLOW: "glow",
        ICON_BACK: "icon-back",
        ICON_CHECK: "icon-check",
        THEME_FRAME: "frame",
        BORDER_LEFT: "border-left",
        BORDER_RIGHT: "border-right",
        BORDER_MIDDLE: "border-middle",
        ROAD_LEFT: "road-left",
        ROAD_RIGHT: "road-right",
        ROAD_MIDDLE: "road-middle",
        LEVEL_ACTIVE: "level-active",
        LEVEL_INACTIVE: "level-inactive",
        LEVEL_COMPLETED: "level-completed",
        // themes
        THEME_BANGKOK: "themes/bangkok",
        THEME_BARCELONA: "themes/barcelona",
        THEME_DUBAI: "themes/dubai",
        THEME_LAS_VEGAS: "themes/las-vegas",
        THEME_LONDON: "themes/london",
        THEME_NEW_YORK: "themes/newyork",
        THEME_PARIS: "themes/paris",
        THEME_ROME: "themes/rome",
        THEME_SINGAPORE: "themes/singapore",
        THEME_TOKYO: "themes/tokyo",
        THEME_ARGENTINA: "themes/argentina",
        THEME_INDIA: "themes/india",
        THEME_AUSTRALIA: "themes/australia",
        THEME_BRAZIL: "themes/brazil",
        THEME_CANADA: "themes/canada",
        THEME_DENMARK: "themes/denmark",
        THEME_EGYPT: "themes/egypt"
      }
    },
    TOURNAMENTS: {
      KEY: "tournaments-resources",
      TEXTURE: `./assets/textures/${imageScale}x/tournaments-resources.png`,
      JSON: `./assets/textures/${imageScale}x/tournaments-resources.json`,
      TEXTURE_32_BIT: `./assets/textures/${imageScale}x/tournaments-resources-32bit.png`,
      FRAME: {
        BLANK: "blank",
        FRAME: "frame",
        ICON_PEOPLE: "icon-people",
        ICON_RANKING: "icon-ranking",
        ICON_TIME: "icon-time",
        PANEL_CLOCK: "panel-clock",
        PANEL: "panel",
        POPUP: "popup",
        LONG_POPUP_TOP: "long-popup-top",
        LONG_POPUP_BOTTOM: "long-popup-bottom",
        LONG_POPUP_MIDDLE: "long-popup-middle",
        RIBBON: "ribbon",
        ROLL_BAR: "roll-bar",
        RANKING_TEXT: "texts/ranking",
        TOURNAMENT_TEXT: "texts/tournament",
        CUP: "cup",
        X: "x",
        MEDAL_GOLD: "medal-gold",
        MEDAL_SILVER: "medal-silver",
        MEDAL_BRONZE: "medal-bronze",
        RANK_BACKGROUND: "panel-number",
        GLOW: "glow",
        AVATAR_BORDER: "avatar-border",
        CROWN: "crown"
      }
    },
    DAILY_MISSIONS: {
      KEY: "daily-missions-resources",
      TEXTURE: `./assets/textures/${imageScale}x/daily-missions-resources.png`,
      JSON: `./assets/textures/${imageScale}x/daily-missions-resources.json`,
      TEXTURE_32_BIT: `./assets/textures/${imageScale}x/daily-missions-resources-32bit.png`,
      FRAME: {
        BLANK: "blank",
        // Daily Missions
        POPUP_BG: "popup",
        RIBBON: "ribbon",
        BLOCK: "block",
        CLOSE: "close",
        PROGRESS_LEFT: "progress-left",
        PROGRESS_RIGHT: "progress-right",
        PROGRESS_MIDDLE: "progress-middle",
        GREEN_BUTTON: "button-green",
        BLUE_BUTTON: "button-blue",
        PROGRESS_BAR: "progress-border",
        ICON_CHECK: "icon-check",
        COIN: "coin",
        // Progress Icons
        MISSION_HINT: "mission-progress-icon/icon-magnify",
        MISSION_SHUFFLE: "mission-progress-icon/icon-shuffle",
        MISSION_ROCKET: "mission-progress-icon/icon-rocket",
        MISSION_BOMB_DEFUSE: "mission-progress-icon/icon-kiem",
        MISSION_COIN: "mission-progress-icon/icon-coin",
        MISSION_FINISH_LEVEL: "mission-progress-icon/icon-finish",
        MISSION_MATCH_PAIRS: "mission-progress-icon/icon-match-pair",
        MISSION_INVITE_FRIEND: "mission-progress-icon/icon-invite",
        MISSION_SHARE_SCORE: "mission-progress-icon/icon-share",
        MISSION_JOIN_TOURNAMENT: "mission-progress-icon/icon-tournament"
      }
    },
    DASHBOARD: {
      KEY: "dashboard-resources",
      TEXTURE: `./assets/textures/${imageScale}x/dashboard-resources.png`,
      JSON: `./assets/textures/${imageScale}x/dashboard-resources.json`,
      TEXTURE_32_BIT: `./assets/textures/${imageScale}x/dashboard-resources-32bit.png`,
      FRAME: {
        BLANK: "blank",
        TITLE: "title",
        PANEL_ICON: "panel-icon",
        PANEL_NAME: "panel-name",
        COIN_PANEL: "coin-panel",
        // Buttons
        BUTTON_FRAME: "buttons/frame",
        BUTTON_GREEN: "buttons/green",
        // Progress
        BORDER_FULL: "progress/border-full",
        PROGRESS_LEFT: "progress/progress-left",
        PROGRESS_RIGHT: "progress/progress-right",
        PROGRESS_MIDDLE: "progress/progress-middle",
        // Journey
        THEME_FRAME: "journey/frame",
        THEME_BANGKOK: "journey/bangkok",
        THEME_BARCELONA: "journey/barcelona",
        THEME_DUBAI: "journey/dubai",
        THEME_LAS_VEGAS: "journey/las-vegas",
        THEME_LONDON: "journey/london",
        THEME_NEW_YORK: "journey/newyork",
        THEME_PARIS: "journey/paris",
        THEME_ROME: "journey/rome",
        THEME_SINGAPORE: "journey/singapore",
        THEME_TOKYO: "journey/tokyo",
        THEME_ARGENTINA: "journey/argentina",
        THEME_INDIA: "journey/india",
        THEME_AUSTRALIA: "journey/australia",
        THEME_BRAZIL: "journey/brazil",
        THEME_CANADA: "journey/canada",
        THEME_DENMARK: "journey/denmark",
        THEME_EGYPT: "journey/egypt",
        // Icons
        ICON_CUP: "icons/cup",
        ICON_COIN: "icons/coin",
        ICON_SHOP: "icons/shop",
        ICON_FRAME: "icons/frame",
        ICON_REWARDS: "icons/rewards",
        ICON_SETTINGS: "icons/settings",
        ICON_DAILY_SPIN: "icons/daily-spin",
        ICON_DAILY_MISSIONS: "icons/daily-missions",
        ICON_INVITE_FRIENDS: "icons/invite-friends",
        ICON_INFO_DOT: "icons/info-dot",
        // LUCKY WHEEL SCREEN
        LUCKY_WHEEL_ARROW: "lucky-wheel/arrow",
        LUCKY_WHEEL_RIBBON: "lucky-wheel/ribbon",
        LUCKY_WHEEL_BG: "lucky-wheel/wheel",
        LUCKY_WHEEL_KNOB: "lucky-wheel/wheel-middle",
        LUCKY_WHEEL_ICON_COIN: "lucky-wheel/icon-coin",
        LUCKY_WHEEL_ICON_HINT: "lucky-wheel/icon-hint",
        LUCKY_WHEEL_ICON_SHUFFLE: "lucky-wheel/icon-shuffle",
        LUCKY_WHEEL_ICON_ROCKET: "lucky-wheel/icon-rocket",
        LUCKY_WHEEL_ICON_DEFUSE: "lucky-wheel/icon-defuse",
        LUCKY_WHEEL_ICON_BULB_ON: "lucky-wheel/bulb",
        LUCKY_WHEEL_ICON_BULB_OFF: "lucky-wheel/bulb-off"
      }
    },
    TILES: {
      BIRD: {
        KEY: "bird-resources",
        TEXTURE: `./assets/textures/${imageScale}x/bird-resources.png`,
        JSON: `./assets/textures/${imageScale}x/bird-resources.json`,
        FRAME: {
          TILE_PREFIX: "tile-",
          START: 1,
          END: 28
        }
      },
      CAKE: {
        KEY: "cake-resources",
        TEXTURE: `./assets/textures/${imageScale}x/cake-resources.png`,
        JSON: `./assets/textures/${imageScale}x/cake-resources.json`,
        FRAME: {
          TILE_PREFIX: "tile-",
          START: 1,
          END: 28
        }
      },
      FRUIT: {
        KEY: "fruit-resources",
        TEXTURE: `./assets/textures/${imageScale}x/fruit-resources.png`,
        JSON: `./assets/textures/${imageScale}x/fruit-resources.json`,
        FRAME: {
          TILE_PREFIX: "tile-",
          START: 1,
          END: 28
        }
      },
      CANDY: {
        KEY: "candy-resources",
        TEXTURE: `./assets/textures/${imageScale}x/candy-resources.png`,
        JSON: `./assets/textures/${imageScale}x/candy-resources.json`,
        FRAME: {
          TILE_PREFIX: "tile-",
          START: 1,
          END: 28
        }
      },
      FLOWER: {
        KEY: "flower-resources",
        TEXTURE: `./assets/textures/${imageScale}x/flower-resources.png`,
        JSON: `./assets/textures/${imageScale}x/flower-resources.json`,
        FRAME: {
          TILE_PREFIX: "tile-",
          START: 1,
          END: 44
        }
      },
      UMBRELLA: {
        KEY: "umbrella-resources",
        TEXTURE: `./assets/textures/${imageScale}x/umbrella-resources.png`,
        JSON: `./assets/textures/${imageScale}x/umbrella-resources.json`,
        FRAME: {
          TILE_PREFIX: "tile-",
          START: 1,
          END: 30
        }
      },
      FOOD: {
        KEY: "food-resources",
        TEXTURE: `./assets/textures/${imageScale}x/food-resources.png`,
        JSON: `./assets/textures/${imageScale}x/food-resources.json`,
        FRAME: {
          TILE_PREFIX: "tile-",
          START: 1,
          END: 30
        }
      },
      BUTTERFLY: {
        KEY: "butterfly-resources",
        TEXTURE: `./assets/textures/${imageScale}x/butterfly-resources.png`,
        JSON: `./assets/textures/${imageScale}x/butterfly-resources.json`,
        FRAME: {
          TILE_PREFIX: "tile-",
          START: 1,
          END: 30
        }
      }
    }
  };
  var sprites_default = SPRITES;

  // src/utils/ScreenUtils.ts
  init_phaser_custom_min();

  // src/constants/ScreenKeys.ts
  init_phaser_custom_min();
  var ScreenKeys = {
    PAUSE_SCREEN: "PauseScreen",
    NOTIFY_SCREEN: "NotifyScreen",
    RESCUE_SCREEN: "RescueScreen",
    RESULT_SCREEN: "ResultScreen",
    CONTINUE_SCREEN: "ContinueScreen",
    REWARD_ITEM_SCREEN: "RewardItemScreen",
    REWARD_COINS_SCREEN: "RewardCoinsScreen",
    LUCKY_WHEEL_SCREEN: "LuckyWheelScreen",
    TOURNAMENTS_SCREEN: "TournamentsScreen",
    TOURNAMENT_DETAIL_SCREEN: "TournamentDetailScreen",
    RESULT_CHALLENGE_FRIEND_SCREEN: "ResultChallengeFriendScreen",
    DAILY_MISSIONS_SCREEN: "DailyMissionsScreen",
    JOURNEY_SCREEN: "JourneyScreen",
    LOADING_SCREEN: "LoadingScreen"
  };
  var ScreenKeys_default = ScreenKeys;

  // src/utils/ScreenUtils.ts
  var { event } = codex;
  var { Events } = Ludex;
  var ScreenUtils = class _ScreenUtils {
    static screens = {};
    static _instance;
    static get inst() {
      if (!this._instance) {
        this._instance = new _ScreenUtils();
      }
      return this._instance;
    }
    static addScreen(screenName, screen2) {
      this.screens[screenName] = screen2;
    }
    static getScreen(screenName) {
      return this.screens[screenName] || null;
    }
    static openScreen(screenName, screenData) {
      event.emit(Events.OPEN_SCREEN, { screenName, screenData });
    }
    static closeScreen(screenName) {
      event.emit(Events.CLOSE_SCREEN, { screenName });
    }
    static showLoadingScreen(duration) {
      this.openScreen(ScreenKeys_default.LOADING_SCREEN, { duration, message: "Loading...", loading: true });
    }
    static closeLoadingScreen() {
      this.closeScreen(ScreenKeys_default.LOADING_SCREEN);
    }
    static showNotificationScreen(message, duration) {
      this.openScreen(ScreenKeys_default.NOTIFY_SCREEN, { message, duration });
    }
    static closeNotificationScreen() {
      this.closeScreen(ScreenKeys_default.NOTIFY_SCREEN);
    }
    static showLoadingNotificationScreen() {
      this.openScreen(ScreenKeys_default.NOTIFY_SCREEN, {
        message: "Loading",
        enableCloseOnTouch: false
      });
    }
  };
  var ScreenUtils_default = ScreenUtils;

  // src/utils/SceneUtils.ts
  var { event: event2 } = codex;
  var { Events: Events2 } = Ludex;
  var SceneUtils = class _SceneUtils {
    currentScene = null;
    static _instance;
    static get inst() {
      if (!this._instance) {
        this._instance = new _SceneUtils();
      }
      return this._instance;
    }
    static setCurrentScene(sceneName) {
      const scene = window.phaser.scene.getScene(sceneName);
      this.inst.currentScene = scene;
    }
    static getCurrentScene() {
      const { currentScene } = this.inst;
      if (currentScene?.scene.isSleeping()) {
        const scenes = window.phaser.scene.getScenes(true);
        return scenes.find((scene) => !scene.scene.isSleeping()) ?? null;
      }
      return currentScene;
    }
    static switchScene(sceneName, sceneData) {
      event2.emit(Events2.SWITCH_SCENE, { sceneName, sceneData });
    }
    static async switchToDashboardScene(sceneData) {
      try {
        ScreenUtils_default.showLoadingScreen();
        await this.waitForDashboardSceneAssetsLoading();
        this.switchScene(SceneKeys_default.DASHBOARD_SCENE, sceneData);
      } catch (error) {
        console.warn("Error switching to dashboard scene:", error);
      } finally {
        ScreenUtils_default.closeLoadingScreen();
      }
    }
    static async switchToGameScene(sceneData) {
      const { score = 0 } = sceneData ?? {};
      this.switchScene(SceneKeys_default.GAME_SCENE, { score });
    }
    static switchToResultMatchScene(sceneData) {
      this.switchScene(SceneKeys_default.RESULT_MATCH_SCENE, sceneData);
    }
    static getMissingDashboardSceneTextures() {
      const { textures } = window.phaser;
      const missingTextures = [];
      const isDashboardReady = textures.exists(sprites_default.DASHBOARD.KEY);
      const isChallengeReady = textures.exists(sprites_default.CHALLENGE.KEY);
      const isDailyMissionsReady = textures.exists(sprites_default.DAILY_MISSIONS.KEY);
      const isJourneyReady = textures.exists(sprites_default.JOURNEY.KEY);
      const isTournamentsReady = textures.exists(sprites_default.TOURNAMENTS.KEY);
      if (!isDashboardReady)
        missingTextures.push({
          key: sprites_default.DASHBOARD.KEY,
          textureURL: sprites_default.DASHBOARD.TEXTURE,
          atlasURL: sprites_default.DASHBOARD.JSON
        });
      if (!isChallengeReady)
        missingTextures.push({
          key: sprites_default.CHALLENGE.KEY,
          textureURL: sprites_default.CHALLENGE.TEXTURE,
          atlasURL: sprites_default.CHALLENGE.JSON
        });
      if (!isDailyMissionsReady)
        missingTextures.push({
          key: sprites_default.DAILY_MISSIONS.KEY,
          textureURL: sprites_default.DAILY_MISSIONS.TEXTURE,
          atlasURL: sprites_default.DAILY_MISSIONS.JSON
        });
      if (!isJourneyReady)
        missingTextures.push({
          key: sprites_default.JOURNEY.KEY,
          textureURL: sprites_default.JOURNEY.TEXTURE,
          atlasURL: sprites_default.JOURNEY.JSON
        });
      if (!isTournamentsReady)
        missingTextures.push({
          key: sprites_default.TOURNAMENTS.KEY,
          textureURL: sprites_default.TOURNAMENTS.TEXTURE,
          atlasURL: sprites_default.TOURNAMENTS.JSON
        });
      return missingTextures;
    }
    static async waitForDashboardSceneAssetsLoading() {
      const missingTextures = this.getMissingDashboardSceneTextures();
      const completedLoadPromises = [];
      const activeScene = this.getCurrentScene();
      if (!activeScene) return Promise.all([]);
      const { FILE_KEY_COMPLETE } = Phaser.Loader.Events;
      for (const texture of missingTextures) {
        completedLoadPromises.push(
          new Promise((resolve) => {
            activeScene.load.once(`${FILE_KEY_COMPLETE}atlasjson-${texture.key}`, () => {
              resolve();
            });
            activeScene.load.atlas({
              key: texture.key,
              textureURL: texture.textureURL,
              atlasURL: texture.atlasURL
            });
          })
        );
      }
      activeScene.load.start();
      return Promise.all(completedLoadPromises);
    }
    static getGlobalScene() {
      return window.phaser.scene.getScene(SceneKeys_default.GLOBAL_SCENE);
    }
  };
  var SceneUtils_default = SceneUtils;

  // src/game/components/audio/AudioChannel.ts
  init_phaser_custom_min();

  // src/game/constants/resources/sounds.ts
  init_phaser_custom_min();
  var SOUNDS = {
    BACKGROUND: {
      KEY: "background_music",
      PREFIX: "./assets/music/bg_music_"
    },
    DASHBOARD: {
      KEY: "dashboard_music",
      FILE: "./assets/music/dashboard_music.mp3"
    },
    NEW_EFFECTS: {
      bomb_explode_1: "./assets/sounds/bomb_explode_1.mp3",
      ticking_bomb_before_explode: "./assets/sounds/ticking_bomb_before_explode.mp3",
      bomb_defuse: "./assets/sounds/bomb_defuse.mp3",
      close_popup_click: "./assets/sounds/close_popup_click.mp3",
      use_item_click: "./assets/sounds/use_item_click.mp3",
      shuffle_item: "./assets/sounds/shuffle_item.mp3",
      hint_item: "./assets/sounds/hint_item.mp3",
      clicks: "./assets/sounds/clicks.mp3",
      combo_1: "./assets/sounds/combo_1.mp3",
      combo_2: "./assets/sounds/combo_2.mp3",
      combo_3: "./assets/sounds/combo_3.mp3",
      combo_4: "./assets/sounds/combo_4.mp3",
      combo_5: "./assets/sounds/combo_5.mp3",
      invalid_match: "./assets/sounds/invalid_match.mp3",
      level_start: "./assets/sounds/level_start.mp3",
      level_complete: "./assets/sounds/level_complete.mp3",
      level_fail: "./assets/sounds/level_fail.mp3",
      rescue_timer: "./assets/sounds/rescue_timer.mp3",
      extra_tile_spawn: "./assets/sounds/extra_tile_spawn.mp3",
      tile_select: "./assets/sounds/tile_select.mp3",
      rocket_fly: "./assets/sounds/rocket_fly.mp3",
      collect_stars: "./assets/sounds/collect_stars.mp3",
      three_stars: "./assets/sounds/three_stars.mp3",
      progress_star: "./assets/sounds/progress_star.mp3",
      gift_charge: "./assets/sounds/gift_charge.mp3",
      gift_explode: "./assets/sounds/gift_explode.mp3",
      gift_reveal: "./assets/sounds/gift_reveal.mp3",
      daily_reward: "./assets/sounds/daily_reward.mp3",
      // lucky wheel
      wheel_click: "./assets/sounds/reward_click.mp3",
      wheel_get_common: "./assets/sounds/reward_get_common.mp3",
      wheel_get_special: "./assets/sounds/reward_get_special.mp3"
    }
  };
  var sounds_default = SOUNDS;

  // src/game/components/audio/AudioPlayer.ts
  init_phaser_custom_min();
  var {
    Plugins: {
      Audio: { BaseAudioPlayer }
    }
  } = Ludex;
  var AudioPlayer = class extends BaseAudioPlayer {
    audioSource;
    constructor(key, audioSource) {
      super(key);
      this.audioSource = audioSource;
    }
    play(config) {
      if (config) {
        const { volume = 1, loop = false } = config;
        this.audioSource.volume = volume;
        this.audioSource.loop = loop;
      }
      this.audioSource.play();
    }
    pause() {
      this.audioSource.pause();
    }
    resume() {
      if (this.audioSource.isPaused) {
        this.audioSource.play();
      }
    }
    stop() {
      this.audioSource.stop();
    }
    setVolume(volume) {
      this.audioSource.volume = volume;
    }
    getVolume() {
      return this.audioSource.volume;
    }
    getAudioSource() {
      return this.audioSource;
    }
  };
  var AudioPlayer_default = AudioPlayer;

  // src/game/components/audio/AudioChannel.ts
  var {
    Plugins: {
      Audio: { BaseChannelManager }
    },
    Utils: { Array: A }
  } = Ludex;
  var AudioChannel = class extends BaseChannelManager {
    game;
    players;
    constructor(game, channelId) {
      super(channelId);
      this.game = game;
      this.players = {};
    }
    playing(key) {
      const players = this.players[key];
      if (!players) return false;
      for (const player33 of players) {
        if (player33.getAudioSource().isPlaying) return true;
      }
      return false;
    }
    async onLoadAudio(key, config) {
      try {
        if (!this.isCached(key)) {
          await this.loadAudio(key);
        }
        const player33 = this.getPlayer(key, config?.allowMultiple);
        return player33;
      } catch (error) {
        console.warn("onLoadAudio", error);
        return null;
      }
    }
    playWithRealConfig(audioPlayer, config) {
      if (config && !this.isPlayable(config.checkList)) return;
      const volume = this.getVolume() * (config?.volume ?? 1);
      audioPlayer.play({ ...config, volume });
    }
    loadAudio(key) {
      let path;
      if (key === sounds_default.BACKGROUND.KEY) {
        path = AudioUtils_default.getMusicPath();
      }
      if (!path) {
        path = sounds_default.NEW_EFFECTS[key] ?? void 0;
      }
      if (!path) return;
      return new Promise((resolve, reject) => {
        const scene = SceneUtils_default.getCurrentScene();
        if (!scene) {
          reject(new Error("No scene found"));
          return;
        }
        scene.load.audio(key, path);
        scene.load.on(`${Phaser.Loader.Events.FILE_KEY_COMPLETE}audio-${key}`, resolve);
        scene.load.start();
      });
    }
    isPlayable(checkList = []) {
      if (checkList.length === 0) return true;
      const playingKeys = Object.keys(this.players);
      for (const key of playingKeys) {
        if (!A.has(checkList, key)) continue;
        const players = this.players[key];
        for (const player33 of players) {
          if (player33.getAudioSource().isPlaying) return false;
        }
      }
      return true;
    }
    isCached(key) {
      const player33 = this.players[key];
      return player33 && player33.length > 0 || this.game.cache.audio.exists(key);
    }
    getPlayer(key, createDuplicateIfAllArePlaying = false) {
      const players = this.players[key];
      if (!players || players.length === 0) return this.createPlayer(key);
      if (!createDuplicateIfAllArePlaying) {
        return players[0];
      }
      for (const player34 of players) {
        if (!player34.getAudioSource().isPlaying) {
          return player34;
        }
      }
      const postfix = `-${players.length}`;
      const player33 = this.createPlayer(key, postfix);
      return player33;
    }
    createPlayer(key, postfix = "") {
      const source = this.game.sound.add(key);
      const player33 = new AudioPlayer_default(`${key}${postfix}`, source);
      const players = this.players[key] ?? [];
      players.push(player33);
      this.players[key] = players;
      return player33;
    }
  };

  // src/game/components/audio/AudioManager.ts
  var { audio } = codex;
  var AudioManager = class _AudioManager {
    static _instance;
    channels = {};
    static get inst() {
      if (!this._instance) {
        this._instance = new _AudioManager();
      }
      return this._instance;
    }
    static playing(key) {
      try {
        return this.inst.playing(key);
      } catch (error) {
        console.warn("Error checking if audio is playing:", error);
        return false;
      }
    }
    static async play(key, config) {
      try {
        return await this.inst.play(key, config);
      } catch (error) {
        console.warn("Error playing audio:", error);
      }
    }
    static pause(key) {
      try {
        this.inst.pause(key);
      } catch (error) {
        console.warn("Error pausing audio:", error);
      }
    }
    static resume(key) {
      try {
        this.inst.resume(key);
      } catch (error) {
        console.warn("Error resuming audio:", error);
      }
    }
    static stop(key) {
      try {
        this.inst.stop(key);
      } catch (error) {
        console.warn("Error stopping audio:", error);
      }
    }
    static stopAll() {
      try {
        this.inst.stopAll();
      } catch (error) {
        console.warn("Error stopping all audio:", error);
      }
    }
    static mute() {
      try {
        this.inst.mute();
      } catch (error) {
        console.warn("Error muting audio:", error);
      }
    }
    static unmute() {
      try {
        this.inst.unmute();
      } catch (error) {
        console.warn("Error unmuting audio:", error);
      }
    }
    static setVolume(volume) {
      try {
        this.inst.setVolume(volume);
      } catch (error) {
        console.warn("Error setting audio volume:", error);
      }
    }
    static getVolume() {
      try {
        return this.inst.getVolume();
      } catch (error) {
        console.warn("Error getting audio volume:", error);
        return 0;
      }
    }
    getCurrentChannel() {
      const scene = SceneUtils_default.getCurrentScene();
      const key = scene?.scene.key ?? void 0;
      if (key === void 0) {
        throw new Error("AudioManager.getCurrentChannelId: No scene found");
      }
      if (this.channels[key]) {
        return this.channels[key];
      }
      const channel = new AudioChannel(window.phaser, key);
      audio.addChannel(channel);
      this.channels[key] = channel;
      return channel;
    }
    playing(key) {
      const channel = this.getCurrentChannel();
      return channel.playing(key);
    }
    play(key, config) {
      const id2 = this.getCurrentChannel().getId();
      return audio.play(key, config, id2);
    }
    pause(key) {
      const id2 = this.getCurrentChannel().getId();
      audio.pause(key, id2);
    }
    resume(key) {
      const id2 = this.getCurrentChannel().getId();
      audio.resume(key, id2);
    }
    stop(key) {
      const id2 = this.getCurrentChannel().getId();
      audio.stop(key, id2);
    }
    stopAll() {
      const id2 = this.getCurrentChannel().getId();
      audio.stopAll(id2);
    }
    mute() {
      const id2 = this.getCurrentChannel().getId();
      audio.mute(id2);
    }
    unmute() {
      const id2 = this.getCurrentChannel().getId();
      audio.unmute(id2);
    }
    setVolume(volume) {
      const id2 = this.getCurrentChannel().getId();
      audio.setVolume(volume, id2);
    }
    getVolume() {
      const id2 = this.getCurrentChannel().getId();
      return audio.getVolume(id2);
    }
  };

  // src/game/components/audio/MusicManager.ts
  init_phaser_custom_min();
  var MusicManager = class _MusicManager {
    musicChannel;
    static get inst() {
      if (!this._instance) {
        this._instance = new _MusicManager();
      }
      return this._instance;
    }
    constructor() {
      this.musicChannel = new AudioChannel(window.phaser, "music");
      const { audio: audio2 } = codex;
      audio2.addChannel(this.musicChannel);
    }
    static playing(key) {
      try {
        return this.inst.playing(key);
      } catch (error) {
        console.warn("Error checking if audio is playing:", error);
        return false;
      }
    }
    static async play(key, config) {
      try {
        return await this.inst.play(key, config);
      } catch (error) {
        console.warn("Error playing audio:", error);
      }
    }
    static pause(key) {
      try {
        this.inst.pause(key);
      } catch (error) {
        console.warn("Error pausing audio:", error);
      }
    }
    static resume(key) {
      try {
        this.inst.resume(key);
      } catch (error) {
        console.warn("Error resuming audio:", error);
      }
    }
    static stop(key) {
      try {
        this.inst.stop(key);
      } catch (error) {
        console.warn("Error stopping audio:", error);
      }
    }
    static stopAll() {
      try {
        this.inst.stopAll();
      } catch (error) {
        console.warn("Error stopping all audio:", error);
      }
    }
    static mute() {
      try {
        this.inst.mute();
      } catch (error) {
        console.warn("Error muting audio:", error);
      }
    }
    static unmute() {
      try {
        this.inst.unmute();
      } catch (error) {
        console.warn("Error unmuting audio:", error);
      }
    }
    static setVolume(volume) {
      try {
        this.inst.setVolume(volume);
      } catch (error) {
        console.warn("Error setting audio volume:", error);
      }
    }
    static getVolume() {
      try {
        return this.inst.getVolume();
      } catch (error) {
        console.warn("Error getting audio volume:", error);
        return 0;
      }
    }
    getCurrentChannel() {
      return this.musicChannel;
    }
    playing(key) {
      return this.musicChannel.playing(key);
    }
    play(key, config) {
      const { audio: audio2 } = codex;
      return audio2.play(key, config, "music");
    }
    pause(key) {
      const { audio: audio2 } = codex;
      audio2.pause(key, "music");
    }
    resume(key) {
      const { audio: audio2 } = codex;
      audio2.resume(key, "music");
    }
    stop(key) {
      const { audio: audio2 } = codex;
      audio2.stop(key, "music");
    }
    stopAll() {
      const { audio: audio2 } = codex;
      audio2.stopAll("music");
    }
    mute() {
      const { audio: audio2 } = codex;
      audio2.mute("music");
    }
    unmute() {
      const { audio: audio2 } = codex;
      audio2.unmute("music");
    }
    setVolume(volume) {
      const { audio: audio2 } = codex;
      audio2.setVolume(volume, "music");
    }
    getVolume() {
      const { audio: audio2 } = codex;
      return audio2.getVolume("music");
    }
  };
  var MusicManager_default = MusicManager;

  // src/utils/AudioUtils.ts
  var { player } = codex;
  var { Music } = GameSettings_default.Sound;
  var AudioUtils = class _AudioUtils {
    static _instance;
    static musicKey;
    static volumeTween;
    static get inst() {
      if (!this._instance) {
        this._instance = new _AudioUtils();
        this.initializeRandomMusicKey();
        this.setDefaultVolumeMusic();
      }
      return this._instance;
    }
    static initializeRandomMusicKey() {
      if (this.musicKey) return;
      const randomKey = Phaser.Math.Between(1, 3);
      this.musicKey = `${sounds_default.BACKGROUND.PREFIX}${randomKey}.mp3`;
    }
    get sound() {
      return AudioManager;
    }
    get music() {
      return MusicManager_default;
    }
    static muteAudio(isMute) {
      this.muteMusic(isMute);
      this.muteSound(isMute);
    }
    static async playSound(name, options) {
      if (!this.inst.sound) return;
      const enabled = player.getPlayerSetting("sound") ?? true;
      if (!enabled) return;
      return this.inst.sound.play(name, options);
    }
    static pauseSound(name) {
      if (!this.inst.sound) return;
      this.inst.sound.pause(name);
    }
    static resumeSound(name) {
      if (!this.inst.sound) return;
      this.inst.sound.resume(name);
    }
    static stopSound(name) {
      if (!this.inst.sound) return;
      this.inst.sound.stop(name);
    }
    static stopAllSounds() {
      if (!this.inst.sound) return;
      this.inst.sound.stopAll();
    }
    static muteSound(isMute) {
      if (!this.inst.sound) return;
      if (isMute) {
        this.inst.sound.mute();
      } else {
        this.inst.sound.unmute();
      }
    }
    static getMusicKey() {
      return sounds_default.BACKGROUND.KEY;
    }
    static getMusicPath() {
      if (!this.musicKey) {
        this.initializeRandomMusicKey();
      }
      return this.musicKey;
    }
    static getAllMusicKeys() {
      return [sounds_default.BACKGROUND.KEY, sounds_default.DASHBOARD.KEY];
    }
    static playMusic(forceMusicKey, forceRestart = false) {
      if (!this.inst.music) return;
      const enabled = player.getPlayerSetting("music") ?? true;
      if (!enabled) return;
      const musicKey = forceMusicKey ?? this.getMusicKey();
      if (!musicKey) return;
      const isPlaying = this.inst.music.playing(musicKey);
      if (!forceRestart && isPlaying) return;
      this.stopOtherMusic(musicKey);
      this.inst.music.play(musicKey, { loop: true });
    }
    static stopOtherMusic(musicKey) {
      if (!this.inst.music) return;
      for (const key of this.getAllMusicKeys()) {
        if (key === musicKey) continue;
        this.inst.music.stop(key);
      }
    }
    static pauseMusic() {
      if (!this.inst.music) return;
      const musicKey = this.getMusicKey();
      if (!musicKey) {
        for (const key of this.getAllMusicKeys()) {
          this.inst.music.pause(key);
        }
      } else {
        this.inst.music.pause(musicKey);
      }
    }
    static muteMusic(isMute) {
      if (!this.inst.music) return;
      if (isMute) {
        this.inst.music.mute();
      } else {
        this.inst.music.unmute();
      }
    }
    static async turnOffMusic() {
      await this.setVolumeMusic(0);
    }
    static getVolumeMusic() {
      return this.inst.music?.getVolume() ?? 0;
    }
    static async setVolumeMusic(volume, withTrans = false) {
      if (!this.inst.music) return;
      if (this.volumeTween?.isPlaying()) {
        this.volumeTween?.stop();
      }
      const currentVolume = this.inst.music.getVolume();
      if (currentVolume === volume) return;
      if (!withTrans) {
        this.inst.music?.setVolume(volume);
        return;
      }
      const scene = SceneUtils_default.getGlobalScene();
      if (!scene) {
        this.inst.music.setVolume(volume);
        return;
      }
      const volumeTween = scene.tweens.addCounter({
        from: 1,
        to: 1e3,
        duration: 1e3,
        ease: Phaser.Math.Easing.Sine.Out,
        onUpdate: (tween) => {
          const newVolume = (volume - currentVolume) * tween.getValue() / 1e3;
          this.inst.music.setVolume(currentVolume + newVolume);
        },
        onComplete: () => {
          this.inst.music.setVolume(volume);
        }
      });
      this.volumeTween = volumeTween;
      volumeTween.play();
    }
    static setDefaultVolumeMusic() {
      this.setVolumeMusic(Music.DefaultVolume, true);
    }
    static setMinVolumeMusic() {
      this.setVolumeMusic(Music.MinVolume, true);
    }
  };
  var AudioUtils_default = AudioUtils;

  // src/utils/WorldUtils.ts
  init_phaser_custom_min();
  var { event: event3 } = codex;
  var {
    Utils: { Browser: B2, Function: F, Device: D2 }
  } = Ludex;
  var {
    AcceptPortraitRatio,
    DesignSize: { Portrait, Landscape, Resolution, DesignScale },
    FULL_PORTRAIT_SIZE,
    FULL_LANDSCAPE_SIZE
  } = GameWorld_default;
  var WorldUtils = class _WorldUtils {
    game;
    static _instance;
    layoutMode;
    static get inst() {
      if (!this._instance) {
        this._instance = new _WorldUtils();
      }
      return this._instance;
    }
    static init(game) {
      this.inst.game = game;
      game.canvas.id = "GameCanvas";
      this.inst.listenEvents();
      event3.emit(GameEvents_default.REQUEST_VIEW_RESIZE);
    }
    listenEvents() {
      const observer = new ResizeObserver(this.handleBodyResize);
      observer.observe(window.document.body);
      event3.on(GameEvents_default.REQUEST_VIEW_RESIZE, this.resizeGame);
    }
    handleBodyResize = F.debounce(() => {
      this.resizeGame();
    }, 300);
    resizeGame = (_payload) => {
      const { width: worldWidth, height: worldHeight } = _WorldUtils.getWorldSize();
      const { width: canvasWidth, height: canvasHeight } = _WorldUtils.getCanvasSize();
      const worldScale = _WorldUtils.getWorldScale();
      this.game.scale.resize(canvasWidth, canvasHeight);
      this.game.scale.setZoom(worldScale);
      const newLayoutMode = _WorldUtils.isLandscape() ? "landscape" : "portrait";
      const isLayoutNotChanged = !this.layoutMode || this.layoutMode === newLayoutMode;
      const correctEvent = isLayoutNotChanged ? GameEvents_default.VIEW_RESIZED : GameEvents_default.
      LAYOUT_CHANGED;
      event3.emit(correctEvent, { width: worldWidth, height: worldHeight });
      this.layoutMode = newLayoutMode;
    };
    static dump() {
      console.warn("--------------------------------");
      const dpr = this.getPixelRatio();
      const zoomRatio = this.getZoomRatio();
      const worldScale = this.getWorldScale();
      const isFullPortrait = this.isFullPortrait();
      const isFullLandscape = this.isFullLandscape();
      const { width: worldWidth, height: worldHeight } = this.getWorldSize();
      const { width: designWidth, height: designHeight } = this.getDesignSize();
      const { width: screenWidth, height: screenHeight } = this.getScreenSize();
      const { width: canvasWidth, height: canvasHeight } = this.getCanvasSize();
      console.warn("dpr", dpr);
      console.warn("zoomRatio", zoomRatio);
      console.warn("worldScale", worldScale);
      console.warn("isFullPortrait", isFullPortrait);
      console.warn("isFullLandscape", isFullLandscape);
      console.warn("worldSize", worldWidth, worldHeight);
      console.warn("designSize", designWidth, designHeight);
      console.warn("screenSize", screenWidth, screenHeight);
      console.warn("canvasSize", canvasWidth, canvasHeight);
      console.warn("--------------------------------");
    }
    static isLandscape() {
      return this.getScreenRatio() > AcceptPortraitRatio;
    }
    static isFullPortrait() {
      const isLandscape = this.isLandscape();
      return !isLandscape && FULL_PORTRAIT_SIZE;
    }
    static isFullLandscape() {
      const isLandscape = this.isLandscape();
      return isLandscape && FULL_LANDSCAPE_SIZE;
    }
    static getZoomRatio() {
      const { width: canvasWidth } = this.getCanvasSize();
      const { width: worldWidth } = this.getWorldSize();
      return canvasWidth / worldWidth;
    }
    static getWorldScale() {
      const { width: canvasWidth, height: canvasHeight } = this.getCanvasSize();
      const { width: screenWidth, height: screenHeight } = this.getScreenSize();
      const scaleX = (screenWidth / canvasWidth).toFixed(3);
      const scaleY = (screenHeight / canvasHeight).toFixed(3);
      return Math.min(+scaleX, +scaleY);
    }
    static getDesignSize() {
      let width = Portrait.WIDTH;
      let height = Portrait.HEIGHT;
      if (this.isLandscape()) {
        width = Landscape.WIDTH;
        height = Landscape.HEIGHT;
      }
      const designScale = this.isLandscape() ? DesignScale.Landscape : DesignScale.Portrait;
      const designWidth = width / Resolution * designScale;
      const designHeight = height / Resolution * designScale;
      return { width: designWidth, height: designHeight };
    }
    static getWorldSize() {
      if (!this.isLandscape()) {
        return this.getWorldSizePortrait();
      }
      return this.getWorldSizeLandscape();
    }
    static getWorldSizePortrait() {
      const { width: designWidth, height: designHeight } = this.getDesignSize();
      const worldWidth = designWidth;
      let worldHeight = designHeight;
      const designRatio = this.getDesignRatio();
      const screenRatio = this.getScreenRatio();
      if (screenRatio > designRatio || this.isFullPortrait()) {
        worldHeight = worldWidth / screenRatio;
      }
      return { width: worldWidth, height: worldHeight };
    }
    static getWorldSizeLandscape() {
      const { width: designWidth, height: designHeight } = this.getDesignSize();
      const { width: screenWidth, height: screenHeight } = this.getScreenSize();
      let worldWidth = designWidth;
      let worldHeight = designHeight;
      const dpr = this.getPixelRatio();
      if (!this.isFullLandscape()) {
        return { width: worldWidth, height: worldHeight };
      }
      const { width: canvasWidth } = this.calculateCanvasSizeForFullLandscape();
      const zoomRatio = canvasWidth / worldWidth;
      worldWidth = screenWidth * dpr / zoomRatio;
      worldHeight = screenHeight * dpr / zoomRatio;
      const currentRatio = worldWidth / worldHeight;
      if (worldHeight < designHeight) {
        worldHeight = designHeight;
        worldWidth = designHeight * currentRatio;
      }
      return { width: worldWidth, height: worldHeight };
    }
    static calculateCanvasSizeForFullLandscape() {
      const { width: screenWidth, height: screenHeight } = this.getScreenSize();
      const dpr = this.getPixelRatio();
      let canvasWidth = screenWidth * dpr;
      let canvasHeight = screenHeight * dpr;
      const designRatio = this.getDesignRatio();
      const screenRatio = this.getScreenRatio();
      if (screenRatio > designRatio) {
        canvasHeight = canvasWidth / screenRatio;
      } else {
        canvasWidth = canvasHeight * screenRatio;
      }
      return { width: canvasWidth, height: canvasHeight };
    }
    static getScreenSize() {
      const width = B2.getScreenWidth();
      const height = B2.getScreenHeight();
      return { width, height };
    }
    static getCanvasSize() {
      const { width: screenWidth, height: screenHeight } = this.getScreenSize();
      const dpr = this.getPixelRatio();
      let canvasWidth = screenWidth * dpr;
      let canvasHeight = screenHeight * dpr;
      if (this.isFullLandscape() || this.isFullPortrait()) {
        return { width: canvasWidth, height: canvasHeight };
      }
      const { width: worldWidth, height: worldHeight } = this.getWorldSize();
      const rateX = screenWidth / worldWidth;
      const rateY = screenHeight / worldHeight;
      const rate = Math.min(rateX, rateY);
      canvasWidth = worldWidth * rate * dpr;
      canvasHeight = worldHeight * rate * dpr;
      return { width: canvasWidth, height: canvasHeight };
    }
    static getPixelRatio() {
      return Math.min(D2.pixelRatio(), Resolution);
    }
    static toPixelSize(displaySize) {
      const dpr = this.getPixelRatio();
      return Math.round(displaySize * dpr);
    }
    static toDisplaySize(pixelSize) {
      const dpr = this.getPixelRatio();
      return Math.round(pixelSize / dpr);
    }
    static getDesignRatio() {
      const { width: designWidth, height: designHeight } = this.getDesignSize();
      return designWidth / designHeight;
    }
    static getScreenRatio() {
      const { width: screenWidth, height: screenHeight } = this.getScreenSize();
      return screenWidth / screenHeight;
    }
  };
  var WorldUtils_default = WorldUtils;

  // src/utils/AdsUtils.ts
  var {
    Configs: {
      Ads: {
        Enabled,
        InterstitialAdOptions,
        RewardedVideoAdOptions,
        RewardedInterstitialAdOptions,
        BannerDisplayAdOptions
      },
      Gameplay: { StartAdAtLevel }
    },
    Plugins: {
      Ads: { Types: AdsTypes, Status: AdStatus }
    },
    Utils: { Array: A2, Function: F2, Time: T }
  } = Ludex;
  var { ads } = codex;
  var Ads = {
    MAX_BOTTOM_BANNER_RATIO: 1 / 6
  };
  var AdsUtils = class _AdsUtils {
    static _instance;
    isAvoidBannerShowed = false;
    static get inst() {
      if (!this._instance) {
        this._instance = new _AdsUtils();
      }
      return this._instance;
    }
    static async preloadAds() {
      this.preloadAdsByType(AdsTypes.INTERSTITIAL);
      this.preloadAdsByType(AdsTypes.REWARDED_VIDEO);
      this.preloadAdsByType(AdsTypes.REWARDED_INTERSTITIAL);
    }
    static isServiceDegraded() {
      return ads.isServiceDegraded();
    }
    // * This will preload all ads by type, including ad services
    static preloadAdsByType(type, placementId) {
      if (!Enabled) return;
      const adsList = ads.getAdsByType(type);
      for (const ad2 of adsList) {
        if (placementId && ad2.placementId !== placementId) continue;
        const isAdReady = ad2.instance.status === AdStatus.FILLED;
        if (isAdReady) continue;
        ads.loadAdAsync(type, ad2.placementId).catch(() => {
        });
      }
    }
    static setAvoidBannerShowed(enable) {
      this.inst.isAvoidBannerShowed = enable;
    }
    static showBannerAds() {
      if (!Enabled) return;
      if (this.inst.isAvoidBannerShowed) return;
      for (const { PlacementId, Position, BannerHeight } of BannerDisplayAdOptions) {
        if (Position === "bottom") {
          const { height } = WorldUtils_default.getWorldSize();
          const bannerRemainSizeCss = WorldUtils_default.toPixelSize(height * Ads.MAX_BOTTOM_BANNER_RATIO);
          if (BannerHeight > bannerRemainSizeCss) {
            ads.hideBannerAdAsync(PlacementId).catch((_) => {
            });
            continue;
          }
        }
        ads.showBannerAdAsync(PlacementId).catch((error) => {
          console.warn("showBannerAdAsync", error);
        });
      }
    }
    static hideBannerAds() {
      if (!Enabled) return;
      const adsList = ads.getAdsByType(AdsTypes.BANNER);
      adsList.forEach((ad2) => {
        if (ad2.instance.status === AdStatus.IDLE) return;
        this.hideBannerAd(ad2.placementId);
      });
    }
    static showBannerAd(placementId) {
      if (this.inst.isAvoidBannerShowed) return;
      ads.showBannerAdAsync(placementId).catch((_) => {
      });
    }
    static hideBannerAd(placementId) {
      ads.hideBannerAdAsync(placementId).catch((_) => {
      });
    }
    static getBannerHeight() {
      if (!Enabled) return 0;
      const bannerOptions = BannerDisplayAdOptions.find(({ Position }) => Position === "bottom");
      return ads.getBannerHeight(bannerOptions?.PlacementId || "", 1, true) || 0;
    }
    getAdReady(type, placementId) {
      if (!Enabled) return null;
      if (placementId) {
        const adsStatus = ads.getAdStatus(type, placementId);
        if (adsStatus === AdStatus.FILLED) return placementId;
      } else {
        const adsList = ads.getAdsByType(type);
        for (const ad2 of adsList) {
          const adsStatus = ad2.instance.status;
          if (adsStatus === AdStatus.FILLED) return ad2.placementId;
        }
      }
      return null;
    }
    getPlacementIdByService(type, service) {
      if (!service) return false;
      switch (type) {
        case AdsTypes.BANNER:
          return A2.search(BannerDisplayAdOptions, (ad2) => ad2.AdService === service)?.PlacementId ||
          false;
        case AdsTypes.INTERSTITIAL:
          return A2.search(InterstitialAdOptions, (ad2) => ad2.AdService === service)?.PlacementId ||
          false;
        case AdsTypes.REWARDED_VIDEO:
          return A2.search(RewardedVideoAdOptions, (ad2) => ad2.AdService === service)?.PlacementId ||
          false;
        case AdsTypes.REWARDED_INTERSTITIAL:
          return A2.search(RewardedInterstitialAdOptions, (ad2) => ad2.AdService === service)?.PlacementId ||
          false;
        default:
          return false;
      }
    }
    getAdIdByPayload(type, payload) {
      const { adService, placementId } = payload || {};
      return this.getPlacementIdByService(type, adService) || placementId;
    }
    // * Utility-specific logic. For advanced ad handling, refer to the Ads plugin.
    static isReadyAdShowable(type, placementId) {
      const adId = this.inst.getAdReady(type, placementId);
      if (!adId) return false;
      return ads.canShowAd(type, adId);
    }
    getAdErrorMessage(type, error) {
      switch (type) {
        case AdsTypes.REWARDED_VIDEO:
        case AdsTypes.REWARDED_INTERSTITIAL:
          if (!this.isUserCancelledAdError(error)) {
            return "No ads to display.";
          }
          return "Sorry, no rewards!\n You have cancelled the ad.";
        default:
          return null;
      }
    }
    async showAdWithType(type, payload) {
      const { placementId, includeSDK, excludeSDK, forceLoad, adService } = payload || {};
      if (!this.canbeShowInSDK(includeSDK, excludeSDK)) return false;
      let adId = this.getAdIdByPayload(type, payload);
      let isSuccess = false;
      let isHasShowFailed = false;
      try {
        AudioUtils_default.muteAudio(true);
        if (forceLoad) {
          ScreenUtils_default.showLoadingScreen();
          const [loadResult] = await F2.allSettled([ads.loadAdAsync(type, adId), T.sleepAsync(500)]);
          if (loadResult?.status === "rejected") {
            throw loadResult.reason;
          }
        }
        while (!isSuccess) {
          try {
            const adIdReady = this.getAdReady(type, adId);
            if (!adIdReady) return false;
            adId = adIdReady;
            await ads.showAdAsync(type, adId);
            isSuccess = true;
          } catch (error) {
            if (adService) throw error;
            if (this.isUserCancelledAdError(error)) throw error;
            if (this.isRequestAdTimeoutError(error)) throw error;
            adId = void 0;
            isSuccess = false;
            isHasShowFailed = true;
          }
        }
        return true;
      } catch (error) {
        isHasShowFailed = true;
        const errorMessage = this.getAdErrorMessage(type, error);
        if (errorMessage) {
          ScreenUtils_default.showNotificationScreen(errorMessage, 2e3);
        }
        return false;
      } finally {
        AudioUtils_default.muteAudio(false);
        if (forceLoad) {
          ScreenUtils_default.closeLoadingScreen();
        }
        if (isHasShowFailed) {
          adId = placementId;
        }
        _AdsUtils.preloadAdsByType(type, adId);
      }
    }
    static async showInterstitialAdAsync(payload) {
      const { forLevel, contextType, forceLoad } = payload || {};
      if (forLevel && StartAdAtLevel >= forLevel) return false;
      if (contextType) {
        window.GoogleAds?.setInterstitialType(contextType);
        window.TranssionH5Ads?.setInterstitialType(contextType);
      }
      let correctForceLoad = forceLoad;
      if (GameSDK.getSDKName() === "MsGames") {
        correctForceLoad = true;
      }
      return this.inst.showAdWithType(AdsTypes.INTERSTITIAL, { ...payload, forceLoad: correctForceLoad });
    }
    static async showRewardVideoAdAsync(payload) {
      const { contextType } = payload || {};
      if (contextType) {
        window.GoogleAds?.setRewardType(contextType);
        window.TranssionH5Ads?.setRewardType(contextType);
      }
      return this.inst.showAdWithType(AdsTypes.REWARDED_VIDEO, { ...payload, forceLoad: true });
    }
    static async showRewardedInterstitialAdAsync(payload) {
      const { contextType } = payload || {};
      if (contextType) {
        window.GoogleAds?.setRewardType(contextType);
        window.TranssionH5Ads?.setRewardType(contextType);
      }
      return this.inst.showAdWithType(AdsTypes.REWARDED_INTERSTITIAL, { ...payload, forceLoad: true });
    }
    canbeShowInSDK(includeSDK = [], excludeSDK = []) {
      const sdkName = GameSDK.getSDKName();
      if (excludeSDK?.length && A2.has(excludeSDK, sdkName)) return false;
      if (includeSDK?.length && !A2.has(includeSDK, sdkName)) return false;
      return true;
    }
    isUserCancelledAdError(error) {
      return error instanceof Object && "code" in error && error.code === "USER_INPUT";
    }
    isRequestAdTimeoutError(error) {
      return error instanceof Object && "code" in error && error.code === "SHOW_ADS_TIMEOUT";
    }
  };
  var AdsUtils_default = AdsUtils;

  // src/utils/PlayerUtils.ts
  init_phaser_custom_min();
  var { player: player2 } = codex;
  var PlayerUtils = class _PlayerUtils {
    static _instance;
    static get inst() {
      if (!this._instance) {
        this._instance = new _PlayerUtils();
      }
      return this._instance;
    }
    static getLevelProgress() {
      return player2.getGameData()?.level ?? 1;
    }
  };
  var PlayerUtils_default = PlayerUtils;

  // src/systems/AdsManager.ts
  var {
    Events: Events3,
    Configs: {
      Ads: { Enabled: Enabled2, PreloadAds, ShowAdOnLoad, BannerDisplayAdOptions: BannerDisplayAdOptions2 },
      Gameplay: { StartAdAtLevel: StartAdAtLevel2 }
    },
    Utils: { Time: T2 }
  } = Ludex;
  var { phaser: phaser2 } = window;
  var { event: event4 } = codex;
  var AdsManager = class {
    currentLayout = "";
    init() {
      this.listenEvents();
      console.info("Ads Manager: Initialized");
    }
    listenEvents() {
      event4.on(GameEvents_default.LAYOUT_CHANGED, this.handleLayoutChanged);
      event4.catchUp(Events3.GAME_READY, this.processPreloadAds);
      event4.catchUp(Events3.GAME_READY, this.processShowBannerAds);
      event4.catchUp(Events3.GAME_SDK_READY, this.processShowFirstInterstitialAd);
    }
    processShowBannerAds = async () => {
      const playerLevel = PlayerUtils_default.getLevelProgress();
      if (playerLevel < StartAdAtLevel2) return;
      await T2.sleepAsync(1500);
      AdsUtils_default.showBannerAds();
    };
    processPreloadAds = async () => {
      if (!PreloadAds) return;
      await T2.sleepAsync(3 * 1e3);
      AdsUtils_default.preloadAds();
    };
    processShowFirstInterstitialAd = async () => {
      if (!Enabled2) return;
      const { Enabled: ShowAdOnLoadEnabled, DelaySeconds } = ShowAdOnLoad;
      if (!ShowAdOnLoadEnabled) return;
      if (DelaySeconds > 0) {
        await T2.sleepAsync(DelaySeconds * 1e3);
      }
      const isYandex = GameSDK.getSDKName() === "Yandex";
      if (isYandex) {
        phaser2.loop.pause();
      }
      try {
        await AdsUtils_default.showInterstitialAdAsync({ forceLoad: true, contextType: "preroll" });
      } catch (error) {
        console.warn("AdsManager: showFirstInterstitialAd", error);
      }
      if (isYandex) {
        phaser2.loop.resume();
      }
    };
    handleLayoutChanged = (layout) => {
      if (this.currentLayout === layout) return;
      this.currentLayout = layout;
      if (layout === GameWorld_default.Layout.Landscape) {
        this.processShowBannerAds();
        return;
      }
      BannerDisplayAdOptions2.forEach(({ PlacementId, Position }) => {
        if (Position === "bottom" || Position === "top") {
          AdsUtils_default.showBannerAd(PlacementId);
        } else {
          AdsUtils_default.hideBannerAd(PlacementId);
        }
      });
    };
  };
  var AdsManager_default = AdsManager;

  // src/systems/CoreManager.ts
  init_phaser_custom_min();
  var { Events: Events4 } = Ludex;
  var { event: event5 } = codex;
  var CoreManager = class {
    init() {
      console.info("Core Manager: Initialized");
    }
    requestStart() {
      event5.emit(Events4.REQUEST_CORE_START);
    }
    onCoreBoot(callback) {
      event5.catchUp(Events4.CORE_BOOTING, callback);
    }
    onCoreStart(callback) {
      event5.catchUp(Events4.CORE_STARTING, callback);
    }
    onCoreReady(callback) {
      event5.catchUp(Events4.CORE_READY, callback);
    }
  };
  var CoreManager_default = CoreManager;

  // src/systems/MatchManager.ts
  init_phaser_custom_min();

  // src/constants/MatchCustomData.ts
  init_phaser_custom_min();
  var MatchCustomData = {
    level: 1
  };
  var MatchCustomData_default = MatchCustomData;

  // src/systems/MatchManager.ts
  var { player: player3, storage } = codex;
  var MatchManager = class {
    init() {
      console.info("Match Manager: Initialized");
    }
    setupDefaultMatchData() {
      this.setupMatchCustomData();
    }
    setupMatchCustomData() {
      const playerLevel = player3.getGameData()?.level ?? 1;
      console.log("playerLevel", playerLevel);
      storage.setStorageData("match", "customData", {
        ...MatchCustomData_default,
        level: playerLevel
      });
    }
  };
  var MatchManager_default = MatchManager;

  // src/systems/PlayerManager.ts
  init_phaser_custom_min();

  // src/constants/GameData.ts
  init_phaser_custom_min();

  // src/game/gameplay/constants/item.ts
  init_phaser_custom_min();
  var ITEM = {
    HINT: {
      ID: "ItemHint",
      REWARD_DESC: "Show one matchable pair on the board"
    },
    ROCKET: {
      ID: "ItemRocket",
      REWARD_DESC: "Destroy two pairs on the board"
    },
    INVITE: {
      ID: "ItemInvite"
    },
    SHUFFLE: {
      ID: "ItemShuffle",
      REWARD_DESC: "Shuffle all tiles on the board"
    },
    BOMB_DEFUSE: {
      ID: "ItemBombDefuse",
      REWARD_DESC: "Remove a bomb tile on the board"
    },
    GUIDE_BOMB_DEFUSE: {
      ID: "ItemGuideBombDefuse"
    },
    SUPER_ROCKET: {
      ID: "ItemSuperRocket",
      REWARD_DESC: "Destroy four pairs on the board"
    },
    // ! Debug items
    WIN_GAME: {
      ID: "ItemWinGame"
    },
    NEW_GAME: {
      ID: "ItemNewGame"
    },
    CHANGE_COLOR: {
      ID: "ItemChangeColor"
    },
    NEXT_LEVEL: {
      ID: "ItemNextLevel"
    },
    OPEN_LUCKY_WHEEL: {
      ID: "ItemOpenLuckyWheel"
    },
    BACK_LEVEL: {
      ID: "ItemBackLevel"
    },
    BOMB_EXPLOSIVE: {
      ID: "ItemBombExplosive"
    },
    TIME_UP: {
      ID: "ItemTimeUp"
    },
    RESET_DATA: {
      ID: "ItemResetData"
    },
    AUTO_MATCH: {
      ID: "ItemAutoMatch"
    },
    EMBED_LOCAL: {
      ID: "ItemEmbedLocal"
    }
  };
  var item_default = ITEM;

  // src/game/gameplay/constants/tutorial.ts
  init_phaser_custom_min();
  var TUTORIAL_ID = {
    NEWBIE: "Newbie",
    NO_TIMER: "NoTimer",
    TIMER: "Timer",
    MAGNIFIER_ITEM: "MagnifierItem",
    ROCKET_TILES: "RocketTiles",
    BOMB_ITEM: "BombItem",
    DIFFUSE_ITEM: "DiffuseItem",
    SHUFFLE_ITEM: "ShuffleItem",
    ROCKET_ITEM: "RocketItem",
    SUPER_ROCKET_ITEM: "SuperRocketItem"
  };

  // src/constants/GameData.ts
  var { StartItems } = GameSettings_default;
  var DEFAULT_TUTORIAL_DISPLAYED = {
    [TUTORIAL_ID.NO_TIMER]: false,
    [TUTORIAL_ID.TIMER]: false,
    [TUTORIAL_ID.MAGNIFIER_ITEM]: false,
    [TUTORIAL_ID.ROCKET_TILES]: false,
    [TUTORIAL_ID.BOMB_ITEM]: false,
    [TUTORIAL_ID.DIFFUSE_ITEM]: false,
    [TUTORIAL_ID.SHUFFLE_ITEM]: false,
    [TUTORIAL_ID.ROCKET_ITEM]: false,
    [TUTORIAL_ID.SUPER_ROCKET_ITEM]: false
  };
  var GameData = {
    level: 1,
    coins: 0,
    lastDailySpin: 0,
    lastTimePlayed: 0,
    lastReceiveGift: 0,
    items: {
      [item_default.HINT.ID]: StartItems.ItemHint,
      [item_default.ROCKET.ID]: StartItems.ItemRocket,
      [item_default.SHUFFLE.ID]: StartItems.ItemShuffle,
      [item_default.BOMB_DEFUSE.ID]: StartItems.ItemBombDefuse,
      [item_default.SUPER_ROCKET.ID]: StartItems.ItemSuperRocket
    },
    tournamentProgress: {},
    tutorialDisplayed: DEFAULT_TUTORIAL_DISPLAYED,
    // * This old data will be removed in the future
    // ? Since: 13/03/2025
    levelProgress: 1
  };
  var GameData_default = GameData;

  // src/constants/PlayerData.ts
  init_phaser_custom_min();
  var PlayerData = {
    gameData: GameData_default,
    dailyRewardedData: {
      logDays: [],
      firstReward: 0,
      lastReward: 0
    }
  };
  var PlayerData_default = PlayerData;

  // src/systems/PlayerManager.ts
  var {
    Utils: { Valid: V },
    Dtos: { Player }
  } = Ludex;
  var { player: player4 } = codex;
  var PlayerManager = class {
    init() {
      console.info("Player Manager: Initialized");
    }
    setupDefaultGameData() {
      Player.Data.addDefaultData(PlayerData_default);
      Player.GameData.addDefaultData(GameData_default);
      Player.GameData.addValidateFunction("lastDailySpin", (lastDailySpin) => {
        if (!V.isNumber(lastDailySpin) || lastDailySpin < 0) {
          throw new Error(`lastDailySpin ${lastDailySpin} is invalid`);
        }
      });
      Player.GameData.addValidateFunction("lastTimePlayed", (lastTimePlayed) => {
        if (!V.isNumber(lastTimePlayed) || lastTimePlayed < 0) {
          throw new Error(`lastTimePlayed ${lastTimePlayed} is invalid`);
        }
      });
      Player.GameData.addValidateFunction("lastReceiveGift", (lastReceiveGift) => {
        if (!V.isNumber(lastReceiveGift) || lastReceiveGift < 0) {
          throw new Error(`lastReceiveGift ${lastReceiveGift} is invalid`);
        }
      });
      Player.GameData.addValidateFunction("items", (items) => {
        if (!V.isObject(items)) {
          throw new Error(`items ${items} is invalid`);
        }
      });
      Player.GameData.addValidateFunction("tournamentProgress", (tournamentProgress) => {
        if (!V.isObject(tournamentProgress)) {
          throw new Error(`tournamentProgress ${tournamentProgress} is invalid`);
        }
      });
      Player.GameData.addValidateFunction("tutorialDisplayed", (tutorialDisplayed) => {
        if (!V.isObject(tutorialDisplayed)) {
          throw new Error(`tutorialDisplayed ${tutorialDisplayed} is invalid`);
        }
      });
      Player.GameData.addValidateFunction("levelProgress", (levelProgress) => {
        if (!V.isNumber(levelProgress) || levelProgress < 0) {
          throw new Error(`levelProgress ${levelProgress} is invalid`);
        }
      });
    }
    // ? Manual sync player data
    async syncPlayerData() {
      const dataSync = {};
      const { userGuideDisplays, gameData } = await GameSDK.player.getDataAsync(["userGuideDisplays",
      "gameData"]);
      const { levelProgress, items } = gameData ?? {};
      const { level: currentLevel = 1 } = player4.getGameData() ?? {};
      const oldData = { userGuideDisplays, levelProgress, items };
      if (userGuideDisplays !== void 0 && userGuideDisplays !== true) {
        dataSync.isFirstLogin = false;
      }
      if (!V.isEmpty(gameData)) {
        dataSync.gameData = {};
        if (V.isNumber(levelProgress) && levelProgress > currentLevel) {
          dataSync.gameData.level = levelProgress;
        }
        if (!V.isEmpty(items)) {
          dataSync.gameData.items = items;
        }
      }
      if (!V.isEmpty(dataSync) && !V.isEmpty(dataSync.gameData)) {
        dataSync.oldData = oldData;
        player4.setPlayerData(dataSync);
      }
    }
    requestConnectedPlayers() {
      player4.requestConnectedPlayers().catch((error) => {
        console.warn("player.requestConnectedPlayers", error);
      });
    }
  };
  var PlayerManager_default = PlayerManager;

  // src/systems/PluginsManager.ts
  init_phaser_custom_min();

  // src/systems/plugins/AdaptivePerformance.ts
  init_phaser_custom_min();
  var {
    Events: Events5,
    Utils: { Valid: V2 }
  } = Ludex;
  var { ads: ads2, event: event6, adaptivePerformance } = codex;
  var AdaptivePerformance = class {
    init() {
      if (!adaptivePerformance) return;
      this.listenEvents();
    }
    listenEvents() {
      event6.on(Events5.REQUEST_RESIZE_GAME, this.handleRequestResizeGame);
      window.phaser.renderer.once(Phaser.Renderer.Events.RENDER, this.handleBeginFrame);
      event6.on(Events5.SCENE_LAUNCHED, this.handleAfterSceneLaunch);
    }
    handleBeginFrame = () => {
      window.phaser.renderer.on(Phaser.Renderer.Events.POST_RENDER, this.lateUpdate);
      window.phaser.renderer.on(Phaser.Renderer.Events.PRE_RENDER, this.updateActualFPS);
    };
    handleAfterSceneLaunch = () => {
      if (!adaptivePerformance) return;
      const scene = SceneUtils_default.getCurrentScene();
      if (!scene) return;
      adaptivePerformance.trackingScene(scene.scene.key);
    };
    handleRequestResizeGame = (payload) => {
      if (ads2.isAdFullSizeShowing()) return;
      const { forcePixelRatio } = payload;
      if (!V2.isNumber(forcePixelRatio)) return;
      event6.emit(GameEvents_default.REQUEST_VIEW_RESIZE, { forcePixelRatio });
    };
    lateUpdate = () => {
      adaptivePerformance?.updatePostStepDeltaTime(window.phaser.loop.delta);
    };
    updateActualFPS = () => {
      const actualFPS = window.phaser.loop.actualFps;
      if (!V2.isNumber(actualFPS)) return;
      adaptivePerformance?.updateActualFPS(actualFPS);
    };
  };
  var AdaptivePerformance_default = AdaptivePerformance;

  // src/systems/plugins/DailyRewards.ts
  init_phaser_custom_min();
  var DailyRewards = class {
    init() {
    }
  };

  // src/systems/plugins/FrameCapture.ts
  init_phaser_custom_min();

  // src/systems/plugins/frame-capture/renderCustomResultChallenge.ts
  init_phaser_custom_min();

  // src/utils/MatchUtils.ts
  init_phaser_custom_min();

  // src/exceptions/PlayerHasTournamentError.ts
  init_phaser_custom_min();

  // src/exceptions/CommonError.ts
  init_phaser_custom_min();
  var CommonError = class extends Error {
    code;
    constructor(code, message) {
      super(message);
      this.code = code;
    }
  };
  var CommonError_default = CommonError;

  // src/exceptions/PlayerHasTournamentError.ts
  var PlayerHasTournamentError = class extends CommonError_default {
    playerId;
    tournamentId;
    constructor(playerId, tournamentId) {
      super("PLAYER_HAS_TOURNAMENT", "Player has a tournament");
      this.playerId = playerId;
      this.tournamentId = tournamentId;
    }
  };

  // src/utils/MissionUtils.ts
  init_phaser_custom_min();

  // src/constants/MissionList.ts
  init_phaser_custom_min();
  var MissionList = [
    {
      id: "hint-1",
      title: "Use Hint 1 time",
      require: {
        hint: 1
      },
      reward: {
        coin: 200
      },
      duration: 1e3 * 60 * 60 * 24
    },
    {
      id: "hint-2",
      title: "Use Hint 3 times",
      require: {
        hint: 3
      },
      reward: {
        coin: 400
      },
      duration: 1e3 * 60 * 60 * 24
    },
    {
      id: "hint-weekly",
      title: "Use Hint 25 times weekly",
      require: {
        hint: 25
      },
      reward: {
        coin: 2e3
      },
      duration: 1e3 * 60 * 60 * 24 * 7
    },
    {
      id: "shuffle-1",
      title: "Use Shuffle 1 time",
      require: {
        shuffle: 1
      },
      reward: {
        coin: 300
      },
      duration: 1e3 * 60 * 60 * 24
    },
    {
      id: "shuffle-2",
      title: "Use Shuffle 3 times",
      require: {
        shuffle: 3
      },
      reward: {
        coin: 600
      },
      duration: 1e3 * 60 * 60 * 24
    },
    {
      id: "shuffle-weekly",
      title: "Use Shuffle 25 times weekly",
      require: {
        shuffle: 30
      },
      reward: {
        coin: 3e3
      },
      duration: 1e3 * 60 * 60 * 24 * 7
    },
    {
      id: "bomb-defuse-1",
      title: "Use Bomb Defuse\n1 time",
      require: {
        defuse: 1
      },
      reward: {
        coin: 400
      },
      duration: 1e3 * 60 * 60 * 24
    },
    {
      id: "bomb-defuse-2",
      title: "Use Bomb Defuse\n3 times",
      require: {
        defuse: 3
      },
      reward: {
        coin: 800
      },
      duration: 1e3 * 60 * 60 * 24
    },
    {
      id: "bomb-defuse-weekly",
      title: "Use Bomb Defuse\n25 times weekly",
      require: {
        defuse: 25
      },
      reward: {
        coin: 3200
      },
      duration: 1e3 * 60 * 60 * 24 * 7
    },
    {
      id: "rocket-1",
      title: "Use Rocket 1 time",
      require: {
        rocket: 1
      },
      reward: {
        coin: 500
      },
      duration: 1e3 * 60 * 60 * 24
    },
    {
      id: "rocket-2",
      title: "Use Rocket 3 times",
      require: {
        rocket: 3
      },
      reward: {
        coin: 1e3
      },
      duration: 1e3 * 60 * 60 * 24
    },
    {
      id: "rocket-weekly",
      title: "Use Rocket 25 times weekly",
      require: {
        rocket: 25
      },
      reward: {
        coin: 4e3
      },
      duration: 1e3 * 60 * 60 * 24 * 7
    },
    {
      id: "finish-level-1",
      title: "Finish 1 levels",
      require: {
        level: 1
      },
      reward: {
        coin: 300
      },
      duration: 1e3 * 60 * 60 * 24
    },
    {
      id: "finish-level-2",
      title: "Finish 3 levels",
      require: {
        level: 3
      },
      reward: {
        coin: 600
      },
      duration: 1e3 * 60 * 60 * 24
    },
    {
      id: "finish-level-3",
      title: "Finish 6 levels",
      require: {
        level: 6
      },
      reward: {
        coin: 900
      },
      duration: 1e3 * 60 * 60 * 24
    },
    {
      id: "finish-level-4",
      title: "Finish 10 levels",
      require: {
        level: 10
      },
      reward: {
        coin: 1200
      },
      duration: 1e3 * 60 * 60 * 24
    },
    {
      id: "finish-level-5",
      title: "Finish 15 levels",
      require: {
        level: 15
      },
      reward: {
        coin: 1500
      },
      duration: 1e3 * 60 * 60 * 24
    },
    {
      id: "finish-level-weekly",
      title: "Finish 120 levels weekly",
      require: {
        level: 120
      },
      reward: {
        coin: 6e3
      },
      duration: 1e3 * 60 * 60 * 24 * 7
    },
    {
      id: "match-pairs-1",
      title: "Match 50 pairs",
      require: {
        pairs: 50
      },
      reward: {
        coin: 300
      },
      duration: 1e3 * 60 * 60 * 24
    },
    {
      id: "match-pairs-2",
      title: "Match 150 pairs",
      require: {
        pairs: 150
      },
      reward: {
        coin: 400
      },
      duration: 1e3 * 60 * 60 * 24
    },
    {
      id: "match-pairs-3",
      title: "Match 300 pairs",
      require: {
        pairs: 300
      },
      reward: {
        coin: 500
      },
      duration: 1e3 * 60 * 60 * 24
    },
    {
      id: "match-pairs-4",
      title: "Match 500 pairs",
      require: {
        pairs: 500
      },
      reward: {
        coin: 600
      },
      duration: 1e3 * 60 * 60 * 24
    },
    {
      id: "match-pairs-5",
      title: "Match 750 pairs",
      require: {
        pairs: 750
      },
      reward: {
        coin: 700
      },
      duration: 1e3 * 60 * 60 * 24
    },
    {
      id: "match-pairs-weekly",
      title: "Match 5000 pairs weekly",
      require: {
        pairs: 5e3
      },
      reward: {
        coin: 7e3
      },
      duration: 1e3 * 60 * 60 * 24 * 7
    },
    {
      id: "invite-friend-1",
      title: "Play with friends\n1 time.",
      require: {
        invite: 1
      },
      reward: {
        coin: 500
      },
      duration: 1e3 * 60 * 60 * 24
    },
    {
      id: "invite-friend-weekly",
      title: "Play with friends\n5 times weekly",
      require: {
        invite: 5
      },
      reward: {
        coin: 2500
      },
      duration: 1e3 * 60 * 60 * 24 * 7
    },
    {
      id: "share-score-1",
      title: "Share your score\n1 time.",
      require: {
        share: 1
      },
      reward: {
        coin: 500
      },
      duration: 1e3 * 60 * 60 * 24
    },
    {
      id: "join-tournament-1",
      title: "Join a tournament\n1 time.",
      require: {
        tournament: 1
      },
      reward: {
        coin: 500
      },
      duration: 1e3 * 60 * 60 * 24
    },
    {
      id: "join-tournament-weekly",
      title: "Join a tournament\n5 times weekly",
      require: {
        tournament: 5
      },
      reward: {
        coin: 2500
      },
      duration: 1e3 * 60 * 60 * 24 * 7
    }
  ];
  var MissionList_default = MissionList;

  // src/utils/GameplayNotificationUtils.ts
  init_phaser_custom_min();

  // src/game/gameplay/events/game.ts
  init_phaser_custom_min();
  var GAME_EVENT = {
    // ? Game State
    DIE: "die",
    REPLAY: "replay",
    RESCUE: "rescue",
    FINISH: "finish",
    CONTINUE: "continue",
    NEXT_LEVEL: "next-level",
    PAUSE: "pause",
    RESUME: "resume",
    // ? Gameplay
    RECEIVE_ITEM: "receive-item",
    TILE_SHOWED_UP: "tile-show-up",
    // ? Game Mode
    SHOW_RESULT_CHALLENGE_SCREEN: "show-result-challenge-screen",
    // ? Gameplay Notification
    GAMEPLAY_PAUSE_NOTIFICATION: "gameplay-pause-notification-available",
    PAUSE_SCREEN_NOTIFICATION: "pause-screen-notification-available"
  };
  var game_default = GAME_EVENT;

  // src/utils/GameplayNotificationUtils.ts
  var { event: event7 } = codex;
  var GameplayNotificationUtils = class _GameplayNotificationUtils {
    static _instance;
    static _gameplayPauseNotificationFlag = false;
    static _pauseScreenNotificationFlag = false;
    static get inst() {
      if (!this._instance) this._instance = new _GameplayNotificationUtils();
      return this._instance;
    }
    static setGameplayPauseNotificationFlag(available) {
      if (this._gameplayPauseNotificationFlag === available) return;
      this._gameplayPauseNotificationFlag = available;
      event7.emit(game_default.GAMEPLAY_PAUSE_NOTIFICATION);
    }
    static setPauseScreenNotificationFlag(available) {
      if (this._pauseScreenNotificationFlag === available) return;
      this._pauseScreenNotificationFlag = available;
      event7.emit(game_default.PAUSE_SCREEN_NOTIFICATION);
    }
    static get isGameplayPauseNotificationAvailable() {
      return this._gameplayPauseNotificationFlag;
    }
    static get isPauseScreenNotificationAvailable() {
      return this._pauseScreenNotificationFlag;
    }
    static initializeFlags() {
      const isDailyMissionClaimable = MissionUtils_default.checkForClaimableMissions() > 0;
      this._gameplayPauseNotificationFlag = isDailyMissionClaimable;
      this._pauseScreenNotificationFlag = isDailyMissionClaimable;
    }
  };
  var GameplayNotificationUtils_default = GameplayNotificationUtils;

  // src/utils/MissionUtils.ts
  var { missions, storage: storage2, player: player5 } = codex;
  var MissionUtils = class _MissionUtils {
    static _instance;
    static finishedMissionCountTracker = null;
    static get inst() {
      if (!this._instance) {
        this._instance = new _MissionUtils();
      }
      return this._instance;
    }
    static addGameMissions() {
      this.removeDefaultMissions();
      const newMissions = this.filterExistingMissions();
      for (const mission of newMissions) {
        this.addMission(mission);
      }
    }
    static removeDefaultMissions() {
      missions.removeMission("finish-level");
    }
    static filterExistingMissions() {
      const existingMissions = storage2.getStorageData("missions", "tasks") ?? [];
      const newMissions = MissionList_default.filter((mission) => {
        return !existingMissions.some((existingMission) => existingMission.id === mission.id);
      });
      return newMissions;
    }
    static getAllMissions() {
      const missions3 = storage2.getStorageData("missions", "tasks") ?? [];
      return missions3.filter((mission) => mission.id !== "finish-level");
    }
    static getAllProcessLogs() {
      const processLogs = storage2.getStorageData("missions", "process") ?? {};
      delete processLogs["finish-level"];
      return processLogs;
    }
    static getGenericExpirationTime() {
      const missions3 = this.getAllMissions();
      if (missions3.length === 0) return -1;
      const firstMission = missions3[0];
      const { expirationTime, duration } = firstMission;
      if (!expirationTime) return Date.now() + duration;
      return expirationTime;
    }
    static getMissionById(id2) {
      const missions3 = this.getAllMissions();
      return missions3.find((mission) => mission.id === id2);
    }
    static getProcessLogById(id2) {
      const processLogs = this.getAllProcessLogs();
      return processLogs[id2];
    }
    static addMission(mission) {
      missions.addMission(mission);
    }
    static removeMission(id2) {
      missions.removeMission(id2);
    }
    static addMissionProgress(missionId, requireType, value) {
      missions.addMissionValue({
        id: missionId,
        type: requireType,
        value
      });
      const currentCount = this.checkForFinishedMissions();
      const result = {
        isMissionFinished: false
      };
      if (this.finishedMissionCountTracker !== null && this.finishedMissionCountTracker !== currentCount) {
        GameplayNotificationUtils_default.setPauseScreenNotificationFlag(true);
        GameplayNotificationUtils_default.setGameplayPauseNotificationFlag(true);
        result.isMissionFinished = true;
      }
      this.finishedMissionCountTracker = currentCount;
      return result;
    }
    static setMissionRewardClaimed(missionId) {
      missions.setMissionRewardClaimed(missionId);
    }
    static addFinishLevelMissionProgress(level) {
      return this.addMissionProgress("finish-level", "level", level);
    }
    static addMatchPairsMissionProgress(pairs) {
      return this.addMissionProgress("match-pairs", "pairs", pairs);
    }
    static addUseBombDefuseMissionProgress(defuse) {
      return this.addMissionProgress("bomb-defuse", "defuse", defuse);
    }
    static addUseRocketMissionProgress(rocket) {
      return this.addMissionProgress("rocket", "rocket", rocket);
    }
    static addUseShuffleMissionProgress(shuffle) {
      return this.addMissionProgress("shuffle", "shuffle", shuffle);
    }
    static addUseHintMissionProgress(hint) {
      return this.addMissionProgress("hint", "hint", hint);
    }
    static addInviteFriendMissionProgress(invite) {
      return this.addMissionProgress("invite-friend", "invite", invite);
    }
    static addShareScoreMissionProgress(share) {
      return this.addMissionProgress("share-score", "share", share);
    }
    static addJoinTournamentMissionProgress(tournament) {
      return this.addMissionProgress("join-tournament", "tournament", tournament);
    }
    static resetMissions() {
      _MissionUtils.resetProcessLog();
      _MissionUtils.resetPlayerMissionProcess();
      storage2.setStorageData("missions", "tasks", []);
      missions.requestMissions();
      this.addDefaultMissions();
    }
    static resetProcessLog() {
      const processLogs = this.getAllProcessLogs();
      const processLogIds = Object.keys(processLogs);
      for (const id2 of processLogIds) {
        const processLog = processLogs[id2];
        const { require: require2 } = processLog;
        const keys = Object.keys(require2);
        for (const key of keys) {
          require2[key] = 0;
        }
        processLog.rewarded = false;
      }
    }
    static resetPlayerMissionProcess() {
      const playerProcess = player5.getPlayerDataByKey("missionsData");
      if (!playerProcess) return;
      const { process: process2 } = playerProcess;
      const processLogIds = Object.keys(process2);
      for (const id2 of processLogIds) {
        const processLog = process2[id2];
        const { require: require2 } = processLog;
        const keys = Object.keys(require2);
        for (const key of keys) {
          require2[key] = 0;
        }
        processLog.rewarded = false;
      }
      player5.setPlayerDataByName("missionsData", {
        process: process2
      });
    }
    static addDefaultMissions() {
      const missions3 = [...MissionList_default];
      for (const mission of missions3) {
        _MissionUtils.addMission(mission);
      }
    }
    static getMissionProgressIcon(missionId) {
      const { FRAME: FRAME100 } = sprites_default.DAILY_MISSIONS;
      if (missionId.includes("hint")) return FRAME100.MISSION_HINT;
      if (missionId.includes("shuffle")) return FRAME100.MISSION_SHUFFLE;
      if (missionId.includes("rocket")) return FRAME100.MISSION_ROCKET;
      if (missionId.includes("bomb-defuse")) return FRAME100.MISSION_BOMB_DEFUSE;
      if (missionId.includes("coin")) return FRAME100.MISSION_COIN;
      if (missionId.includes("finish-level")) return FRAME100.MISSION_FINISH_LEVEL;
      if (missionId.includes("match-pairs")) return FRAME100.MISSION_MATCH_PAIRS;
      if (missionId.includes("invite-friend")) return FRAME100.MISSION_INVITE_FRIEND;
      if (missionId.includes("share-score")) return FRAME100.MISSION_SHARE_SCORE;
      if (missionId.includes("join-tournament")) return FRAME100.MISSION_JOIN_TOURNAMENT;
      return "";
    }
    static checkForClaimableMissions() {
      const missions3 = this.getAllMissions();
      const processLogs = this.getAllProcessLogs();
      let claimableMissions = 0;
      for (const mission of missions3) {
        if (mission.expirationTime && mission.expirationTime < Date.now()) continue;
        const processLog = processLogs[mission.id];
        if (processLog.rewarded) continue;
        const require2 = processLog.require;
        const requireKeys = Object.keys(require2);
        for (const key of requireKeys) {
          const currentProcess = require2[key];
          const missionRequire = mission.require[key];
          if (!missionRequire || currentProcess < missionRequire) continue;
          claimableMissions++;
        }
      }
      return claimableMissions;
    }
    static checkForFinishedMissions() {
      const missions3 = this.getAllMissions();
      const processLogs = this.getAllProcessLogs();
      let finishedMissions = 0;
      for (const mission of missions3) {
        if (mission.expirationTime && mission.expirationTime < Date.now()) continue;
        const processLog = processLogs[mission.id];
        if (processLog.rewarded) {
          finishedMissions++;
          continue;
        }
        const require2 = processLog.require;
        const requireKeys = Object.keys(require2);
        for (const key of requireKeys) {
          const currentProcess = require2[key];
          const missionRequire = mission.require[key];
          if (!missionRequire || currentProcess < missionRequire) continue;
          finishedMissions++;
        }
      }
      return finishedMissions;
    }
    static initializeFinishedMissionCount() {
      const currentCount = this.checkForFinishedMissions();
      this.finishedMissionCountTracker = currentCount;
    }
    static reduceAllMissionExpirationTime() {
      const missions3 = this.getAllMissions();
      for (const mission of missions3) {
        if (!mission.expirationTime) continue;
        mission.expirationTime = mission.expirationTime - 1e3 * 60 * 60 * 24 * 2;
      }
      storage2.setStorageData("missions", "tasks", missions3);
      storage2.updateToWebStorage("missions");
    }
  };
  var MissionUtils_default = MissionUtils;

  // src/utils/MatchUtils.ts
  var {
    Match: { Modes },
    Utils: { Object: O, Valid: V4, String: S, Decorator, Function: F3, Time: T3 },
    Plugins: {
      Analytics: { Events: AnalyticsEvents }
    }
  } = Ludex;
  var { match, player: player6, leaderboard, analytics } = codex;
  var showLoadingScreen = () => {
    ScreenUtils_default.showLoadingScreen();
  };
  var hideLoadingScreen = async () => {
    await T3.sleepAsync(0);
    ScreenUtils_default.closeLoadingScreen();
  };
  var handleError = (error) => {
    hideLoadingScreen();
    if (error instanceof Error) {
      let message = "Something went wrong";
      if (V4.isDebugger()) {
        message = error.message;
        console.warn("Error handled", error);
      }
      ScreenUtils_default.showNotificationScreen(message, 3e3);
    }
  };
  var _MatchUtils = class _MatchUtils {
    static _instance;
    static get inst() {
      if (!this._instance) {
        this._instance = new _MatchUtils();
      }
      return this._instance;
    }
    static isMatchActive() {
      const matchState = this.getMatchState();
      const { status: matchStatus } = matchState;
      return matchStatus === "active";
    }
    static isMatchFinished() {
      const matchState = this.getMatchState();
      const { status: matchStatus } = matchState;
      return matchStatus === "finished";
    }
    static isSingleMode() {
      const matchMode = this.getMatchMode();
      return matchMode === Modes.SINGLE;
    }
    static isChallengeMode() {
      const matchMode = this.getMatchMode();
      return matchMode === Modes.CHALLENGE_FRIEND;
    }
    static isTournamentMode() {
      const matchMode = this.getMatchMode();
      return matchMode === Modes.TOURNAMENT;
    }
    static isPlayerFinished() {
      const matchState = this.getMatchState();
      const { profiles = {} } = matchState;
      const playerId = player6.getPlayerId();
      const playerProfile = profiles[playerId];
      if (!playerProfile) return false;
      return playerProfile.finished ?? false;
    }
    static getMatchPlayerScore() {
      const matchState = this.getMatchState();
      const { profiles = {} } = matchState;
      const playerId = player6.getPlayerId();
      return profiles[playerId]?.score ?? 0;
    }
    static getMatchMode() {
      const matchState = this.getMatchState();
      if (!V4.isString(matchState.mode)) {
        return null;
      }
      return matchState.mode;
    }
    static getMatchState() {
      const matchState = match.getMatchState();
      if (!matchState) {
        throw new Error("Match state not found");
      }
      return matchState;
    }
    static getMatchCustomData() {
      const matchState = this.getMatchState();
      if (!V4.isObject(matchState.customData)) {
        return null;
      }
      return matchState.customData;
    }
    static async setProfileMatchDataAsync(payload) {
      await match.handler.setProfileData(payload);
    }
    static async setMatchCustomDataAsync(payload) {
      await match.handler.setMatchCustomData(payload);
    }
    static async fetchMatchCustomDataAsync() {
      await match.handler.getMatchCustomData();
    }
    static async setLeaderboardScoreAsync(payload) {
      await match.handler.setLeaderboardScore(payload);
    }
    static getMatchLevel() {
      const { level = 1 } = this.getMatchCustomData() ?? {};
      return level;
    }
    static async startSingleModeAsync() {
      const playerId = player6.getPlayerId();
      const level = PlayerUtils_default.getLevelProgress();
      await match.strategy.start.processAsync({
        matchId: "local",
        playerId,
        gameMode: Modes.SINGLE,
        extraData: { level }
      });
      return true;
    }
    static async finishSingleModeAsync() {
      await match.strategy.finish.processAsync({
        setPlayerBestScore: true,
        postGlobalLeaderboard: true
      });
      return true;
    }
    static async autoChallengeModeAsync() {
      let success = await this.continueChallengeModeAsync();
      if (success) return true;
      ScreenUtils_default.closeNotificationScreen();
      success = await this.startChallengeRandomOpponentAsync();
      if (success) return true;
      ScreenUtils_default.closeNotificationScreen();
      success = await this.startChallengeChooseOpponentAsync();
      if (success) return true;
      ScreenUtils_default.closeNotificationScreen();
      success = await this.joinChallengeModeAsync();
      if (success) return true;
      return false;
    }
    static async startChallengeRandomOpponentAsync() {
      const friendIds = player6.getConnectedPlayerIds(10, 0);
      const rand = Math.floor(Math.random() * friendIds.length);
      const opponentId = friendIds[rand];
      if (!V4.isString(opponentId) || V4.isEmpty(opponentId)) return false;
      MissionUtils_default.addInviteFriendMissionProgress(1);
      return this.startChallengeModeAsync(opponentId);
    }
    static async startChallengeChooseOpponentAsync() {
      const playerId = player6.getPlayerId();
      const level = PlayerUtils_default.getLevelProgress();
      const correctedLevel = Math.max(level, 2);
      const promise = match.context.choose.processAsync({
        playerId,
        fallbackSingleMode: false,
        extraData: {
          level: correctedLevel
        }
      });
      const [_, error] = await F3.handleAsync(promise);
      if (this.inst.isUserInputError(error)) return false;
      if (error) throw error;
      MissionUtils_default.addInviteFriendMissionProgress(1);
      return true;
    }
    static async startChallengeModeAsync(opponentId) {
      const playerId = player6.getPlayerId();
      const level = PlayerUtils_default.getLevelProgress();
      const correctedLevel = Math.max(level, 2);
      const promise = match.challenge.friend.processAsync({
        playerId,
        opponentId,
        extraData: {
          level: correctedLevel
        }
      });
      const [_, error] = await F3.handleAsync(promise);
      if (this.inst.isUserInputError(error)) return false;
      if (error) throw error;
      return true;
    }
    static async joinChallengeModeAsync() {
      const { id: id2, customData } = _MatchUtils.getMatchState();
      const { playerId, opponentId } = customData;
      if (!V4.isString(id2)) {
        throw new Error("Invalid match id");
      }
      if (!V4.isString(playerId)) {
        throw new Error("Invalid player id");
      }
      if (!V4.isString(opponentId)) {
        throw new Error("Invalid opponent id");
      }
      const promise = match.challenge.join.processAsync({ matchId: id2, playerId, opponentId });
      const [_, error] = await F3.handleAsync(promise);
      if (this.inst.isUserInputError(error)) return false;
      if (error) throw error;
      MissionUtils_default.addInviteFriendMissionProgress(1);
      return true;
    }
    static async continueChallengeModeAsync() {
      const { id: id2, customData } = _MatchUtils.getMatchState();
      const { playerId, opponentId } = customData;
      if (!V4.isString(id2)) {
        throw new Error("Invalid match id");
      }
      if (!V4.isString(playerId)) {
        throw new Error("Invalid player id");
      }
      if (!V4.isString(opponentId)) {
        throw new Error("Invalid opponent id");
      }
      const contextId = GameSDK.context.getID();
      if (!contextId) {
        throw new Error("Cannot get contextId");
      }
      const promise = match.challenge.continue.processAsync({
        matchId: id2,
        contextId,
        playerId,
        opponentId
      });
      const [_, error] = await F3.handleAsync(promise);
      if (this.inst.isUserInputError(error)) return false;
      if (error) throw error;
      MissionUtils_default.addInviteFriendMissionProgress(1);
      return true;
    }
    static async finishChallengeModeAsync() {
      const level = this.getMatchLevel();
      await match.challenge.finish.processAsync({ extraData: { level } });
      return true;
    }
    static async joinTournamentAsync(tournamentId, level) {
      const playerId = player6.getPlayerId();
      await this.setMatchCustomDataAsync({ playerId, level, contextId: "SOLO" });
      const promise = match.tournament.join.processAsync({ tournamentId, playerId });
      const [_, error] = await F3.handleAsync(promise);
      if (!error) return true;
      if (this.inst.isUserInputError(error)) return false;
      throw error;
    }
    static async continueTournamentAsync() {
      const playerId = player6.getPlayerId();
      const contextId = GameSDK.context.getID();
      await match.tournament.continue.processAsync({ playerId, contextId });
      return true;
    }
    static async finishTournamentAsync() {
      const playerId = player6.getPlayerId();
      const bestScore = player6.getBestScore();
      await match.tournament.finish.processAsync({
        playerId,
        bestScore
      });
      return true;
    }
    static async createTournamentAsync() {
      let isSuccess = false;
      const tournaments = await this.inst.getTournamentsAsync();
      const playerTournament = tournaments.find((tournament) => {
        const payload = JSON.parse(tournament.getPayload());
        const isDefault = tournament.getTournamentType() === "DEFAULT";
        return isDefault && payload.playerId === player6.getPlayerId();
      });
      if (playerTournament) {
        throw new PlayerHasTournamentError(player6.getPlayerId(), playerTournament.getID());
      }
      const tournamentCreatePayload = this.inst.createTournamentPayload();
      try {
        await match.tournament.create.processAsync(tournamentCreatePayload);
        const { leaderboardId } = tournamentCreatePayload;
        leaderboard.addLeaderboard({
          name: leaderboardId,
          type: "tournament",
          autoSortRank: true,
          leaderboardId
        });
        isSuccess = true;
      } catch (error) {
        console.warn("processCreateTournament", error);
      }
      return isSuccess;
    }
    static async shareTournamentAsync(score) {
      const [_, error] = await F3.handleAsync(GameSDK.tournament.shareAsync({ score }));
      const isSuccess = !error;
      analytics.event(AnalyticsEvents.TOURNAMENT_SHARE, { success: isSuccess });
      if (isSuccess) return true;
      if (this.inst.isUserInputError(error)) return false;
      throw error;
    }
    async getTournamentsAsync() {
      try {
        return await GameSDK.tournament.getTournamentsAsync();
      } catch (error) {
        console.error(error);
        return [];
      }
    }
    createTournamentPayload() {
      const leaderboardId = S.generateObjectId();
      const playerId = player6.getPlayerId();
      const matchData = _MatchUtils.getMatchState();
      const { profiles = {} } = matchData;
      const score = profiles[playerId]?.score ?? 0;
      return {
        score,
        playerId,
        mode: Modes.TOURNAMENT,
        name: this.createTournamentName(),
        leaderboardId,
        payload: {
          playerId,
          leaderboardId
        }
      };
    }
    createTournamentName() {
      const playerProfile = player6.getPlayer();
      const { name = null } = playerProfile;
      if (name) {
        const shortName = name.substring(0, 7);
        const tournamentName = `${shortName.split(" ")[0] || shortName}'s Tournament`;
        const normalizedName = S.removeDiacritics(tournamentName);
        return `${normalizedName}`;
      }
      return "Tournament";
    }
    isUserInputError(error) {
      if (!error) return false;
      if (error instanceof Error) {
        const userInputKeywords = ["dismissed", "closed", "refused"];
        if (userInputKeywords.some((item) => error.message.indexOf(item) !== -1)) return true;
        if (O.hasOwn(error, "code") && error.code === "USER_INPUT") return true;
      }
      return false;
    }
  };
  __decorateClass([
    Decorator.tryCatch()
  ], _MatchUtils, "setProfileMatchDataAsync", 1);
  __decorateClass([
    Decorator.tryCatch()
  ], _MatchUtils, "setMatchCustomDataAsync", 1);
  __decorateClass([
    Decorator.tryCatch()
  ], _MatchUtils, "fetchMatchCustomDataAsync", 1);
  __decorateClass([
    Decorator.tryCatch()
  ], _MatchUtils, "setLeaderboardScoreAsync", 1);
  __decorateClass([
    Decorator.tryCatch(handleError),
    Decorator.preStart(showLoadingScreen)
  ], _MatchUtils, "startSingleModeAsync", 1);
  __decorateClass([
    Decorator.tryCatch(handleError)
  ], _MatchUtils, "finishSingleModeAsync", 1);
  __decorateClass([
    Decorator.tryCatch(handleError)
  ], _MatchUtils, "autoChallengeModeAsync", 1);
  __decorateClass([
    Decorator.tryCatch(handleError),
    Decorator.preStart(showLoadingScreen)
  ], _MatchUtils, "startChallengeChooseOpponentAsync", 1);
  __decorateClass([
    Decorator.tryCatch(handleError),
    Decorator.preStart(showLoadingScreen)
  ], _MatchUtils, "startChallengeModeAsync", 1);
  __decorateClass([
    Decorator.tryCatch(handleError),
    Decorator.preStart(showLoadingScreen)
  ], _MatchUtils, "joinChallengeModeAsync", 1);
  __decorateClass([
    Decorator.tryCatch(handleError),
    Decorator.preStart(showLoadingScreen)
  ], _MatchUtils, "continueChallengeModeAsync", 1);
  __decorateClass([
    Decorator.tryCatch(handleError),
    Decorator.preStart(showLoadingScreen)
  ], _MatchUtils, "finishChallengeModeAsync", 1);
  __decorateClass([
    Decorator.tryCatch(handleError),
    Decorator.preStart(showLoadingScreen)
  ], _MatchUtils, "joinTournamentAsync", 1);
  __decorateClass([
    Decorator.tryCatch(handleError),
    Decorator.preStart(showLoadingScreen)
  ], _MatchUtils, "continueTournamentAsync", 1);
  __decorateClass([
    Decorator.tryCatch(handleError),
    Decorator.preStart(showLoadingScreen)
  ], _MatchUtils, "finishTournamentAsync", 1);
  var MatchUtils = _MatchUtils;
  var MatchUtils_default = MatchUtils;

  // src/systems/plugins/frame-capture/renderCustomResultChallenge.ts
  var {
    Configs: {
      FrameCapture: { Enabled: Enabled3, WideframeConfigs }
    },
    Utils: { Object: O3 }
  } = Ludex;
  var renderResultChallenge = async (payload) => {
    if (!Enabled3) {
      console.warn("FrameCapture is not enabled");
      return null;
    }
    const renderOptions = getRenderOptions(payload);
    if (!renderOptions) return null;
    addWideframe(renderOptions, WideframeConfigs.ResultChallenge);
    const { frameCapture: frameCapture2 } = codex;
    const { Width, Height } = WideframeConfigs.ResultChallenge;
    return frameCapture2.captureAsync({
      name: "ResultChallenge",
      width: Width,
      height: Height,
      renderOptions
    });
  };
  var addWideframe = (renderOptions, wideframe) => {
    const { Width, Height, Wideframe } = wideframe;
    renderOptions.wideframe = {
      name: "result-challenge",
      type: "image",
      depth: 0,
      image: Wideframe,
      size: [Width, Height],
      position: [0, 0]
    };
  };
  var getRenderOptions = (payload) => {
    try {
      const {
        playerId = "10",
        playerPhoto = "",
        playerScore = 0,
        opponentId = "20",
        opponentPhoto = "",
        opponentScore = 0,
        isPlayerFinished,
        isOpponentFinished
      } = payload;
      const { RenderOptions } = WideframeConfigs.ResultChallenge;
      const renderOptionsClone = O3.clone(RenderOptions);
      if (!renderOptionsClone) return null;
      const renderOptionsCleared = O3.clear(renderOptionsClone);
      const renderOptions = O3.camelCaseKeys(renderOptionsCleared);
      const { playerPhoto: playerPhotoRender, opponentPhoto: opponentPhotoRender } = renderOptions;
      const isDraw = playerScore === opponentScore;
      const isPlayerWin = playerScore > opponentScore;
      const isGameFinished = isPlayerFinished && isOpponentFinished;
      if (playerPhotoRender.type === "image") {
        playerPhotoRender.name = `${playerId}`;
        playerPhotoRender.image = playerPhoto;
      }
      if (opponentPhotoRender.type === "image") {
        opponentPhotoRender.name = `${opponentId}`;
        opponentPhotoRender.image = opponentPhoto;
      }
      addRenderScores(renderOptions, {
        playerScore,
        opponentScore,
        isPlayerFinished,
        isOpponentFinished
      });
      if (!isGameFinished || isDraw) {
        delete renderOptions.leftCrown;
        delete renderOptions.rightCrown;
        return renderOptions;
      }
      if (isPlayerWin) {
        delete renderOptions.rightCrown;
      } else {
        delete renderOptions.leftCrown;
      }
      return renderOptions;
    } catch (error) {
      console.warn("getRenderOptionsShareScore", error);
      return null;
    }
  };
  var addRenderScores = (renderOptions, payload) => {
    const { leftScore, rightScore } = renderOptions;
    const { playerScore = 0, opponentScore = 0, isPlayerFinished, isOpponentFinished } = payload;
    if (leftScore?.type === "text") {
      const { level } = MatchUtils_default.getMatchCustomData() ?? {};
      leftScore.text = isPlayerFinished ? `${playerScore}` : `Level ${level}`;
    }
    if (rightScore?.type === "text") {
      rightScore.text = isOpponentFinished ? `${opponentScore}` : "???";
    }
  };
  var renderCustomResultChallenge_default = renderResultChallenge;

  // src/systems/plugins/frame-capture/renderCustomUpdateChallenge.ts
  init_phaser_custom_min();

  // src/game/constants/resources/images.ts
  init_phaser_custom_min();
  var {
    Utils: { Device: D3 }
  } = Ludex;
  var imageScale2 = Math.min(D3.pixelRatio(), 2);
  var IMAGES = {
    AVATAR_DEFAULT: {
      KEY: "avatar-default",
      FILE: "./assets/images/others/avatar-default.png",
      CONFIG: {}
    },
    BACKGROUND: {
      KEY: "background",
      FILE: `./assets/images/${imageScale2}x/bg.jpg`,
      FILE_LANDSCAPE: `./assets/images/${imageScale2}x/landscape-bg.jpg`,
      CONFIG: {}
    }
  };
  var images_default = IMAGES;

  // src/systems/plugins/frame-capture/renderCustomUpdateChallenge.ts
  var {
    Configs: {
      FrameCapture: { Enabled: Enabled4, WideframeConfigs: WideframeConfigs2 }
    },
    Utils: { Object: O5 }
  } = Ludex;
  var renderUpdateChallenge = async (_payload) => {
    if (!Enabled4) {
      console.warn("FrameCapture is not enabled");
      return null;
    }
    const renderOptions = getRenderOptions2(_payload);
    if (!renderOptions) return null;
    addWideframe2(renderOptions, WideframeConfigs2.ResultChallenge);
    const { frameCapture: frameCapture2 } = codex;
    const { Width, Height } = WideframeConfigs2.ResultChallenge;
    return frameCapture2.captureAsync({
      name: "UpdateChallenge",
      width: Width,
      height: Height,
      renderOptions
    });
  };
  var addWideframe2 = (renderOptions, wideframe) => {
    const { Width, Height, Wideframe } = wideframe;
    renderOptions.wideframe = {
      name: "update-challenge",
      type: "image",
      depth: 0,
      image: Wideframe,
      size: [Width, Height],
      position: [0, 0]
    };
  };
  var getPayloadFromMatchUtils = () => {
    const payload = {
      playerId: "10",
      playerPhoto: "",
      playerScore: 0,
      opponentId: "20",
      opponentPhoto: "",
      opponentScore: 0,
      isPlayerFinished: false,
      isOpponentFinished: false
    };
    const matchState = MatchUtils_default.getMatchState();
    const { player: player33 } = codex;
    if (!matchState) return payload;
    const { customData = {}, profiles = {} } = matchState;
    const opponentId = customData.opponentId ?? "0";
    const playerId = player33.getPlayerId();
    const playerAvatar = player33.getPlayer()?.photo ?? images_default.AVATAR_DEFAULT.FILE;
    const playerScore = profiles[playerId]?.score ?? 0;
    const opponentAvatar = profiles[opponentId]?.photo ?? images_default.AVATAR_DEFAULT.FILE;
    const opponentScore = profiles[opponentId]?.score ?? 0;
    const isPlayerFinished = profiles[playerId]?.finished ?? false;
    const isOpponentFinished = profiles[opponentId]?.finished ?? false;
    payload.playerId = playerId;
    payload.playerPhoto = playerAvatar;
    payload.playerScore = playerScore;
    payload.opponentId = opponentId;
    payload.opponentPhoto = opponentAvatar;
    payload.opponentScore = opponentScore;
    payload.isPlayerFinished = isPlayerFinished;
    payload.isOpponentFinished = isOpponentFinished;
    return payload;
  };
  var getRenderOptions2 = (_payload) => {
    try {
      const {
        playerId,
        playerPhoto,
        playerScore,
        opponentId,
        opponentPhoto,
        opponentScore,
        isPlayerFinished,
        isOpponentFinished
      } = getPayloadFromMatchUtils();
      console.log(
        "getRenderOptions",
        playerId,
        playerPhoto,
        playerScore,
        opponentId,
        opponentPhoto,
        opponentScore,
        isPlayerFinished,
        isOpponentFinished
      );
      const { RenderOptions } = WideframeConfigs2.ResultChallenge;
      const renderOptionsClone = O5.clone(RenderOptions);
      if (!renderOptionsClone) return null;
      const renderOptionsCleared = O5.clear(renderOptionsClone);
      const renderOptions = O5.camelCaseKeys(renderOptionsCleared);
      const { playerPhoto: playerPhotoRender, opponentPhoto: opponentPhotoRender } = renderOptions;
      const isDraw = playerScore === opponentScore;
      const isPlayerWin = playerScore > opponentScore;
      const isGameFinished = isPlayerFinished && isOpponentFinished;
      if (playerPhotoRender.type === "image") {
        playerPhotoRender.name = `${playerId}`;
        playerPhotoRender.image = playerPhoto;
      }
      if (opponentPhotoRender.type === "image") {
        opponentPhotoRender.name = `${opponentId}`;
        opponentPhotoRender.image = opponentPhoto;
      }
      addRenderScores2(renderOptions, {
        playerScore,
        opponentScore,
        isPlayerFinished,
        isOpponentFinished
      });
      if (!isGameFinished || isDraw) {
        delete renderOptions.leftCrown;
        delete renderOptions.rightCrown;
        return renderOptions;
      }
      if (isPlayerWin) {
        delete renderOptions.rightCrown;
      } else {
        delete renderOptions.leftCrown;
      }
      return renderOptions;
    } catch (error) {
      console.warn("getRenderOptionsShareScore", error);
      return null;
    }
  };
  var addRenderScores2 = (renderOptions, payload) => {
    const { leftScore, rightScore } = renderOptions;
    const { playerScore = 0, opponentScore = 0, isPlayerFinished, isOpponentFinished } = payload;
    if (leftScore?.type === "text") {
      leftScore.text = isPlayerFinished ? `${playerScore}` : "???";
    }
    if (rightScore?.type === "text") {
      rightScore.text = isOpponentFinished ? `${opponentScore}` : "???";
    }
  };
  var renderCustomUpdateChallenge_default = renderUpdateChallenge;

  // src/systems/plugins/frame-capture/renderPostBestScore.ts
  init_phaser_custom_min();
  var {
    Configs: {
      FrameCapture: { Enabled: Enabled5, WideframeConfigs: WideframeConfigs3 }
    },
    Utils: { Object: O6 }
  } = Ludex;
  var renderPostBestScore = async (payload) => {
    if (!Enabled5) {
      console.warn("FrameCapture is not enabled");
      return null;
    }
    const { PostBestScore } = WideframeConfigs3;
    if (!PostBestScore) {
      console.warn("PostBestScore is not found in WideframeConfigs");
      return null;
    }
    const renderOptions = getRenderOptions3(payload);
    if (!renderOptions) return null;
    addWideframe3(renderOptions, PostBestScore);
    const { frameCapture: frameCapture2 } = codex;
    const { Width, Height } = PostBestScore;
    return frameCapture2.captureAsync({
      name: "PostBestScore",
      width: Width,
      height: Height,
      renderOptions
    });
  };
  var addWideframe3 = (renderOptions, wideframe) => {
    const { Width, Height, Wideframe } = wideframe;
    renderOptions.wideframe = {
      name: "post-best-score",
      type: "image",
      depth: 0,
      image: Wideframe,
      size: [Width, Height],
      position: [0, 0]
    };
  };
  var getRenderOptions3 = (payload) => {
    try {
      const { PostBestScore } = WideframeConfigs3;
      if (!PostBestScore) {
        console.warn("PostBestScore is not found in WideframeConfigs");
        return null;
      }
      const { playerId, playerPhoto, playerScore } = payload;
      const { RenderOptions } = PostBestScore;
      const renderOptionsClone = O6.clone(RenderOptions);
      if (!renderOptionsClone) return null;
      const renderOptionsCleared = O6.clear(renderOptionsClone);
      const renderOptions = O6.camelCaseKeys(renderOptionsCleared);
      console.log("renderOptions", renderOptions);
      const { avatar: avatarRender, playerScore: playerScoreRender } = renderOptions;
      if (avatarRender && avatarRender.type === "image") {
        avatarRender.name = `${playerId}`;
        avatarRender.image = playerPhoto;
      }
      if (playerScoreRender && playerScoreRender.type === "text") {
        playerScoreRender.text = `${playerScore}`;
      }
      return renderOptions;
    } catch (error) {
      console.warn("getRenderOptionsInviteFriends", error);
      return null;
    }
  };
  var renderPostBestScore_default = renderPostBestScore;

  // src/systems/plugins/FrameCapture.ts
  var { frameCapture } = codex;
  var FrameCapture = class {
    async init() {
      if (!frameCapture) return;
      frameCapture.addWideframeRender("renderPostBestScore", renderPostBestScore_default);
      frameCapture.addWideframeRender("renderResultChallenge", renderCustomResultChallenge_default);
      frameCapture.addWideframeRender("renderUpdateChallenge", renderCustomUpdateChallenge_default);
    }
  };
  var FrameCapture_default = FrameCapture;

  // src/systems/plugins/Leaderboards.ts
  init_phaser_custom_min();

  // src/constants/Leaderboard.ts
  init_phaser_custom_min();
  var LeaderboardKeys = {
    GLOBAL: "global-leaderboard-key",
    FRIENDS: "friends-leaderboard-key"
  };
  var LeaderboardIds = {
    GLOBAL: "global-leaderboard-id",
    FRIENDS: "friends-leaderboard-id"
  };

  // src/systems/plugins/Leaderboards.ts
  var {
    Configs: {
      Mockup: {
        Leaderboards: LeaderboardsMockupConfig,
        GameSDK: { Player: PlayerMockupConfig }
      },
      Leaderboards: LeaderboardsConfig
    },
    Utils: { Number: N }
  } = Ludex;
  var { leaderboard: leaderboard2 } = codex;
  var Leaderboards = class {
    init() {
      this.handleWhenGameSDKStarted();
    }
    handleWhenGameSDKStarted = () => {
      if (!LeaderboardsMockupConfig.Enabled) {
        this.setupLeaderboards();
      } else {
        this.setupLeaderboardsMockup();
      }
    };
    async setupLeaderboards() {
      this.setupLeaderboardByConfigs();
    }
    setupLeaderboardByConfigs() {
      const { LeaderboardList } = LeaderboardsConfig;
      for (const LeaderboardConfig of LeaderboardList) {
        const { Id, Name } = LeaderboardConfig;
        leaderboard2.addLeaderboard({
          name: Name,
          type: "global",
          autoSortRank: true,
          leaderboardId: Id
        });
      }
    }
    // ! Mock specific
    async setupLeaderboardsMockup() {
      this.setupMockGlobalLeaderboards();
      this.setupMockFriendsLeaderboard();
    }
    async setupMockGlobalLeaderboards() {
      const { NumOfLeaders } = LeaderboardsMockupConfig;
      const { LeaderboardList } = LeaderboardsConfig;
      for (const LeaderboardConfig of LeaderboardList) {
        const { Name: name, Id: _id } = LeaderboardConfig;
        if (!name) continue;
        const leaderboardId = await leaderboard2.createLeaderboardAsync({
          _id,
          name,
          numberOfLeaders: N.random(NumOfLeaders.Max - NumOfLeaders.Min) + NumOfLeaders.Min
        });
        leaderboard2.addLeaderboard({
          name,
          type: "global",
          autoSortRank: true,
          leaderboardId
        });
        await leaderboard2.requestLeaderboardAsync(name, 10);
        let data = leaderboard2.getLeaderboard(name);
        console.info("setupGlobalLeaderboard fetch new", data, data && Object.keys(data.leaders).length);
        data = leaderboard2.getLeaderboard(name);
        console.info("setupGlobalLeaderboard load more", data, data && Object.keys(data.leaders).length);
      }
    }
    async setupMockFriendsLeaderboard() {
      const name = LeaderboardKeys.FRIENDS;
      const mockId = LeaderboardIds.FRIENDS;
      let numberOfLeaders = 0;
      const { ConnectedPlayers } = PlayerMockupConfig;
      if (ConnectedPlayers.Enabled) {
        numberOfLeaders = N.random(ConnectedPlayers.NumOfPlayers - 1) + 1;
      }
      const leaderboardId = await leaderboard2.createLeaderboardAsync({
        _id: mockId,
        name,
        numberOfLeaders
      });
      leaderboard2.addLeaderboard({
        name,
        type: "friends",
        autoSortRank: true,
        leaderboardId
      });
      await leaderboard2.requestLeaderboardAsync(name, 10);
      const data = leaderboard2.getLeaderboard(name);
      console.info("setupFriendsLeaderboard done", data);
    }
  };
  var Leaderboards_default = Leaderboards;

  // src/systems/plugins/Missions.ts
  init_phaser_custom_min();
  var { missions: missions2 } = codex;
  var Missions = class {
    async init() {
      missions2.requestMissions();
    }
  };

  // src/systems/PluginsManager.ts
  var PluginsManager = class {
    init() {
      console.info("Plugins Manager: Initialized");
    }
    initFrameCapture() {
      const frameCapture2 = new FrameCapture_default();
      frameCapture2.init();
    }
    initLeaderboards() {
      const leaderboards = new Leaderboards_default();
      leaderboards.init();
    }
    initMissions() {
      const missions3 = new Missions();
      missions3.init();
    }
    initDailyRewards() {
      const dailyRewards = new DailyRewards();
      dailyRewards.init();
    }
    initAdaptivePerformance() {
      const adaptivePerformance3 = new AdaptivePerformance_default();
      adaptivePerformance3.init();
    }
  };
  var PluginsManager_default = PluginsManager;

  // src/systems/SceneManager.ts
  init_phaser_custom_min();

  // src/utils/AnalyticsUtils.ts
  init_phaser_custom_min();
  var {
    Utils: { Array: A3 },
    Plugins: {
      Analytics: { Events: AnalyticsEvents2 }
    }
  } = Ludex;
  var { analytics: analytics2 } = codex;
  var AnalyticsUtils = class _AnalyticsUtils {
    static _instance;
    static get inst() {
      if (!this._instance) {
        this._instance = new _AnalyticsUtils();
      }
      return this._instance;
    }
    static trackingPages = [];
    static trackCurrentPage(pageName, isOpen) {
      if (!isOpen && !A3.has(this.trackingPages, pageName)) return;
      this.trackingPages = this.trackingPages.filter((page) => page !== pageName);
      if (isOpen) {
        this.trackingPages.push(pageName);
      }
      const currentPage = this.getCurrentPage();
      analytics2.pageview(currentPage);
    }
    static switchSceneTracking() {
      this.trackingPages = [];
      const currentPage = this.getCurrentPage();
      analytics2.pageview(currentPage);
    }
    static getCurrentPage() {
      if (this.trackingPages.length > 0) {
        return this.trackingPages[this.trackingPages.length - 1] || "Unknown Page";
      }
      const scene = SceneUtils_default.getCurrentScene();
      return scene?.scene.key || "Unknown Page";
    }
    static trackButtonClick(buttonName) {
      const currentPage = this.getCurrentPage();
      analytics2.event(AnalyticsEvents2.BUTTON_CLICK, {
        screen_name: currentPage,
        button_name: buttonName
      });
    }
  };
  var AnalyticsUtils_default = AnalyticsUtils;

  // src/systems/SceneManager.ts
  var { event: event8, monitorError } = codex;
  var { Events: Events6 } = Ludex;
  var SceneManager = class {
    sceneInfo;
    callbackSwitchScene = null;
    init() {
      this.listenEvents();
      this.sceneInfo = {
        sceneName: SceneKeys_default.BOOT_SCENE,
        sceneData: {}
      };
      console.info("Scene Manager: Initialized");
    }
    listenEvents() {
      event8.on(Events6.SWITCH_SCENE, this.switchScene);
      event8.on(Events6.SCENE_LOADED, this.handleSceneLoaded);
      event8.on(Events6.SCENE_LAUNCHED, this.handleSceneLaunched);
    }
    correctSceneName(payload) {
      const { sceneName, sceneData } = payload;
      if (sceneName === this.sceneInfo.sceneName) return null;
      if (sceneName === "ChallengeResultScene") {
        return SceneKeys_default.GAME_SCENE;
      }
      const { isFromLoader } = sceneData ?? {};
      if (sceneName === SceneKeys_default.DASHBOARD_SCENE && isFromLoader) {
        return SceneKeys_default.GAME_SCENE;
      }
      return sceneName;
    }
    switchScene = async (payload) => {
      console.groupCollapsed("Scene Process Info");
      const { sceneData } = payload;
      const name = this.correctSceneName(payload);
      console.debug("Switching", name, sceneData ?? {});
      if (!name) return;
      this.startScene({ sceneName: name, sceneData });
      console.groupEnd();
    };
    // ? Make scene flow like Cocos
    sleepOtherScenes = (name) => {
      const { scenes } = window.phaser.scene;
      for (const scene of scenes) {
        if (!scene.scene.isActive()) continue;
        if (scene.scene.key === name) continue;
        if (scene.scene.key === SceneKeys_default.GLOBAL_SCENE) continue;
        scene.scene.sleep();
      }
    };
    async startScene(payload) {
      const { sceneName, sceneData } = payload;
      const { sceneName: currentSceneName } = this.sceneInfo;
      console.log("Start scene", sceneName);
      console.log("Current scene", currentSceneName);
      const { scene } = window.phaser;
      scene.dump();
      this.sceneInfo = {
        sceneName,
        sceneData
      };
      scene.switch(currentSceneName, sceneName);
      event8.emit(GameEvents_default.DESTROY_SCREENS, { sceneKey: currentSceneName });
      scene.dump();
      SceneUtils_default.setCurrentScene(sceneName);
    }
    handleSceneLoaded = (payload) => {
      const { sceneName, sceneData } = this.sceneInfo;
      if (payload.sceneName !== sceneName) return;
      this.setSceneData(sceneName, sceneData ?? {});
    };
    handleSceneLaunched = (payload) => {
      const { sceneName, sceneData } = this.sceneInfo;
      if (payload.sceneName !== sceneName) return;
      AnalyticsUtils_default.switchSceneTracking();
      monitorError?.addMetadata({ currentScene: sceneName });
      this.callbackSwitchScene?.({ sceneName, sceneData });
      this.sleepOtherScenes(sceneName);
      event8.emit(Events6.SCENE_RENDERED, { sceneName });
    };
    onSwitchScene(callback) {
      this.callbackSwitchScene = callback;
    }
    setSceneData(sceneName, sceneData) {
      if (!sceneData) return;
      const scene = window.phaser.scene.getScene(sceneName);
      const currentData = scene.data.get("data");
      const mergedData = { ...currentData, ...sceneData };
      scene.data.set("data", mergedData);
      console.debug("SceneManager.setSceneData", { sceneName, sceneData: mergedData });
    }
  };
  var SceneManager_default = SceneManager;

  // src/systems/ScreenManager.ts
  init_phaser_custom_min();

  // src/constants/ScreenInstances.ts
  init_phaser_custom_min();

  // src/game/screens/ContinueScreen.ts
  init_phaser_custom_min();

  // src/game/components/HighlightButton.ts
  init_phaser_custom_min();

  // src/game/components/Button.ts
  init_phaser_custom_min();

  // src/game/animations/basic/ScaleDown.ts
  init_phaser_custom_min();

  // src/game/animations/easing/BubbleOut.ts
  init_phaser_custom_min();
  var import_bezier_easing = __toESM(require_src());
  var EaseBubbleOut = (0, import_bezier_easing.default)(0.48, 1.57, 0.6, 0.83);
  var BubbleOut_default = EaseBubbleOut;

  // src/game/animations/basic/ScaleDown.ts
  var DEFAULT_SCALE_DOWN_ANIM_CONFIG = {
    duration: 400,
    ease: BubbleOut_default,
    props: {
      scale: "-=0.1"
    }
  };
  var ScaleDown_default = DEFAULT_SCALE_DOWN_ANIM_CONFIG;

  // src/game/animations/basic/ScaleUp.ts
  init_phaser_custom_min();
  var DEFAULT_SCALE_UP_ANIM_CONFIG = {
    duration: 400,
    ease: BubbleOut_default,
    props: {
      scale: "+=0.1"
    }
  };
  var ScaleUp_default = DEFAULT_SCALE_UP_ANIM_CONFIG;

  // src/game/constants/depth.ts
  init_phaser_custom_min();
  var DEPTH_OBJECTS = {
    BACKGROUND: 1,
    FIREWORKS: 5,
    ITEM: 10,
    LOGO: 15,
    BUTTON: 20,
    TILE: 25,
    TEXT: 30,
    EFFECT: 32,
    BOMB: 34,
    ROCKET: 35,
    ENCOURAGING: 38,
    MESSAGE: 40,
    POPUP: 45,
    PRIORITY: 80,
    DEBUG: 90,
    ON_TOP: 1e4
  };
  var depth_default = DEPTH_OBJECTS;

  // src/game/constants/soundEffects.ts
  init_phaser_custom_min();
  var SOUND_EFFECT = {
    //! sort in load order
    // TILE INTERACTION
    TILE_SELECT: "tile_select",
    COMBO_1: "combo_1",
    COLLECT_STARS: "collect_stars",
    INVALID_MATCH: "invalid_match",
    COMBO_2: "combo_2",
    COMBO_3: "combo_3",
    COMBO_4: "combo_4",
    COMBO_5: "combo_5",
    SHUFFLE_ITEM: "shuffle_item",
    HINT_ITEM: "hint_item",
    // POPUP RESULT
    THREE_STARS: "three_stars",
    PROGRESS_STAR: "progress_star",
    // item effects
    BOMB_DEFUSE: "bomb_defuse",
    ROCKET_FLY: "rocket_fly",
    BOMB_EXPLODE_1: "bomb_explode_1",
    TICKING_BOMB_BEFORE_EXPLODE: "ticking_bomb_before_explode",
    EXTRA_TILE_SPAWN: "extra_tile_spawn",
    CLOSE_POPUP_CLICK: "close_popup_click",
    GENERAL_BUTTON_CLICK: "use_item_click",
    CLICKS: "clicks",
    GIFT_CHARGE: "gift_charge",
    GIFT_EXPLODE: "gift_explode",
    GIFT_REVEAL: "gift_reveal",
    DAILY_REWARD: "daily_reward",
    LEVEL_START: "level_start",
    LEVEL_COMPLETE: "level_complete",
    LEVEL_FAIL: "level_fail",
    RESCUE_TIMER: "rescue_timer",
    WHEEL_CLICK: "wheel_click",
    WHEEL_GET_COMMON: "wheel_get_common",
    WHEEL_GET_SPECIAL: "wheel_get_special"
  };
  var soundEffects_default = SOUND_EFFECT;

  // src/utils/AnimUtils.ts
  init_phaser_custom_min();
  var AnimUtils = class {
    static runTween(tween, signal) {
      if (signal === void 0) {
        if (tween.hasStarted) {
          tween.restart();
        } else {
          tween.play();
        }
        return;
      }
      if (signal.aborted) {
        tween.stop();
        return;
      }
      const cancel = () => tween.stop();
      const cleanup = () => signal.off(cancel);
      signal.once(cancel);
      tween.once(Phaser.Tweens.Events.TWEEN_COMPLETE, cleanup);
      tween.once(Phaser.Tweens.Events.TWEEN_STOP, cleanup);
      if (tween.hasStarted) {
        tween.restart();
      } else {
        tween.play();
      }
    }
    static runTweenAsync(tween) {
      return new Promise((resolve) => {
        tween.off(Phaser.Tweens.Events.TWEEN_COMPLETE, resolve);
        tween.once(Phaser.Tweens.Events.TWEEN_COMPLETE, resolve);
        if (tween.hasStarted) {
          tween.restart();
        } else {
          tween.play();
        }
      });
    }
  };

  // src/game/components/Button.ts
  var Button = class extends Phaser.GameObjects.Container {
    useSound = true;
    isClicked = false;
    // * Default scale is 1, scale down to 0.8 when pressed
    scaleUp = 1;
    scaleDown = 0.985;
    button;
    upAnimation;
    downAnimation;
    isUsePixelPerfect = false;
    hitArea;
    hitZone;
    hitSoundEffectKey = soundEffects_default.GENERAL_BUTTON_CLICK;
    scaleDownPress;
    constructor(scene, key, frame, width, height, usePixelPerfect = false) {
      super(scene);
      this.isUsePixelPerfect = usePixelPerfect;
      this.setDepth(depth_default.BUTTON);
      this.createButton(key, frame, width, height);
      this.updateSize();
      this.listenEvents();
      this.scene.add.existing(this);
    }
    listenEvents() {
      this.scene.events.on(Phaser.Scenes.Events.SLEEP, this.handleSceneSleep);
      this.once(Phaser.GameObjects.Events.DESTROY, this.handelObjectDestroy);
    }
    handelObjectDestroy = () => {
      if (!this.scene) return;
      this.scene.events.off(Phaser.Scenes.Events.SLEEP, this.handleSceneSleep);
    };
    handleSceneSleep = () => {
      if (!this.scene) return;
      this.scene.tweens.killTweensOf(this);
    };
    set onClick(callback) {
      if (this.isUsePixelPerfect) {
        this.hitArea = this.button;
        this.hitArea.setInteractive({
          useHandCursor: true,
          pixelPerfect: true
        });
      } else {
        this.hitArea = this.hitZone;
        this.updateSize();
        this.hitArea.setInteractive({
          useHandCursor: true
        });
      }
      this.hitArea.off(Phaser.Input.Events.GAMEOBJECT_POINTER_DOWN);
      this.hitArea.off(Phaser.Input.Events.GAMEOBJECT_POINTER_UP);
      this.hitArea.off(Phaser.Input.Events.GAMEOBJECT_POINTER_OUT);
      this.hitArea.on(Phaser.Input.Events.GAMEOBJECT_POINTER_DOWN, this.handlePointerDown);
      this.hitArea.on(Phaser.Input.Events.GAMEOBJECT_POINTER_UP, this.handleOnClick(callback));
      this.hitArea.on(Phaser.Input.Events.GAMEOBJECT_POINTER_OUT, this.handlePointerOut);
    }
    get isUsePixelPerFect() {
      return this.isUsePixelPerfect;
    }
    getTargetScaleUp() {
      return this.scaleUp;
    }
    getTargetScaleDown() {
      return this.scaleDown;
    }
    setTargetScaleUp(value) {
      this.scaleUp = value;
    }
    setTargetScaleDown(value) {
      this.scaleDown = value;
    }
    handlePointerDown = () => {
      if (this.isClicked) return;
      if (this.upAnimation?.isPlaying()) return;
      this.isClicked = true;
      this.runDownAnimation();
    };
    handleOnClick = (callback) => () => {
      if (!this.isClicked) return;
      if (this.upAnimation?.isPlaying()) return;
      this.isClicked = false;
      this.runUpAnimation();
      this.upAnimation?.once(Phaser.Tweens.Events.TWEEN_COMPLETE, () => {
        AnalyticsUtils_default.trackButtonClick(this.name);
        this.processCallback(callback);
      });
    };
    handlePointerOut = () => {
      if (!this.isClicked) return;
      if (this.upAnimation?.isPlaying()) return;
      this.isClicked = false;
      this.runUpAnimation();
    };
    processCallback(callback) {
      this.upAnimation?.stop();
      this.downAnimation?.stop();
      this.scene?.tweens.killTweensOf(this);
      this.setScale(this.scaleUp);
      callback();
    }
    setDisabled(disable) {
      if (disable) {
        this.setAlpha(0.5);
        this.hitArea?.disableInteractive();
      } else {
        this.setAlpha(1);
        this.hitArea?.setInteractive();
      }
    }
    createButton(key, frame, width, height) {
      this.button = this.scene.add.image(0, 0, key, frame);
      if (width && height) {
        this.button.setWorldSize(width, height);
      }
      const { displayWidth, displayHeight } = this.button;
      this.hitZone = this.scene.make.zone({
        width: displayWidth,
        height: displayHeight
      });
      this.add([this.button, this.hitZone]);
    }
    // This method can be change on child classes for specific buttons
    updateSize() {
      const { width, height } = this.button;
      const padMax = 10;
      const padWidth = width / 100 * 10;
      const padHeight = height / 100 * 10;
      const bounceWidth = padWidth < padMax ? padWidth : padMax;
      const bounceHeight = padHeight < padMax ? padHeight : padMax;
      this.setSize(width + bounceWidth, height + bounceHeight);
      this.hitZone.setSize(width + bounceWidth, height + bounceHeight);
    }
    runDownAnimation() {
      if (this.useSound) {
        AudioUtils_default.playSound(this.hitSoundEffectKey);
      }
      this.downAnimation?.remove();
      this.downAnimation = this.scene.tweens.add({
        ...ScaleDown_default,
        targets: [this],
        duration: 150,
        props: {
          scale: this.scaleDown
        },
        onUpdate: () => {
          this.hitZone.scale = 1 / this.scale;
        }
      });
      AnimUtils.runTween(this.downAnimation);
    }
    runUpAnimation() {
      this.upAnimation?.remove();
      this.upAnimation = this.scene.tweens.add({
        ...ScaleUp_default,
        targets: [this],
        duration: 150,
        props: {
          scale: this.scaleUp
        },
        onUpdate: () => {
          this.hitZone.scale = 1 / this.scale;
        }
      });
      AnimUtils.runTween(this.upAnimation);
    }
    setButtonHitSoundEffect(key) {
      this.hitSoundEffectKey = key;
    }
  };
  var Button_default = Button;

  // src/game/components/HighlightButton.ts
  var {
    Utils: { Signal: S2 }
  } = Ludex;
  var HighlightButton = class extends Button_default {
    content;
    highlightAnimController = new S2.SignalController();
    useHighlight = false;
    highlightScaleRange = [1, 1.05];
    constructor(scene, key, frame) {
      super(scene, key, frame);
      this.content = this.createContent();
      this.content.add(this.button);
    }
    createContent() {
      const content = this.scene.add.container();
      content.setSize(this.width, this.height);
      this.add(content);
      return content;
    }
    playHighlightAnimation() {
      if (this.useHighlight) return;
      this.useHighlight = true;
      this.runHighlightAnimation();
    }
    stopHighlightAnimation() {
      if (!this.useHighlight) return;
      this.useHighlight = false;
      this.runHighlightExitAnimation();
    }
    runHighlightAnimation() {
      const signal = this.highlightAnimController.renew();
      const [from, to] = this.highlightScaleRange;
      AnimUtils.runTween(
        this.scene.tweens.add({
          targets: this.content,
          props: {
            scale: { from, to }
          },
          paused: true,
          duration: 600,
          ease: Phaser.Math.Easing.Cubic.InOut,
          repeatDelay: 200,
          yoyo: true,
          repeat: -1
        }),
        signal
      );
    }
    runHighlightExitAnimation() {
      const signal = this.highlightAnimController.renew();
      AnimUtils.runTween(
        this.scene.tweens.add({
          targets: this.content,
          props: {
            scale: 1
          },
          paused: true,
          duration: 150,
          ease: Phaser.Math.Easing.Cubic.Out
        }),
        signal
      );
    }
    runDownAnimation() {
      super.runDownAnimation();
      this.runHighlightExitAnimation();
    }
    runUpAnimation() {
      super.runUpAnimation();
      if (this.useHighlight) {
        this.runHighlightAnimation();
      }
    }
  };

  // src/game/animations/exits/FadeOut.ts
  init_phaser_custom_min();
  var DEFAULT_FADE_OUT_ANIM_CONFIG = {
    duration: 600,
    ease: Phaser.Math.Easing.Quadratic.Out,
    props: {
      alpha: 0
    }
  };
  var FadeOut_default = DEFAULT_FADE_OUT_ANIM_CONFIG;

  // src/game/animations/special/ShowUp.ts
  init_phaser_custom_min();
  var DEFAULT_SHOW_UP_ANIM_CONFIG = {
    duration: 400,
    ease: Phaser.Math.Easing.Back.Out,
    props: {
      y: { from: 250, to: 0 },
      scale: { from: 0.9, to: 1 },
      alpha: { start: 0, from: 0, to: 1 }
    }
  };
  var ShowUp_default = DEFAULT_SHOW_UP_ANIM_CONFIG;

  // src/game/components/Screen.ts
  init_phaser_custom_min();

  // src/game/animations/entrances/FadeIn.ts
  init_phaser_custom_min();
  var DEFAULT_FADE_IN_ANIM_CONFIG = {
    duration: 600,
    ease: Phaser.Math.Easing.Cubic.Out,
    props: {
      alpha: 1
    }
  };
  var FadeIn_default = DEFAULT_FADE_IN_ANIM_CONFIG;

  // src/game/components/Screen.ts
  var { event: event9 } = codex;
  var {
    Utils: { Valid: V5 }
  } = Ludex;
  var Screen = class extends Phaser.GameObjects.Container {
    zone;
    background;
    backgroundFadeAnimation$;
    async animateBackgroundAlpha(alpha, duration = 400) {
      if (!this.scene) return;
      this.backgroundFadeAnimation$?.remove();
      this.backgroundFadeAnimation$ = this.scene.tweens.add({
        ...FadeIn_default,
        targets: [this.background],
        props: { alpha: alpha + 0.05 },
        duration,
        paused: true
      });
      await AnimUtils.runTweenAsync(this.backgroundFadeAnimation$);
    }
    constructor(scene, name) {
      super(scene);
      this.setName(name);
      const { width, height } = WorldUtils_default.getWorldSize();
      this.setWorldSize(width, height);
      this.addZone$();
      this.addBackground$();
      this.registerEvents();
      this.kill();
    }
    registerEvents() {
      event9.on(GameEvents_default.VIEW_RESIZED, this.handleResize$);
      event9.on(GameEvents_default.LAYOUT_CHANGED, this.handleResize$);
    }
    unregisterEvents() {
      event9.off(GameEvents_default.VIEW_RESIZED, this.handleResize$);
      event9.off(GameEvents_default.LAYOUT_CHANGED, this.handleResize$);
    }
    destroy() {
      this.unregisterEvents();
      super.destroy();
    }
    open(data) {
      this.revive();
      if (V5.isObject(data)) {
        this.setDataEnabled();
        this.setData(data);
      }
      this.scene.children.bringToTop(this);
      this.handleResize$();
    }
    close() {
      this.kill();
    }
    incY(y) {
      this.y += y;
      this.background.y -= y;
    }
    incX(x) {
      this.x += x;
      this.background.x -= x;
    }
    incScale(scale) {
      this.scale += scale;
      this.background.scale -= scale ^ scale * (100 / scale);
    }
    addZone$() {
      this.zone = this.scene.add.zone(0, 0, 0, 0);
      this.zone.setWorldSize(this.width, this.height);
      this.zone.setInteractive();
      this.add(this.zone);
    }
    addBackground$() {
      const texture = "screen-background";
      if (!this.scene.textures.exists(texture)) {
        const width = this.width + 2;
        const height = this.height + 2;
        const graphics = this.scene.add.graphics();
        graphics.fillStyle(0, 1);
        graphics.fillRect(0, 0, width, height);
        graphics.generateTexture(texture, width, height);
        graphics.destroy();
      }
      this.background = this.scene.add.image(0, 0, texture);
      this.background.setWorldSize(this.width, this.height);
      this.add(this.background);
    }
    handleResize$ = () => {
      const { width, height } = WorldUtils_default.getWorldSize();
      this.setWorldSize(width, height);
      this.zone.setSize(this.width, this.height);
      this.background.setWorldSize(this.width, this.height);
    };
  };
  var Screen_default = Screen;

  // src/constants/ScreenDepth.ts
  init_phaser_custom_min();
  var ScreenDepth = {
    SCREEN: 200,
    POPUP: 300,
    PRIORITY: 999
  };
  var ScreenDepth_default = ScreenDepth;

  // src/utils/FontUtils.ts
  init_phaser_custom_min();

  // src/game/constants/resources/fonts.ts
  init_phaser_custom_min();
  var FONTS = {
    // ? Update env.local with GOOGLE_FONTS = Noto+Sans:wght@100..900
    FONT_FAMILY: '"Noto Sans",-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Canta\
rell,"Open Sans","Helvetica Neue",sans-serif'
  };
  var fonts_default = FONTS;

  // src/utils/FontUtils.ts
  var MOD_SIZE = 1;
  var BASE_FONT_SIZE = 18;
  var TruncateStyles = {
    CLIP: "clip",
    ELLIPSIS: "ellipsis"
  };
  var FontUtils = class _FontUtils {
    static _instance;
    static get inst() {
      if (!this._instance) {
        this._instance = new _FontUtils();
      }
      return this._instance;
    }
    static getModSize(size, modSize = MOD_SIZE) {
      return size * modSize;
    }
    // * Final Text
    static createText(scene, text, fontSize = BASE_FONT_SIZE) {
      return scene.make.text({
        text,
        padding: {
          left: 2,
          right: 2,
          top: 1,
          bottom: 1
        },
        origin: {
          x: 0.5,
          y: 0.5
        },
        style: {
          fontSize: `${fontSize}px`,
          fontStyle: "600",
          fontFamily: fonts_default.FONT_FAMILY
          // testString: text,
          // backgroundColor: '#ccc',
        }
      });
    }
    static createShadowText(scene, text, fontSize = BASE_FONT_SIZE) {
      return this.createText(scene, text, fontSize).setShadow(0, 1, "#2e2e2e", 1).setPadding(2, 1, 2,
      4);
    }
    static createStrokeText(scene, text, fontSize = BASE_FONT_SIZE) {
      return this.createText(scene, text, fontSize).setStroke("#2e2e2e", 2).setPadding(3, 2, 3, 2);
    }
    /**
     * Creates a text object with an underline below it
     * The underline is created using underscore characters
     */
    static createUnderlineText(scene, text, fontSize = BASE_FONT_SIZE) {
      if (!text) {
        return this.createText(scene, "", fontSize);
      }
      const textObj = this.createText(scene, "_", fontSize);
      const singleUnderscoreWidth = this.getUnderscoreWidth(textObj);
      const fullTextWidth = this.getTextWidthForUnderscore(textObj, text);
      const requiredUnderscoreCount = Math.ceil(fullTextWidth / singleUnderscoreWidth);
      const LINE_SPACING_FACTOR = 0.9;
      const lineSpacing = -(fontSize * LINE_SPACING_FACTOR);
      textObj.setLineSpacing(lineSpacing);
      textObj.setText(`${text}
${"_".repeat(requiredUnderscoreCount)}`);
      return textObj;
    }
    static getUnderscoreWidth(text) {
      const repeatCount = 5;
      text.setText("_".repeat(repeatCount));
      const { left = 0, right = 0 } = text.padding;
      const width = (text.getBounds().width - left - right) / repeatCount;
      return width;
    }
    static getTextWidthForUnderscore(text, underscoreString) {
      text.setText(underscoreString);
      const { left = 0, right = 0 } = text.padding;
      const width = text.getBounds().width - left - right;
      return width;
    }
    static applyShadow(text, color = "#2e2e2e", offsetX = 0, offsetY = 3, blur = 0.5) {
      return text.setShadow(offsetX, offsetY, color, blur);
    }
    static applyGreenStyle(text) {
      this.applyShadow(text, "#3e770f");
      const strokeWidth = this.calcStrokeWidth(text, 0.75);
      return text.setTint(16777215, 16777215, 13231515, 13231515).setStroke("#3e770f", strokeWidth);
    }
    static applyBlueStyle(text) {
      this.applyShadow(text, "#1f778f");
      const strokeWidth = this.calcStrokeWidth(text, 0.75);
      return text.setTint(16777215, 16777215, 9492713, 9492713).setStroke("#1f778f", strokeWidth);
    }
    static applyOrangeStyle(text) {
      this.applyShadow(text, "#a66919");
      const strokeWidth = this.calcStrokeWidth(text, 0.75);
      return text.setTint(16777215, 16777215, 16769946, 16769946).setStroke("#a66919", strokeWidth);
    }
    static applyBrownStyle(text) {
      const strokeWidth = this.calcStrokeWidth(text);
      return text.setTint(16777215, 16777215, 16380124, 16380124).setStroke("#a46b21", strokeWidth);
    }
    static applyYellowStyle(text) {
      this.applyShadow(text, "#4a260f", 0, 2);
      return text.setTint(16374700);
    }
    static applyWoodStyle(text) {
      return text.setTint(10243599);
    }
    static applyWarningStyle(text) {
      const strokeWidth = this.calcStrokeWidth(text);
      return text.setTint(16772490).setStroke("#784225", strokeWidth);
    }
    static applyRedStyle(text) {
      const strokeWidth = this.calcStrokeWidth(text);
      return text.setTint(16509563, 16509563, 16307499, 16307499).setStroke("#ff0000", strokeWidth);
    }
    // * Utils
    static calcStrokeWidth(text, mod = 1) {
      const { fontSize } = text.style;
      let size = BASE_FONT_SIZE;
      if (typeof fontSize === "string") {
        size = +fontSize.replace("px", "");
      }
      return size * 0.2 * mod;
    }
    static setTruncateOverflow(text, width, style = TruncateStyles.ELLIPSIS) {
      return text.setWordWrapWidth(width).setWordWrapCallback(_FontUtils.applyTruncate(style));
    }
    static applyTruncate = (style = TruncateStyles.ELLIPSIS) => (text, obj) => {
      const { wordWrapWidth: styleWordWrapWidth } = obj.style;
      const wordWrapWidth = styleWordWrapWidth ?? 0;
      const context2 = obj.context;
      const postfix = style === TruncateStyles.CLIP ? "" : "...";
      if (context2.measureText(text).width <= wordWrapWidth) {
        return text;
      }
      let curr = text;
      while (context2.measureText(`${curr}${postfix}`).width > wordWrapWidth) {
        curr = curr.slice(0, -1);
      }
      return `${curr}${postfix}`;
    };
  };
  var FontUtils_default = FontUtils;

  // src/utils/AlignUtils.ts
  init_phaser_custom_min();
  var AlignUtils = class _AlignUtils {
    static _instance;
    static get inst() {
      if (!this._instance) {
        this._instance = new _AlignUtils();
      }
      return this._instance;
    }
    /**
     * Align child objects within container to the top left corner. Use the same parameters as Phaser.Display.Align.In.TopLeft.
     */
    static alignChildTopLeft(child, parent, offsetX = 0, offsetY = 0) {
      const parentOffsetX = parent.x;
      const parentOffsetY = parent.y;
      Phaser.Display.Align.In.TopLeft(child, parent, offsetX + parentOffsetX, offsetY + parentOffsetY);
    }
    /**
     * Align child objects within container to the top right corner. Use the same parameters as Phaser.Display.Align.In.TopRight.
     */
    static alignChildTopRight(child, parent, offsetX = 0, offsetY = 0) {
      const parentOffsetX = parent.x;
      const parentOffsetY = parent.y;
      Phaser.Display.Align.In.TopRight(child, parent, offsetX + parentOffsetX, offsetY + parentOffsetY);
    }
    /**
     * Align child objects within container to the bottom left corner. Use the same parameters as Phaser.Display.Align.In.BottomLeft.
     */
    static alignChildBottomLeft(child, parent, offsetX = 0, offsetY = 0) {
      const parentOffsetX = parent.x;
      const parentOffsetY = parent.y;
      Phaser.Display.Align.In.BottomLeft(child, parent, offsetX - parentOffsetX, offsetY - parentOffsetY);
    }
    /**
     * Align child objects within container to the bottom right corner. Use the same parameters as Phaser.Display.Align.In.BottomRight.
     */
    static alignChildBottomRight(child, parent, offsetX = 0, offsetY = 0) {
      const parentOffsetX = parent.x;
      const parentOffsetY = parent.y;
      Phaser.Display.Align.In.BottomRight(child, parent, offsetX - parentOffsetX, offsetY - parentOffsetY);
    }
    /**
     * Align child objects within container to the center. Use the same parameters as Phaser.Display.Align.In.Center.
     */
    static alignChildCenter(child, parent, offsetX = 0, offsetY = 0) {
      const parentOffsetX = parent.x;
      const parentOffsetY = parent.y;
      Phaser.Display.Align.In.Center(child, parent, offsetX - parentOffsetX, offsetY - parentOffsetY);
    }
    /**
     * Align child objects within container to the left center. Use the same parameters as Phaser.Display.Align.In.LeftCenter.
     */
    static alignChildLeftCenter(child, parent, offsetX = 0, offsetY = 0) {
      const parentOffsetX = parent.x;
      const parentOffsetY = parent.y;
      Phaser.Display.Align.In.LeftCenter(child, parent, offsetX - parentOffsetX, offsetY - parentOffsetY);
    }
    /**
     * Align child objects within container to the right center. Use the same parameters as Phaser.Display.Align.In.RightCenter.
     */
    static alignChildRightCenter(child, parent, offsetX = 0, offsetY = 0) {
      const parentOffsetX = parent.x;
      const parentOffsetY = parent.y;
      Phaser.Display.Align.In.RightCenter(child, parent, offsetX - parentOffsetX, offsetY - parentOffsetY);
    }
    /**
     * Align child objects within container to the top center. Use the same parameters as Phaser.Display.Align.In.TopCenter.
     */
    static alignChildTopCenter(child, parent, offsetX = 0, offsetY = 0) {
      const parentOffsetX = parent.x;
      const parentOffsetY = parent.y;
      Phaser.Display.Align.In.TopCenter(child, parent, offsetX + parentOffsetX, offsetY + parentOffsetY);
    }
    /**
     * Align child objects within container to the bottom center. Use the same parameters as Phaser.Display.Align.In.BottomCenter.
     */
    static alignChildBottomCenter(child, parent, offsetX = 0, offsetY = 0) {
      const parentOffsetX = parent.x;
      const parentOffsetY = parent.y;
      Phaser.Display.Align.In.BottomCenter(child, parent, offsetX - parentOffsetX, offsetY - parentOffsetY);
    }
    /**
     * Align children objects within container.
     * @param children - The children objects to align.
     * @param options - The options for the alignment.
     */
    static alignChildrenContainer(children, options) {
      const { width = -1, height = -1, x = 0, y = 0 } = options;
      const horizontal = width !== -1;
      const vertical = height !== -1;
      if (horizontal) {
        const cellWidth = width / (children.length - 1);
        Phaser.Actions.GridAlign(children, {
          height: 1,
          cellWidth,
          cellHeight: 0,
          x: x - width / 2,
          y,
          position: Phaser.Display.Align.LEFT_CENTER
        });
      } else if (vertical) {
        const cellHeight = height / (children.length - 1);
        Phaser.Actions.GridAlign(children, {
          width: 1,
          cellWidth: 0,
          cellHeight,
          x,
          y: y - height / 2
        });
      }
    }
  };
  var AlignUtils_default = AlignUtils;

  // src/game/screens/ContinueScreen.ts
  var { KEY, FRAME } = sprites_default.DEFAULT;
  var { MaxRescueCount, RescueGamePopupTimeout } = GameSettings_default;
  var { event: event10 } = codex;
  var ContinueScreen = class extends Screen_default {
    level$;
    reason$;
    isUseRescue$;
    popup$;
    contents$;
    countdownText$;
    countdownTimer$;
    countdownCount$;
    realTimeCountdown$;
    progressTween$;
    rescueSoundEvent$;
    progressCircle$;
    progressMaskImage$;
    progressMask$;
    reasonText$;
    continueButton$;
    continueButtonBg$;
    popupShowUpAnimation$;
    popupFadeOutAnimation$;
    constructor(scene, name) {
      super(scene, name);
      this.reason$ = "";
      this.realTimeCountdown$ = 1400;
      this.countdownCount$ = MaxRescueCount;
      this.setDepth(ScreenDepth_default.POPUP);
      this.createContent$();
      this.addContent$();
    }
    open = (data) => {
      super.open();
      this.progressCircle$.clearMask();
      this.isUseRescue$ = false;
      this.countdownCount$ = RescueGamePopupTimeout;
      this.setTime$(this.countdownCount$);
      this.level$ = data.level;
      this.reason$ = data.reason;
      this.updateReasonText$(data.reason);
      this.runOpenAnimation$();
      event10.emit(game_default.PAUSE);
    };
    close() {
      this.rescueSoundEvent$?.remove();
      super.close();
    }
    handleShowRewardedVideoAd$ = async () => {
      try {
        if (this.isUseRescue$) return;
        this.isUseRescue$ = true;
        this.progressTween$.pause();
        this.rescueSoundEvent$?.remove();
        this.countdownTimer$?.remove();
        const success = await AdsUtils_default.showRewardVideoAdAsync();
        if (!success) throw new Error("Failed to show rewarded video ad");
        AudioUtils_default.playSound(soundEffects_default.DAILY_REWARD);
        this.runCloseAnimation$();
        event10.emit(game_default.RESUME);
        this.popupFadeOutAnimation$?.once(Phaser.Tweens.Events.TWEEN_COMPLETE, () => {
          event10.emit(game_default.CONTINUE, { reason: this.reason$ });
        });
      } catch (error) {
        this.countdownTimer$?.remove();
        this.progressTween$.pause();
        this.runCloseAnimation$();
        ScreenUtils_default.openScreen(ScreenKeys_default.RESCUE_SCREEN, { level: this.level$, reason: this.
        reason$ });
        this.isUseRescue$ = false;
      }
    };
    createContent$() {
      this.createPopup$();
      this.createCountdown$();
      this.createProgressCircle$();
      this.createReasonText$();
      this.createContinueButton$();
    }
    createPopup$() {
      this.popup$ = this.scene.add.container(0, 0);
      this.popup$.setSize(292, 374);
      const board = this.scene.make.image({
        key: KEY,
        frame: FRAME.POPUP
      });
      const title = this.scene.make.image({
        key: KEY,
        frame: FRAME.CONTINUE_TEXT
      });
      Phaser.Display.Align.In.TopCenter(title, board, 4, -23);
      this.popup$.add([board, title]);
      this.add(this.popup$);
      const bannerHeightOffset = AdsUtils_default.getBannerHeight() / 2;
      Phaser.Display.Align.In.Center(this.popup$, this.zone, 0, -bannerHeightOffset);
    }
    createCountdown$() {
      this.countdownText$ = FontUtils_default.createText(this.scene, "", 53);
      FontUtils_default.applyWarningStyle(this.countdownText$);
      this.setTime$(this.countdownCount$);
    }
    runCountdown$() {
      const config = {
        loop: true,
        delay: this.realTimeCountdown$,
        callback: this.handleRunCountdown$
      };
      this.countdownTimer$ = this.scene.time.addEvent(config);
      this.startProgressCircle$();
    }
    setProgressCircle$(angle) {
      const { translateX, translateY } = this.progressCircle$.getWorldTransformMatrix().decomposeMatrix();
      this.progressMaskImage$.setPosition(translateX, translateY);
      this.progressMaskImage$.clear();
      if (angle === 0) return;
      this.progressMaskImage$.fillStyle(16777215, 0);
      const startingAngle = -Math.PI / 2;
      const endingAngle = 3 * Math.PI / 2 - Phaser.Math.DegToRad(360 - angle);
      this.progressMaskImage$.slice(0, 0, 80, startingAngle, endingAngle, false);
      this.progressMaskImage$.fillPath();
    }
    setTime$(time) {
      this.countdownText$.setText(`${time}`);
    }
    createProgressCircle$() {
      this.progressCircle$ = this.scene.make.image({
        key: KEY,
        frame: FRAME.PROGRESS_CIRCLE
      });
      const progressCircleBG = this.scene.make.image({
        key: KEY,
        frame: FRAME.PROGRESS_CIRCLE_BG
      });
      this.progressMaskImage$ = this.scene.make.graphics({});
      this.progressMask$ = this.progressMaskImage$.createGeometryMask();
      AlignUtils_default.alignChildCenter(this.progressCircle$, this.popup$, 0, -40);
      AlignUtils_default.alignChildCenter(progressCircleBG, this.popup$, 0, -40);
      Phaser.Display.Align.In.Center(this.countdownText$, progressCircleBG, 0, 0);
      this.popup$.add([progressCircleBG, this.progressCircle$]);
    }
    startProgressCircle$() {
      this.setProgressCircle$(360);
      this.progressCircle$.setMask(this.progressMask$);
      this.progressTween$ = this.scene.tweens.addCounter({
        from: 360,
        to: 0,
        duration: RescueGamePopupTimeout * this.realTimeCountdown$,
        onUpdate: (tween) => {
          const angle = +tween.getValue().toFixed(2);
          this.setProgressCircle$(angle);
        },
        onComplete: () => {
          this.setProgressCircle$(0);
          this.rescueSoundEvent$?.remove();
        }
      });
      this.playSoundTimeCountdown$();
      this.rescueSoundEvent$ = this.scene.time.addEvent({
        repeat: 3,
        delay: this.realTimeCountdown$,
        callback: this.playSoundTimeCountdown$
      });
    }
    playSoundTimeCountdown$ = () => {
      AudioUtils_default.playSound(soundEffects_default.RESCUE_TIMER, {
        volume: 1.5
      });
    };
    createReasonText$() {
      this.reasonText$ = FontUtils_default.createText(this.scene, "", 18);
      FontUtils_default.applyWarningStyle(this.reasonText$);
    }
    updateReasonText$(reason) {
      switch (reason) {
        case "bombExplosive":
          this.reasonText$.setText("The bomb exploded!");
          break;
        case "timeUp":
          this.reasonText$.setText("Time is up!");
          break;
        default:
          this.reasonText$.setText("You have failed the level!");
      }
      AlignUtils_default.alignChildCenter(this.reasonText$, this.popup$, 0, 57);
    }
    createContinueButton$() {
      this.continueButton$ = new HighlightButton(this.scene, KEY, FRAME.BUTTON_GREEN);
      this.continueButton$.setName("Continue");
      this.continueButtonBg$ = this.scene.make.image({
        key: KEY,
        frame: FRAME.BUTTON_FRAME
      });
      this.continueButton$.onClick = this.handleShowRewardedVideoAd$;
      const iconAds = this.scene.add.image(0, 0, KEY, FRAME.ICON_ADS);
      Phaser.Display.Align.In.Center(iconAds, this.continueButton$, -60);
      this.continueButton$.content.add(iconAds);
      const continueText = FontUtils_default.createText(this.scene, "Continue", 20).setFontStyle("70\
0");
      FontUtils_default.applyGreenStyle(continueText);
      continueText.setOrigin(0.35, 0.75);
      this.continueButton$.content.add(continueText);
      continueText.setPosition(1, 6);
      AlignUtils_default.alignChildBottomCenter(this.continueButton$, this.popup$, 0, -40);
      Phaser.Display.Align.In.Center(this.continueButtonBg$, this.continueButton$, 0, -1);
    }
    handleRunCountdown$ = () => {
      this.countdownCount$ -= 1;
      this.setTime$(this.countdownCount$);
      if (this.countdownCount$ <= 0) {
        this.countdownTimer$?.remove();
        this.progressTween$.complete();
        this.rescueTimeout$();
        return;
      }
    };
    rescueTimeout$() {
      this.scene.time.delayedCall(800, () => {
        this.runCloseAnimation$();
        if (!this.isUseRescue$) {
          this.popupFadeOutAnimation$?.once(Phaser.Tweens.Events.TWEEN_COMPLETE, () => {
            ScreenUtils_default.openScreen(ScreenKeys_default.RESCUE_SCREEN, {
              level: this.level$,
              reason: this.reason$
            });
          });
        }
      });
    }
    // Animations
    runContinueButtonAnimation$() {
      this.continueButton$.playHighlightAnimation();
    }
    addContent$() {
      this.contents$ = this.scene.add.group();
      this.contents$.addMultiple([
        this.countdownText$,
        this.reasonText$,
        this.continueButtonBg$,
        this.continueButton$
      ]);
      this.popup$.add(this.contents$.getChildren());
    }
    // Animations
    runOpenAnimation$() {
      if (this.popupShowUpAnimation$?.isPlaying()) return;
      this.background.setAlpha(0);
      this.animateBackgroundAlpha(0.8);
      this.runPopupEntrancesAnimation$(0, 400);
    }
    runCloseAnimation$() {
      if (this.popupFadeOutAnimation$?.isPlaying()) return;
      this.animateBackgroundAlpha(0, 200);
      this.runPopupExitsAnimation$(0, 200);
    }
    // Entrances animations
    runPopupEntrancesAnimation$(delay, duration) {
      const bannerHeightOffset = AdsUtils_default.getBannerHeight() / 2;
      this.popupShowUpAnimation$ = this.scene.tweens.add({
        ...ShowUp_default,
        targets: [this.popup$],
        delay,
        duration,
        props: {
          ...ShowUp_default.props,
          y: { from: 350 - bannerHeightOffset, to: -bannerHeightOffset },
          alpha: { start: 1, from: 1, to: 1 },
          scale: { start: 0, from: 0, to: 1 }
        },
        onComplete: () => {
          this.runCountdown$();
          this.runContinueButtonAnimation$();
        }
      });
      AnimUtils.runTween(this.popupShowUpAnimation$);
    }
    // Exits animations
    runPopupExitsAnimation$(delay, duration) {
      const bannerHeightOffset = AdsUtils_default.getBannerHeight() / 2;
      this.popupFadeOutAnimation$ = this.scene.tweens.add({
        ...FadeOut_default,
        targets: [this.popup$],
        delay,
        duration,
        props: {
          ...FadeOut_default.props,
          y: 250 - bannerHeightOffset,
          scale: 0
        },
        onComplete: () => {
          this.popup$.setY(0);
          ScreenUtils_default.closeScreen(this.name);
        }
      });
      AnimUtils.runTween(this.popupFadeOutAnimation$);
    }
  };
  var ContinueScreen_default = ContinueScreen;

  // src/game/screens/DailyMissionsScreen.ts
  init_phaser_custom_min();

  // src/game/screens/common/MissionBlock.ts
  init_phaser_custom_min();

  // src/game/screens/common/DailyMissionProgress.ts
  init_phaser_custom_min();
  var { KEY: KEY2, FRAME: FRAME2 } = sprites_default.DAILY_MISSIONS;
  var DailyMissionProgress = class extends Phaser.GameObjects.Container {
    process;
    minProcess;
    maxProcess;
    progressBoxBg;
    progressBarLeft;
    progressBarBg;
    progressBarRight;
    progressAnimation;
    constructor(scene) {
      super(scene);
      this.setWorldSize(90, 14);
      this.process = 0;
      this.minProcess = 0;
      this.maxProcess = 1;
      this.createProgressBox();
      this.createProgressBar();
      this.createContainer();
    }
    setProcess(value, instance = false) {
      this.process = this.getCorrectValue(value);
      if (!this.scene || instance) {
        this.updateProcess();
        return;
      }
      this.runProcessAnimation(value);
    }
    updateProcess() {
      const { displayHeight } = this.progressBarBg;
      const displayWidth = this.getDisplayWidthByProcess(this.process);
      this.progressBarBg.setWorldSize(displayWidth, displayHeight);
      const { x } = this.progressBarBg;
      this.progressBarRight.setX(x + displayWidth);
    }
    getCorrectValue(value) {
      let correctValue = value;
      if (!isFinite(correctValue)) {
        correctValue = 0;
      }
      if (correctValue < this.minProcess) {
        correctValue = this.minProcess;
      }
      if (correctValue > this.maxProcess) {
        correctValue = this.maxProcess;
      }
      return correctValue;
    }
    getDisplayWidthByProcess(process2) {
      const { width: progressWidth } = this;
      const padding = 12;
      const displayWidth = (progressWidth - padding) * process2;
      return displayWidth;
    }
    runProcessAnimation(value) {
      this.progressAnimation?.stop();
      this.progressAnimation = this.scene.add.tween({
        targets: [this.progressBarBg],
        duration: 300,
        ease: Phaser.Math.Easing.Quadratic.InOut,
        props: {
          displayWidth: () => {
            const process2 = this.getCorrectValue(value);
            return this.getDisplayWidthByProcess(process2);
          }
        },
        onStart: () => {
          const { displayHeight } = this.progressBarBg;
          const displayWidth = this.getDisplayWidthByProcess(this.process);
          this.progressBarBg.setWorldSize(displayWidth, displayHeight);
        },
        onUpdate: () => {
          const { x, displayWidth } = this.progressBarBg;
          this.progressBarRight.setX(x + displayWidth);
        },
        onComplete: () => {
          this.updateProcess();
        }
      });
    }
    createProgressBox() {
      this.progressBoxBg = this.scene.make.image({
        key: KEY2,
        frame: FRAME2.PROGRESS_BAR,
        origin: { x: 0, y: 0.5 }
      });
      Phaser.Display.Align.In.Center(this.progressBoxBg, this);
    }
    createProgressBar() {
      this.progressBarLeft = this.scene.make.image({
        key: KEY2,
        frame: FRAME2.PROGRESS_LEFT,
        origin: { x: 0, y: 0.5 }
      });
      this.progressBarRight = this.scene.make.image({
        key: KEY2,
        frame: FRAME2.PROGRESS_RIGHT,
        origin: { x: 0, y: 0.5 }
      });
      this.progressBarBg = this.scene.make.image({
        key: KEY2,
        frame: FRAME2.PROGRESS_MIDDLE,
        origin: { x: 0, y: 0.5 }
      });
      const posX = -1.5;
      const bgPosX = -5.8;
      Phaser.Display.Align.In.LeftCenter(this.progressBarBg, this, bgPosX);
      Phaser.Display.Align.In.LeftCenter(this.progressBarLeft, this, posX);
      Phaser.Display.Align.In.LeftCenter(this.progressBarRight, this, posX);
      this.setProcess(0, true);
    }
    createContainer() {
      this.add([this.progressBoxBg, this.progressBarBg, this.progressBarLeft, this.progressBarRight]);
      this.scene.add.existing(this);
    }
  };
  var DailyMissionProgress_default = DailyMissionProgress;

  // src/utils/WideframeUtils.ts
  init_phaser_custom_min();
  var {
    Plugins: {
      Analytics: {
        Events: { SHARE }
      }
    }
  } = Ludex;
  var WideframeUtils = class _WideframeUtils {
    static _instance;
    static get inst() {
      if (!this._instance) {
        this._instance = new _WideframeUtils();
      }
      return this._instance;
    }
    static async postBestScoreWideframe() {
      const { player: player33, analytics: analytics20, frameCapture: frameCapture2 } = codex;
      try {
        const { playerId, name: playerName, photo: playerPhoto, data } = player33.getPlayer();
        const { score: playerScore } = data || {};
        const { renderPostBestScore: renderPostBestScore2 } = frameCapture2.wideframe;
        if (!renderPostBestScore2) {
          throw new Error("renderPostBestScore is not defined");
        }
        const imageShare = await renderPostBestScore2({
          playerId,
          playerPhoto,
          playerScore
        });
        this.validateImageRender(imageShare);
        await FBInstant.shareAsync({
          text: "Great! I have a best score!",
          intent: "SHARE",
          image: imageShare ?? "",
          data: { playerId, playerName, playerPhoto, type: "share_invite" }
        });
        MissionUtils_default.addShareScoreMissionProgress(1);
        analytics20.event(SHARE, {
          share_content_type: "BestScore",
          success: true
        });
      } catch (error) {
        analytics20.event(SHARE, {
          share_content_type: "BestScore",
          success: false
        });
        console.warn(error);
      }
    }
    static validateImageRender(imageShare) {
      if (typeof imageShare !== "string" || !imageShare) {
        throw new Error("Invalid wideframe");
      }
    }
  };
  var WideframeUtils_default = WideframeUtils;

  // src/game/screens/common/MissionBlock.ts
  var { KEY: KEY3, FRAME: FRAME3 } = sprites_default.DAILY_MISSIONS;
  var {
    Utils: { Object: O7, Valid: V6 }
  } = Ludex;
  var MissionBlock = class extends Phaser.GameObjects.Container {
    payload;
    process;
    isCompleted;
    background;
    titleText;
    processText;
    progressBar;
    claimButton;
    goButton;
    rewardedIcon;
    rewardValue;
    progressIcon;
    coinIcon;
    constructor(scene, payload) {
      super(scene);
      this.createBackground();
      this.updateSize();
      this.createTitle();
      this.createProcessBar();
      this.createProcessIcon();
      this.createProcessStatus();
      this.createClaimButton();
      this.createGoButton();
      this.createRewardIcon();
      this.createRewardValue();
      this.createRewardedIcon();
      if (payload) {
        this.updateInfo(payload);
      }
    }
    updateInfo(payload) {
      const { missionData, process: process2, onClaim } = payload;
      this.payload = missionData;
      this.process = process2;
      this.onClaim = onClaim;
      this.titleText.setText(missionData.title);
      this.rewardValue.setText(`${missionData.reward.coin}`);
      const missionName = Ludex.Utils.String.toUpperCamelCase(missionData.id);
      const buttonName = `Claim:${missionName}`;
      this.claimButton.setName(buttonName);
      this.assignGoButtonFunctionality(missionData.id);
      this.setName(`Task: ${missionData.id}`);
      this.updateData();
    }
    assignGoButtonFunctionality(missionId) {
      if (missionId.includes("invite-friend")) {
        this.goButton.onClick = this.handleInviteFriends;
        return;
      }
      if (missionId.includes("join-tournament")) {
        this.goButton.onClick = this.handleOpenTournamentScreen;
        return;
      }
      if (missionId.includes("share-score")) {
        this.goButton.onClick = this.handleShareScore;
        return;
      }
      this.goButton.onClick = this.handlePlaySingle;
    }
    setProcess(process2) {
      this.process = process2;
      this.updateData();
    }
    getId() {
      return this.payload.id;
    }
    // Input
    set onClaim(callback) {
      this.claimButton.onClick = this.handleOnClaim(callback);
      this.updateData();
    }
    // Event
    handleOnClaim = (callback) => () => {
      this.rewardedIcon.revive();
      this.claimButton.kill();
      const { id: id2, reward } = this.payload;
      const { x, y } = this.rewardedIcon.getWorldPosition();
      AudioUtils_default.playSound(soundEffects_default.GIFT_EXPLODE, {
        volume: 0.3
      });
      MissionUtils_default.setMissionRewardClaimed(id2);
      const rewardTypes = Object.keys(reward);
      for (const type of rewardTypes) {
        const value = reward[type];
        const payload = {
          type,
          value,
          claimButtonX: x,
          claimButtonY: y
        };
        callback(payload);
      }
    };
    // Logic
    // TODO: support multi require
    getProcessValue() {
      const { require: require2 } = this.payload;
      if (!V6.isObject(require2)) return { current: 0, target: 0 };
      const requireIds = Object.keys(require2);
      let target = 0;
      let current = 0;
      for (const id2 of requireIds) {
        if (!O7.hasOwn(require2, id2)) continue;
        const value = require2[id2];
        if (!V6.isNumber(value)) continue;
        target = value;
        const processValue = this.process.require[id2];
        current = typeof processValue === "number" ? processValue : 0;
      }
      return { current, target };
    }
    updateData = () => {
      const { current, target } = this.getProcessValue();
      const process2 = current / target;
      this.progressBar.setProcess(process2, true);
      const frame = MissionUtils_default.getMissionProgressIcon(this.payload.id);
      this.progressIcon.setFrame(frame);
      this.alignProcessIcon();
      this.setProcessText(current, target);
      this.isCompleted = current >= target && !this.process?.rewarded;
      if (this.isCompleted) {
        this.claimButton.revive();
        this.goButton.kill();
        this.rewardedIcon.kill();
        this.coinIcon.revive();
        this.rewardValue.revive();
        return;
      }
      if (this.process?.rewarded) {
        this.claimButton.kill();
        this.goButton.kill();
        this.rewardedIcon.revive();
        this.coinIcon.kill();
        this.rewardValue.kill();
        return;
      }
      this.claimButton.kill();
      this.goButton.revive();
      this.rewardedIcon.kill();
      this.coinIcon.revive();
      this.rewardValue.revive();
    };
    setProcessText(current, target) {
      this.processText.setText(`${current > target ? target : current}/${target}`);
    }
    createRewardedIcon() {
      this.rewardedIcon = this.scene.make.image({
        key: KEY3,
        frame: FRAME3.ICON_CHECK
      });
      this.add(this.rewardedIcon);
      Phaser.Display.Align.In.RightCenter(this.rewardedIcon, this.background, -35, -1.5);
      this.rewardedIcon.kill();
    }
    // Draw
    createBackground() {
      this.background = this.scene.make.image({
        key: KEY3,
        frame: FRAME3.BLOCK
      });
      this.add(this.background);
    }
    updateSize() {
      const { width, height } = this.background;
      this.setSize(width, height);
    }
    createTitle() {
      this.titleText = FontUtils_default.createText(this.scene, "", 9).setWordWrapWidth(90).setOrigin(
      0, 0.5).setLineSpacing(-2).setTint(8406559);
      this.add(this.titleText);
      Phaser.Display.Align.In.LeftCenter(this.titleText, this.background, -58, -10);
    }
    createProcessBar() {
      this.progressBar = new DailyMissionProgress_default(this.scene);
      this.add(this.progressBar);
      Phaser.Display.Align.In.Center(this.progressBar, this.background, -22, 10);
    }
    createProcessIcon() {
      this.progressIcon = this.scene.make.image({
        key: KEY3,
        frame: FRAME3.MISSION_HINT,
        origin: { x: 0.5, y: 0.5 }
      });
      this.add(this.progressIcon);
      Phaser.Display.Align.In.LeftCenter(this.progressIcon, this.background, -15, -2);
    }
    createProcessStatus() {
      this.processText = FontUtils_default.createText(this.scene, "", 9).setShadow(0, 1, "#000000", 1).
      setFontStyle("700");
      this.add(this.processText);
      Phaser.Display.Align.In.Center(this.processText, this, -21, 10);
    }
    createClaimButton() {
      this.claimButton = new Button_default(this.scene, KEY3, FRAME3.GREEN_BUTTON);
      const claimLabel = FontUtils_default.createText(this.scene, "Claim", 12).setFontStyle("800");
      FontUtils_default.applyGreenStyle(claimLabel);
      this.claimButton.add(claimLabel);
      Phaser.Display.Align.In.Center(claimLabel, this.claimButton);
      this.add(this.claimButton);
      Phaser.Display.Align.In.RightCenter(this.claimButton, this, -6, -1.5);
    }
    createGoButton() {
      this.goButton = new Button_default(this.scene, KEY3, FRAME3.BLUE_BUTTON);
      const goLabel = FontUtils_default.createText(this.scene, "Go", 12).setFontStyle("800");
      FontUtils_default.applyBlueStyle(goLabel);
      this.goButton.add(goLabel);
      Phaser.Display.Align.In.Center(goLabel, this.goButton);
      this.add(this.goButton);
      Phaser.Display.Align.In.RightCenter(this.goButton, this, -6, -1.5);
    }
    createRewardIcon() {
      this.coinIcon = this.scene.make.image({
        key: KEY3,
        frame: FRAME3.COIN
      });
      this.add(this.coinIcon);
      Phaser.Display.Align.In.Center(this.coinIcon, this.background, 43, -3);
    }
    createRewardValue() {
      this.rewardValue = FontUtils_default.createText(this.scene, "", 13).setOrigin(0.5, 0).setFontStyle(
      "700");
      FontUtils_default.applyOrangeStyle(this.rewardValue);
      this.add(this.rewardValue);
      Phaser.Display.Align.In.Center(this.rewardValue, this.coinIcon, 0, 10);
    }
    alignProcessIcon() {
      const { name } = this.progressIcon.frame;
      switch (name) {
        case FRAME3.MISSION_BOMB_DEFUSE:
        case FRAME3.MISSION_SHARE_SCORE:
          this.progressIcon.setOrigin(0.6, 0.5);
          break;
        case FRAME3.MISSION_JOIN_TOURNAMENT:
          this.progressIcon.setOrigin(0.52, 0.5);
          break;
        default:
          this.progressIcon.setOrigin(0.5, 0.5);
          break;
      }
    }
    handlePlaySingle = async () => {
      const success = await MatchUtils_default.startSingleModeAsync();
      if (!success) return;
      SceneUtils_default.switchToGameScene();
    };
    handleOpenTournamentScreen = async () => {
      ScreenUtils_default.closeScreen(ScreenKeys_default.DAILY_MISSIONS_SCREEN);
      ScreenUtils_default.openScreen(ScreenKeys_default.TOURNAMENTS_SCREEN);
    };
    handleShareScore = async () => {
      try {
        ScreenUtils_default.showLoadingScreen();
        await WideframeUtils_default.postBestScoreWideframe();
      } catch (error) {
        console.warn(error);
      } finally {
        ScreenUtils_default.closeLoadingScreen();
      }
    };
    handleInviteFriends = async () => {
      const success = await MatchUtils_default.autoChallengeModeAsync();
      if (!success) return;
      SceneUtils_default.switchToGameScene();
    };
    async runShowItemAnimation(delay, duration) {
      this.scene.tweens.killTweensOf(this);
      this.setScale(1);
      this.setAlpha(0);
      return new Promise((resolve) => {
        this.scene.tweens.add({
          targets: this,
          duration,
          delay,
          props: {
            alpha: {
              duration: 500,
              value: { start: 0, from: 0, to: 1 },
              ease: Phaser.Math.Easing.Cubic.Out
            },
            scale: {
              duration: 800,
              start: 0.8,
              end: 1,
              value: { start: 0.8, from: 0.8, to: 1 },
              ease: Phaser.Math.Easing.Elastic.Out,
              easeParams: [0.1, 0.45]
            }
          },
          onComplete: () => {
            resolve();
          },
          onStop: () => {
            resolve();
          }
        });
      });
    }
  };
  var MissionBlock_default = MissionBlock;

  // src/game/components/scroller/ReuseScroller.ts
  init_phaser_custom_min();

  // src/game/components/scroller/Scroller.ts
  init_phaser_custom_min();

  // src/game/components/scroller/SimpleScroller.ts
  init_phaser_custom_min();

  // src/game/animations/lerp/exponentialDecay.ts
  init_phaser_custom_min();
  function exponentialDecay(a, b, decay, dt) {
    return b + (a - b) * Math.exp(-decay * dt);
  }

  // src/game/components/scroller/constants/ScrollerEvents.ts
  init_phaser_custom_min();
  var ScrollEvents = {
    SCROLL: "scroll",
    SCROLL_VALUE_CHANGED: "scroll-value-changed"
  };

  // src/game/components/scroller/SimpleScroller.ts
  var SimpleScroller = class _SimpleScroller extends Phaser.GameObjects.Container {
    config;
    content;
    currentResponse = 0;
    targetY = 0;
    lastVelocityY = {
      value: 0,
      timeStamp: 0
    };
    isScrolling = false;
    static parseMaxScrollOver(config) {
      const { maxOverScroll } = config;
      const defaultScrollOver = 0.15 * config.size.height;
      if (maxOverScroll === void 0) {
        return { top: defaultScrollOver, bottom: defaultScrollOver };
      }
      if (typeof maxOverScroll === "number") {
        return { top: maxOverScroll, bottom: maxOverScroll };
      }
      return {
        top: maxOverScroll.top ?? defaultScrollOver,
        bottom: maxOverScroll.bottom ?? defaultScrollOver
      };
    }
    static parseConfig(config) {
      return {
        // ? Defaults
        contentSize: {
          ...config.size
        },
        response: Phaser.Math.Clamp(config.response ?? 25, 1, 25),
        flickResponse: Phaser.Math.Clamp(config.flickResponse ?? 3, 1, 25),
        distancePerScrollWheel: 0.5,
        flickVelocityMultiplier: 5,
        flickTimeOut: 20,
        sticky: config.sticky ?? "top",
        // ? Override
        ...config,
        // ? Custom parsers
        maxOverScroll: _SimpleScroller.parseMaxScrollOver(config)
      };
    }
    constructor(scene, config) {
      super(scene);
      this.config = _SimpleScroller.parseConfig(config);
      const {
        size: { width, height },
        contentSize: { width: contentWidth, height: contentHeight },
        response
      } = this.config;
      this.currentResponse = response;
      this.setSize(width, height);
      this.content = this.scene.make.container({});
      this.content.setSize(contentWidth, contentHeight);
      this.add(this.content);
      this.setScrollInteractive();
      this.listenToEvents();
      this.scene.add.existing(this);
    }
    /**
     * Calls this.content.setSize() and update scroll position to maintain the current scroll position
     * @param height - The new height of the content
     */
    setContentHeight(height) {
      const currentY = this.content.y;
      const offsetY = (height - this.content.height) / 2;
      const newY = currentY + offsetY;
      const newTargetY = this.targetY + offsetY;
      this.content.setWorldSize(this.width, height);
      this.content.setY(newY);
      this.targetY = newTargetY;
    }
    scrollToTop(immediate = false) {
      this.targetY = this.getYAtTop();
      if (immediate) {
        this.content.y = this.targetY;
        this.isScrolling = false;
      } else {
        this.isScrolling = true;
      }
      this.emitOnScrollValueChangedEvent();
    }
    scrollToBottom(immediate = false) {
      this.targetY = this.getYAtBottom();
      if (immediate) {
        this.content.y = this.targetY;
        this.isScrolling = false;
      } else {
        this.isScrolling = true;
      }
      this.emitOnScrollValueChangedEvent();
    }
    scrollTo(y, immediate = false) {
      this.targetY = y;
      if (immediate) {
        this.content.y = y;
        this.isScrolling = false;
      } else {
        this.isScrolling = true;
      }
      this.emitOnScrollValueChangedEvent();
    }
    reset(immediate = false) {
      this.targetY = 0;
      if (immediate) {
        this.content.y = 0;
        this.isScrolling = false;
      } else {
        this.isScrolling = true;
      }
    }
    setEnabled(isEnabled = true) {
      this.setScrollInteractive(isEnabled);
    }
    update(_time, delta) {
      if (!this.isScrolling) return;
      const isWithinSnapDistance = Math.abs(this.targetY - this.content.y) < 0.01;
      if (isWithinSnapDistance) {
        this.content.y = this.targetY;
        this.isScrolling = false;
      } else {
        const response = this.currentResponse;
        const seconds = delta / 1e3;
        const current = exponentialDecay(this.content.y, this.targetY, response, seconds);
        this.content.y = current;
      }
      this.emitOnScrollValueChangedEvent();
    }
    preDestroy() {
      super.preDestroy();
      this.unlistenToEvents();
    }
    getStickyY() {
      const { sticky } = this.config;
      if (sticky === "top") {
        return this.getYAtTop();
      }
      if (sticky === "bottom") {
        return this.getYAtBottom();
      }
      return 0;
    }
    setScrollInteractive(isInteractive = true) {
      if (isInteractive) {
        this.setInteractive({
          draggable: true,
          useHandCursor: true
        });
      } else {
        this.disableInteractive();
      }
    }
    listenToEvents() {
      this.on(Phaser.Input.Events.POINTER_WHEEL, this.onMouseScroll, this);
      this.on(Phaser.Input.Events.GAMEOBJECT_DRAG, this.onTouchScroll, this);
      this.on(Phaser.Input.Events.GAMEOBJECT_POINTER_DOWN, this.onTouchDown, this);
      this.scene.input.on(Phaser.Input.Events.POINTER_UP, this.onTouchEnd, this);
      this.scene.events.on(Phaser.Scenes.Events.UPDATE, this.update, this);
    }
    unlistenToEvents() {
      this.off(Phaser.Input.Events.POINTER_WHEEL, this.onMouseScroll, this);
      this.off(Phaser.Input.Events.GAMEOBJECT_DRAG, this.onTouchScroll, this);
      this.off(Phaser.Input.Events.GAMEOBJECT_POINTER_DOWN, this.onTouchDown, this);
      this.scene.input.off(Phaser.Input.Events.POINTER_UP, this.onTouchEnd, this);
      this.scene.events.off(Phaser.Scenes.Events.UPDATE, this.update, this);
    }
    emitOnScrollEvents(value, delta) {
      this.emit(ScrollEvents.SCROLL, { scroller: this, value, delta });
    }
    emitOnScrollValueChangedEvent() {
      this.emit(ScrollEvents.SCROLL_VALUE_CHANGED, { scroller: this });
    }
    calcDistUnderTop(y) {
      const yValue = y ?? this.content.y;
      return yValue - this.content.height * 0.5 - -this.height * 0.5;
    }
    calcDistAboveBottom(y) {
      const yValue = y ?? this.content.y;
      return this.height * 0.5 - (yValue + this.content.height * 0.5);
    }
    getYAtTop(withScrollOver = false) {
      const scrollOver = withScrollOver ? this.config.maxOverScroll.top : 0;
      return this.content.height * 0.5 - this.height * 0.5 + scrollOver;
    }
    getYAtBottom(withScrollOver = false) {
      const scrollOver = withScrollOver ? this.config.maxOverScroll.bottom : 0;
      return -this.content.height * 0.5 - -this.height * 0.5 - scrollOver;
    }
    onMouseScroll(_pointer, _deltaX, deltaY) {
      this.isScrolling = true;
      this.currentResponse = this.config.response;
      const posY = -deltaY * this.config.distancePerScrollWheel * WorldUtils_default.getZoomRatio();
      let targetY = this.targetY + posY;
      const isContentSmallerThanScroller = this.height >= this.content.height;
      if (isContentSmallerThanScroller) {
        targetY = this.getStickyY();
        this.targetY = targetY;
        this.emitOnScrollEvents(this.targetY, posY);
        return;
      }
      const distPassedTop = this.calcDistUnderTop(targetY);
      const distPassedBottom = this.calcDistAboveBottom(targetY);
      if (distPassedTop > 0) {
        targetY = this.getYAtTop();
      }
      if (distPassedBottom > 0) {
        targetY = this.getYAtBottom();
      }
      this.targetY = targetY;
      this.emitOnScrollEvents(this.targetY, posY);
    }
    onTouchScroll(pointer) {
      this.isScrolling = true;
      this.currentResponse = this.config.response;
      const { position, prevPosition, velocity } = pointer;
      const posY = (position.y - prevPosition.y) / WorldUtils_default.getZoomRatio();
      this.lastVelocityY = {
        value: Math.abs(velocity.y) > 100 ? velocity.y * this.config.flickVelocityMultiplier : 0,
        timeStamp: Date.now()
      };
      let targetY = this.targetY + posY;
      const isContentSmallerThanScroller = this.height >= this.content.height;
      if (isContentSmallerThanScroller) {
        const smallOverScroll = Math.min(
          (this.height - this.content.height) / 2 * 0.8,
          this.config.maxOverScroll.top,
          this.config.maxOverScroll.bottom
        );
        const stickyY = this.getStickyY();
        const isInsideOverScrollRange = stickyY - smallOverScroll < targetY && targetY < stickyY + smallOverScroll;
        if (isInsideOverScrollRange) {
          targetY = this.targetY + posY / 2;
        } else {
          targetY = Phaser.Math.Clamp(targetY, stickyY - smallOverScroll, stickyY + smallOverScroll);
        }
        this.targetY = targetY;
        this.emitOnScrollEvents(this.targetY, posY);
        return;
      }
      const distPassedTop = this.calcDistUnderTop(targetY);
      const distPassedBottom = this.calcDistAboveBottom(targetY);
      if (distPassedTop > 0) {
        const isInsideOverScrollRange = distPassedTop < this.config.maxOverScroll.top;
        if (isInsideOverScrollRange) {
          targetY = this.targetY + posY / 2;
        } else {
          targetY = this.getYAtTop(true);
        }
      }
      if (distPassedBottom > 0) {
        const isInsideOverScrollRange = distPassedBottom < this.config.maxOverScroll.bottom;
        if (isInsideOverScrollRange) {
          targetY = this.targetY + posY / 2;
        } else {
          targetY = this.getYAtBottom(true);
        }
      }
      this.targetY = targetY;
      this.emitOnScrollEvents(this.targetY, posY);
    }
    onTouchDown() {
      if (this.isScrolling) {
        this.targetY = this.content.y;
      }
      this.isScrolling = true;
    }
    onTouchEnd() {
      this.isScrolling = true;
      let distPassedTop = this.calcDistUnderTop(this.targetY);
      let distPassedBottom = this.calcDistAboveBottom(this.targetY);
      const isFlick = Math.abs(this.lastVelocityY.value) > 0 && Math.abs(Date.now() - this.lastVelocityY.
      timeStamp) < this.config.flickTimeOut && distPassedBottom <= 0 && distPassedTop <= 0;
      if (isFlick) {
        const posY = this.targetY + this.lastVelocityY.value;
        this.targetY = posY;
        this.lastVelocityY = { value: 0, timeStamp: 0 };
        this.currentResponse = this.config.flickResponse;
      }
      const isContentSmallerThanScroller = this.height >= this.content.height;
      if (isContentSmallerThanScroller) {
        this.targetY = this.getStickyY();
        return;
      }
      distPassedTop = this.calcDistUnderTop(this.targetY);
      distPassedBottom = this.calcDistAboveBottom(this.targetY);
      if (distPassedTop > 0) {
        this.targetY = this.getYAtTop();
        return;
      }
      if (distPassedBottom > 0) {
        this.targetY = this.getYAtBottom();
      }
    }
  };
  var SimpleScroller_default = SimpleScroller;

  // src/game/components/scroller/Scroller.ts
  var Scroller = class _Scroller extends SimpleScroller_default {
    visualConfig;
    boundTop;
    boundBottom;
    maskGraphics;
    objects;
    contentDebug;
    static parseMarginConfig(config) {
      const { margin } = config.visual ?? {};
      const defaultMargin = 0;
      if (margin === void 0) {
        return { top: defaultMargin, bottom: defaultMargin };
      }
      if (typeof margin === "number") {
        return { top: margin, bottom: margin };
      }
      return {
        top: margin.top ?? defaultMargin,
        bottom: margin.bottom ?? defaultMargin
      };
    }
    static parseBoundsConfig(config) {
      const { bounds = false } = config.visual ?? {};
      if (typeof bounds !== "boolean")
        return {
          key: sprites_default.DEFAULT.KEY,
          frame: sprites_default.DEFAULT.FRAME.BLANK,
          height: 20,
          tint: 9917991,
          ...bounds
        };
      if (bounds)
        return {
          key: sprites_default.DEFAULT.KEY,
          frame: sprites_default.DEFAULT.FRAME.BLANK,
          height: 20,
          tint: 9917991
        };
      return false;
    }
    static parseBoundDetectionPaddingConfig(config) {
      const { boundDetectionPadding } = config.visual ?? {};
      const defaultBoundDetectionPadding = 0;
      if (boundDetectionPadding === void 0) {
        return {
          top: defaultBoundDetectionPadding,
          bottom: defaultBoundDetectionPadding
        };
      }
      if (typeof boundDetectionPadding === "number") {
        return {
          top: boundDetectionPadding,
          bottom: boundDetectionPadding
        };
      }
      return {
        top: boundDetectionPadding.top ?? defaultBoundDetectionPadding,
        bottom: boundDetectionPadding.bottom ?? defaultBoundDetectionPadding
      };
    }
    static parseVisualConfig(config) {
      return {
        mask: false,
        spacing: 0,
        onEnterViewport: () => {
        },
        onExitViewport: () => {
        },
        ...config.visual,
        margin: _Scroller.parseMarginConfig(config),
        bounds: _Scroller.parseBoundsConfig(config),
        boundDetectionPadding: _Scroller.parseBoundDetectionPaddingConfig(config)
      };
    }
    static parseBaseConfig(config) {
      const visualConfig = _Scroller.parseVisualConfig(config);
      const { contentSize = { ...config.size } } = config;
      const width = contentSize.width;
      const height = contentSize.height + visualConfig.margin.top + visualConfig.margin.bottom;
      return {
        visualConfig,
        contentSize: { width, height }
      };
    }
    constructor(scene, config) {
      const { visualConfig, contentSize } = _Scroller.parseBaseConfig(config);
      super(scene, {
        ...config,
        contentSize
      });
      this.visualConfig = visualConfig;
      this.createGroup();
      if (this.visualConfig.mask) {
        this.createMask();
      }
      if (this.visualConfig.bounds) {
        this.createBounds(
          this.visualConfig.bounds.key,
          this.visualConfig.bounds.frame,
          this.visualConfig.bounds.height,
          this.visualConfig.bounds.tint
        );
      }
    }
    addItems(...objects) {
      this.content.addAt(objects);
      this.objects.addMultiple(objects);
      const contentHeight = this.calcContentHeight();
      this.setContentHeight(contentHeight);
      this.updateObjectPosition();
      this.updateObjectVisibility();
    }
    clearItem() {
      this.objects.clear(true, true);
      this.reset(true);
    }
    getChildren() {
      return this.objects.getChildren().filter((o) => o.active);
    }
    updateMaskScale(scale) {
      if (!this.visualConfig.mask) return;
      this.maskGraphics.setScale(scale);
    }
    scrollToTop(immediate) {
      super.scrollToTop(immediate);
      this.updateObjectVisibility();
    }
    scrollToBottom(immediate) {
      super.scrollToBottom(immediate);
      this.updateObjectVisibility();
    }
    scrollTo(y, immediate, snapToBounds = true) {
      if (!snapToBounds) {
        super.scrollTo(y, immediate);
        this.updateObjectVisibility();
        return;
      }
      const isContentSmallerThanScroller = this.height >= this.content.height;
      if (isContentSmallerThanScroller) {
        super.scrollTo(this.getStickyY(), immediate);
        this.updateObjectVisibility();
        return;
      }
      const distPassedTop = this.calcDistUnderTop(y);
      const distPassedBottom = this.calcDistAboveBottom(y);
      if (distPassedTop > 0) {
        super.scrollTo(this.getYAtTop(), immediate);
        this.updateObjectVisibility();
        return;
      }
      if (distPassedBottom > 0) {
        super.scrollTo(this.getYAtBottom(), immediate);
        this.updateObjectVisibility();
        return;
      }
      super.scrollTo(y, immediate);
      this.updateObjectVisibility();
    }
    update(time, delta) {
      super.update(time, delta);
      if (this.isScrolling) {
        this.updateObjectVisibility();
      }
    }
    updateMask() {
      const { x, y } = this.getWorldPosition();
      this.maskGraphics.setPosition(x, y);
    }
    createGroup() {
      this.objects = this.scene.make.group({});
    }
    createMask() {
      this.maskGraphics?.destroy();
      this.maskGraphics = this.scene.make.graphics({
        fillStyle: { color: 255, alpha: 1 }
      });
      this.maskGraphics.setName("MaskGraphics");
      const displayWidth = this.width;
      const displayHeight = this.height;
      this.maskGraphics.fillRoundedRect(0 - displayWidth / 2, 0 - displayHeight / 2, displayWidth, displayHeight,
      0);
      this.setMask(this.maskGraphics.createGeometryMask());
      this.scene.events.off(Phaser.Scenes.Events.UPDATE, this.updateMask, this);
      this.scene.events.on(Phaser.Scenes.Events.UPDATE, this.updateMask, this);
    }
    createBounds(key, frame, height, tint) {
      if (!(this.scene.renderer instanceof Phaser.Renderer.WebGL.WebGLRenderer)) {
        console.warn("Scroller: Bounds is not supported in WebGL renderer");
        return;
      }
      this.boundTop = this.scene.make.image({ key, frame });
      this.boundBottom = this.scene.make.image({ key, frame });
      this.boundTop.setTint(tint);
      this.boundBottom.setTint(tint);
      this.boundTop.setAlpha(1, 1, 0, 0);
      this.boundBottom.setAlpha(0, 0, 1, 1);
      this.boundTop.setDepth(depth_default.PRIORITY);
      this.boundBottom.setDepth(depth_default.PRIORITY);
      const displayWidth = this.width;
      const displayHeight = height;
      const { x, y } = this.getWorldPosition();
      this.boundTop.setDisplaySize(displayWidth, displayHeight);
      this.boundBottom.setDisplaySize(displayWidth, displayHeight);
      this.boundTop.setY(-this.displayHeight / 2 + displayHeight / 2 + y - this.y - 1);
      this.boundBottom.setY(this.displayHeight / 2 - displayHeight / 2 + y - this.y + 1);
      this.boundTop.setX(x - this.x);
      this.boundBottom.setX(x - this.x);
      this.add([this.boundTop, this.boundBottom]);
    }
    updateObjectPosition() {
      const objs = this.objects.getChildren();
      let currentY = -this.content.height / 2 + this.visualConfig.margin.top;
      for (const obj of objs) {
        obj.setPosition(0, currentY + obj.height / 2);
        currentY += obj.height + this.visualConfig.spacing;
      }
    }
    updateObjectVisibility() {
      const objs = this.objects.getChildren();
      const lowerbound = -this.content.y - this.height / 2 + this.visualConfig.boundDetectionPadding.
      top;
      const upperbound = -this.content.y + this.height / 2 - this.visualConfig.boundDetectionPadding.
      bottom;
      for (const obj of objs) {
        const objLowerbound = obj.y - obj.height / 2;
        const objUpperbound = obj.y + obj.height / 2;
        const isInViewport = objLowerbound < upperbound && objUpperbound > lowerbound;
        this.setObjectInViewport(obj, isInViewport);
      }
    }
    setObjectInViewport(obj, isInViewport) {
      if (isInViewport) {
        if (obj.visible) return;
        obj.setVisible(true);
        this.visualConfig.onEnterViewport?.call(this, obj);
      } else {
        if (!obj.visible) return;
        this.visualConfig.onExitViewport?.call(this, obj);
        obj.setVisible(false);
      }
    }
    calcContentHeight() {
      const objs = this.objects.getChildren();
      const sumOfObjHeights = objs.reduce((acc, obj) => acc + obj.height, 0);
      const sumOfSpacing = this.visualConfig.spacing * (objs.length - 1);
      const height = sumOfObjHeights + this.visualConfig.margin.top + this.visualConfig.margin.bottom +
      sumOfSpacing;
      return height;
    }
  };

  // src/game/components/scroller/ReuseScroller.ts
  var ReuseScroller = class extends Scroller {
    depthStrategy;
    ContentClassType;
    configs;
    objectUpdater;
    contentGameObjects = [];
    constructor(scene, config) {
      super(scene, config);
      this.depthStrategy = config.reuse.depthStrategy ?? "none";
      this.ContentClassType = config.reuse.ClassType;
      this.configs = [...config.reuse.configs];
      this.objectUpdater = config.reuse.update;
      this.objects.classType = this.ContentClassType;
      this.setConfigs(this.configs);
    }
    reset(immediate = false) {
      super.reset(immediate);
      this.killAndHideAll();
    }
    getChildren() {
      const objs = [];
      for (const o of this.contentGameObjects) {
        if (o.gameObject === void 0) continue;
        objs.push(o.gameObject);
      }
      return objs;
    }
    setConfigs(configs) {
      this.killAndHideAll();
      this.configs = [...configs];
      this.contentGameObjects = [];
      for (const config of configs) {
        this.contentGameObjects.push({ config, gameObject: void 0 });
      }
      this.updateObjectVisibility();
    }
    /**
     * @deprecated Use setConfigs instead
     */
    addItems(...objects) {
      super.addItems(...objects);
    }
    scrollToConfig(index, immediate = false, snapToBounds = true) {
      if (index < 0 || index >= this.configs.length) return;
      const maxObjHeight = this.getMaxObjectHeight();
      const yAfterMargin = -this.content.height / 2 + this.visualConfig.margin.top;
      const objHeightWithSpacing = maxObjHeight + this.visualConfig.spacing;
      const targetY = -(yAfterMargin + index * objHeightWithSpacing + maxObjHeight / 2);
      this.scrollTo(targetY, immediate, snapToBounds);
    }
    scrollToConfigWithTween(index, immediate = false, onComplete) {
      if (index < 0 || index >= this.configs.length) return;
      const maxObjHeight = this.getMaxObjectHeight();
      const yAfterMargin = -this.content.height / 2 + this.visualConfig.margin.top;
      const objHeightWithSpacing = maxObjHeight + this.visualConfig.spacing;
      let targetY = -(yAfterMargin + index * objHeightWithSpacing + maxObjHeight / 2);
      if (this.height >= this.content.height) {
        targetY = this.getStickyY();
      } else {
        const scrollY = targetY;
        if (this.calcDistUnderTop(scrollY) > 0) {
          targetY = this.getYAtTop();
        } else if (this.calcDistAboveBottom(scrollY) > 0) {
          targetY = this.getYAtBottom();
        }
      }
      if (this.content.y === targetY) {
        this.updateObjectVisibility();
        onComplete?.();
        return;
      }
      if (immediate) {
        this.targetY = targetY;
        this.content.y = targetY;
        this.updateObjectVisibility();
        onComplete?.();
        return;
      }
      this.targetY = targetY;
      this.isScrolling = false;
      this.scene.add.tween({
        targets: [this.content],
        duration: 1e3,
        props: {
          y: {
            getEnd: () => this.targetY
          }
        },
        ease: Phaser.Math.Easing.Quintic.Out,
        onUpdate: () => {
          this.updateObjectVisibility();
        },
        onComplete: () => {
          this.content.y = targetY;
          this.targetY = targetY;
          this.isScrolling = true;
          this.updateObjectVisibility();
          onComplete?.();
        }
      });
    }
    getMaxObjectHeight() {
      if (this.configs.length === 0) return Infinity;
      const objs = this.objects.getChildren();
      if (objs.length !== 0) {
        const max2 = Math.max(...objs.map((o) => o.height));
        return max2;
      }
      this.setObjectActive(0);
      const max = this.contentGameObjects[0].gameObject?.height;
      if (max === void 0) return Infinity;
      this.setObjectInactive(0);
      return max;
    }
    killAndHideAll() {
      for (let i = 0; i < this.contentGameObjects.length; i++) {
        const o = this.contentGameObjects[i];
        if (o.gameObject === void 0) continue;
        this.contentGameObjects[i] = {
          config: o.config,
          gameObject: void 0
        };
        this.objects.killAndHide(o.gameObject);
      }
    }
    updateObjectPosition() {
      const configs = this.configs;
      const maxObjHeight = this.getMaxObjectHeight();
      let currentY = -this.content.height / 2 + this.visualConfig.margin.top;
      for (let i = 0; i < configs.length; i++) {
        const obj = this.contentGameObjects[i].gameObject;
        if (obj !== void 0) {
          obj.setPosition(0, currentY + maxObjHeight / 2);
        }
        currentY += maxObjHeight + this.visualConfig.spacing;
      }
    }
    updateObjectVisibility() {
      const configs = this.configs;
      const lowerbound = -this.content.y - this.height / 2 + this.visualConfig.boundDetectionPadding.
      top;
      const upperbound = -this.content.y + this.height / 2 - this.visualConfig.boundDetectionPadding.
      bottom;
      const maxObjHeight = this.getMaxObjectHeight();
      const yAfterMargin = -this.content.height / 2 + this.visualConfig.margin.top;
      const objHeightWithSpacing = maxObjHeight + this.visualConfig.spacing;
      const indicesInViewport = [];
      for (let i = 0; i < configs.length; i++) {
        const objY = yAfterMargin + i * objHeightWithSpacing + maxObjHeight / 2;
        const objLowerbound = objY - maxObjHeight / 2;
        const objUpperbound = objY + maxObjHeight / 2;
        const isInViewport = objLowerbound < upperbound && objUpperbound > lowerbound;
        this.setReusableObjectInViewport(i, isInViewport);
        if (isInViewport) indicesInViewport.push(i);
      }
      for (const index of indicesInViewport) {
        const item = this.contentGameObjects[index].gameObject;
        if (item === void 0) continue;
        this.tryUpdateObjectDepths(item);
      }
    }
    setReusableObjectInViewport(index, isInViewport) {
      const existingObj = this.contentGameObjects[index]?.gameObject;
      if (!isInViewport) {
        if (existingObj) this.visualConfig.onExitViewport?.call(this, existingObj);
        this.setObjectInactive(index);
        return;
      }
      this.setObjectActive(index);
      const obj = this.contentGameObjects[index]?.gameObject;
      const isNewlyCreated = existingObj === void 0 && obj !== void 0;
      if (isNewlyCreated) this.visualConfig.onEnterViewport?.call(this, obj);
    }
    calcContentHeight() {
      const maxObjHeight = this.getMaxObjectHeight();
      const sumOfObjHeights = maxObjHeight * this.configs.length;
      const sumOfSpacing = this.visualConfig.spacing * (this.configs.length - 1);
      const height = sumOfObjHeights + this.visualConfig.margin.top + this.visualConfig.margin.bottom +
      sumOfSpacing;
      return height;
    }
    setObjectActive(index) {
      const existing = this.contentGameObjects[index];
      if (existing?.gameObject !== void 0) return;
      const item = this.objects.getFirstDead(true);
      if (item === null || item === void 0) return;
      const config = this.configs[index];
      this.objectUpdater(item, config);
      item.setActive(true);
      item.setVisible(true);
      this.content.addAt(item);
      this.contentGameObjects[index] = {
        config,
        gameObject: item
      };
      const contentHeight = this.calcContentHeight();
      this.setContentHeight(contentHeight);
      this.updateObjectPosition();
    }
    setObjectInactive(index) {
      const existing = this.contentGameObjects[index];
      if (existing?.gameObject === void 0) return;
      this.objects.killAndHide(existing.gameObject);
      this.contentGameObjects[index] = {
        config: existing.config,
        gameObject: void 0
      };
    }
    tryUpdateObjectDepths(item) {
      if (this.depthStrategy === "none") return;
      switch (this.depthStrategy) {
        case "top-to-bottom":
          this.content.sendToBack(item);
          break;
        case "bottom-to-top":
          this.content.bringToTop(item);
          break;
      }
    }
  };

  // src/utils/CoinUtils.ts
  init_phaser_custom_min();
  var CoinUtils = class _CoinUtils {
    static _instance;
    static coin = 0;
    static get inst() {
      if (!this._instance) {
        this._instance = new _CoinUtils();
      }
      return this._instance;
    }
    static getCoin() {
      return this.coin;
    }
    static setCoin(coin) {
      this.coin = coin;
      this.saveCoin();
      this.emitCoinChanged();
    }
    static addCoin(coin) {
      this.coin += coin;
      this.saveCoin();
      this.emitCoinChanged();
    }
    static removeCoin(coin) {
      this.coin -= coin;
      if (this.coin < 0) this.coin = 0;
      this.saveCoin();
      this.emitCoinChanged();
    }
    static saveCoin() {
      const { player: player33 } = codex;
      player33.setGameData({
        coins: this.coin
      });
    }
    static loadCoin() {
      const { player: player33 } = codex;
      const playerGameData = player33.getGameData();
      this.coin = playerGameData?.coins ?? 0;
    }
    static emitCoinChanged() {
      const { event: event49 } = codex;
      event49.emit(GameEvents_default.COINS_CHANGED);
    }
  };
  var CoinUtils_default = CoinUtils;

  // src/game/scenes/dashboard-scene/components/CoinsBar.ts
  init_phaser_custom_min();
  var {
    Utils: { Number: N2 }
  } = Ludex;
  var {
    DASHBOARD: { KEY: KEY4, FRAME: FRAME4 }
  } = sprites_default;
  var CoinsBar = class extends Phaser.GameObjects.Container {
    background;
    icon;
    text;
    coinCount;
    constructor(scene) {
      super(scene);
      this.setWorldSize(80, 30);
      this.createBackground();
      this.createIcon();
      this.createText();
      this.coinCount = 0;
      this.setDepth(depth_default.BUTTON);
      this.scene.add.existing(this);
    }
    createBackground() {
      this.background = this.scene.add.image(0, 0, KEY4, FRAME4.COIN_PANEL);
      this.add(this.background);
    }
    createIcon() {
      this.icon = this.scene.add.image(0, 0, KEY4, FRAME4.ICON_COIN);
      this.add(this.icon);
      Phaser.Display.Align.In.LeftCenter(this.icon, this.background);
    }
    createText() {
      this.text = FontUtils_default.createText(this.scene, "0", 14).setFontStyle("900");
      FontUtils_default.applyYellowStyle(this.text);
      this.add(this.text);
      Phaser.Display.Align.In.Center(this.text, this.background, 10, 1);
    }
    setCoins(coins) {
      this.coinCount = coins;
      const text = N2.getShortNumber(coins, 3);
      this.text.setText(text);
    }
    incCoins(coins) {
      this.coinCount += coins;
      const text = N2.getShortNumber(this.coinCount, 3);
      this.text.setText(text);
    }
    updatePlayerCoin() {
      const coins = CoinUtils_default.getCoin();
      this.setCoins(coins);
    }
    bringThisToTop() {
      this.scene.children.bringToTop(this);
      this.setDepth(depth_default.ON_TOP);
    }
    revertDepth() {
      this.setDepth(depth_default.BUTTON);
    }
  };
  var CoinsBar_default = CoinsBar;

  // src/game/effects/CoinExplosive.ts
  init_phaser_custom_min();

  // src/game/effects/StarsExplosive.ts
  init_phaser_custom_min();
  var { KEY: KEY5, FRAME: FRAME5 } = sprites_default.EFFECTS;
  var StarsExplosive = class extends Phaser.GameObjects.Container {
    emitter;
    constructor(scene) {
      super(scene);
      this.scene = scene;
      this.createEmitters();
      this.setActive(false);
      this.setVisible(false);
      this.scene.add.existing(this);
    }
    createEmitters() {
      this.emitter = this.scene.add.particles(0, 0, KEY5, {
        frame: FRAME5.FX_STAR_YELLOW,
        alpha: { start: 1, end: 0.8 },
        speed: { min: 50, max: 150 },
        scale: { start: 0.4, end: 0.7 },
        lifespan: { min: 600, max: 1500 },
        emitting: true
      });
      this.add(this.emitter);
    }
    explode(count, x, y) {
      this.setActive(true);
      this.setVisible(true);
      this.emitter.explode(count, x, y);
    }
  };
  var StarsExplosive_default = StarsExplosive;

  // src/game/effects/StarsExplosiveSmall.ts
  init_phaser_custom_min();
  var { KEY: KEY6, FRAME: FRAME6 } = sprites_default.EFFECTS;
  var StarsExplosiveSmall = class extends Phaser.GameObjects.Container {
    emitter;
    constructor(scene) {
      super(scene);
      this.scene = scene;
      this.createEmitters();
      this.setActive(false);
      this.setVisible(false);
    }
    createEmitters() {
      this.emitter = this.scene.add.particles(0, 0, KEY6, {
        frame: FRAME6.FX_COMET,
        alpha: { start: 1, end: 0.8 },
        speed: { min: 40, max: 80 },
        scale: { start: 0.4, end: 0.7 },
        lifespan: { min: 400, max: 600 }
      });
      this.add(this.emitter);
    }
    explode(count, x, y) {
      this.revive();
      this.setPosition(x, y);
      this.emitter.explode(count);
    }
  };
  var StarsExplosiveSmall_default = StarsExplosiveSmall;

  // src/game/effects/CoinExplosive.ts
  var { KEY: KEY7, FRAME: FRAME7 } = sprites_default.DASHBOARD;
  var CoinsExplosive = class extends Phaser.GameObjects.Container {
    coinGroup;
    containerGroup;
    startsExplosive;
    startsExplosiveSmall;
    startsExplosiveSmallTimer;
    gravity = 300;
    isActive = false;
    constructor(scene) {
      super(scene);
      this.setVisible(true);
      this.coinGroup = this.scene.add.group({
        defaultKey: KEY7,
        defaultFrame: FRAME7.ICON_COIN
      });
      this.containerGroup = this.scene.add.group({
        classType: Phaser.GameObjects.Container
      });
      this.startsExplosive = new StarsExplosive_default(scene);
      this.startsExplosive.setDepth(depth_default.ON_TOP + 1);
      this.startsExplosiveSmall = new StarsExplosiveSmall_default(scene);
      this.startsExplosiveSmall.setDepth(depth_default.ON_TOP + 1);
      this.add([this.startsExplosive, this.startsExplosiveSmall]);
      this.scene.add.existing(this);
      this.setDepth(depth_default.ON_TOP + 1);
    }
    createConfigOne(dist, container, left) {
      const scale = dist / 300;
      const startPoint = new Phaser.Math.Vector2(0, 0);
      const endPoint = new Phaser.Math.Vector2(0, -dist);
      const random = left ? -1 : 1;
      const angle1 = Phaser.Math.RND.between(-90, 90);
      const magicNumber = angle1 < 0 ? 1 : (300 - Math.abs(angle1)) / 300;
      const maxLength1 = (angle1 + 90) / 180 * 180 * magicNumber * scale;
      const length1 = Phaser.Math.RND.between(20, maxLength1 + 20);
      const vec1 = new Phaser.Math.Vector2(1, 0);
      vec1.setAngle(angle1 * Math.PI / 180);
      const angle2 = Phaser.Math.RND.between(-Math.abs(angle1) - 15, -Math.abs(angle1) + 15);
      const maxLength2 = length1 * (100 - Math.abs(angle1)) / 100 * scale;
      const length2 = Phaser.Math.RND.between(maxLength2 * 0.2, maxLength2);
      const vec2 = new Phaser.Math.Vector2(1, 0);
      vec2.setAngle(angle2 * Math.PI / 180);
      const x12 = random * vec1.x * length1;
      const y12 = vec1.y * length1;
      const x2 = random * vec2.x * length2;
      const y2 = vec2.y * length2 - dist;
      const controlPoint1 = new Phaser.Math.Vector2(x12, y12);
      const controlPoint2 = new Phaser.Math.Vector2(x2, y2);
      const curve = new Phaser.Curves.CubicBezier(startPoint, controlPoint1, controlPoint2, endPoint);
      const duration = Phaser.Math.RND.between(750 + length1 * 3, 1e3 + length1 * 3);
      const coin = this.coinGroup.get(0, 0);
      coin.revive();
      coin.setRotation(-container.rotation);
      coin.setWorldSize(24, 22);
      container.add(coin);
      return {
        from: 0,
        to: 1,
        duration,
        ease: "Sine.In",
        onUpdate: (tween) => {
          const point = curve.getPointAt(tween.getValue());
          coin.setPosition(point.x, point.y);
        },
        onComplete: (tween) => {
          coin.kill();
          this.scene.children.remove(coin);
          if (tween.totalProgress < 1) return;
          if (this.startsExplosiveSmallTimer && !this.startsExplosiveSmallTimer.hasDispatched) return;
          this.startsExplosiveSmallTimer = this.scene.time.delayedCall(100, () => null);
          const pos = coin.getWorldPosition();
          this.startsExplosiveSmall.explode(10, pos.x, pos.y);
        }
      };
    }
    explode(count, srcX, srcY, destX, destY) {
      if (count <= 0) return [];
      this.isActive = true;
      this.startsExplosive.explode(10, srcX, srcY);
      const vec = new Phaser.Math.Vector2(destX - srcX, destY - srcY);
      const dist = vec.length();
      const container = this.containerGroup.get(srcX, srcY);
      container.setRotation(vec.angle() + Math.PI / 2);
      container.revive();
      this.add(container);
      this.scene.children.bringToTop(this);
      let longestTween = void 0;
      let totalTime = 0;
      const allTweens = [];
      for (let i = 0; i < count; i++) {
        const config = this.createConfigOne(dist, container, i % 2 === 0);
        const tween = this.scene.tweens.addCounter(config);
        allTweens.push(tween);
        if (config.duration > totalTime) {
          totalTime = config.duration;
          longestTween = tween;
        }
      }
      const killEffectBeforeSceneSleep = () => {
        for (const tween of allTweens) {
          tween.complete();
        }
        this.startsExplosive.emitter.killAll();
        this.startsExplosiveSmall.emitter.killAll();
        container.kill();
        this.isActive = false;
      };
      longestTween?.once(Phaser.Tweens.Events.TWEEN_COMPLETE, () => {
        container.kill();
        this.isActive = false;
        this.scene.events.off("sleep", killEffectBeforeSceneSleep);
      });
      this.scene.events.once("sleep", killEffectBeforeSceneSleep);
      return allTweens;
    }
  };
  var CoinExplosive_default = CoinsExplosive;

  // src/game/screens/DailyMissionsScreen.ts
  var { KEY: KEY8, FRAME: FRAME8 } = sprites_default.DAILY_MISSIONS;
  var { KEY: DEFAULT_KEY, FRAME: DEFAULT_FRAME } = sprites_default.DEFAULT;
  var DailyMissionsScreen = class extends Screen_default {
    onReward;
    missionsData$;
    missionProcess$;
    expirationTime$;
    popup$;
    countdownTimer$;
    countdownText$;
    countdownContainer$;
    coinBar$;
    backgroundFadeInAnimation$;
    popupShowUpAnimation$;
    popupExitsAnimation$;
    coinExplosiveEffects$ = [];
    scroller$;
    constructor(scene, name) {
      super(scene, name);
      this.createPopup$();
      this.createPopupContents$();
      this.createOnReward$();
      this.createDebugTools$();
      this.setDepth(ScreenDepth_default.POPUP);
      this.background.setAlpha(0.8);
    }
    // Method
    open(data) {
      super.open(data);
      this.setCoinBar(data?.coinBar);
      this.scroller$.setEnabled(false);
      this.scroller$.setVisible(false);
      this.updateTasksData$();
      this.setMissionBlockScrollerConfig$();
      this.runOpenAnimation$();
    }
    // Events
    handleClosePopup$ = () => {
      this.runCloseAnimation$();
    };
    handleOnClaim$ = (payload) => {
      this.claimReward$(payload);
    };
    // Logic
    claimReward$(payload) {
      if (typeof this.onReward !== "function") return;
      this.onReward(payload);
      this.updateTasksData$();
      this.updateMissionBlocks$();
      AudioUtils_default.playSound(soundEffects_default.DAILY_REWARD);
    }
    resetTaskData$ = async () => {
      MissionUtils_default.resetMissions();
    };
    requestNewTasks$ = async () => {
      MissionUtils_default.reduceAllMissionExpirationTime();
    };
    updateTasksData$ = () => {
      const tasksData = MissionUtils_default.getAllMissions();
      const tasksProcess = MissionUtils_default.getAllProcessLogs();
      const expirationTime = MissionUtils_default.getGenericExpirationTime();
      this.missionsData$ = tasksData;
      this.missionProcess$ = tasksProcess;
      this.expirationTime$ = expirationTime;
    };
    // Animations
    runOpenAnimation$() {
      this.setVisible(true);
      this.runBackgroundEntrancesAnimation$(0, 300);
      this.runPopupEntrancesAnimation$(200, 500);
    }
    runCloseAnimation$() {
      this.runPopupExitsAnimation$(0, 200);
    }
    // Entrances animations
    runBackgroundEntrancesAnimation$(delay, duration) {
      this.backgroundFadeInAnimation$ = this.scene.tweens.add({
        ...FadeIn_default,
        targets: [this.background],
        delay,
        duration,
        props: {
          alpha: { start: 0, from: 0, to: 0.8 }
        }
      });
      AnimUtils.runTween(this.backgroundFadeInAnimation$);
      this.bringCoinBarToTop();
    }
    runPopupEntrancesAnimation$(delay, duration) {
      const bannerHeightOffset = AdsUtils_default.getBannerHeight() / 2;
      this.popupShowUpAnimation$ = this.scene.tweens.add({
        ...ShowUp_default,
        targets: [this.popup$],
        delay,
        duration,
        props: {
          ...ShowUp_default.props,
          y: { from: 350 - bannerHeightOffset, to: -bannerHeightOffset },
          scale: { start: 0, from: 0, to: 1 },
          alpha: { start: 1, from: 1, to: 1 }
        },
        onComplete: () => {
          this.updateMissionData();
        },
        onStop: () => {
          this.updateMissionData();
        }
      });
      AnimUtils.runTween(this.popupShowUpAnimation$);
    }
    // Exits animations
    runPopupExitsAnimation$(delay, duration) {
      const bannerHeightOffset = AdsUtils_default.getBannerHeight() / 2;
      this.popupExitsAnimation$ = this.scene.tweens.add({
        ...FadeOut_default,
        targets: [this.popup$],
        delay,
        duration,
        props: {
          ...FadeOut_default.props,
          y: 250 - bannerHeightOffset,
          scale: 0
        },
        onComplete: () => {
          this.revertCoinBarDepth();
          ScreenUtils_default.closeScreen(this.name);
        }
      });
      AnimUtils.runTween(this.popupExitsAnimation$);
    }
    // Draw
    createDebugTools$() {
      if (!Ludex.Utils.Valid.isDebugger()) return;
      const resetBtn = new Button_default(this.scene, KEY8, FRAME8.COIN);
      resetBtn.setName("Reset");
      resetBtn.onClick = this.resetTaskData$;
      this.add(resetBtn);
      Phaser.Display.Align.In.TopLeft(resetBtn, this.zone, -10, -40);
      const newTaskBtn = new Button_default(this.scene, KEY8, FRAME8.CLOSE);
      newTaskBtn.setName("New Task");
      newTaskBtn.onClick = this.requestNewTasks$;
      this.add(newTaskBtn);
      Phaser.Display.Align.In.TopLeft(newTaskBtn, this.zone, -30, -40);
    }
    createPopup$() {
      this.popup$ = this.scene.add.container(0, 0);
      this.popup$.setWorldSize(292, 390);
      const board = this.scene.make.image({
        key: KEY8,
        frame: FRAME8.POPUP_BG
      });
      this.popup$.add(board);
      this.add(this.popup$);
      const bannerHeightOffset = AdsUtils_default.getBannerHeight() / 2;
      Phaser.Display.Align.In.Center(this.popup$, this.zone, 0, -bannerHeightOffset);
    }
    createPopupContents$() {
      this.createTitle$();
      this.createReuseScroller$();
    }
    createOnReward$() {
      this.onReward = (payload) => {
        this.runClaimCoinAnimation$(payload);
      };
    }
    runClaimCoinAnimation$(payload) {
      if (!this.coinBar$) return;
      const { claimButtonX, claimButtonY, value } = payload;
      const { x, y } = this.coinBar$.getWorldPosition();
      const coinExplosive = this.requestCoinExplosive$();
      const allTweens = coinExplosive.explode(10, claimButtonX, claimButtonY, x, y);
      for (const tween of allTweens) {
        tween.on(Phaser.Tweens.Events.TWEEN_COMPLETE, () => {
          const rewardCoins = Math.floor(value / 10);
          CoinUtils_default.addCoin(rewardCoins);
        });
      }
    }
    requestCoinExplosive$() {
      const inactiveCoinExplosive = this.coinExplosiveEffects$.find((effect) => !effect.isActive);
      if (inactiveCoinExplosive) {
        return inactiveCoinExplosive;
      }
      const newCoinExplosive = new CoinExplosive_default(this.coinBar$?.scene ?? this.scene);
      this.coinExplosiveEffects$.push(newCoinExplosive);
      return newCoinExplosive;
    }
    createReuseScroller$() {
      this.scroller$ = new ReuseScroller(this.scene, {
        size: {
          width: 245,
          height: 335
        },
        visual: {
          mask: true,
          bounds: true
        },
        reuse: {
          ClassType: MissionBlock_default,
          configs: [],
          update: (mission, config) => {
            mission.updateInfo(config);
          }
        }
      });
      this.scroller$.setPosition(0, 1);
      this.popup$.add(this.scroller$);
    }
    createTitle$() {
      const title = this.scene.add.container();
      const ribbon = this.scene.make.image({
        key: KEY8,
        frame: FRAME8.RIBBON
      });
      const close = new Button_default(this.scene, DEFAULT_KEY, DEFAULT_FRAME.BUTTON_CLOSE);
      close.setName("Close");
      close.useSound = true;
      close.onClick = this.handleClosePopup$;
      Phaser.Display.Align.In.RightCenter(close, ribbon, 50, 10);
      title.add([ribbon, close]);
      this.popup$.add(title);
      AlignUtils_default.alignChildTopCenter(title, this.popup$, 0, 25);
    }
    // private createCountdown$(): void {
    //     this.countdownContainer$ = this.scene.add.container()
    //    this.countdownText$ = FontUtils.createText(this.scene, '00:00:00', 30).setShadow(0, 1, '0x000000', 0.5)
    //    this.countdownContainer$.add(this.countdownText$)
    //    this.popup$.add(this.countdownContainer$)
    //     Phaser.Display.Align.In.TopCenter(this.countdownContainer$, this.popup$, 0, 10)
    // }
    // private createCountdownTimer$(): void {
    //     this.countdownTimer$?.destroy()
    //     this.countdownTimer$ = this.scene.time.addEvent({
    //         loop: true,
    //         delay: 1000,
    //         startAt: 1000,
    //         callback: this.updateCountdown$,
    //     })
    // }
    // private updateCountdown$ = async () => {
    //     if (!this.expirationTime$) return
    //     const now = Date.now()
    //     let remain = this.expirationTime$ - now
    //     if (remain <= 0) {
    //         remain = 0
    //         await this.resetTaskData$()
    //     }
    // this.countdownText.setText(`${this.formatDateHMS(remain)}`)
    // }
    // private formatDateHMS$(remain: number): string {
    //     const hours = Math.floor(remain / (1000 * 60 * 60))
    //     const minutes = Math.floor((remain % (1000 * 60 * 60)) / (1000 * 60))
    //     const seconds = Math.floor((remain % (1000 * 60)) / 1000)
    //     const hoursStr = hours.toString().padStart(2, '0')
    //     const minutesStr = minutes.toString().padStart(2, '0')
    //     const secondsStr = seconds.toString().padStart(2, '0')
    //     return `${hoursStr}:${minutesStr}:${secondsStr}`
    // }
    updateMissionData() {
      this.scroller$.setVisible(true);
      this.scroller$.scrollToTop(true);
      const missionBlockAnimations = [];
      const missionBlocks = this.scroller$.getChildren();
      const maxNumberOfShownMissionBlocks = Math.min(missionBlocks.length, 7);
      for (let index = 0; index < maxNumberOfShownMissionBlocks; index++) {
        const mission = missionBlocks[index];
        if (!mission) continue;
        const animation = mission.runShowItemAnimation(index * 75, 150);
        missionBlockAnimations.push(animation);
      }
      Promise.all(missionBlockAnimations).then(() => {
        this.scroller$.setEnabled(true);
      });
    }
    setMissionBlockScrollerConfig$() {
      const missionBlocks = [];
      for (const mission of this.missionsData$) {
        const payload = {
          missionData: mission,
          process: this.missionProcess$[mission.id],
          onClaim: this.handleOnClaim$
        };
        missionBlocks.push(payload);
      }
      this.scroller$.setConfigs(missionBlocks);
    }
    updateMissionBlocks$() {
      const missionBlocks = this.scroller$.getChildren();
      for (const mission of missionBlocks) {
        if (mission instanceof MissionBlock_default) {
          const id2 = mission.getId();
          if (!Ludex.Utils.Object.hasOwn(this.missionProcess$, id2)) continue;
          const process2 = this.missionProcess$[id2];
          if (!Ludex.Utils.Valid.isObject(process2)) continue;
          mission.setProcess(process2);
        }
      }
    }
    incScale(scale) {
      super.incScale(scale);
      this.scroller$.updateMaskScale(this.scale);
    }
    setCoinBar(coinBar) {
      if (coinBar instanceof CoinsBar_default) {
        this.coinBar$ = coinBar;
      } else {
        this.coinBar$ = null;
      }
    }
    bringCoinBarToTop() {
      if (!this.coinBar$) return;
      this.coinBar$.bringThisToTop();
    }
    revertCoinBarDepth() {
      if (!this.coinBar$) return;
      this.coinBar$.revertDepth();
    }
  };
  var DailyMissionsScreen_default = DailyMissionsScreen;

  // src/game/screens/LoadingScreen.ts
  init_phaser_custom_min();
  var {
    Utils: { Valid: V7 }
  } = Ludex;
  var { KEY: LOADING_KEY, FRAME: LOADING_FRAME } = sprites_default.DEFAULT;
  var IconFrames = [
    LOADING_FRAME.LOADING_SCREEN_TILE_ICON_1,
    LOADING_FRAME.LOADING_SCREEN_TILE_ICON_2,
    LOADING_FRAME.LOADING_SCREEN_TILE_ICON_3,
    LOADING_FRAME.LOADING_SCREEN_TILE_ICON_4,
    LOADING_FRAME.LOADING_SCREEN_TILE_ICON_5
  ];
  var LoadingScreen = class extends Screen_default {
    loadIconIndex$ = 0;
    loadingIconContainer$;
    loadingIcon$;
    closeTimerEvent$;
    loadingEntranceAnimation$;
    loadingAnimation$;
    loadingExitAnimation$;
    constructor(scene, name) {
      super(scene, name);
      this.addLoadingContainer$();
      this.setDepth(ScreenDepth_default.PRIORITY);
    }
    open(data) {
      super.open(data);
      this.switchToNextIcon$();
      const parsed = this.getData(["duration"]);
      const duration = V7.isNumber(parsed?.[0]) ? parsed[0] : 0;
      this.closeTimerEvent$?.remove();
      if (duration > 0) {
        this.closeTimerEvent$ = this.scene.time.addEvent({
          delay: duration,
          callback: () => {
            if (this.visible) {
              this.closeAfterAnimation$();
            }
          }
        });
      }
      this.runPopupEntracesAnimation$();
    }
    switchToNextIcon$() {
      this.loadingIcon$.setFrame(IconFrames[this.loadIconIndex$]);
      this.loadIconIndex$ = (this.loadIconIndex$ + 1) % IconFrames.length;
    }
    addLoadingContainer$() {
      this.loadingIconContainer$ = this.scene.add.container();
      this.loadingIconContainer$.setWorldSize(130, 130);
      const background = this.scene.make.image({
        key: LOADING_KEY,
        frame: LOADING_FRAME.LOADING_SCREEN_TILE_BG
      });
      this.loadingIconContainer$.add(background);
      this.loadingIcon$ = this.scene.make.image({
        key: LOADING_KEY,
        frame: LOADING_FRAME.LOADING_SCREEN_TILE_ICON_1
      });
      this.loadingIconContainer$.add(this.loadingIcon$);
      this.add(this.loadingIconContainer$);
      const bannerHeightOffset = AdsUtils_default.getBannerHeight() / 2;
      AlignUtils_default.alignChildCenter(background, this.loadingIconContainer$);
      AlignUtils_default.alignChildCenter(this.loadingIcon$, this.loadingIconContainer$);
      Phaser.Display.Align.In.Center(this.loadingIconContainer$, this.zone, 0, -bannerHeightOffset);
    }
    closeAfterAnimation$() {
      this.runPopupExitsAnimation$(() => {
        ScreenUtils_default.closeScreen(this.name);
      });
    }
    close() {
      super.close();
      this.loadingAnimation$?.stop();
    }
    runPopupEntracesAnimation$() {
      this.background.setAlpha(0);
      this.animateBackgroundAlpha(0.8);
      this.runEntranceAnimation$();
      this.runLoadingAnimation$();
    }
    runEntranceAnimation$(onComplete) {
      this.loadingIconContainer$.setAlpha(0);
      this.loadingIconContainer$.setScale(0);
      this.loadingIconContainer$.setAngle(0);
      this.loadingEntranceAnimation$ = this.scene.tweens.add({
        targets: [this.loadingIconContainer$],
        props: {
          alpha: 1,
          scale: 1
        },
        duration: 300,
        ease: Phaser.Math.Easing.Cubic.Out,
        onStart: () => {
          console.log("onStart", this.visible);
        }
      });
      AnimUtils.runTweenAsync(this.loadingEntranceAnimation$).then(onComplete);
    }
    runLoadingAnimation$() {
      this.loadingAnimation$?.stop();
      this.loadingAnimation$ = this.scene.tweens.add({
        targets: [this.loadingIconContainer$],
        repeat: -1,
        props: {
          angle: { from: 0, to: 360 }
        },
        duration: 1500,
        ease: Phaser.Math.Easing.Cubic.InOut
      });
      AnimUtils.runTween(this.loadingAnimation$);
    }
    runPopupExitsAnimation$(onComplete) {
      this.animateBackgroundAlpha(0, 200);
      this.loadingExitAnimation$ = this.scene.tweens.add({
        targets: [this.loadingIconContainer$],
        props: {
          alpha: 0
        },
        duration: 200,
        ease: Phaser.Math.Easing.Cubic.Out
      });
      AnimUtils.runTweenAsync(this.loadingExitAnimation$).then(onComplete);
    }
  };
  var LoadingScreen_default = LoadingScreen;

  // src/game/screens/NotifyScreen.ts
  init_phaser_custom_min();

  // src/game/animations/special/BubbleTouch.ts
  init_phaser_custom_min();
  var DEFAULT_BUBBLE_TOUCH_ANIM_CONFIG = {
    duration: 300,
    ease: BubbleOut_default,
    props: {
      scale: { start: 1.2, from: 1.2, to: 1 }
    }
  };
  var BubbleTouch_default = DEFAULT_BUBBLE_TOUCH_ANIM_CONFIG;

  // src/game/components/Loading.ts
  init_phaser_custom_min();
  var { KEY: KEY9, FRAME: FRAME9 } = sprites_default.DEFAULT;
  var Loading = class extends Phaser.GameObjects.Image {
    anim;
    constructor(scene) {
      super(scene, 0, 0, KEY9, FRAME9.PRELOADER);
      this.runAnimation();
      this.scene.add.existing(this);
    }
    runAnimation() {
      this.anim = this.scene.tweens.add({
        targets: this,
        props: {
          angle: { from: 0, to: 360 }
        },
        duration: 1200,
        repeat: -1
      });
    }
    setVisible(visible) {
      super.setVisible(visible);
      if (visible) {
        this.runAnimation();
      } else {
        this.anim.stop();
        this.scene.tweens.remove(this.anim);
      }
      return this;
    }
  };
  var Loading_default = Loading;

  // src/game/screens/NotifyScreen.ts
  var NotifyScreen = class extends Screen_default {
    loadingIcon$;
    messageText$;
    originalIconScale$;
    originalTextScale$;
    closeTimerEvent$;
    constructor(scene, name) {
      super(scene, name);
      this.addLoadingIcon$();
      this.addMessageText$();
      this.originalIconScale$ = this.loadingIcon$.scale;
      this.originalTextScale$ = this.messageText$.scale;
      this.setDepth(ScreenDepth_default.PRIORITY);
    }
    open(data) {
      super.open(data);
      const [message = "", duration = 0, loading = false] = this.getData(["message", "duration", "lo\
ading"]);
      this.setMessage$(message);
      this.showLoading$(loading);
      this.closeTimerEvent$?.remove();
      if (duration > 0) {
        this.closeTimerEvent$ = this.scene.time.addEvent({
          delay: duration,
          callback: () => {
            if (this.visible) {
              this.runCloseAnimation$();
            }
          }
        });
      }
      this.runOpenAnimation$();
    }
    addLoadingIcon$() {
      this.loadingIcon$ = new Loading_default(this.scene);
      this.add(this.loadingIcon$);
      const bannerHeightOffset = AdsUtils_default.getBannerHeight() / 2;
      Phaser.Display.Align.In.Center(this.loadingIcon$, this.zone, 0, -bannerHeightOffset);
    }
    addMessageText$() {
      this.messageText$ = FontUtils_default.createText(this.scene, "", 24).setTint(16770463).setShadow(
      0, 3, "#ce5f0f", 0.5).setStroke("#ce5f0f", 2).setOrigin(0.5, 0.5).setAlign("center").setFontStyle(
      "900").setWordWrapWidth(this.zone.width - 50, true);
      this.add(this.messageText$);
    }
    setMessage$(message) {
      this.messageText$.setText(message);
    }
    showLoading$(loading) {
      this.loadingIcon$.setVisible(loading);
      const bannerHeightOffset = AdsUtils_default.getBannerHeight() / 2;
      const posY = loading === false ? 20 : 90;
      Phaser.Display.Align.In.Center(this.messageText$, this.zone, 0, posY - bannerHeightOffset);
    }
    runOpenAnimation$() {
      this.background.setAlpha(0);
      this.animateBackgroundAlpha(0.8);
      const openIconAnimation = this.scene.tweens.add({
        ...BubbleTouch_default,
        targets: [this.loadingIcon$],
        props: {
          ...BubbleTouch_default.props,
          scale: {
            from: this.originalIconScale$ - 0.3,
            to: this.originalIconScale$
          },
          alpha: 1
        }
      });
      const openTextAnimation = this.scene.tweens.add({
        ...BubbleTouch_default,
        targets: [this.messageText$],
        props: {
          ...BubbleTouch_default.props,
          scale: {
            from: this.originalTextScale$ - 0.3,
            to: this.originalTextScale$
          },
          alpha: 1
        }
      });
      AnimUtils.runTweenAsync(openIconAnimation);
      AnimUtils.runTweenAsync(openTextAnimation);
    }
    runCloseAnimation$() {
      this.animateBackgroundAlpha(0, 200);
      const closeIconAnimation = this.scene.tweens.add({
        ...BubbleTouch_default,
        targets: [this.loadingIcon$],
        ease: Phaser.Math.Easing.Cubic.Out,
        props: {
          ...BubbleTouch_default.props,
          scale: {
            from: this.originalIconScale$,
            to: this.originalIconScale$ - 0.3
          },
          alpha: 0
        }
      });
      const closeTextAnimation = this.scene.tweens.add({
        ...BubbleTouch_default,
        targets: [this.messageText$],
        ease: Phaser.Math.Easing.Cubic.Out,
        props: {
          ...BubbleTouch_default.props,
          scale: {
            from: this.originalTextScale$,
            to: this.originalTextScale$ - 0.3
          },
          alpha: 0
        }
      });
      AnimUtils.runTween(closeIconAnimation);
      AnimUtils.runTweenAsync(closeTextAnimation).then(() => {
        ScreenUtils_default.closeScreen(this.name);
      });
    }
  };
  var NotifyScreen_default = NotifyScreen;

  // src/game/screens/pause-screen/PauseScreen.ts
  init_phaser_custom_min();

  // src/game/components/ToggleButton.ts
  init_phaser_custom_min();
  var { KEY: KEY10 } = sprites_default.DEFAULT;
  var ToggleButton = class extends Button_default {
    options;
    icon;
    constructor(scene, options) {
      super(scene, KEY10, options.frameOn);
      this.options = options;
    }
    processCallback(callback) {
      const { enable } = this.options;
      this.updateStatus(!enable);
      callback(!enable);
    }
    updateStatus(enable) {
      this.options.enable = enable;
      const frame = this.getFrameByStatus();
      this.button.setFrame(frame);
    }
    getFrameByStatus = () => {
      const { enable, frameOn, frameOff } = this.options;
      return enable ? frameOn : frameOff;
    };
  };
  var ToggleButton_default = ToggleButton;

  // src/game/scenes/LoadScene.ts
  init_phaser_custom_min();

  // src/game/gameplay/levels/gameLevels.ts
  init_phaser_custom_min();

  // src/game/gameplay/constants/modes.ts
  init_phaser_custom_min();
  var MODES = {
    NORMAL: "normal",
    FALL_DOWN: "fall-down",
    FLY_UP: "fly-up",
    PUSH_LEFT: "push-left",
    PUSH_RIGHT: "push-right",
    PUT_ROWS_MIDDLE: "put-rows-middle",
    PUT_COLUMNS_MIDDLE: "put-columns-middle",
    FLY_UP_PUSH_LEFT: "fly-up-push-left",
    FLY_UP_PUSH_RIGHT: "fly-up-push-right",
    FALL_DOWN_PUSH_LEFT: "fall-down-push-left",
    FALL_DOWN_PUSH_RIGHT: "fall-down-push-right",
    FLY_UP_PUT_COLUMNS_MIDDLE: "fly-up-put-columns-middle",
    FALL_DOWN_PUT_COLUMNS_MIDDLE: "fall-down-put-columns-middle"
  };
  var modes_default = MODES;

  // src/game/gameplay/constants/tile.ts
  init_phaser_custom_min();
  var TILE_SPECIALS = {
    BOMB: "bomb",
    ROCKET: "rocket",
    EMPTY: "empty"
  };
  var TILE = {
    SIZE: 70,
    STATUS: {
      READY: "ready",
      MOVING: "moving",
      CAPTURING: "capturing",
      CAPTURED: "captured"
    },
    EVENTS: {
      NEXT_TURN: "next-turn",
      CAPTURING: "capturing",
      INTERACTION: "interaction",
      /**
       * event for tutorial
       */
      NO_PATH_FOUND: "no-path-found",
      ROCKET_EXPLODE: "rocket-explode",
      FIRST_INTERACTION: "first-interaction",
      PAUSE_BOMB_TIMER: "pause-bomb-timer",
      RESUME_BOMB_TIMER: "resume-bomb-timer",
      BOMB_TIMER_RESCUE: "bomb-timer-rescue"
    },
    // COLORS: TILE_COLORS,
    SPECIALS: TILE_SPECIALS,
    // HASH: TILE_HASH,
    HASH: {
      1: "t01",
      2: "t02",
      3: "t03",
      4: "t04",
      5: "t05",
      6: "t06",
      7: "t07",
      8: "t08",
      9: "t09",
      10: "t10",
      11: "t11",
      12: "t12",
      13: "t13",
      14: "t14",
      15: "t15",
      16: "t16",
      17: "t17",
      empty: "i01",
      rocket: "i02"
      //! 'b??', => special tile bomb
    }
  };
  var tile_default = TILE;

  // src/game/gameplay/constants/rules.ts
  init_phaser_custom_min();
  var RULES = {
    MAX_SPACE_OF_PAIR: "maxSpaceOfPair",
    ADD_RANDOM_TILES_PER_MOVE: "addRandomTilesPerMove"
  };
  var rules_default = RULES;

  // src/game/gameplay/constants/theme.ts
  init_phaser_custom_min();
  var THEME = {
    BIRD: "BIRD",
    CAKE: "CAKE",
    FRUIT: "FRUIT",
    CANDY: "CANDY"
  };
  var theme_default = THEME;

  // src/game/gameplay/levels/gameLevels.ts
  var { BOMB, ROCKET } = tile_default.SPECIALS;
  var { ADD_RANDOM_TILES_PER_MOVE, MAX_SPACE_OF_PAIR } = rules_default;
  var listMode = Object.values(modes_default);
  var {
    Utils: { Function: F4 }
  } = Ludex;
  var randomMode = {
    toString: () => {
      return listMode[Math.floor(Math.random() * listMode.length)];
    }
  };
  var fetchLevels = async () => {
    const filename = (await Promise.resolve().then(() => __toESM(require_levels()))).default;
    const levels = await (await fetch(filename)).json();
    if (!Array.isArray(levels)) {
      throw new Error("Levels is not an array");
    }
    if (levels.length === 0) {
      throw new Error("No levels found");
    }
    GAME_LEVELS.push(...levels);
  };
  var GAME_LEVELS = [
    // Level 0RE
    {
      level: 0,
      // mode: MODES.NORMAL,
      mode: randomMode,
      time: 120,
      rows: 12,
      columns: 7,
      colors: 28,
      specials: {
        [BOMB]: 10,
        [ROCKET]: 5
      },
      rules: {
        [MAX_SPACE_OF_PAIR]: 15,
        [ADD_RANDOM_TILES_PER_MOVE]: 35
      },
      theme: [theme_default.BIRD, theme_default.CAKE, theme_default.FRUIT, theme_default.CANDY]
    }
  ];
  try {
    F4.retryAsync(fetchLevels, fetchLevels);
  } catch (error) {
    console.error("Error fetching levels", error);
  }
  var gameLevels_default = GAME_LEVELS;

  // src/game/scenes/global-scene/index.ts
  init_phaser_custom_min();

  // src/game/scenes/global-scene/GlobalScene.ts
  init_phaser_custom_min();

  // src/game/scenes/BaseScene.ts
  init_phaser_custom_min();

  // src/game/components/GameZone.ts
  init_phaser_custom_min();
  var GameZone = class extends Phaser.GameObjects.Zone {
    constructor(scene, width, height) {
      super(scene, 0, 0, width, height);
      this.setWorldSize(width, height);
    }
  };
  var GameZone_default = GameZone;

  // src/game/scenes/BaseScene.ts
  var {
    Events: Events7,
    Utils: { Valid: V8 }
  } = Ludex;
  var { event: event11 } = codex;
  var BaseScene = class extends Phaser.Scene {
    unsubscribeList;
    gameZone;
    background;
    handleResize = (payload) => {
      if (!this.scene.isActive()) return;
      if (!this.background || !this.gameZone) return;
      const { width, height } = payload;
      this.gameZone.setWorldSize(width, height);
      this.background.setWorldSize(width, height);
      this.scaleGame();
      Phaser.Display.Align.In.Center(this.background, this.gameZone);
    };
    constructor() {
      super({ visible: false });
    }
    create() {
      event11.emit(Events7.SCENE_LOADED, { sceneName: this.scene.key });
      this.createGameZone();
      this.scaleGame();
      event11.on(GameEvents_default.VIEW_RESIZED, this.handleResize);
      event11.on(GameEvents_default.LAYOUT_CHANGED, this.handleResize);
      this.events.once(Phaser.Scenes.Events.RENDER, () => {
        event11.emit(Events7.SCENE_LAUNCHED, { sceneName: this.scene.key });
      });
      this.events.on(Phaser.Scenes.Events.WAKE, this.handleSceneRendered);
      this.events.on(Phaser.Scenes.Events.RESUME, this.handleSceneRendered);
      this.events.on(Phaser.Scenes.Events.ADDED_TO_SCENE, (gameObject) => {
        if ("setWorldSize" in gameObject && V8.isFunction(gameObject.setWorldSize)) {
          gameObject.setWorldSize();
        }
        if ("setHighQuality" in gameObject && V8.isFunction(gameObject.setHighQuality)) {
          gameObject.setHighQuality();
        }
      });
    }
    handleSceneRendered = () => {
      event11.emit(Events7.SCENE_RENDERED, { sceneName: this.scene.key });
      this.events.once(Phaser.Scenes.Events.RENDER, () => {
        event11.emit(Events7.SCENE_LAUNCHED, { sceneName: this.scene.key });
      });
    };
    scaleGame() {
      const camera = this.getCamera("main");
      const zoomRatio = WorldUtils_default.getZoomRatio();
      camera.setZoom(zoomRatio);
      camera.startFollow(this.gameZone);
    }
    createGameZone() {
      const { width, height } = WorldUtils_default.getWorldSize();
      this.gameZone = new GameZone_default(this, width, height);
    }
    getCamera(name) {
      if (name === "main") return this.cameras.main;
      return this.cameras.getCamera(name);
    }
    createMask(alpha = 1) {
      const camera = this.getCamera("main");
      camera.setBackgroundColor(`rgba(0, 0, 0, ${alpha})`);
    }
    createBackground(key, frame, alpha, tint) {
      if (this.background) {
        this.background.setTexture(key);
        frame && this.background.setFrame(frame);
      } else {
        this.background = this.make.image({ key, frame });
      }
      this.background.setName(key);
      const { width, height } = this.gameZone;
      this.background.setWorldSize(width, height);
      if (V8.isNumber(alpha)) {
        this.background.setAlpha(alpha);
      }
      if (V8.isNumber(tint)) {
        this.background.setTint(tint);
      }
      Phaser.Display.Align.In.Center(this.background, this.gameZone);
    }
  };
  var BaseScene_default = BaseScene;

  // src/game/scenes/global-scene/common/FpsMeter.ts
  init_phaser_custom_min();
  var { KEY: KEY11, FRAME: FRAME10 } = sprites_default.DEFAULT;
  var FpsMeter = class extends Phaser.GameObjects.Container {
    fps = 0;
    fpsString = "FPS: %1";
    fpsText;
    background;
    zone;
    lastUpdate;
    constructor(scene) {
      super(scene, 0, 0);
      this.createFps();
      this.createInputZone();
      this.setDepth(depth_default.DEBUG);
      this.scene.add.existing(this);
      this.scene.events.on(Phaser.Scenes.Events.UPDATE, this.update);
    }
    update = (time) => {
      if (time - this.lastUpdate < 800) return;
      this.lastUpdate = time;
      const actualFps = Math.floor(this.scene.game.loop.actualFps);
      this.setFps(actualFps);
    };
    setFps(fps) {
      this.fps = fps;
      const text = this.fpsString.replace("%1", fps.toString());
      this.fpsText.setText(text);
    }
    createFps() {
      this.background = this.scene.make.image({
        key: KEY11,
        frame: FRAME10.BLANK
      });
      this.background.setTint(32768);
      this.background.setAlpha(0.5);
      this.background.setWorldSize(50, 20);
      this.fpsText = FontUtils_default.createText(this.scene, this.fpsString, 10);
      this.fpsText.setName("FPS Meter");
      Phaser.Display.Align.In.Center(this.fpsText, this.background, 4);
      this.add([this.background, this.fpsText]);
      this.setFps(0);
    }
    createInputZone() {
      const { width, height } = this.background;
      this.zone = this.scene.make.zone({
        width,
        height
      });
      this.add(this.zone);
      this.zone.setInteractive({
        useHandCursor: true
      });
      this.zone.on(Phaser.Input.Events.GAMEOBJECT_POINTER_DOWN, this.handleShowFps);
    }
    handleShowFps = () => {
      const { fpsText, background } = this;
      fpsText.setVisible(!fpsText.visible);
      background.setVisible(!background.visible);
    };
  };
  var FpsMeter_default = FpsMeter;

  // src/game/gameplay/components/BackgroundMaskManager.ts
  init_phaser_custom_min();

  // src/utils/element/backgroundMask.ts
  init_phaser_custom_min();
  var updateBackgroundMaskAlpha = (alpha, isClosingScreen, closingScreen) => {
    if (isClosingScreen && closingScreen) {
      const scene = SceneUtils_default.getCurrentScene();
      if (!scene) return;
      const screens = scene.children.getAll();
      let noScreensVisible = true;
      for (const screen2 of screens) {
        if (!(screen2 instanceof Screen_default) || screen2 === closingScreen) continue;
        if (screen2.visible) noScreensVisible = false;
      }
      if (!noScreensVisible) return;
    }
    const bgMaskElm = document.getElementById("background-mask");
    if (!bgMaskElm) return;
    bgMaskElm.style.backgroundColor = `rgba(0, 0, 0, ${alpha})`;
  };
  var backgroundMask_default = updateBackgroundMaskAlpha;

  // src/game/gameplay/components/BackgroundMaskManager.ts
  var BackgroundMaskManager = class {
    backgroundAlphaList;
    constructor() {
      this.backgroundAlphaList = [];
    }
    requestBackgroundMaskUpdate(screenName, alpha) {
      const index = this.backgroundAlphaList.findIndex((item) => item.screenName === screenName);
      if (index === -1) {
        this.backgroundAlphaList.push({
          alpha,
          screenName
        });
      } else {
        this.backgroundAlphaList[index].alpha = alpha;
      }
      this.updateBackgroundMask();
    }
    updateBackgroundMask() {
      if (this.backgroundAlphaList.length === 0) {
        backgroundMask_default(0);
        return;
      }
      let accumulatedValue = 1;
      for (const item of this.backgroundAlphaList) {
        accumulatedValue *= 1 - item.alpha;
      }
      backgroundMask_default(1 - accumulatedValue);
    }
  };
  var BackgroundMaskManager_default = BackgroundMaskManager;

  // src/game/scenes/global-scene/GlobalScene.ts
  var { ads: ads3, event: event12 } = codex;
  var {
    Events: Events8,
    Utils: { Valid: V9 }
  } = Ludex;
  var GlobalScene = class extends BaseScene_default {
    fpsMeter$;
    backgroundMaskManager$;
    init() {
      this.setGlobalSceneOnTop$();
      this.backgroundMaskManager$ = new BackgroundMaskManager_default();
      this.listenEvents$();
    }
    listenEvents$() {
      event12.on("hideFPS", this.hideFPS$);
      event12.on("showFPS", this.showFPS$);
      this.handlePauseAudio$();
    }
    // ? Testing transition
    /* private handleTransition() {
        event.on(Events.SWITCH_SCENE, this.startTransition)
    } */
    /* private startTransition = () => {
        this.cameras.main.fadeIn(300)
    } */
    handlePauseAudio$() {
      event12.on(Events8.VISIBILITY_HIDDEN, this.muteAudio);
      event12.on(Events8.VISIBILITY_VISIBLE, this.unmuteAudio);
    }
    muteAudio = () => {
      console.log("mute audio");
      AudioUtils_default.muteAudio(true);
      this.input.once(Phaser.Input.Events.POINTER_DOWN, this.unmuteAudio);
    };
    unmuteAudio = async () => {
      if (ads3.isAdFullSizeShowing()) return;
      console.log("unmute audio");
      AudioUtils_default.muteAudio(false);
      try {
        await phaser.sound.context.suspend();
        await phaser.sound.context.resume();
      } catch (error) {
        console.error("can not resume audio", error);
      }
    };
    setup() {
      if (!this.scene.isActive()) return;
      this.addFPS$();
      this.setGlobalSceneOnTop$();
    }
    addFPS$() {
      if (!V9.isDebugger()) return;
      this.fpsMeter$ = new FpsMeter_default(this);
      Phaser.Display.Align.In.TopLeft(this.fpsMeter$, this.gameZone, -20, -10);
    }
    hideFPS$ = () => {
      this.fpsMeter$?.kill();
    };
    showFPS$ = () => {
      this.fpsMeter$?.revive();
    };
    setGlobalSceneOnTop$() {
      this.scene.bringToTop(this);
    }
    requestBackgroundMaskUpdate(screenName, alpha) {
      this.backgroundMaskManager$.requestBackgroundMaskUpdate(screenName, alpha);
    }
    recalculateBackgroundMask() {
      this.backgroundMaskManager$.updateBackgroundMask();
    }
  };
  var GlobalScene_default = GlobalScene;

  // src/game/scenes/global-scene/index.ts
  var global_scene_default = GlobalScene_default;

  // src/game/scenes/LoadScene.ts
  var { player: player7 } = codex;
  var {
    Utils: { Valid: V10, Object: O8 }
  } = Ludex;
  var LoadScene = class extends BaseScene_default {
    isMusicLoaded = false;
    isLazyLoadRequesting = false;
    preload() {
      this.load.on(Phaser.Loader.Events.FILE_LOAD_ERROR, (file) => {
        console.error("Load resources at LoadScene failed.", file);
      });
      this.load.image(images_default.AVATAR_DEFAULT.KEY, images_default.AVATAR_DEFAULT.FILE);
      if (WorldUtils_default.isLandscape()) {
        this.load.image(images_default.BACKGROUND.KEY, images_default.BACKGROUND.FILE_LANDSCAPE);
      } else {
        this.load.image(images_default.BACKGROUND.KEY, images_default.BACKGROUND.FILE);
      }
      this.load.atlas({
        key: sprites_default.DEFAULT.KEY,
        textureURL: sprites_default.DEFAULT.TEXTURE,
        atlasURL: sprites_default.DEFAULT.JSON
      });
      this.load.multiatlas({
        key: sprites_default.EFFECTS.KEY,
        path: sprites_default.EFFECTS.PATH,
        atlasURL: sprites_default.EFFECTS.JSON
      });
      this.load.multiatlas({
        key: sprites_default.GAMEPLAY.KEY,
        path: sprites_default.GAMEPLAY.PATH,
        atlasURL: sprites_default.GAMEPLAY.JSON
      });
      const currentLevel = player7.getGameData()?.level ?? 1;
      if (currentLevel <= GameSettings_default.FinalGuideLevel) {
        this.load.atlas({
          key: sprites_default.TUTORIAL.KEY,
          textureURL: sprites_default.TUTORIAL.TEXTURE,
          atlasURL: sprites_default.TUTORIAL.JSON
        });
      }
      this.load.atlas({
        key: sprites_default.TILES.CAKE.KEY,
        textureURL: sprites_default.TILES.CAKE.TEXTURE,
        atlasURL: sprites_default.TILES.CAKE.JSON
      });
      const isNewUser = player7.isFirstSession();
      if (isNewUser) {
        this.loadFlowForNewUser();
      } else {
        this.loadFlowForReturningUser();
      }
    }
    loadFlowForNewUser() {
      this.loadCurrentLevelTiles();
    }
    loadFlowForReturningUser() {
      this.load.atlas({
        key: sprites_default.JOURNEY.KEY,
        textureURL: sprites_default.JOURNEY.TEXTURE,
        atlasURL: sprites_default.JOURNEY.JSON
      });
      this.load.atlas({
        key: sprites_default.TOURNAMENTS.KEY,
        textureURL: sprites_default.TOURNAMENTS.TEXTURE,
        atlasURL: sprites_default.TOURNAMENTS.JSON
      });
      this.load.atlas({
        key: sprites_default.DAILY_MISSIONS.KEY,
        textureURL: sprites_default.DAILY_MISSIONS.TEXTURE,
        atlasURL: sprites_default.DAILY_MISSIONS.JSON
      });
      this.load.atlas({
        key: sprites_default.DASHBOARD.KEY,
        textureURL: sprites_default.DASHBOARD.TEXTURE,
        atlasURL: sprites_default.DASHBOARD.JSON
      });
      this.load.atlas({
        key: sprites_default.CHALLENGE.KEY,
        textureURL: sprites_default.CHALLENGE.TEXTURE,
        atlasURL: sprites_default.CHALLENGE.JSON
      });
    }
    create() {
      super.create();
      this.setupGlobalScene();
      this.lazyLoadResource();
      MissionUtils_default.initializeFinishedMissionCount();
      GameplayNotificationUtils_default.initializeFlags();
    }
    setupGlobalScene() {
      const scene = this.scene.get(SceneKeys_default.GLOBAL_SCENE);
      if (!(scene instanceof global_scene_default)) return;
      scene.setup();
    }
    lazyLoadResource() {
      setTimeout(() => {
        this.scene.wake();
        const isNewUser = player7.isFirstSession();
        if (isNewUser) {
          this.lazyLoadResourceForNewUser();
        } else {
          this.lazyLoadResourceForReturningUser();
        }
        this.loadSounds();
        this.lazyLoadTiles();
        this.load.start();
        this.load.once(Phaser.Loader.Events.COMPLETE, () => {
          this.scene.sleep();
        });
      }, 1500);
    }
    lazyLoadResourceForReturningUser() {
      this.load.atlas({
        key: sprites_default.TILES.CAKE.KEY,
        textureURL: sprites_default.TILES.CAKE.TEXTURE,
        atlasURL: sprites_default.TILES.CAKE.JSON
      });
      const currentLevel = player7.getGameData()?.level ?? 1;
      if (currentLevel <= GameSettings_default.FinalGuideLevel) {
        this.loadTexture32Bit(sprites_default.TUTORIAL.KEY, [sprites_default.TUTORIAL.TEXTURE_32_BIT]);
      }
      this.loadTexture32Bit(sprites_default.JOURNEY.KEY, [sprites_default.JOURNEY.TEXTURE_32_BIT]);
      this.loadTexture32Bit(sprites_default.TOURNAMENTS.KEY, [sprites_default.TOURNAMENTS.TEXTURE_32_BIT]);
      this.loadTexture32Bit(sprites_default.DAILY_MISSIONS.KEY, [sprites_default.DAILY_MISSIONS.TEXTURE_32_BIT]);
      this.loadTexture32Bit(sprites_default.DASHBOARD.KEY, [sprites_default.DASHBOARD.TEXTURE_32_BIT]);
      this.loadTexture32Bit(sprites_default.CHALLENGE.KEY, [sprites_default.CHALLENGE.TEXTURE_32_BIT]);
    }
    lazyLoadResourceForNewUser() {
      const currentLevel = player7.getGameData()?.level ?? 1;
      if (currentLevel <= GameSettings_default.FinalGuideLevel) {
        this.loadTexture32Bit(sprites_default.TUTORIAL.KEY, [sprites_default.TUTORIAL.TEXTURE_32_BIT]);
      }
      this.lazyLoadAtlas(
        sprites_default.JOURNEY.KEY,
        sprites_default.JOURNEY.TEXTURE,
        sprites_default.JOURNEY.JSON,
        sprites_default.JOURNEY.TEXTURE_32_BIT
      );
      this.lazyLoadAtlas(
        sprites_default.TOURNAMENTS.KEY,
        sprites_default.TOURNAMENTS.TEXTURE,
        sprites_default.TOURNAMENTS.JSON,
        sprites_default.TOURNAMENTS.TEXTURE_32_BIT
      );
      this.lazyLoadAtlas(
        sprites_default.DAILY_MISSIONS.KEY,
        sprites_default.DAILY_MISSIONS.TEXTURE,
        sprites_default.DAILY_MISSIONS.JSON,
        sprites_default.DAILY_MISSIONS.TEXTURE_32_BIT
      );
      this.lazyLoadAtlas(
        sprites_default.DASHBOARD.KEY,
        sprites_default.DASHBOARD.TEXTURE,
        sprites_default.DASHBOARD.JSON,
        sprites_default.DASHBOARD.TEXTURE_32_BIT
      );
      this.lazyLoadAtlas(
        sprites_default.CHALLENGE.KEY,
        sprites_default.CHALLENGE.TEXTURE,
        sprites_default.CHALLENGE.JSON,
        sprites_default.CHALLENGE.TEXTURE_32_BIT
      );
    }
    lazyLoadAtlas(sourceKey, baseTextureUrl, baseAtlasUrl, atlas32BitUrl) {
      const { FILE_KEY_COMPLETE } = Phaser.Loader.Events;
      this.load.atlas({
        key: sourceKey,
        textureURL: baseTextureUrl,
        atlasURL: baseAtlasUrl
      });
      this.load.once(`${FILE_KEY_COMPLETE}atlasjson-${sourceKey}`, () => {
        this.loadTexture32Bit(sourceKey, [atlas32BitUrl]);
      });
    }
    loadSounds() {
      const isMusicEnabled = !!player7.getPlayerSetting("music");
      this.loadSoundFX();
      if (isMusicEnabled) {
        this.loadMusic();
      }
    }
    loadSoundFX() {
      const keys = O8.vals(soundEffects_default);
      for (const key of keys) {
        if (key === sounds_default.BACKGROUND.KEY) continue;
        if (key === sounds_default.DASHBOARD.KEY) continue;
        const path = sounds_default.NEW_EFFECTS[key] ?? void 0;
        if (!path) continue;
        this.load.audio(key, path);
      }
    }
    loadMusic() {
      if (this.isMusicLoaded) return;
      this.isMusicLoaded = true;
      const { FILE_KEY_COMPLETE } = Phaser.Loader.Events;
      const file = AudioUtils_default.getMusicPath();
      const key = sounds_default.BACKGROUND.KEY;
      this.load.once(`${FILE_KEY_COMPLETE}audio-${key}`, this.handleLoadMusicCompleted);
      this.load.audio(key, file);
    }
    handleLoadMusicCompleted = () => {
      AudioUtils_default.playMusic();
      AudioUtils_default.setDefaultVolumeMusic();
    };
    loadCurrentLevelTiles() {
      const { level } = player7.getGameData() ?? {};
      let currentLevel = level;
      if (!V10.isNumber(currentLevel)) {
        currentLevel = 1;
      }
      let usedTiles = GameSettings_default.Themes;
      if (currentLevel < gameLevels_default.length) {
        usedTiles = gameLevels_default[currentLevel].theme;
      }
      for (const tile of usedTiles) {
        switch (tile) {
          case "cake": {
            console.log("Loaded cake");
            this.load.atlas({
              key: sprites_default.TILES.CAKE.KEY,
              textureURL: sprites_default.TILES.CAKE.TEXTURE,
              atlasURL: sprites_default.TILES.CAKE.JSON
            });
            break;
          }
          case "bird": {
            console.log("Loaded bird");
            this.load.atlas({
              key: sprites_default.TILES.BIRD.KEY,
              textureURL: sprites_default.TILES.BIRD.TEXTURE,
              atlasURL: sprites_default.TILES.BIRD.JSON
            });
            break;
          }
          case "fruit": {
            console.log("Loaded fruit");
            this.load.atlas({
              key: sprites_default.TILES.FRUIT.KEY,
              textureURL: sprites_default.TILES.FRUIT.TEXTURE,
              atlasURL: sprites_default.TILES.FRUIT.JSON
            });
            break;
          }
          case "flower": {
            console.log("Loaded flower");
            this.load.atlas({
              key: sprites_default.TILES.FLOWER.KEY,
              textureURL: sprites_default.TILES.FLOWER.TEXTURE,
              atlasURL: sprites_default.TILES.FLOWER.JSON
            });
            break;
          }
          case "umbrella": {
            console.log("Loaded umbrella");
            this.load.atlas({
              key: sprites_default.TILES.UMBRELLA.KEY,
              textureURL: sprites_default.TILES.UMBRELLA.TEXTURE,
              atlasURL: sprites_default.TILES.UMBRELLA.JSON
            });
            break;
          }
          case "food": {
            console.log("Loaded food");
            this.load.atlas({
              key: sprites_default.TILES.FOOD.KEY,
              textureURL: sprites_default.TILES.FOOD.TEXTURE,
              atlasURL: sprites_default.TILES.FOOD.JSON
            });
            break;
          }
          case "candy": {
            console.log("Loaded candy");
            this.load.atlas({
              key: sprites_default.TILES.CANDY.KEY,
              textureURL: sprites_default.TILES.CANDY.TEXTURE,
              atlasURL: sprites_default.TILES.CANDY.JSON
            });
            break;
          }
          case "butterfly": {
            console.log("Loaded butterfly");
            this.load.atlas({
              key: sprites_default.TILES.BUTTERFLY.KEY,
              textureURL: sprites_default.TILES.BUTTERFLY.TEXTURE,
              atlasURL: sprites_default.TILES.BUTTERFLY.JSON
            });
          }
        }
      }
    }
    lazyLoadTiles() {
      if (!this.textures.exists(sprites_default.TILES.CAKE.KEY)) {
        this.isLazyLoadRequesting = true;
        console.log("Lazy load cake");
        this.load.atlas({
          key: sprites_default.TILES.CAKE.KEY,
          textureURL: sprites_default.TILES.CAKE.TEXTURE,
          atlasURL: sprites_default.TILES.CAKE.JSON
        });
      }
      if (!this.textures.exists(sprites_default.TILES.BIRD.KEY)) {
        this.isLazyLoadRequesting = true;
        console.log("Lazy load bird");
        this.load.atlas({
          key: sprites_default.TILES.BIRD.KEY,
          textureURL: sprites_default.TILES.BIRD.TEXTURE,
          atlasURL: sprites_default.TILES.BIRD.JSON
        });
      }
      if (!this.textures.exists(sprites_default.TILES.FRUIT.KEY)) {
        this.isLazyLoadRequesting = true;
        console.log("Lazy load fruit");
        this.load.atlas({
          key: sprites_default.TILES.FRUIT.KEY,
          textureURL: sprites_default.TILES.FRUIT.TEXTURE,
          atlasURL: sprites_default.TILES.FRUIT.JSON
        });
      }
      if (!this.textures.exists(sprites_default.TILES.FLOWER.KEY)) {
        this.isLazyLoadRequesting = true;
        console.log("Lazy load flower");
        this.load.atlas({
          key: sprites_default.TILES.FLOWER.KEY,
          textureURL: sprites_default.TILES.FLOWER.TEXTURE,
          atlasURL: sprites_default.TILES.FLOWER.JSON
        });
      }
      if (!this.textures.exists(sprites_default.TILES.FOOD.KEY)) {
        this.isLazyLoadRequesting = true;
        console.log("Lazy load food");
        this.load.atlas({
          key: sprites_default.TILES.FOOD.KEY,
          textureURL: sprites_default.TILES.FOOD.TEXTURE,
          atlasURL: sprites_default.TILES.FOOD.JSON
        });
      }
      if (!this.textures.exists(sprites_default.TILES.UMBRELLA.KEY)) {
        this.isLazyLoadRequesting = true;
        console.log("Lazy load umbrella");
        this.load.atlas({
          key: sprites_default.TILES.UMBRELLA.KEY,
          textureURL: sprites_default.TILES.UMBRELLA.TEXTURE,
          atlasURL: sprites_default.TILES.UMBRELLA.JSON
        });
      }
      if (!this.textures.exists(sprites_default.TILES.CANDY.KEY)) {
        this.isLazyLoadRequesting = true;
        console.log("Lazy load candy");
        this.load.atlas({
          key: sprites_default.TILES.CANDY.KEY,
          textureURL: sprites_default.TILES.CANDY.TEXTURE,
          atlasURL: sprites_default.TILES.CANDY.JSON
        });
      }
      if (!this.textures.exists(sprites_default.TILES.BUTTERFLY.KEY)) {
        this.isLazyLoadRequesting = true;
        console.log("Lazy load butterfly");
        this.load.atlas({
          key: sprites_default.TILES.BUTTERFLY.KEY,
          textureURL: sprites_default.TILES.BUTTERFLY.TEXTURE,
          atlasURL: sprites_default.TILES.BUTTERFLY.JSON
        });
      }
    }
    loadTexture32Bit(sourceKey, textureURL) {
      const listKeys = [];
      for (const url of textureURL) {
        const tempKey = Ludex.Utils.String.generateObjectId();
        this.load.image(tempKey, url);
        listKeys.push(tempKey);
      }
      this.load.start();
      let numOfFinish = 0;
      const callback = (key) => {
        const idx = listKeys.indexOf(key);
        if (idx === -1) return;
        const textures32Bit = this.textures.get(key);
        const texture8Bit = this.textures.get(sourceKey);
        texture8Bit.source[idx].glTexture = textures32Bit.source[0].glTexture;
        texture8Bit.source[idx].glIndex = textures32Bit.source[0].glIndex;
        texture8Bit.source[idx].glIndexCounter = textures32Bit.source[0].glIndexCounter;
        numOfFinish++;
        if (numOfFinish === listKeys.length) {
          this.textures.off(Phaser.Textures.Events.ADD, callback);
        }
      };
      this.textures.on(Phaser.Textures.Events.ADD, callback);
    }
  };
  var LoadScene_default = LoadScene;

  // src/game/screens/pause-screen/GameplayNotification.ts
  init_phaser_custom_min();

  // src/utils/BlendModeUtils.ts
  init_phaser_custom_min();
  var { Events: Events9 } = Ludex;
  var { event: event13, adaptivePerformance: adaptivePerformance2 } = codex;
  var BlendModeUtils = class _BlendModeUtils {
    static _instance;
    static get inst() {
      if (!this._instance) {
        this._instance = new _BlendModeUtils();
      }
      return this._instance;
    }
    currentQuality = "high";
    constructor() {
      event13.on(Events9.REQUEST_QUALITY_UPGRADED, () => {
        this.currentQuality = "high";
      });
      event13.on(Events9.REQUEST_QUALITY_DOWNGRADED, () => {
        this.currentQuality = "low";
      });
    }
    setBlendModeWithPerf(obj, mode) {
      if (!adaptivePerformance2) {
        obj.setBlendMode(mode);
        return;
      }
      const tracker = this.trackGameObjectDestruction(obj);
      const updateBlendMode = (mode2) => {
        if (tracker.isDestroyed || mode2 === obj.blendMode) return;
        obj.setBlendMode(mode2);
      };
      const onQualityUpgradeRequest = () => {
        if (tracker.isDestroyed) return;
        updateBlendMode(mode);
        event13.once(Events9.REQUEST_QUALITY_DOWNGRADED, onQualityDowngradeRequest);
      };
      const onQualityDowngradeRequest = () => {
        if (tracker.isDestroyed) return;
        updateBlendMode(Phaser.BlendModes.NORMAL);
        event13.once(Events9.REQUEST_QUALITY_UPGRADED, onQualityUpgradeRequest);
      };
      if (this.currentQuality === "high") {
        onQualityUpgradeRequest();
      } else {
        onQualityDowngradeRequest();
      }
    }
    trackGameObjectDestruction(obj) {
      let destroyed = false;
      const setDestroyed = () => {
        destroyed = true;
      };
      obj.once(Phaser.GameObjects.Events.DESTROY, setDestroyed);
      return {
        get isDestroyed() {
          return destroyed;
        }
      };
    }
  };

  // src/game/screens/pause-screen/GameplayNotification.ts
  var {
    Utils: { Signal: S3 }
  } = Ludex;
  var { KEY: KEY12, FRAME: FRAME11 } = sprites_default.DEFAULT;
  var GameplayNotification = class extends Phaser.GameObjects.Container {
    lastUpdate = 0;
    alertIcon;
    alertShine;
    alertShineOgScale;
    alertAnimController = new S3.SignalController();
    isAlerting = false;
    isMinimized = false;
    constructor(scene, config) {
      super(scene);
      const { isMinimized = false } = config || {};
      this.isMinimized = isMinimized;
      this.createAlertIcon();
      this.createAlertShine();
      this.setName("GameplayNotification");
    }
    createAlertIcon() {
      this.alertIcon = this.scene.add.image(0, 0, KEY12, FRAME11.ICON_INFO_DOT);
      this.add(this.alertIcon);
      if (this.isMinimized) {
        this.alertIcon.setScale(0.8);
      }
      this.alertIcon.kill();
    }
    createAlertShine() {
      this.alertShine = this.scene.add.image(0, 0, KEY12, FRAME11.ICON_INFO_DOT);
      this.alertShine.setAlpha(0);
      if (this.isMinimized) {
        this.alertShine.setScale(0.5);
      }
      BlendModeUtils.inst.setBlendModeWithPerf(this.alertShine, Phaser.BlendModes.ADD);
      this.add(this.alertShine);
      this.alertShineOgScale = this.alertShine.scale;
      this.alertShine.kill();
    }
    playAlertAnimation() {
      if (this.isAlerting) return;
      this.isAlerting = true;
      const signal = this.alertAnimController.renew();
      this.alertIcon.revive();
      this.alertShine.revive();
      const targetScale = this.isMinimized ? 0.5 : 1;
      const scaleMultiplier = this.isMinimized ? 3 : 1.7;
      AnimUtils.runTween(
        this.scene.tweens.chain({
          paused: true,
          tweens: [
            {
              targets: this,
              props: {
                scale: { from: 0, to: targetScale }
              },
              duration: 200,
              ease: Phaser.Math.Easing.Sine.Out
            },
            {
              targets: this.alertShine,
              props: {
                alpha: { from: 0.4, to: 0 },
                scale: { from: this.alertShineOgScale, to: this.alertShineOgScale * scaleMultiplier }
              },
              duration: 1e3,
              ease: Phaser.Math.Easing.Cubic.Out,
              repeat: -1
            }
          ]
        }),
        signal
      );
    }
    stopAlertAnimation() {
      if (!this.isAlerting) return;
      this.isAlerting = false;
      const signal = this.alertAnimController.renew();
      const kill = () => {
        this.alertIcon.kill();
        this.alertShine.kill();
      };
      const targetScale = WorldUtils_default.isLandscape() ? 0.5 : 1;
      AnimUtils.runTween(
        this.scene.tweens.add({
          targets: this,
          props: {
            scale: { from: targetScale, to: 0 }
          },
          duration: 200,
          ease: Phaser.Math.Easing.Sine.In,
          paused: true,
          onComplete: kill
        }),
        signal
      );
    }
  };
  var GameplayNotification_default = GameplayNotification;

  // src/game/screens/pause-screen/PauseScreen.ts
  var { player: player8, event: event14 } = codex;
  var {
    Utils: { Device: D4 }
  } = Ludex;
  var { KEY: KEY13, FRAME: FRAME12 } = sprites_default.DEFAULT;
  var MenuButton = class extends Button_default {
    scaleDown = 0.98;
  };
  var PauseScreen = class extends Screen_default {
    popup$;
    title$;
    buttonClose$;
    contents$;
    settingMusic$;
    settingSound$;
    settingVibrate$;
    restartButton$;
    newGameButton$;
    continueButton$;
    dashboardButton$;
    shareButton$;
    dashboardNotification$;
    popupShowUpAnimation$;
    popupFadeOutAnimation$;
    contentShowUpAnimation$;
    constructor(scene, name) {
      super(scene, name);
      this.createPopup$();
      this.createTitle$();
      this.createButtons$();
      this.addItem$();
      this.arrangeItems$();
      this.createInput$();
      this.setDepth(ScreenDepth_default.POPUP);
    }
    open() {
      super.open();
      event14.emit(game_default.PAUSE);
      const playerSettings = player8.getPlayerSettings();
      const { music, sound, vibrate } = playerSettings;
      this.settingMusic$.updateStatus(music);
      this.settingSound$.updateStatus(sound);
      if (!D4.isDesktop()) {
        this.settingVibrate$.updateStatus(vibrate);
      }
      this.updateButtonByMode$();
      const isNotificationAvailable = GameplayNotificationUtils_default.isPauseScreenNotificationAvailable;
      if (isNotificationAvailable && this.dashboardButton$.visible) {
        this.playDashboardNotification();
      }
      this.runOpenAnimation$();
    }
    createInput$() {
      this.buttonClose$.setButtonHitSoundEffect(soundEffects_default.CLOSE_POPUP_CLICK);
      this.buttonClose$.onClick = this.handleClose$;
      this.settingMusic$.onClick = this.handleMusicSetting$;
      this.settingSound$.onClick = this.handleSoundSetting$;
      if (!D4.isDesktop()) {
        this.settingVibrate$.onClick = this.handleVibrateSetting$;
      } else {
        this.settingVibrate$.setDisabled(true);
      }
    }
    isDashboardScene$() {
      return this.scene.scene.key === SceneKeys_default.DASHBOARD_SCENE;
    }
    updateTitleByMode$() {
      if (this.isDashboardScene$()) {
        this.title$.setFrame(FRAME12.SETTINGS_TEXT);
      } else {
        this.title$.setFrame(FRAME12.PAUSE_TEXT);
      }
    }
    updateButtonByMode$() {
      const isChallenge = MatchUtils_default.isChallengeMode();
      this.updateTitleByMode$();
      if (this.isDashboardScene$()) {
        this.newGameButton$.setVisible(true);
        this.restartButton$.setVisible(false);
        this.dashboardButton$.setVisible(false);
        this.continueButton$.setVisible(false);
        this.shareButton$.setVisible(true);
      } else {
        this.dashboardButton$.setVisible(true);
        this.shareButton$.setVisible(false);
        this.continueButton$.setVisible(false);
        this.newGameButton$.setVisible(isChallenge);
        this.restartButton$.setVisible(!isChallenge);
      }
    }
    handleClose$ = () => {
      event14.emit(game_default.RESUME);
      this.runCloseAnimation$();
      this.stopDashboardNotification();
      GameplayNotificationUtils_default.setPauseScreenNotificationFlag(false);
    };
    handleDashboard$ = async () => {
      this.runCloseAnimation$();
      GameplayNotificationUtils_default.setPauseScreenNotificationFlag(false);
      if (MatchUtils_default.isTournamentMode()) {
        await MatchUtils_default.finishTournamentAsync();
      }
      this.scene.time.delayedCall(200, () => {
        SceneUtils_default.switchToDashboardScene();
      });
    };
    handleRestart$ = () => {
      this.runCloseAnimation$();
      event14.emit(game_default.REPLAY);
    };
    handleNewGame$ = async () => {
      const success = await MatchUtils_default.startSingleModeAsync();
      if (!success) return;
      this.runCloseAnimation$();
      if (this.isDashboardScene$()) {
        this.scene.time.delayedCall(200, () => {
          SceneUtils_default.switchToGameScene();
        });
      }
    };
    handleMusicSetting$ = (enable) => {
      player8.setSetting("music", enable);
      if (enable) {
        const scene = this.scene.game.scene.getScene(SceneKeys_default.LOAD_SCENE);
        if (scene instanceof LoadScene_default) {
          scene.loadMusic();
        }
        AudioUtils_default.playMusic();
      } else {
        AudioUtils_default.pauseMusic();
      }
    };
    handleInvite$ = async () => {
      const success = this.isDashboardScene$() ? await MatchUtils_default.autoChallengeModeAsync() :
      await MatchUtils_default.startChallengeChooseOpponentAsync();
      if (!success) return;
      if (this.isDashboardScene$()) {
        this.scene.time.delayedCall(200, () => {
          SceneUtils_default.switchToGameScene();
        });
      } else {
        this.runCloseAnimation$();
        event14.emit(game_default.REPLAY);
      }
    };
    handleSoundSetting$ = (enable) => {
      player8.setSetting("sound", enable);
    };
    handleVibrateSetting$ = (enable) => {
      player8.setSetting("vibrate", enable);
    };
    createPopup$() {
      this.popup$ = this.scene.add.container(0, 0);
      this.popup$.setSize(292, 374);
      const board = this.scene.make.image({
        key: KEY13,
        frame: FRAME12.POPUP
      });
      this.popup$.add(board);
      this.add(this.popup$);
      const bannerHeightOffset = AdsUtils_default.getBannerHeight() / 2;
      Phaser.Display.Align.In.Center(this.popup$, this.zone, 0, -bannerHeightOffset);
    }
    createTitle$() {
      this.title$ = this.scene.make.image({
        key: KEY13,
        frame: FRAME12.PAUSE_TEXT
      });
      this.popup$.add(this.title$);
      AlignUtils_default.alignChildTopCenter(this.title$, this.popup$, 2, -23);
    }
    createButtons$() {
      const { music, sound, vibrate } = player8.getPlayerSettings();
      this.createCloseButton$();
      this.createButtonFrames$();
      this.createDashboardButton$();
      this.createContinueButton$();
      this.createShareButton$();
      this.createRestartButton$();
      this.createNewGameButton$();
      this.createInviteButton$();
      this.createMusicButton$(music);
      this.createSoundButton$(sound);
      this.createVibrateButton(vibrate);
    }
    createCloseButton$() {
      this.buttonClose$ = new Button_default(this.scene, KEY13, FRAME12.BUTTON_CLOSE);
      const icon = this.scene.make.image({
        key: KEY13,
        frame: FRAME12.ICON_X
      });
      this.buttonClose$.add(icon);
      this.buttonClose$.setName("Close");
      this.popup$.add(this.buttonClose$);
      AlignUtils_default.alignChildTopRight(this.buttonClose$, this.popup$, -15, -15);
    }
    // bg button for 3 buttons: continue, restart, invite
    createButtonFrames$() {
      const bg1 = this.scene.make.image({
        key: KEY13,
        frame: FRAME12.BUTTON_FRAME
      });
      const bg2 = this.scene.make.image({
        key: KEY13,
        frame: FRAME12.BUTTON_FRAME
      });
      const bg3 = this.scene.make.image({
        key: KEY13,
        frame: FRAME12.BUTTON_FRAME
      });
      this.popup$.add([bg1, bg2, bg3]);
      AlignUtils_default.alignChildCenter(bg1, this.popup$, 0, -10.5);
      AlignUtils_default.alignChildCenter(bg2, this.popup$, 0, 49.5);
      AlignUtils_default.alignChildCenter(bg3, this.popup$, 0, 109.5);
    }
    createDashboardButton$() {
      const button = new MenuButton(this.scene, KEY13, FRAME12.BUTTON_BLUE);
      const label = FontUtils_default.createText(this.scene, "Home", 17).setFontStyle("900");
      FontUtils_default.applyBlueStyle(label);
      const icon = this.scene.make.image({
        key: KEY13,
        frame: FRAME12.ICON_HOME
      });
      button.add([icon, label]);
      Phaser.Display.Align.In.Center(label, button, 16);
      Phaser.Display.Align.In.LeftCenter(icon, label, 40);
      button.setName("Dashboard");
      this.popup$.add(button);
      AlignUtils_default.alignChildCenter(button, this.popup$, 0, -10);
      button.onClick = this.handleDashboard$;
      this.dashboardNotification$ = new GameplayNotification_default(this.scene);
      this.popup$.add(this.dashboardNotification$);
      AlignUtils_default.alignChildTopRight(this.dashboardNotification$, button, -7, 4);
      this.dashboardButton$ = button;
    }
    createContinueButton$() {
      const button = new MenuButton(this.scene, KEY13, FRAME12.BUTTON_BLUE);
      const label = FontUtils_default.createText(this.scene, "Continue", 17).setFontStyle("900");
      FontUtils_default.applyBlueStyle(label);
      const icon = this.scene.make.image({
        key: KEY13,
        frame: FRAME12.ICON_CONTINUE
      });
      button.add([icon, label]);
      Phaser.Display.Align.In.Center(label, button, 16);
      Phaser.Display.Align.In.LeftCenter(icon, label, 40);
      button.setName("Continue");
      this.popup$.add(button);
      AlignUtils_default.alignChildCenter(button, this.popup$, 0, -10);
      button.onClick = this.handleClose$;
      this.continueButton$ = button;
    }
    createShareButton$() {
      const button = new MenuButton(this.scene, KEY13, FRAME12.BUTTON_BLUE);
      const label = FontUtils_default.createText(this.scene, "Share", 17).setFontStyle("900");
      FontUtils_default.applyBlueStyle(label);
      const icon = this.scene.make.image({
        key: KEY13,
        frame: FRAME12.ICON_SHARE
      });
      button.add([icon, label]);
      Phaser.Display.Align.In.Center(label, button, 14);
      Phaser.Display.Align.In.LeftCenter(icon, label, 40);
      button.setName("Share");
      this.popup$.add(button);
      AlignUtils_default.alignChildCenter(button, this.popup$, 0, -10);
      button.onClick = this.handleShare$;
      this.shareButton$ = button;
    }
    createRestartButton$() {
      const button = new MenuButton(this.scene, KEY13, FRAME12.BUTTON_YELLOW);
      const label = FontUtils_default.createText(this.scene, "Restart", 17).setFontStyle("900");
      FontUtils_default.applyOrangeStyle(label);
      const icon = this.scene.make.image({
        key: KEY13,
        frame: FRAME12.ICON_REPLAY
      });
      button.add(icon);
      button.add(label);
      Phaser.Display.Align.In.Center(label, button, 16);
      Phaser.Display.Align.In.LeftCenter(icon, label, 40);
      button.setName("Restart");
      this.popup$.add(button);
      AlignUtils_default.alignChildCenter(button, this.popup$, 0, 50);
      button.onClick = this.handleRestart$;
      this.restartButton$ = button;
    }
    // like restart button
    createNewGameButton$() {
      const button = new MenuButton(this.scene, KEY13, FRAME12.BUTTON_YELLOW);
      const label = FontUtils_default.createText(this.scene, "New Game", 17).setFontStyle("900");
      FontUtils_default.applyOrangeStyle(label);
      const icon = this.scene.make.image({
        key: KEY13,
        frame: FRAME12.ICON_REPLAY
      });
      button.add(icon);
      button.add(label);
      Phaser.Display.Align.In.Center(label, button, 16);
      Phaser.Display.Align.In.LeftCenter(icon, label, 35);
      button.setName("New Game");
      this.popup$.add(button);
      AlignUtils_default.alignChildCenter(button, this.popup$, 0, 50);
      button.onClick = this.handleNewGame$;
      this.newGameButton$ = button;
    }
    createInviteButton$() {
      const button = new MenuButton(this.scene, KEY13, FRAME12.BUTTON_GREEN);
      const label = FontUtils_default.createText(this.scene, "Invite Friends", 17).setFontStyle("900");
      FontUtils_default.applyGreenStyle(label);
      const icon = this.scene.make.image({
        key: KEY13,
        frame: FRAME12.ICON_INVITE
      });
      button.add(icon);
      button.add(label);
      Phaser.Display.Align.In.Center(label, button, 16);
      Phaser.Display.Align.In.LeftCenter(icon, label, 30);
      button.setName("Invite");
      this.popup$.add(button);
      AlignUtils_default.alignChildCenter(button, this.popup$, 0, 110);
      button.onClick = this.handleInvite$;
    }
    createMusicButton$(enable) {
      this.settingMusic$ = new ToggleButton_default(this.scene, {
        enable,
        frameOn: FRAME12.ICON_MUSIC_ON,
        frameOff: FRAME12.ICON_MUSIC_OFF
      });
      this.settingMusic$.setName("Music");
    }
    createSoundButton$(enable) {
      this.settingSound$ = new ToggleButton_default(this.scene, {
        enable,
        frameOn: FRAME12.ICON_SOUND_ON,
        frameOff: FRAME12.ICON_SOUND_OFF
      });
      this.settingSound$.setName("Sound");
    }
    createVibrateButton(enable) {
      this.settingVibrate$ = new ToggleButton_default(this.scene, {
        enable,
        frameOn: FRAME12.ICON_VIBRATE_ON,
        frameOff: FRAME12.ICON_VIBRATE_OFF
      });
      this.settingVibrate$.setName("Vibrate");
    }
    addItem$() {
      this.contents$ = this.scene.add.group();
      this.contents$.addMultiple([this.settingMusic$, this.settingSound$, this.settingVibrate$]);
      this.popup$.add(this.contents$.getChildren());
    }
    arrangeItems$() {
      const space = 70;
      this.settingSound$.setPosition(-space, -this.popup$.height * 0.22);
      this.settingMusic$.setPosition(0, -this.popup$.height * 0.22);
      this.settingVibrate$.setPosition(space, -this.popup$.height * 0.22);
    }
    // Animations
    runOpenAnimation$() {
      if (this.popupShowUpAnimation$?.isPlaying()) return;
      this.background.setAlpha(0);
      this.animateBackgroundAlpha(0.8);
      this.runPopupEntrancesAnimation$(0, 400);
      this.runPopupContentEntrancesAnimation$(200, 300);
    }
    runCloseAnimation$() {
      if (this.popupFadeOutAnimation$?.isPlaying()) return;
      this.animateBackgroundAlpha(0, 200);
      this.runPopupExitsAnimation$(0, 200);
    }
    // Entrances animations
    runPopupEntrancesAnimation$(delay, duration) {
      const bannerHeightOffset = AdsUtils_default.getBannerHeight() / 2;
      this.popupShowUpAnimation$ = this.scene.tweens.add({
        ...ShowUp_default,
        targets: [this.popup$],
        delay,
        duration,
        props: {
          ...ShowUp_default.props,
          y: { from: 350 - bannerHeightOffset, to: -bannerHeightOffset },
          alpha: { start: 1, from: 1, to: 1 },
          scale: { start: 0, from: 0, to: 1 }
        }
      });
      AnimUtils.runTween(this.popupShowUpAnimation$);
    }
    runPopupContentEntrancesAnimation$(delay, duration) {
      const targets = this.contents$.getChildren();
      const targetsAlpha = targets.map((target) => target.alpha);
      for (const target of targets) {
        target.setAlpha(0);
      }
      this.contentShowUpAnimation$?.remove();
      this.contentShowUpAnimation$ = this.scene.tweens.add({
        ...BubbleTouch_default,
        targets,
        duration,
        delay,
        props: {
          ...BubbleTouch_default.props,
          alpha: {
            getStart: () => 0,
            getEnd: (_target, _key, _value, targetIndex) => {
              return targetsAlpha[targetIndex];
            }
          }
        }
      });
      AnimUtils.runTween(this.contentShowUpAnimation$);
    }
    // Exits animations
    runPopupExitsAnimation$(delay, duration) {
      this.popupFadeOutAnimation$?.remove();
      const bannerHeightOffset = AdsUtils_default.getBannerHeight() / 2;
      this.popupFadeOutAnimation$ = this.scene.tweens.add({
        ...FadeOut_default,
        targets: [this.popup$],
        delay,
        duration,
        props: {
          ...FadeOut_default.props,
          y: 250 - bannerHeightOffset,
          scale: 0
        },
        onComplete: () => {
          this.popup$.setY(0);
        }
      });
      AnimUtils.runTweenAsync(this.popupFadeOutAnimation$).then(() => {
        ScreenUtils_default.closeScreen(this.name);
      });
    }
    handleShare$ = async () => {
      try {
        ScreenUtils_default.showLoadingScreen();
        await WideframeUtils_default.postBestScoreWideframe();
      } catch (error) {
        console.warn(error);
      } finally {
        ScreenUtils_default.closeLoadingScreen();
      }
    };
    playDashboardNotification() {
      if (!this.dashboardNotification$) return;
      this.dashboardNotification$.playAlertAnimation();
    }
    stopDashboardNotification() {
      if (!this.dashboardNotification$) return;
      this.dashboardNotification$.stopAlertAnimation();
    }
  };
  var PauseScreen_default = PauseScreen;

  // src/game/screens/RescueScreen.ts
  init_phaser_custom_min();

  // src/game/screens/common/ResultBombAnimation.ts
  init_phaser_custom_min();

  // src/game/gameplay/constants/animation.ts
  init_phaser_custom_min();
  var { EFFECTS, GAMEPLAY } = sprites_default;
  var { KEY: KEY14, FRAME: FRAME13 } = EFFECTS;
  var ANIMATIONS = {
    CONFETTI_STAR_X: {
      KEY: "confetti-star-x",
      TEXTURE: KEY14,
      PREFIX: FRAME13.ANIMATION_STAR_X,
      FRAME_RATE: 4,
      END: 4,
      ZERO_PAD: 0
    },
    CONFETTI_STAR_Y: {
      KEY: "confetti-star-y",
      TEXTURE: KEY14,
      PREFIX: FRAME13.ANIMATION_STAR_Y,
      FRAME_RATE: 4,
      END: 4,
      ZERO_PAD: 0
    },
    RIBBON_A: {
      KEY: "animation-ribbon-a",
      TEXTURE: KEY14,
      PREFIX: FRAME13.PREFIX_ANIMATION_RIBBON_CONFETTI_A,
      FRAME_RATE: 16,
      END: 3,
      ZERO_PAD: 0
    },
    RIBBON_B: {
      KEY: "animation-ribbon-b",
      TEXTURE: KEY14,
      PREFIX: FRAME13.PREFIX_ANIMATION_RIBBON_CONFETTI_B,
      FRAME_RATE: 16,
      END: 4,
      ZERO_PAD: 0
    },
    RIBBON_C: {
      KEY: "animation-ribbon-c",
      TEXTURE: KEY14,
      PREFIX: FRAME13.PREFIX_ANIMATION_RIBBON_CONFETTI_C,
      FRAME_RATE: 16,
      END: 4,
      ZERO_PAD: 0
    },
    RIBBON_D: {
      KEY: "animation-ribbon-d",
      TEXTURE: KEY14,
      PREFIX: FRAME13.PREFIX_ANIMATION_RIBBON_CONFETTI_D,
      FRAME_RATE: 16,
      END: 4,
      ZERO_PAD: 0
    },
    POLISH_EFFECT: {
      KEY: "polish-effect-animation",
      TEXTURE: EFFECTS.KEY,
      PREFIX: EFFECTS.FRAME.POLISH_EFFECT,
      FRAME_RATE: 30,
      END: 5,
      ZERO_PAD: 1
    },
    BOMB_EXPLOSION: {
      KEY: "bomb-explosion-animation",
      TEXTURE: EFFECTS.KEY,
      PREFIX: EFFECTS.FRAME.EFFECT_BOMB_EXPLOSION,
      FRAME_RATE: 16,
      END: 8,
      ZERO_PAD: 1
    },
    BOMB_DEFUSE: {
      KEY: "bomb-defuse-animation",
      TEXTURE: EFFECTS.KEY,
      PREFIX: EFFECTS.FRAME.EFFECT_BOMB_DEFUSE,
      FRAME_RATE: 16,
      END: 8,
      ZERO_PAD: 1
    },
    ROCKET_EXPLOSION: {
      KEY: "rocket-explosion-animation",
      TEXTURE: EFFECTS.KEY,
      PREFIX: EFFECTS.FRAME.EFFECT_ROCKET_EXPLOSION,
      FRAME_RATE: 16,
      END: 8,
      ZERO_PAD: 1
    },
    ROCKET_TAIL: {
      KEY: "rocket-tail-animation",
      TEXTURE: EFFECTS.KEY,
      PREFIX: EFFECTS.FRAME.ROCKET_TAIL,
      FRAME_RATE: 60,
      END: 70,
      ZERO_PAD: 1
    },
    TILE_HIGHLIGHT: {
      KEY: "tile-highlight-animation",
      TEXTURE: GAMEPLAY.KEY,
      PREFIX: GAMEPLAY.FRAME.EFFECT_TILE_HIGHLIGHT,
      FRAME_RATE: 31,
      END: 31,
      ZERO_PAD: 1
    }
  };
  var animation_default = ANIMATIONS;

  // src/game/screens/common/ResultBombAnimation.ts
  var { DEFAULT, EFFECTS: EFFECTS2 } = sprites_default;
  var ResultBombAnimation = class extends Phaser.GameObjects.Container {
    whiteGlow;
    bomb;
    explosion;
    bombShakeTween;
    glowSpinTween;
    constructor(scene) {
      super(scene);
      this.createWhiteGlow();
      this.createBomb();
      this.createExplosion();
    }
    createWhiteGlow() {
      const whiteGlow = this.scene.add.image(0, 0, DEFAULT.KEY, DEFAULT.FRAME.ART_WHITE_GLOW);
      this.add(whiteGlow);
      whiteGlow.setPosition(0, 0);
      this.whiteGlow = whiteGlow;
    }
    createBomb() {
      const bomb = this.scene.add.image(0, 0, DEFAULT.KEY, DEFAULT.FRAME.ICON_BOMB);
      this.add(bomb);
      bomb.setPosition(0, 0);
      this.bomb = bomb;
    }
    createExplosion() {
      const explosion = this.scene.add.sprite(0, 0, EFFECTS2.KEY, `${EFFECTS2.FRAME.EFFECT_BOMB_EXPLOSION}\
0`);
      this.add(explosion);
      explosion.setPosition(0, 0);
      explosion.setWorldSize(45, 45);
      explosion.kill();
      this.explosion = explosion;
    }
    runBombShakeAnimation() {
      this.bombShakeTween?.stop();
      this.bomb.setPosition(0, 0);
      this.bomb.revive();
      this.whiteGlow.revive();
      this.explosion.kill();
      this.bombShakeTween = this.scene.tweens.add({
        targets: this.bomb,
        x: -2,
        delay: 800,
        duration: 50,
        ease: "Sine.easeInOut",
        yoyo: true,
        repeat: 6,
        onComplete: this.runBombExplodeAnimation
      });
    }
    runGlowSpinAnimation() {
      this.glowSpinTween?.stop();
      this.whiteGlow.revive();
      this.whiteGlow.angle = 0;
      this.glowSpinTween = this.scene.tweens.add({
        targets: this.whiteGlow,
        angle: 360,
        duration: 5e3,
        repeat: -1
      });
    }
    runBombExplodeAnimation = () => {
      this.bomb.kill();
      this.whiteGlow.kill();
      this.explosion.revive();
      this.explosion.anims.play(animation_default.BOMB_EXPLOSION.KEY, true);
      this.explosion.on(Phaser.Animations.Events.ANIMATION_COMPLETE, () => {
        this.explosion.kill();
        this.runBombShakeAnimation();
        this.runGlowSpinAnimation();
      });
    };
    play() {
      this.runGlowSpinAnimation();
      this.runBombShakeAnimation();
    }
    stop() {
      this.bombShakeTween?.stop();
      this.glowSpinTween?.stop();
      this.bomb.kill();
      this.explosion.kill();
      this.whiteGlow.kill();
    }
    revive() {
      super.revive();
      this.whiteGlow.angle = 0;
      this.whiteGlow.revive();
      this.bomb.setPosition(0, 0);
      this.bomb.revive();
    }
  };
  var ResultBombAnimation_default = ResultBombAnimation;

  // src/game/screens/common/ResultTimeOutAnimation.ts
  init_phaser_custom_min();
  var { KEY: KEY15, FRAME: FRAME14 } = sprites_default.DEFAULT;
  var ResultTimeOutAnimation = class extends Phaser.GameObjects.Container {
    clock;
    clockSpinTween;
    whiteGlow;
    glowSpinTween;
    constructor(scene) {
      super(scene);
      this.createWhiteGlow();
      this.createClock();
    }
    createClock() {
      const clock = this.scene.add.image(0, 0, KEY15, FRAME14.ICON_TIMEOUT_CLOCK);
      this.add(clock);
      clock.setPosition(0, 0);
      this.clock = clock;
    }
    createWhiteGlow() {
      const whiteGlow = this.scene.add.image(0, 0, KEY15, FRAME14.ART_WHITE_GLOW);
      this.add(whiteGlow);
      whiteGlow.setPosition(0, 0);
      this.whiteGlow = whiteGlow;
    }
    runClockSpinAnimation() {
      this.clockSpinTween?.stop();
      this.clock.angle = 0;
      this.clock.setFlipY(false);
      this.clock.revive();
      this.clockSpinTween = this.scene.tweens.add({
        targets: this.clock,
        angle: this.clock.angle + 180,
        duration: 800,
        delay: 800,
        ease: Phaser.Math.Easing.Sine.InOut,
        repeat: -1,
        repeatDelay: 800,
        onStart: () => {
          this.clock.setFlipY(false);
        }
      });
    }
    runGlowSpinAnimation() {
      this.glowSpinTween?.stop();
      this.whiteGlow.angle = 0;
      this.whiteGlow.revive();
      this.glowSpinTween = this.scene.tweens.add({
        targets: this.whiteGlow,
        angle: 360,
        duration: 5e3,
        repeat: -1
      });
    }
    play() {
      this.runClockSpinAnimation();
      this.runGlowSpinAnimation();
    }
    stop() {
      this.clockSpinTween?.stop();
      this.glowSpinTween?.stop();
    }
    revive() {
      super.revive();
      this.clock.angle = 0;
      this.clock.setFlipY(false);
      this.clock.revive();
      this.whiteGlow.angle = 0;
      this.whiteGlow.revive();
    }
  };
  var ResultTimeOutAnimation_default = ResultTimeOutAnimation;

  // src/game/screens/common/TextButton.ts
  init_phaser_custom_min();
  var TextButton = class extends Phaser.GameObjects.Container {
    useSound = true;
    isClicked = false;
    text;
    // Default scale values
    scaleUp = 1;
    scaleDown = 0.985;
    // Hit area components
    hitArea;
    hitZone;
    // Animations
    upAnimation;
    downAnimation;
    hitSoundEffectKey = soundEffects_default.GENERAL_BUTTON_CLICK;
    // Padding around text for hit area
    padding = 10;
    constructor(scene, text = "", fontSize = 16, width, height) {
      super(scene);
      this.setDepth(depth_default.BUTTON);
      this.createText(text, fontSize);
      this.createHitZone(width, height);
      this.listenEvents();
      this.scene.add.existing(this);
    }
    createText(content, fontSize) {
      this.text = FontUtils_default.createUnderlineText(this.scene, content, fontSize);
      this.text.setDepth(depth_default.TEXT);
      this.text.setAlpha(0.8);
      this.add(this.text);
    }
    createHitZone(width, height) {
      const textWidth = this.text.width + this.padding * 2;
      const textHeight = this.text.height + this.padding * 2;
      const hitWidth = width || textWidth;
      const hitHeight = height || textHeight;
      this.hitZone = this.scene.make.zone({
        width: hitWidth,
        height: hitHeight
      });
      this.add(this.hitZone);
      this.updateSize();
    }
    // Click handler implementation
    set onClick(callback) {
      this.hitArea = this.hitZone;
      this.hitArea.setInteractive({
        useHandCursor: true
      });
      this.hitArea.off(Phaser.Input.Events.GAMEOBJECT_POINTER_DOWN);
      this.hitArea.off(Phaser.Input.Events.GAMEOBJECT_POINTER_UP);
      this.hitArea.off(Phaser.Input.Events.GAMEOBJECT_POINTER_OUT);
      this.hitArea.on(Phaser.Input.Events.GAMEOBJECT_POINTER_DOWN, this.handlePointerDown);
      this.hitArea.on(Phaser.Input.Events.GAMEOBJECT_POINTER_UP, this.handleOnClick(callback));
      this.hitArea.on(Phaser.Input.Events.GAMEOBJECT_POINTER_OUT, this.handlePointerOut);
    }
    handlePointerDown = () => {
      if (this.isClicked) return;
      if (this.upAnimation?.isPlaying()) return;
      this.isClicked = true;
      this.runDownAnimation();
    };
    handleOnClick = (callback) => () => {
      if (!this.isClicked) return;
      if (this.upAnimation?.isPlaying()) return;
      this.isClicked = false;
      this.runUpAnimation();
      this.upAnimation?.once(Phaser.Tweens.Events.TWEEN_COMPLETE, () => {
        AnalyticsUtils_default.trackButtonClick(this.name);
        this.processCallback(callback);
      });
    };
    handlePointerOut = () => {
      if (!this.isClicked) return;
      if (this.upAnimation?.isPlaying()) return;
      this.isClicked = false;
      this.runUpAnimation();
    };
    processCallback(callback) {
      this.upAnimation?.stop();
      this.downAnimation?.stop();
      this.scene?.tweens.killTweensOf(this);
      this.setScale(this.scaleUp);
      callback();
    }
    // Method to set text content
    setText(content) {
      if (this.text) {
        this.text.setText(content);
        this.updateHitZoneSize();
      }
      return this;
    }
    updateHitZoneSize() {
      if (!this.text || !this.hitZone) return;
      const textWidth = this.text.width + this.padding * 2;
      const textHeight = this.text.height + this.padding * 2;
      this.hitZone.setSize(textWidth, textHeight);
      this.updateSize();
    }
    setDisabled(disable) {
      if (disable) {
        this.setAlpha(0.5);
        this.hitArea?.disableInteractive();
      } else {
        this.setAlpha(1);
        this.hitArea?.setInteractive();
      }
    }
    updateSize() {
      if (!this.hitZone) return;
      const width = this.hitZone.width;
      const height = this.hitZone.height;
      this.setSize(width, height);
    }
    runDownAnimation() {
      if (this.useSound) {
        AudioUtils_default.playSound(this.hitSoundEffectKey);
      }
      this.downAnimation?.remove();
      this.downAnimation = this.scene.tweens.add({
        ...ScaleDown_default,
        targets: [this],
        duration: 150,
        props: {
          scale: this.scaleDown
        },
        onUpdate: () => {
          if (this.hitZone) {
            this.hitZone.scale = 1 / this.scale;
          }
        }
      });
      AnimUtils.runTween(this.downAnimation);
    }
    runUpAnimation() {
      this.upAnimation?.remove();
      this.upAnimation = this.scene.tweens.add({
        ...ScaleUp_default,
        targets: [this],
        duration: 150,
        props: {
          scale: this.scaleUp
        },
        onUpdate: () => {
          if (this.hitZone) {
            this.hitZone.scale = 1 / this.scale;
          }
        }
      });
      AnimUtils.runTween(this.upAnimation);
    }
    setButtonHitSoundEffect(key) {
      this.hitSoundEffectKey = key;
    }
    // Set padding around text for hit area
    setPadding(padding) {
      this.padding = padding;
      this.updateHitZoneSize();
      return this;
    }
    listenEvents() {
      this.scene.events.on(Phaser.Scenes.Events.SLEEP, this.handleSceneSleep);
      this.once(Phaser.GameObjects.Events.DESTROY, this.handleObjectDestroy);
    }
    handleObjectDestroy = () => {
      if (!this.scene) return;
      this.scene.events.off(Phaser.Scenes.Events.SLEEP, this.handleSceneSleep);
    };
    handleSceneSleep = () => {
      if (!this.scene) return;
      this.scene.tweens.killTweensOf(this);
    };
  };
  var TextButton_default = TextButton;

  // src/game/screens/RescueScreen.ts
  var { event: event15 } = codex;
  var { KEY: KEY16, FRAME: FRAME15 } = sprites_default.DEFAULT;
  var RescueScreen = class extends Screen_default {
    level;
    reason;
    isUseRescue;
    popup;
    levelText;
    reasonText;
    reasonIcon;
    resultBombAnimation;
    resultTimeOutAnimation;
    rescueButton;
    replayButton;
    popupShowUpAnimation;
    popupFadeOutAnimation;
    constructor(scene, name) {
      super(scene, name);
      this.setDepth(ScreenDepth_default.POPUP);
      this.createPopup$();
    }
    open = (data) => {
      super.open();
      this.isUseRescue = false;
      this.level = data.level;
      this.reason = data.reason;
      this.updateLevel$();
      this.updateReason$();
      this.runOpenAnimation$();
      this.runContinueButtonAnimation$();
    };
    close() {
      this.resultBombAnimation.stop();
      this.resultBombAnimation.kill();
      this.resultTimeOutAnimation.stop();
      this.resultTimeOutAnimation.kill();
      event15.emit(game_default.RESUME);
      super.close();
    }
    handleShowRewardedVideoAd$ = async () => {
      try {
        if (this.isUseRescue) return;
        this.isUseRescue = true;
        const success = await AdsUtils_default.showRewardVideoAdAsync();
        if (!success) throw new Error("Failed to show rewarded video ad");
        this.runCloseAnimation$();
        this.popupFadeOutAnimation?.once(Phaser.Tweens.Events.TWEEN_COMPLETE, () => {
          event15.emit(game_default.RESCUE, { reason: this.reason });
        });
        AudioUtils_default.playSound(soundEffects_default.DAILY_REWARD);
      } catch (error) {
        this.isUseRescue = false;
        console.warn("Error show rewarded video ad", error);
      }
    };
    handleReplay$ = async () => {
      this.runCloseAnimation$();
      await MatchUtils_default.finishSingleModeAsync();
      await MatchUtils_default.startSingleModeAsync();
      event15.emit(game_default.REPLAY);
    };
    createContent$() {
      this.createTitle$();
      this.createLevelText$();
      this.createReasonText$();
      this.createReasonIcon$();
      this.createResultBombAnimation$();
      this.createResultTimeOutAnimation$();
      this.createRescueButton$();
      this.createReplayText$();
    }
    createPopup$() {
      this.popup = this.scene.add.container();
      this.popup.setSize(292, 374);
      const board = this.scene.make.image({
        key: KEY16,
        frame: FRAME15.POPUP
      });
      const background = this.scene.make.image({
        key: KEY16,
        frame: FRAME15.ART_BG_LIGHT
      });
      this.popup.add([background, board]);
      this.add(this.popup);
      this.createContent$();
      const bannerHeightOffset = AdsUtils_default.getBannerHeight() / 2;
      Phaser.Display.Align.In.Center(this.popup, this.zone, 0, -bannerHeightOffset);
    }
    createTitle$() {
      const title = this.scene.make.image({
        key: KEY16,
        frame: FRAME15.FAILED_TEXT
      });
      this.popup.add(title);
      AlignUtils_default.alignChildTopCenter(title, this.popup, 0, -20);
    }
    createLevelText$() {
      this.levelText = FontUtils_default.createText(this.scene, "Level X", 18);
      FontUtils_default.applyWarningStyle(this.levelText);
      this.popup.add(this.levelText);
      AlignUtils_default.alignChildTopCenter(this.levelText, this.popup, 0, -80);
    }
    createReasonText$() {
      this.reasonText = FontUtils_default.createText(this.scene, "", 16);
      FontUtils_default.applyWarningStyle(this.reasonText);
      this.reasonText.kill();
      this.popup.add(this.reasonText);
      AlignUtils_default.alignChildCenter(this.reasonText, this.popup, 0, 55);
    }
    createReasonIcon$() {
      this.reasonIcon = this.scene.make.image({
        key: KEY16,
        frame: FRAME15.ICON_LOSE
      });
      this.reasonIcon.kill();
      this.popup.add(this.reasonIcon);
      AlignUtils_default.alignChildCenter(this.reasonIcon, this.popup, -60, 60);
    }
    createResultBombAnimation$() {
      this.resultBombAnimation = new ResultBombAnimation_default(this.scene);
      this.popup.add(this.resultBombAnimation);
      AlignUtils_default.alignChildCenter(this.resultBombAnimation, this.popup, 0, -15);
      this.resultBombAnimation.kill();
    }
    createResultTimeOutAnimation$() {
      this.resultTimeOutAnimation = new ResultTimeOutAnimation_default(this.scene);
      this.popup.add(this.resultTimeOutAnimation);
      AlignUtils_default.alignChildCenter(this.resultTimeOutAnimation, this.popup, 0, -15);
      this.resultTimeOutAnimation.kill();
    }
    updateLevel$() {
      this.levelText.setText(`Level ${this.level}`);
    }
    updateReason$() {
      this.reasonText.revive();
      switch (this.reason) {
        case "bombExplosive":
          this.resultBombAnimation.revive();
          this.resultBombAnimation.play();
          this.reasonText.setText("The bomb exploded!");
          break;
        case "timeUp":
          this.resultTimeOutAnimation.revive();
          this.resultTimeOutAnimation.play();
          this.reasonIcon.setFrame(FRAME15.ICON_CLOCK);
          this.reasonText.setText("Time is up!");
          break;
        default:
          this.reasonText.setText("You have failed the level!");
      }
    }
    createRescueButton$() {
      this.rescueButton = new HighlightButton(this.scene, KEY16, FRAME15.BUTTON_GREEN);
      this.rescueButton.setName("Continue");
      const bg = this.scene.make.image({
        key: KEY16,
        frame: FRAME15.BUTTON_FRAME
      });
      this.rescueButton.onClick = this.handleShowRewardedVideoAd$;
      const iconAds = this.scene.make.image({
        key: KEY16,
        frame: FRAME15.ICON_ADS
      });
      Phaser.Display.Align.In.Center(iconAds, this.rescueButton, -65);
      this.rescueButton.content.add(iconAds);
      const continueText = FontUtils_default.createText(this.scene, "Resurrection", 18).setFontStyle(
      "700");
      FontUtils_default.applyGreenStyle(continueText);
      this.rescueButton.content.add(continueText);
      Phaser.Display.Align.In.Center(continueText, this.rescueButton, 14);
      this.popup.add([bg, this.rescueButton]);
      AlignUtils_default.alignChildBottomCenter(this.rescueButton, this.popup, 0, -40);
      Phaser.Display.Align.In.Center(bg, this.rescueButton);
    }
    createReplayText$() {
      this.replayButton = new TextButton_default(this.scene, "Replay", 16);
      this.replayButton.setAlpha(0.8);
      this.popup.add(this.replayButton);
      this.replayButton.onClick = this.handleReplay$;
      AlignUtils_default.alignChildBottomCenter(this.replayButton, this.popup, 0, 40);
    }
    // Animations
    runContinueButtonAnimation$() {
      this.rescueButton.playHighlightAnimation();
    }
    runOpenAnimation$() {
      if (this.popupShowUpAnimation?.isPlaying()) return;
      this.background.setAlpha(0);
      this.animateBackgroundAlpha(0.8);
      this.runPopupEntrancesAnimation$(0, 400);
    }
    runCloseAnimation$() {
      if (this.popupFadeOutAnimation?.isPlaying()) return;
      this.animateBackgroundAlpha(0, 200);
      this.runPopupExitsAnimation$(0, 200);
    }
    // Entrances animations
    runPopupEntrancesAnimation$(delay, duration) {
      const bannerHeightOffset = AdsUtils_default.getBannerHeight() / 2;
      const { y } = this.popup;
      this.popupShowUpAnimation = this.scene.tweens.add({
        ...ShowUp_default,
        targets: [this.popup],
        delay,
        duration,
        props: {
          ...ShowUp_default.props,
          y: { from: 350 - bannerHeightOffset, to: -bannerHeightOffset },
          alpha: { start: 1, from: 1, to: 1 },
          scale: { start: 0, from: 0, to: 1 }
        },
        onComplete: () => {
          this.updateLevel$();
          this.updateReason$();
        }
      });
      AnimUtils.runTween(this.popupShowUpAnimation);
    }
    // Exits animations
    runPopupExitsAnimation$(delay, duration) {
      const bannerHeightOffset = AdsUtils_default.getBannerHeight() / 2;
      this.popupFadeOutAnimation = this.scene.tweens.add({
        ...FadeOut_default,
        targets: [this.popup],
        delay,
        duration,
        props: {
          ...FadeOut_default.props,
          y: 250 - bannerHeightOffset,
          scale: 0
        },
        onComplete: () => {
          this.popup.setY(0);
          ScreenUtils_default.closeScreen(this.name);
        }
      });
      AnimUtils.runTween(this.popupFadeOutAnimation);
    }
  };
  var RescueScreen_default = RescueScreen;

  // src/game/screens/ResultChallengeScreen.ts
  init_phaser_custom_min();

  // src/game/screens/common/ChallengeResultPopup.ts
  init_phaser_custom_min();

  // src/game/components/AvatarFrame.ts
  init_phaser_custom_min();

  // src/utils/image/drawBorder.ts
  init_phaser_custom_min();
  var drawBorder = (payload) => {
    const { scene, key, newKey, radius } = payload;
    let { width, height } = payload;
    const source = scene.textures.get(key).getSourceImage();
    if (!source) return false;
    if (!width) width = source.width;
    if (!height) height = source.height;
    if (!newKey) {
      scene.textures.removeKey(key);
    }
    const photo = scene.textures.createCanvas(newKey || key, width, height);
    const ctx = photo.context;
    const size = Math.min(width, height);
    const mdRadius = size / 100 * radius / 2;
    const x = 0;
    const y = 0;
    ctx.beginPath();
    ctx.moveTo(x + mdRadius, y);
    ctx.lineTo(x + width - mdRadius, y);
    ctx.quadraticCurveTo(x + width, y, x + width, y + mdRadius);
    ctx.lineTo(x + width, y + height - mdRadius);
    ctx.quadraticCurveTo(x + width, y + height, x + width - mdRadius, y + height);
    ctx.lineTo(x + mdRadius, y + height);
    ctx.quadraticCurveTo(x, y + height, x, y + height - mdRadius);
    ctx.lineTo(x, y + mdRadius);
    ctx.quadraticCurveTo(x, y, x + mdRadius, y);
    ctx.closePath();
    ctx.clip();
    photo.draw(0, 0, source);
    return true;
  };
  var drawBorder_default = drawBorder;

  // src/utils/image/drawCircle.ts
  init_phaser_custom_min();
  var drawCircle = (payload) => {
    const { scene, key, newKey } = payload;
    const source = scene.textures.get(key).getSourceImage();
    if (!source) return false;
    const size = Math.min(source.width, source.height);
    if (!newKey) {
      scene.textures.removeKey(key);
    }
    const photo = scene.textures.createCanvas(newKey || key, size, size);
    const ctx = photo.context;
    ctx.beginPath();
    ctx.arc(size / 2, size / 2, size / 2, 0, Math.PI * 2, false);
    ctx.clip();
    photo.draw((source.width - size) / 2, (source.height - size) / 2, source);
    return true;
  };
  var drawCircle_default = drawCircle;

  // src/game/components/AvatarFrame.ts
  var AvatarFrame = class extends Phaser.GameObjects.Container {
    payload;
    loading;
    photo;
    avtFrame;
    background;
    loadPhotoTimer;
    constructor(scene, payload) {
      super(scene);
      this.scene.add.existing(this);
      this.payload = payload;
      this.setWorldSize(payload.width, payload.height);
      this.createBackground();
      this.createLoading();
      this.createPhoto();
      this.createFrame();
      const { id: id2, url, radius } = this.payload;
      if (id2 && url) {
        this.loadPhoto(id2, url, radius);
      }
      this.addDefaultListeners();
    }
    setFrame(frame) {
      this.avtFrame.revive();
      this.avtFrame.setFrame(frame);
    }
    setBackground(frame) {
      this.background.setFrame(frame);
    }
    loadPhoto(id2, url, radius = 0) {
      this.payload.id = id2;
      this.payload.url = url;
      this.payload.radius = radius;
      this.loadPhotoTimer?.remove();
      if (!id2 || !url) {
        this.setPhoto(images_default.AVATAR_DEFAULT.KEY);
        return;
      }
      const texture = this.scene.textures.get(id2);
      if (texture && texture.key === id2) {
        this.handleLoadComplete(id2);
        return;
      }
      this.showLoading(true);
      const delayTime = this.payload.loadDelay || 0;
      this.loadPhotoTimer = this.scene.time.delayedCall(delayTime, this.handleLoadPhotoAfterDelay(id2,
      url));
    }
    handleLoadPhotoAfterDelay = (id2, url) => () => {
      const texture = this.scene.textures.get(id2);
      if (texture && texture.key === id2) {
        this.handleLoadComplete(id2);
        return;
      }
      this.scene.load.once(`filecomplete-image-${id2}`, this.handleLoadComplete);
      this.scene.load.image(id2, url);
      this.scene.load.start();
    };
    addDefaultListeners() {
      this.scene.load.on(Phaser.Loader.Events.FILE_LOAD_ERROR, this.handleLoadPhotoFailed);
      this.on(Phaser.GameObjects.Events.DESTROY, () => {
        this.loadPhotoTimer?.remove();
        this.scene.load.off(Phaser.Loader.Events.FILE_LOAD_ERROR, this.handleLoadPhotoFailed);
      });
    }
    handleLoadComplete = (key) => {
      if (!this.scene) return;
      const { id: id2, radius = 0 } = this.payload;
      if (!id2 || id2 !== key) return;
      const avatarBorderedId = `${id2}_bordered_${radius}`;
      const photoId = radius > 0 ? avatarBorderedId : id2;
      const texture = this.scene.textures.get(photoId);
      if (texture && texture.key === photoId) {
        this.setPhoto(texture.key);
        return;
      }
      if (radius !== 0 && radius < 100) {
        const success = drawBorder_default({
          scene: this.scene,
          key: id2,
          newKey: avatarBorderedId,
          radius
        });
        if (!success) {
          this.showLoading(false);
          return;
        }
        this.setPhoto(avatarBorderedId);
      } else if (radius === 100) {
        const success = drawCircle_default({
          scene: this.scene,
          key: id2,
          newKey: avatarBorderedId
        });
        if (!success) {
          this.showLoading(false);
          return;
        }
        this.setPhoto(avatarBorderedId);
      } else {
        this.setPhoto(id2);
      }
    };
    handleLoadPhotoFailed = (photo) => {
      if (photo.key !== this.payload.id) return;
      this.setDefaultAvatar(photo.key);
    };
    setDefaultAvatar(key) {
      this.loadPhoto(key, images_default.AVATAR_DEFAULT.FILE, this.payload.radius);
    }
    createBackground() {
      const { key, background } = this.payload;
      this.background = this.scene.make.image({ key, frame: background });
      this.add(this.background);
    }
    createLoading() {
      this.loading = new Loading_default(this.scene);
      const { width, height } = this.payload;
      this.loading.setWorldSize(width, height);
      this.loading.kill();
      this.add(this.loading);
    }
    createPhoto() {
      this.photo = this.scene.make.image({
        x: 0,
        y: 0,
        origin: {
          x: 0.5,
          y: 0.5
        },
        visible: false
      });
      this.add(this.photo);
    }
    createFrame() {
      const { key, frame } = this.payload;
      if (!frame) {
        this.avtFrame = this.scene.make.image({
          x: 0,
          y: 0,
          origin: { x: 0.5, y: 0.5 },
          visible: false
        });
      } else {
        this.avtFrame = this.scene.make.image({ key, frame });
      }
      this.add(this.avtFrame);
    }
    showLoading(enable) {
      if (enable) {
        this.loading.revive();
        this.photo.kill();
      } else {
        this.loading.kill();
        this.photo.revive();
      }
    }
    setPhoto(texture) {
      this.showLoading(false);
      this.photo.setTexture(texture);
      this.photo.setFrame(0);
      const { width, height } = this.payload;
      const size = Math.min(width, height);
      this.photo.setWorldSize(size, size);
      Phaser.Display.Align.In.Center(this.photo, this.background);
    }
  };
  var AvatarFrame_default = AvatarFrame;

  // src/game/effects/StarSparkle.ts
  init_phaser_custom_min();

  // src/game/effects/particle/SparklingStar.ts
  init_phaser_custom_min();
  var SparklingStar = class extends Phaser.GameObjects.Particles.Particle {
    scale;
    update(delta, _step, _professors) {
      const result = super.update(delta, _step, _professors);
      this.updateScale();
      this.updateVelocity();
      return result;
    }
    setScale(scale) {
      this.scale = Phaser.Math.FloatBetween(scale.min, scale.max);
    }
    easeInCubic(x) {
      return x * x * x;
    }
    updateScale() {
      const cubicLifeProgress = this.easeInCubic(1 - this.lifeT);
      this.scaleX = this.scale * Math.sin(cubicLifeProgress * Math.PI);
      this.scaleY = this.scale * Math.sin(cubicLifeProgress * Math.PI);
    }
    updateVelocity() {
      this.velocityX += Phaser.Math.Between(-1, 1);
    }
  };
  var SparklingStar_default = SparklingStar;

  // src/game/effects/StarSparkle.ts
  var { KEY: KEY17, FRAME: FRAME16 } = sprites_default.EFFECTS;
  var StarSparkle = class extends Phaser.GameObjects.Container {
    emitZone;
    emitter;
    constructor(scene) {
      super(scene);
      this.scene = scene;
      this.createEmitZone();
      this.createEmitters();
    }
    createEmitZone() {
      this.emitZone = new Phaser.Geom.Rectangle();
    }
    createEmitters() {
      this.emitter = this.scene.add.particles(0, 0, KEY17, {
        frame: FRAME16.FX_STAR_YELLOW,
        emitZone: {
          source: this.emitZone,
          type: "random"
        },
        deathZone: {
          source: this.emitZone,
          type: "onLeave"
        },
        frequency: 200,
        speedX: { min: -1, max: 1 },
        speedY: { min: -9, max: -13 },
        lifespan: { min: 1e3, max: 1500 },
        scale: {
          min: 0.01,
          max: 0.015
        },
        emitCallback: (star) => {
          star.setScale({ min: 0.3, max: 0.7 });
        },
        particleClass: SparklingStar_default
      });
      this.add(this.emitter);
    }
    run(count, x, y, width, height) {
      this.stop();
      this.emitZone.setSize(width, height);
      this.emitZone.setPosition(x - width / 2, y - height / 2);
      this.emitter.setQuantity(count);
      this.emitter.start();
    }
    stop() {
      this.emitter?.killAll();
      this.emitter?.stop();
    }
  };
  var StarSparkle_default = StarSparkle;

  // src/game/screens/common/ChallengeResultPopup.ts
  var { KEY: DEFAULT_KEY2, FRAME: DEFAULT_FRAME2 } = sprites_default.DEFAULT;
  var { KEY: CHALLENGE_KEY, FRAME: CHALLENGE_FRAME } = sprites_default.CHALLENGE;
  var MenuButton2 = class extends Button_default {
    scaleDown = 0.98;
  };
  var ChallengeResultPopup = class extends Phaser.GameObjects.Container {
    popup;
    winTitle;
    loseTitle;
    drawTitle;
    waitTitle;
    iconCrown;
    leftAvatar;
    rightAvatar;
    leftScore;
    rightScore;
    homeButton;
    restartButton;
    newMatchButton;
    challengeButton;
    starSparkle;
    set onHomeClick(callback) {
      if (!this.homeButton) return;
      if (typeof callback !== "function") return;
      this.homeButton.onClick = callback;
      this.homeButton.setDisabled(false);
    }
    set onRestartClick(callback) {
      if (!this.restartButton) return;
      if (typeof callback !== "function") return;
      this.restartButton.onClick = callback;
      this.restartButton.setDisabled(false);
    }
    set onNewMatchClick(callback) {
      if (!this.newMatchButton) return;
      if (typeof callback !== "function") return;
      this.newMatchButton.onClick = callback;
      this.newMatchButton.setDisabled(false);
    }
    set onChallengeClick(callback) {
      if (!this.challengeButton) return;
      if (typeof callback !== "function") return;
      this.challengeButton.onClick = callback;
      this.challengeButton.setDisabled(false);
    }
    constructor(scene) {
      super(scene);
      this.createPopup();
      this.updateSize();
      this.createBackground();
      this.createResultInfo();
      this.createButtons();
      this.createEffects();
      this.setDepth(depth_default.POPUP);
      this.scene.add.existing(this);
    }
    createPopup() {
      this.popup = this.scene.add.container(0, 0);
      this.popup.setWorldSize(375, 667);
      this.add(this.popup);
    }
    createBackground() {
      const popupBg = this.scene.make.image({
        key: CHALLENGE_KEY,
        frame: CHALLENGE_FRAME.POPUP
      });
      this.popup.add(popupBg);
    }
    createEffects() {
      this.createStarSparkle();
    }
    createStarSparkle() {
      this.starSparkle = new StarSparkle_default(this.scene);
      this.popup.add(this.starSparkle);
    }
    createResultInfo() {
      this.createCrown();
      this.createAvatars();
      this.createScorePanel();
      this.createScoreText();
      this.createResultTexts();
    }
    createCrown() {
      this.iconCrown = this.scene.make.image({
        x: 0,
        y: -130,
        key: CHALLENGE_KEY,
        frame: CHALLENGE_FRAME.CROWN,
        visible: false,
        origin: { x: 0.5, y: 0.5 }
      });
      this.popup.add(this.iconCrown);
    }
    createAvatars() {
      const options = {
        key: CHALLENGE_KEY,
        width: 84,
        height: 84,
        radius: 12,
        frame: CHALLENGE_FRAME.AVATAR_BIG_FRAME,
        background: CHALLENGE_FRAME.AVATAR_BIG
      };
      this.leftAvatar = new AvatarFrame_default(this.scene, options);
      this.leftAvatar.setPosition(-80, -73);
      this.leftAvatar.loading.setAlpha(0);
      this.rightAvatar = new AvatarFrame_default(this.scene, options);
      this.rightAvatar.setPosition(80, -73);
      this.rightAvatar.loading.setAlpha(0);
      this.popup.add(this.leftAvatar);
      this.popup.add(this.rightAvatar);
    }
    createScorePanel() {
      const scorePanelLeft = this.scene.make.image({
        key: CHALLENGE_KEY,
        frame: CHALLENGE_FRAME.SCORE_PANEL,
        x: -80
      });
      const scorePanelRight = this.scene.make.image({
        key: CHALLENGE_KEY,
        frame: CHALLENGE_FRAME.SCORE_PANEL,
        x: 80
      });
      this.popup.add([scorePanelLeft, scorePanelRight]);
    }
    createScoreText() {
      this.leftScore = FontUtils_default.createText(this.scene, "", 20).setFontStyle("700").setOrigin(
      0.5, 0.5).setPosition(-80, 0);
      FontUtils_default.applyYellowStyle(this.leftScore);
      this.rightScore = FontUtils_default.createText(this.scene, "", 20).setFontStyle("700").setOrigin(
      0.5, 0.5).setPosition(80, 0);
      FontUtils_default.applyYellowStyle(this.rightScore);
      this.popup.add([this.leftScore, this.rightScore]);
    }
    createResultTexts() {
      const options = {
        key: CHALLENGE_KEY,
        x: 0,
        y: -187,
        visible: true
      };
      this.winTitle = this.scene.make.image({ ...options, frame: CHALLENGE_FRAME.WIN });
      this.loseTitle = this.scene.make.image({ ...options, frame: CHALLENGE_FRAME.LOSE });
      this.drawTitle = this.scene.make.image({ ...options, frame: CHALLENGE_FRAME.DRAW });
      this.waitTitle = this.scene.make.image({ ...options, frame: CHALLENGE_FRAME.WAITING });
      this.popup.add([this.winTitle, this.loseTitle, this.drawTitle, this.waitTitle]);
    }
    createButtons() {
      this.createBGButtons();
      this.createHomeButton();
      this.createRestartButton();
      this.createNewMatchButton();
      this.createChallengeButton();
    }
    createBGButtons() {
      const firstBtn = this.scene.make.image({
        key: DEFAULT_KEY2,
        frame: DEFAULT_FRAME2.BUTTON_FRAME,
        y: 80
      });
      const secondBtn = this.scene.make.image({
        key: DEFAULT_KEY2,
        frame: DEFAULT_FRAME2.BUTTON_FRAME,
        y: 150
      });
      this.popup.add([firstBtn, secondBtn]);
    }
    createHomeButton() {
      this.homeButton = new MenuButton2(this.scene, DEFAULT_KEY2, DEFAULT_FRAME2.BUTTON_BLUE);
      this.homeButton.setDisabled(true);
      const iconHome = this.scene.make.image({
        key: CHALLENGE_KEY,
        frame: CHALLENGE_FRAME.ICON_HOME,
        x: -50
      });
      const homeText = FontUtils_default.createText(this.scene, "Home", 20).setFontStyle("900").setPosition(
      10, 0);
      FontUtils_default.applyBlueStyle(homeText);
      this.homeButton.add([iconHome, homeText]);
      this.popup.add(this.homeButton);
      Phaser.Display.Align.In.Center(this.homeButton, this.popup, 0, 150);
    }
    createRestartButton() {
      this.restartButton = new MenuButton2(this.scene, DEFAULT_KEY2, DEFAULT_FRAME2.BUTTON_YELLOW);
      this.restartButton.setVisible(false);
      this.restartButton.setDisabled(true);
      const iconReplay = this.scene.make.image({
        key: CHALLENGE_KEY,
        frame: CHALLENGE_FRAME.ICON_REPLAY,
        x: -50
      });
      const restartText = FontUtils_default.createText(this.scene, "Restart", 20).setFontStyle("900").
      setPosition(10, 0);
      FontUtils_default.applyOrangeStyle(restartText);
      this.restartButton.add([iconReplay, restartText]);
      this.popup.add(this.restartButton);
      Phaser.Display.Align.In.Center(this.restartButton, this.popup, 0, 80);
    }
    createNewMatchButton() {
      this.newMatchButton = new MenuButton2(this.scene, DEFAULT_KEY2, DEFAULT_FRAME2.BUTTON_GREEN);
      this.newMatchButton.setVisible(false);
      this.newMatchButton.setDisabled(true);
      const iconPlay = this.scene.make.image({
        key: CHALLENGE_KEY,
        frame: CHALLENGE_FRAME.ICON_CONTINUE,
        x: -55
      });
      const newMatchText = FontUtils_default.createText(this.scene, "New Game", 20).setFontStyle("90\
0").setPosition(15, 0);
      FontUtils_default.applyGreenStyle(newMatchText);
      this.newMatchButton.add([iconPlay, newMatchText]);
      this.popup.add(this.newMatchButton);
      Phaser.Display.Align.In.Center(this.newMatchButton, this.popup, 0, 80);
    }
    createChallengeButton() {
      this.challengeButton = new MenuButton2(this.scene, DEFAULT_KEY2, DEFAULT_FRAME2.BUTTON_GREEN);
      this.challengeButton.setVisible(false);
      this.challengeButton.setDisabled(true);
      const iconChallenge = this.scene.make.image({
        key: CHALLENGE_KEY,
        frame: CHALLENGE_FRAME.ICON_INVITE,
        x: -65
      });
      const challengeText = FontUtils_default.createText(this.scene, "Invite Friends", 18).setFontStyle(
      "900").setPosition(16, 0);
      FontUtils_default.applyGreenStyle(challengeText);
      this.challengeButton.add([iconChallenge, challengeText]);
      this.popup.add(this.challengeButton);
      Phaser.Display.Align.In.Center(this.challengeButton, this.popup, 0, 80);
    }
    updateSize() {
      const { displayWidth, displayHeight } = this.popup;
      this.setSize(displayWidth, displayHeight);
    }
    setResult(result, winnerSide) {
      const isWin = result === "win";
      const isDraw = result === "draw";
      const isLose = result === "lose";
      const isWaiting = result === "waiting";
      if (isWin) {
        this.starSparkle.run(3, 0, -180, 260, 90);
      }
      const shouldShowCrown = isWin || isLose;
      this.iconCrown.setVisible(shouldShowCrown);
      if (shouldShowCrown) {
        const xPosition = winnerSide === "left" ? -80 : 80;
        this.iconCrown.setX(xPosition);
      }
      this.winTitle.setVisible(isWin);
      this.loseTitle.setVisible(isLose);
      this.drawTitle.setVisible(isDraw);
      this.waitTitle.setVisible(isWaiting);
      this.restartButton.setVisible(isLose || isDraw);
      this.newMatchButton.setVisible(isWin);
      this.challengeButton.setVisible(isWaiting);
    }
    setScores(leftScore, rightScore) {
      const leftScoreText = leftScore >= 0 ? leftScore : "???";
      const rightScoreText = rightScore >= 0 ? rightScore : "???";
      this.leftScore.setText(`${leftScoreText}`);
      this.rightScore.setText(`${rightScoreText}`);
    }
    setAvatars(data) {
      const { playerId, opponentId, playerAvatar, opponentAvatar } = data;
      this.leftAvatar.loadPhoto(playerId, playerAvatar, 20);
      this.rightAvatar.loadPhoto(opponentId, opponentAvatar, 20);
    }
  };
  var ChallengeResultPopup_default = ChallengeResultPopup;

  // src/game/screens/ResultChallengeScreen.ts
  var { event: event16 } = codex;
  var ResultChallengeScreen = class extends Screen_default {
    popup$;
    popupShowUpAnimation$;
    popupFadeOutAnimation$;
    constructor(scene, name) {
      super(scene, name);
      this.createPopup$();
      this.setDepth(ScreenDepth_default.POPUP);
    }
    open = (data) => {
      super.open(data);
      this.updateData$();
      AudioUtils_default.setVolumeMusic(0, true);
      this.runOpenAnimation$();
    };
    updateData$() {
      const [playerScore, opponentScore] = this.getData(["playerScore", "opponentScore"]);
      const isWinner = playerScore > opponentScore;
      const isDraw = playerScore === opponentScore;
      const isLose = playerScore < opponentScore;
      const isWaiting = !(playerScore > 0 && opponentScore > 0);
      const result = isWaiting ? "waiting" : isDraw ? "draw" : isWinner ? "win" : "lose";
      const winnerSide = isWinner ? "left" : "right";
      if (isWinner) {
        AudioUtils_default.playSound(soundEffects_default.LEVEL_COMPLETE);
      }
      if (isLose) {
        AudioUtils_default.playSound(soundEffects_default.LEVEL_FAIL);
      }
      this.popup$.setResult(result, winnerSide);
      this.popup$.setScores(playerScore, opponentScore);
      const [playerId, opponentId, playerAvatar, opponentAvatar] = this.getData([
        "playerId",
        "opponentId",
        "playerAvatar",
        "opponentAvatar"
      ]);
      this.popup$.setAvatars({
        playerId,
        opponentId,
        playerAvatar,
        opponentAvatar
      });
    }
    createPopup$() {
      this.popup$ = new ChallengeResultPopup_default(this.scene);
      this.add(this.popup$);
      this.popup$.onHomeClick = this.handleHomeClick$;
      this.popup$.onRestartClick = this.handleRestartClick$;
      this.popup$.onNewMatchClick = this.handleNewMatchClick$;
      this.popup$.onChallengeClick = this.handleChallengeClick$;
      const bannerHeightOffset = AdsUtils_default.getBannerHeight() / 2;
      Phaser.Display.Align.In.Center(this.popup$, this.zone, 0, -bannerHeightOffset);
    }
    handleHomeClick$ = () => {
      this.runCloseAnimation$();
      setTimeout(() => {
        SceneUtils_default.switchToDashboardScene();
      }, 250);
    };
    handleNewMatchClick$ = async () => {
      await this.processInviteFriend$();
    };
    handleChallengeClick$ = async () => {
      await this.processInviteFriend$();
    };
    handleRestartClick$ = async () => {
      await this.processChallenge$();
    };
    processChallenge$ = async () => {
      const opponentId = this.getData("opponentId");
      const success = await MatchUtils_default.startChallengeModeAsync(opponentId);
      if (!success) return;
      this.runCloseAnimation$();
      event16.emit(game_default.REPLAY);
    };
    processInviteFriend$ = async () => {
      const success = await MatchUtils_default.startChallengeChooseOpponentAsync();
      if (!success) return;
      this.runCloseAnimation$();
      event16.emit(game_default.REPLAY);
    };
    // Animations
    runOpenAnimation$() {
      this.background.setAlpha(0);
      this.animateBackgroundAlpha(0.6);
      this.runPopupEntrancesAnimation$(0, 300);
    }
    runCloseAnimation$() {
      this.animateBackgroundAlpha(0, 200);
      this.runPopupExitsAnimation$(0, 200);
    }
    // Entrances animations
    runPopupEntrancesAnimation$(delay, duration) {
      const bannerHeightOffset = AdsUtils_default.getBannerHeight() / 2;
      this.popupShowUpAnimation$ = this.scene.tweens.add({
        ...ShowUp_default,
        targets: [this.popup$],
        delay,
        duration,
        props: {
          ...ShowUp_default.props,
          y: { from: 350 - bannerHeightOffset, to: -bannerHeightOffset },
          alpha: { start: 1, from: 1, to: 1 },
          scale: { start: 0, from: 0, to: 1 }
        }
      });
      AnimUtils.runTween(this.popupShowUpAnimation$);
    }
    // Exits animations
    runPopupExitsAnimation$(delay, duration) {
      const bannerHeightOffset = AdsUtils_default.getBannerHeight() / 2;
      this.popupFadeOutAnimation$ = this.scene.tweens.add({
        ...FadeOut_default,
        targets: [this.popup$],
        delay,
        duration,
        props: {
          ...FadeOut_default.props,
          y: 250 - bannerHeightOffset,
          scale: 0
        },
        onComplete: () => {
          this.popup$.setY(0);
          ScreenUtils_default.closeScreen(this.name);
        }
      });
      AnimUtils.runTweenAsync(this.popupFadeOutAnimation$);
    }
  };
  var ResultChallengeScreen_default = ResultChallengeScreen;

  // src/game/screens/ResultScreen.ts
  init_phaser_custom_min();

  // src/game/scenes/game-scene/index.ts
  init_phaser_custom_min();

  // src/game/scenes/game-scene/GameScene.ts
  init_phaser_custom_min();

  // src/game/gameplay/managers/AnimationManager.ts
  init_phaser_custom_min();

  // src/game/managers/BaseManager.ts
  init_phaser_custom_min();

  // src/game/constants/manager.ts
  init_phaser_custom_min();
  var MANAGER = {
    STATUS: {
      READY: "ready",
      RUNNING: "running",
      STOPPED: "stopped"
    }
  };
  var manager_default = MANAGER;

  // src/game/managers/BaseManager.ts
  var { STATUS } = manager_default;
  var BaseManager = class {
    state$;
    scene;
    constructor(scene) {
      this.scene = scene;
    }
    init() {
      this.setState(STATUS.READY);
    }
    start() {
      if (this.isRunning()) return;
      this.setState(STATUS.RUNNING);
    }
    stop() {
      if (!this.isRunning()) return;
      this.setState(STATUS.STOPPED);
    }
    setState(state) {
      this.state$ = state;
    }
    // Check status
    isReady() {
      return this.state$ === STATUS.READY;
    }
    isRunning() {
      return this.state$ === STATUS.RUNNING;
    }
    isStopped() {
      return this.state$ === STATUS.STOPPED;
    }
  };
  var BaseManager_default = BaseManager;

  // src/game/gameplay/animations/animation/BombDefuseAnimation.ts
  init_phaser_custom_min();
  var { KEY: KEY18, TEXTURE, FRAME_RATE, END, PREFIX, ZERO_PAD } = animation_default.BOMB_DEFUSE;
  var BombDefuseAnimation = class extends Phaser.Animations.Animation {
    constructor(manager) {
      const animationConfig = {
        repeat: 0,
        frameRate: FRAME_RATE,
        frames: manager.generateFrameNames(TEXTURE, {
          prefix: PREFIX,
          end: END,
          zeroPad: ZERO_PAD
        }),
        showOnStart: true,
        hideOnComplete: true,
        skipMissedFrames: true
      };
      super(manager, KEY18, animationConfig);
    }
  };
  var BombDefuseAnimation_default = BombDefuseAnimation;

  // src/game/gameplay/animations/animation/BombExplosionAnimation.ts
  init_phaser_custom_min();
  var { KEY: KEY19, TEXTURE: TEXTURE2, FRAME_RATE: FRAME_RATE2, END: END2, PREFIX: PREFIX2, ZERO_PAD: ZERO_PAD2 } = animation_default.
  BOMB_EXPLOSION;
  var BombExplosionAnimation = class extends Phaser.Animations.Animation {
    constructor(manager) {
      const animationConfig = {
        repeat: 0,
        frameRate: FRAME_RATE2,
        frames: manager.generateFrameNames(TEXTURE2, {
          prefix: PREFIX2,
          end: END2,
          zeroPad: ZERO_PAD2
        }),
        showOnStart: true,
        hideOnComplete: true,
        skipMissedFrames: true
      };
      super(manager, KEY19, animationConfig);
    }
  };
  var BombExplosionAnimation_default = BombExplosionAnimation;

  // src/game/gameplay/animations/animation/PolishEffectAnimation.ts
  init_phaser_custom_min();
  var { KEY: KEY20, TEXTURE: TEXTURE3, FRAME_RATE: FRAME_RATE3, END: END3, PREFIX: PREFIX3, ZERO_PAD: ZERO_PAD3 } = animation_default.
  POLISH_EFFECT;
  var PolishEffectAnimation = class extends Phaser.Animations.Animation {
    constructor(manager) {
      const animationConfig = {
        repeat: 0,
        frameRate: FRAME_RATE3,
        frames: manager.generateFrameNames(TEXTURE3, {
          prefix: PREFIX3,
          end: END3,
          zeroPad: ZERO_PAD3
        }),
        showOnStart: true,
        hideOnComplete: true,
        skipMissedFrames: true
      };
      super(manager, KEY20, animationConfig);
    }
  };
  var PolishEffectAnimation_default = PolishEffectAnimation;

  // src/game/gameplay/animations/animation/RocketExplosionAnimation.ts
  init_phaser_custom_min();
  var { KEY: KEY21, TEXTURE: TEXTURE4, FRAME_RATE: FRAME_RATE4, END: END4, PREFIX: PREFIX4, ZERO_PAD: ZERO_PAD4 } = animation_default.
  ROCKET_EXPLOSION;
  var RocketExplosionAnimation = class extends Phaser.Animations.Animation {
    constructor(manager) {
      const animationConfig = {
        repeat: 0,
        frameRate: FRAME_RATE4,
        frames: manager.generateFrameNames(TEXTURE4, {
          prefix: PREFIX4,
          end: END4,
          zeroPad: ZERO_PAD4
        }),
        showOnStart: true,
        hideOnComplete: true,
        skipMissedFrames: true
      };
      super(manager, KEY21, animationConfig);
    }
  };
  var RocketExplosionAnimation_default = RocketExplosionAnimation;

  // src/game/gameplay/animations/animation/RocketTailAnimation.ts
  init_phaser_custom_min();
  var { KEY: KEY22, TEXTURE: TEXTURE5, FRAME_RATE: FRAME_RATE5, END: END5, PREFIX: PREFIX5, ZERO_PAD: ZERO_PAD5 } = animation_default.
  ROCKET_TAIL;
  var RocketTailAnimation = class extends Phaser.Animations.Animation {
    constructor(manager) {
      const animationConfig = {
        repeat: -1,
        frameRate: FRAME_RATE5,
        frames: manager.generateFrameNames(TEXTURE5, {
          prefix: PREFIX5,
          end: END5,
          zeroPad: ZERO_PAD5
        }),
        showOnStart: true,
        hideOnComplete: true,
        skipMissedFrames: true
      };
      super(manager, KEY22, animationConfig);
    }
  };
  var RocketTailAnimation_default = RocketTailAnimation;

  // src/game/gameplay/animations/animation/TileHighlightAnimation.ts
  init_phaser_custom_min();
  var { KEY: KEY23, TEXTURE: TEXTURE6, FRAME_RATE: FRAME_RATE6, END: END6, PREFIX: PREFIX6, ZERO_PAD: ZERO_PAD6 } = animation_default.
  TILE_HIGHLIGHT;
  var TileHighlightAnimation = class extends Phaser.Animations.Animation {
    constructor(manager) {
      const animationConfig = {
        repeat: -1,
        frameRate: FRAME_RATE6,
        frames: manager.generateFrameNames(TEXTURE6, {
          prefix: PREFIX6,
          end: END6,
          zeroPad: ZERO_PAD6
        }),
        showOnStart: true,
        hideOnComplete: true,
        skipMissedFrames: true
      };
      super(manager, KEY23, animationConfig);
    }
  };
  var TileHighlightAnimation_default = TileHighlightAnimation;

  // src/game/gameplay/managers/AnimationManager.ts
  var AnimationManager = class extends BaseManager_default {
    scene;
    moveDuration = 500;
    isMoveTilesCompleted;
    pairWrongTween$;
    constructor(scene) {
      super(scene);
      this.scene = scene;
      this.isMoveTilesCompleted = true;
      this.createAnimations$();
    }
    start() {
      this.isMoveTilesCompleted = true;
    }
    createAnimations$() {
      const { POLISH_EFFECT, BOMB_EXPLOSION: BOMB_EXPLOSION2, BOMB_DEFUSE: BOMB_DEFUSE3, ROCKET_EXPLOSION,
      ROCKET_TAIL, TILE_HIGHLIGHT } = animation_default;
      const rocketTailAnim = new RocketTailAnimation_default(this.scene.anims);
      const bombDefuseAnim = new BombDefuseAnimation_default(this.scene.anims);
      const polishEffectAnim = new PolishEffectAnimation_default(this.scene.anims);
      const bombExplosionAnim = new BombExplosionAnimation_default(this.scene.anims);
      const rocketExplosionAnim = new RocketExplosionAnimation_default(this.scene.anims);
      const tileHighlightAnimation = new TileHighlightAnimation_default(this.scene.anims);
      this.scene.anims.add(BOMB_DEFUSE3.KEY, bombDefuseAnim);
      this.scene.anims.add(ROCKET_TAIL.KEY, rocketTailAnim);
      this.scene.anims.add(POLISH_EFFECT.KEY, polishEffectAnim);
      this.scene.anims.add(BOMB_EXPLOSION2.KEY, bombExplosionAnim);
      this.scene.anims.add(ROCKET_EXPLOSION.KEY, rocketExplosionAnim);
      this.scene.anims.add(TILE_HIGHLIGHT.KEY, tileHighlightAnimation);
    }
    prepareStartBoardAnimation(targets) {
      const { boardManager, levelHandler } = this.scene;
      const { rows, columns } = levelHandler.getConfigs();
      const tileSize = boardManager.getTileSizeWithSpacing();
      const firstTile = boardManager.boardMap[1][1];
      const boardCenterX = firstTile.x + tileSize * (columns - 1) / 2;
      const boardCenterY = firstTile.y + tileSize * (rows - 1) / 2;
      const posX = boardCenterX;
      const posY = boardCenterY;
      const originProps = [];
      for (const tile of targets) {
        const { x, y, scale } = tile;
        originProps.push({ x, y, scale });
        tile.setX(posX);
        tile.setY(posY);
        tile.setAlpha(0);
        tile.setScale(0);
      }
      return originProps;
    }
    runStartBoardAnimation(targets, originProps) {
      const duration = 600;
      const delay = duration / targets.length;
      const tween = this.scene.tweens.add({
        targets,
        duration,
        props: {
          y: {
            value: {
              getEnd: (_target, _key, _value, targetIndex) => {
                return originProps[targetIndex].y;
              }
            },
            duration: duration - duration / 12
          },
          x: {
            value: {
              getEnd: (_target, _key, _value, targetIndex) => {
                return originProps[targetIndex].x;
              }
            },
            duration: duration - duration / 5
          },
          scale: {
            value: {
              getEnd: (_target, _key, _value, targetIndex) => {
                return originProps[targetIndex].scale;
              }
            },
            delay: 0
          },
          alpha: {
            value: 1,
            duration: duration - 100
          }
        },
        // paused: true,
        // ease: this.dropEase,
        delay: (_target, _targetKey, _value, targetIndex) => {
          const random = Phaser.Math.RND.between(0, delay * targetIndex / 2);
          const correctDelay = delay * targetIndex - random;
          return correctDelay;
        }
      });
      return tween;
    }
    // Animation
    startBoard(targets) {
      const originProps = this.prepareStartBoardAnimation(targets);
      const tween = this.runStartBoardAnimation(targets, originProps);
      return tween;
    }
    pairWrong(targets, count = 2) {
      this.pairWrongTween$?.remove();
      if (count < 1) return;
      const space = Math.random() * 3 - 3;
      const props = {
        x: `+=${space}`,
        y: `-=${space}`
      };
      const config = {
        targets,
        duration: 30,
        yoyo: true,
        props,
        ease: Phaser.Math.Easing.Expo.Out
      };
      this.pairWrongTween$ = this.scene.add.tween({
        ...config,
        onComplete: () => {
          props.x = `-=${space}`;
          props.y = `+=${space}`;
          this.pairWrongTween$ = this.scene.add.tween({
            ...config,
            onComplete: () => {
              this.pairWrong(targets, count - 1);
            }
          });
        }
      });
    }
    capturing(targets) {
      targets.forEach((tile, index) => {
        tile.explosive(index);
      });
    }
    moveRows(data, delay = 0, duration) {
      const { tile, fromRow, toRow } = data;
      if (!fromRow || !toRow) return;
      this.isMoveTilesCompleted = false;
      this.updateNextState$(tile);
      const tileSize = this.scene.boardManager.getTileSizeWithSpacing();
      const posY = toRow * tileSize - fromRow * tileSize;
      const tileY = tile.y;
      const nextY = tileY + posY;
      tile.nextY = nextY;
      this.scene.tweens.add({
        targets: [tile],
        delay,
        duration: duration || this.moveDuration,
        completeDelay: 300,
        ease: Phaser.Math.Easing.Quartic.InOut,
        props: {
          y: nextY
        },
        onUpdate: () => {
          this.isMoveTilesCompleted = false;
        },
        onStop: () => {
          tile.setY(nextY);
          tile.nextY = null;
        },
        onComplete: () => {
          tile.nextY = null;
          this.isMoveTilesCompleted = true;
        }
      });
    }
    moveColumns(data, delay = 0, duration) {
      const { tile, fromColumn, toColumn } = data;
      if (!fromColumn || !toColumn) return;
      this.isMoveTilesCompleted = false;
      this.updateNextState$(tile);
      const tileSize = this.scene.boardManager.getTileSizeWithSpacing();
      const posX = toColumn * tileSize - fromColumn * tileSize;
      const tileX = tile.x;
      const nextX = tileX + posX;
      tile.nextX = nextX;
      this.scene.tweens.add({
        targets: [tile],
        delay,
        duration: duration || this.moveDuration,
        completeDelay: 300,
        ease: Phaser.Math.Easing.Quartic.InOut,
        props: {
          x: nextX
        },
        onUpdate: () => {
          this.isMoveTilesCompleted = false;
        },
        onStop: () => {
          tile.setX(nextX);
          tile.nextX = null;
        },
        onComplete: () => {
          tile.nextX = null;
          this.isMoveTilesCompleted = true;
        }
      });
    }
    moveRowsAndColumns(data, delay = 0, duration) {
      const { tile, fromRow, toRow, fromColumn, toColumn } = data;
      if (!fromRow || !toRow || !fromColumn || !toColumn) return;
      this.isMoveTilesCompleted = false;
      this.updateNextState$(tile);
      const tileSize = this.scene.boardManager.getTileSizeWithSpacing();
      const posX = toColumn * tileSize - fromColumn * tileSize;
      const posY = toRow * tileSize - fromRow * tileSize;
      const nextX = tile.x + posX;
      const nextY = tile.y + posY;
      tile.nextX = nextX;
      tile.nextY = nextY;
      this.scene.tweens.add({
        targets: [tile],
        delay,
        duration: duration || this.moveDuration,
        completeDelay: 300,
        ease: Phaser.Math.Easing.Quartic.InOut,
        props: {
          x: nextX,
          y: nextY
        },
        onUpdate: () => {
          this.isMoveTilesCompleted = false;
        },
        onStop: () => {
          tile.setX(nextX);
          tile.setY(nextY);
          tile.nextX = null;
          tile.nextY = null;
        },
        onComplete: () => {
          tile.nextX = null;
          tile.nextY = null;
          this.isMoveTilesCompleted = true;
        }
      });
    }
    updateNextState$(tile) {
      const tweens = this.scene.tweens.getTweensOf(tile);
      for (const tween of tweens) {
        tween.stop();
        tile.nextX && tile.setX(tile.nextX);
        tile.nextY && tile.setX(tile.nextY);
        tile.nextX = null;
        tile.nextY = null;
      }
      this.scene.tweens.killTweensOf(tile);
    }
  };
  var AnimationManager_default = AnimationManager;

  // src/game/gameplay/managers/BoardManager.ts
  init_phaser_custom_min();

  // src/game/components/BoardSizeHandler.ts
  init_phaser_custom_min();
  var BoardSizeHandler = class {
    scene;
    tileSize;
    constructor(scene) {
      this.scene = scene;
      this.tileSize = 0;
    }
    getTileSize() {
      return this.tileSize || tile_default.SIZE;
    }
    /**
     * portrait:
     *  ------
     *  header
     *  gap for path effect
     *  board
     *  gap for path effect
     *  footer
     *  ------
     * landscape:
     *  ------
     *  header
     *  gap for path effect
     *  board
     *  gap for path effect
     *  banner ads
     *  -----
     */
    calculateTileSize() {
      this.tileSize = 0;
      const { rows, columns } = this.scene.levelHandler.getConfigs();
      const { width, height } = this.scene.gameZone;
      const { height: topFooterHeight } = this.scene.layoutManager.objects.topFooterBG;
      const bottomFooterHeight = AdsUtils_default.getBannerHeight();
      const { height: headerHeight } = this.scene.layoutManager.objects.headerBG;
      const footerHeight = topFooterHeight + bottomFooterHeight;
      const virtualRows = 0.5 + rows + 0.5;
      const virtualColumns = 0.5 + columns + 0.5;
      const maxWidth = width;
      const landscapeMargin = AdsUtils_default.getBannerHeight();
      let maxHeight = height - headerHeight;
      if (WorldUtils_default.isLandscape()) {
        maxHeight -= landscapeMargin;
      } else {
        maxHeight -= footerHeight;
      }
      const scaledUpWidth = Math.floor(maxWidth / virtualColumns);
      const scaledUpHeight = Math.floor(maxHeight / virtualRows);
      this.tileSize = Math.min(scaledUpWidth, scaledUpHeight, tile_default.SIZE);
    }
    getBoardSize() {
      const { rows, columns } = this.scene.levelHandler.getConfigs();
      const width = this.getTileSize() * columns;
      const height = this.getTileSize() * rows;
      return { width, height };
    }
  };
  var BoardSizeHandler_default = BoardSizeHandler;

  // src/game/gameplay/constants/manager.ts
  init_phaser_custom_min();
  var MANAGER2 = {
    STATUS: {
      READY: "ready",
      RUNNING: "running",
      STOPPED: "stopped"
    }
  };
  var manager_default2 = MANAGER2;

  // src/game/gameplay/objects/tiles/BombTile.ts
  init_phaser_custom_min();

  // src/game/effects/BombCountdown.ts
  init_phaser_custom_min();
  var COUNTDOWN_TILE_SIZE = 35;
  var RECT_RADIUS = 3;
  var BombCountdown = class extends Phaser.GameObjects.Graphics {
    tileSize;
    rectRadius;
    topLeftCurve;
    topRightCurve;
    bottomRightCurve;
    bottomLeftCurve;
    constructor(scene, tileSize, rectRadius) {
      super(scene);
      this.tileSize = tileSize || COUNTDOWN_TILE_SIZE;
      this.rectRadius = rectRadius || RECT_RADIUS;
      this.setDepth(depth_default.TILE + 1);
      this.createCurves();
      this.scene.events.on(Phaser.Scenes.Events.UPDATE, this.update);
      this.scene.add.existing(this);
    }
    createCurves() {
      const radius = this.rectRadius;
      const tileSize = this.tileSize;
      const lineLength = tileSize - 2 * radius;
      this.topRightCurve = new Phaser.Curves.QuadraticBezier(
        new Phaser.Math.Vector2(lineLength / 2, -tileSize / 2),
        new Phaser.Math.Vector2(tileSize / 2, -tileSize / 2),
        new Phaser.Math.Vector2(tileSize / 2, -lineLength / 2)
      );
      this.topLeftCurve = new Phaser.Curves.QuadraticBezier(
        new Phaser.Math.Vector2(-tileSize / 2, -lineLength / 2),
        new Phaser.Math.Vector2(-tileSize / 2, -tileSize / 2),
        new Phaser.Math.Vector2(-lineLength / 2, -tileSize / 2)
      );
      this.bottomLeftCurve = new Phaser.Curves.QuadraticBezier(
        new Phaser.Math.Vector2(-lineLength / 2, tileSize / 2),
        new Phaser.Math.Vector2(-tileSize / 2, tileSize / 2),
        new Phaser.Math.Vector2(-tileSize / 2, lineLength / 2)
      );
      this.bottomRightCurve = new Phaser.Curves.QuadraticBezier(
        new Phaser.Math.Vector2(tileSize / 2, lineLength / 2),
        new Phaser.Math.Vector2(tileSize / 2, tileSize / 2),
        new Phaser.Math.Vector2(lineLength / 2, tileSize / 2)
      );
    }
    stop() {
      this.clear();
      this.scene.events.off(Phaser.Scenes.Events.UPDATE, this.update);
    }
    drawCountdown(currentTime, totalTime) {
      const tileSize = this.tileSize;
      const rectRadius = this.rectRadius;
      const lineLength = tileSize - 2 * rectRadius;
      const triangleAngleFromCenter = Math.atan(lineLength / tileSize);
      const roundedRectAngleFromCenter = Math.PI / 2 - 2 * triangleAngleFromCenter;
      const croppedAngle = currentTime / totalTime * 2 * Math.PI;
      let remainingAngle = croppedAngle;
      this.clear();
      this.lineStyle(0, 0, 1);
      this.fillStyle(0, 0.25);
      if (remainingAngle === 0) return;
      if (remainingAngle === Math.PI * 2) {
        this.fillRoundedRect(-tileSize / 2, -tileSize / 2, tileSize, tileSize, rectRadius);
        return;
      }
      this.beginPath();
      this.moveTo(0, 0);
      this.lineTo(0, -tileSize / 2);
      if (remainingAngle > triangleAngleFromCenter) {
        this.lineTo(lineLength / 2, -tileSize / 2);
        remainingAngle -= triangleAngleFromCenter;
      } else {
        this.lineTo(Math.tan(remainingAngle) * tileSize / 2, -tileSize / 2);
        this.lineTo(0, 0);
        this.closePath();
        this.fillPath();
        return;
      }
      this.lineTo(0, 0);
      this.closePath();
      this.fillPath();
      if (remainingAngle > roundedRectAngleFromCenter) {
        this.slice(lineLength / 2, -lineLength / 2, rectRadius, -Math.PI / 2, 0, false);
        remainingAngle -= roundedRectAngleFromCenter;
        this.fillPath();
        this.beginPath();
        this.moveTo(0, 0);
        this.lineTo(lineLength / 2, -tileSize / 2);
        this.lineTo(lineLength / 2, -lineLength / 2);
        this.lineTo(tileSize / 2, -lineLength / 2);
        this.lineTo(0, 0);
        this.closePath();
        this.fillPath();
      } else {
        const angleRatio = remainingAngle / roundedRectAngleFromCenter;
        this.beginPath();
        this.arc(
          lineLength / 2,
          -lineLength / 2,
          rectRadius,
          -Math.PI / 2,
          -Math.PI / 2 + angleRatio * Math.PI / 2,
          false
        );
        this.fillPath();
        const circleIntersection = this.topRightCurve.getPoint(angleRatio);
        this.beginPath();
        this.moveTo(0, 0);
        this.lineTo(lineLength / 2, -tileSize / 2);
        this.lineTo(circleIntersection.x, circleIntersection.y);
        this.lineTo(0, 0);
        this.closePath();
        this.fillPath();
        return;
      }
      this.beginPath();
      this.moveTo(0, 0);
      this.lineTo(tileSize / 2, -lineLength / 2);
      if (remainingAngle > triangleAngleFromCenter) {
        this.lineTo(tileSize / 2, 0);
        remainingAngle -= triangleAngleFromCenter;
      } else {
        this.lineTo(tileSize / 2, -lineLength / 2 - -Math.tan(remainingAngle) * tileSize / 2);
        this.lineTo(0, 0);
        this.closePath();
        this.fillPath();
        return;
      }
      this.lineTo(0, 0);
      this.closePath();
      this.fillPath();
      this.beginPath();
      this.moveTo(0, 0);
      this.lineTo(tileSize / 2, 0);
      if (remainingAngle > triangleAngleFromCenter) {
        this.lineTo(tileSize / 2, lineLength / 2);
        remainingAngle -= triangleAngleFromCenter;
      } else {
        this.lineTo(tileSize / 2, Math.tan(remainingAngle) * tileSize / 2);
        this.lineTo(0, 0);
        this.closePath();
        this.fillPath();
        return;
      }
      this.lineTo(0, 0);
      this.closePath();
      this.fillPath();
      if (remainingAngle > roundedRectAngleFromCenter) {
        this.slice(lineLength / 2, lineLength / 2, rectRadius, 0, Math.PI / 2, false);
        remainingAngle -= roundedRectAngleFromCenter;
        this.fillPath();
        this.beginPath();
        this.moveTo(0, 0);
        this.lineTo(tileSize / 2, lineLength / 2);
        this.lineTo(lineLength / 2, lineLength / 2);
        this.lineTo(lineLength / 2, tileSize / 2);
        this.lineTo(0, 0);
        this.closePath();
        this.fillPath();
      } else {
        const angleRatio = remainingAngle / roundedRectAngleFromCenter;
        this.beginPath();
        this.arc(lineLength / 2, lineLength / 2, rectRadius, 0, angleRatio * Math.PI / 2, false);
        this.fillPath();
        const circleIntersection = this.bottomRightCurve.getPoint(angleRatio);
        this.beginPath();
        this.moveTo(0, 0);
        this.lineTo(tileSize / 2, lineLength / 2);
        this.lineTo(circleIntersection.x, circleIntersection.y);
        this.lineTo(0, 0);
        this.closePath();
        this.fillPath();
        return;
      }
      this.beginPath();
      this.moveTo(0, 0);
      this.lineTo(lineLength / 2, tileSize / 2);
      if (remainingAngle > triangleAngleFromCenter) {
        this.lineTo(0, tileSize / 2);
        remainingAngle -= triangleAngleFromCenter;
      } else {
        this.lineTo(lineLength / 2 - Math.tan(remainingAngle) * tileSize / 2, tileSize / 2);
        this.lineTo(0, 0);
        this.closePath();
        this.fillPath();
        return;
      }
      this.lineTo(0, 0);
      this.closePath();
      this.fillPath();
      this.beginPath();
      this.moveTo(0, 0);
      this.lineTo(0, tileSize / 2);
      if (remainingAngle > triangleAngleFromCenter) {
        this.lineTo(-lineLength / 2, tileSize / 2);
        remainingAngle -= triangleAngleFromCenter;
      } else {
        this.lineTo(-Math.tan(remainingAngle) * tileSize / 2, tileSize / 2);
        this.lineTo(0, 0);
        this.closePath();
        this.fillPath();
        return;
      }
      this.lineTo(0, 0);
      this.closePath();
      this.fillPath();
      if (remainingAngle > roundedRectAngleFromCenter) {
        this.slice(-lineLength / 2, lineLength / 2, rectRadius, Math.PI / 2, Math.PI, false);
        remainingAngle -= roundedRectAngleFromCenter;
        this.fillPath();
        this.beginPath();
        this.moveTo(0, 0);
        this.lineTo(-lineLength / 2, tileSize / 2);
        this.lineTo(-lineLength / 2, lineLength / 2);
        this.lineTo(-tileSize / 2, lineLength / 2);
        this.lineTo(0, 0);
        this.closePath();
        this.fillPath();
      } else {
        const angleRatio = remainingAngle / roundedRectAngleFromCenter;
        this.beginPath();
        this.arc(
          -lineLength / 2,
          lineLength / 2,
          rectRadius,
          Math.PI / 2,
          Math.PI / 2 + angleRatio * Math.PI / 2,
          false
        );
        this.fillPath();
        const circleIntersection = this.bottomLeftCurve.getPoint(angleRatio);
        this.beginPath();
        this.moveTo(0, 0);
        this.lineTo(-lineLength / 2, tileSize / 2);
        this.lineTo(circleIntersection.x, circleIntersection.y);
        this.lineTo(0, 0);
        this.closePath();
        this.fillPath();
        return;
      }
      this.beginPath();
      this.moveTo(0, 0);
      this.lineTo(-tileSize / 2, lineLength / 2);
      if (remainingAngle > triangleAngleFromCenter) {
        this.lineTo(-tileSize / 2, 0);
        remainingAngle -= triangleAngleFromCenter;
      } else {
        this.lineTo(-tileSize / 2, lineLength / 2 - Math.tan(remainingAngle) * tileSize / 2);
        this.lineTo(0, 0);
        this.closePath();
        this.fillPath();
        return;
      }
      this.lineTo(0, 0);
      this.closePath();
      this.fillPath();
      this.beginPath();
      this.moveTo(0, 0);
      this.lineTo(-tileSize / 2, 0);
      if (remainingAngle > triangleAngleFromCenter) {
        this.lineTo(-tileSize / 2, -lineLength / 2);
        remainingAngle -= triangleAngleFromCenter;
      } else {
        this.lineTo(-tileSize / 2, -Math.tan(remainingAngle) * tileSize / 2);
        this.lineTo(0, 0);
        this.closePath();
        this.fillPath();
        return;
      }
      this.lineTo(0, 0);
      this.closePath();
      this.fillPath();
      if (remainingAngle > roundedRectAngleFromCenter) {
        this.slice(-lineLength / 2, -lineLength / 2, rectRadius, Math.PI, 3 * Math.PI / 2, false);
        remainingAngle -= roundedRectAngleFromCenter;
        this.fillPath();
        this.beginPath();
        this.moveTo(0, 0);
        this.lineTo(-tileSize / 2, -lineLength / 2);
        this.lineTo(-lineLength / 2, -lineLength / 2);
        this.lineTo(-lineLength / 2, -tileSize / 2);
        this.lineTo(0, 0);
        this.closePath();
        this.fillPath();
      } else {
        const angleRatio = remainingAngle / roundedRectAngleFromCenter;
        this.beginPath();
        this.arc(-lineLength / 2, -lineLength / 2, rectRadius, Math.PI, Math.PI + angleRatio * Math.
        PI / 2, false);
        this.fillPath();
        const circleIntersection = this.topLeftCurve.getPoint(angleRatio);
        this.beginPath();
        this.moveTo(0, 0);
        this.lineTo(-tileSize / 2, -lineLength / 2);
        this.lineTo(circleIntersection.x, circleIntersection.y);
        this.lineTo(0, 0);
        this.closePath();
        this.fillPath();
        return;
      }
      this.beginPath();
      this.moveTo(0, 0);
      this.lineTo(-lineLength / 2, -tileSize / 2);
      if (remainingAngle > triangleAngleFromCenter) {
        this.lineTo(0, -tileSize / 2);
        remainingAngle -= triangleAngleFromCenter;
      } else {
        this.lineTo(-lineLength / 2 - -Math.tan(remainingAngle) * tileSize / 2, -tileSize / 2);
        this.lineTo(0, 0);
        this.closePath();
        this.fillPath();
        return;
      }
      this.lineTo(0, 0);
      this.closePath();
      this.fillPath();
    }
  };
  var BombCountdown_default = BombCountdown;

  // src/game/gameplay/objects/tiles/BaseTile.ts
  init_phaser_custom_min();

  // src/game/gameplay/animations/particle/TileExplosionParticle.ts
  init_phaser_custom_min();

  // src/game/gameplay/animations/particle/ExplodeParticle.ts
  init_phaser_custom_min();
  var { KEY: KEY24, FRAME: FRAME17 } = sprites_default.GAMEPLAY;
  var ExplodeParticle = class extends Phaser.GameObjects.Container {
    deathZone;
    emitter;
    constructor(scene) {
      super(scene);
      this.createDeathZone();
      this.createEmitters();
      this.kill();
      this.scene.add.existing(this);
    }
    createDeathZone() {
      this.deathZone = new Phaser.Geom.Circle();
    }
    createEmitters() {
      this.emitter = this.scene.add.particles(0, 0, KEY24, {
        frame: FRAME17.EFFECT_SPARK,
        speed: { min: 100, max: 250 },
        scale: { min: 0.5, max: 0.9 },
        alpha: { min: 0.8, max: 1 },
        deathZone: {
          source: this.deathZone,
          type: "onLeave"
        }
        // lifespan: 50000,
      });
    }
    explode(count, x, y, radius) {
      this.revive();
      this.deathZone.radius = radius;
      this.deathZone.setPosition(x, y);
      this.emitter.explode(count, x, y);
    }
  };
  var ExplodeParticle_default = ExplodeParticle;

  // src/game/gameplay/animations/particle/TileExplosionParticle.ts
  var TileExplosionParticle = class extends ExplodeParticle_default {
    explode(count, x, y, radius) {
      super.explode(count, x, y, radius);
      this.runParticleTween();
    }
    runParticleTween() {
      let index = 0;
      this.emitter.forEachAlive((particle) => {
        this.scene.tweens.killTweensOf(particle);
        this.scene.tweens.add({
          targets: [particle],
          duration: 400,
          delay: 5 * index,
          ease: Phaser.Math.Easing.Circular.Out,
          props: {
            velocityX: particle.velocityX / 50,
            velocityY: particle.velocityY / 50
          },
          onComplete: () => {
            index++;
            this.scene.add.tween({
              targets: [particle],
              duration: 800,
              delay: 10 * index,
              ease: Phaser.Math.Easing.Circular.Out,
              props: {
                alpha: 0,
                scaleX: 0,
                scaleY: 0
              },
              onComplete: () => {
                particle.lifeCurrent = 0;
              },
              onStop: () => {
                particle.lifeCurrent = 0;
              }
            });
          }
        });
      }, this);
    }
  };
  var TileExplosionParticle_default = TileExplosionParticle;

  // src/game/gameplay/objects/tiles/BaseTile.ts
  var {
    Utils: { Object: O9 }
  } = Ludex;
  var { GAMEPLAY: GAMEPLAY2, EFFECTS: EFFECTS3, TILES } = sprites_default;
  var { STATUS: STATUS2 } = tile_default;
  var BaseTile = class extends Phaser.GameObjects.Container {
    scene;
    nextX;
    nextY;
    row;
    column;
    color;
    frame;
    isBreakWhenExplosive;
    block;
    icon;
    polishEffect;
    explodeParticle;
    unselectAnimation;
    selectAnimation;
    extraSpawnEffect;
    constructor(scene, frame, color) {
      super(scene, 0, 0);
      this.scene = scene;
      if (color) {
        this.color = color;
      }
      this.nextX = null;
      this.nextY = null;
      this.isBreakWhenExplosive = false;
      this.setWorldSize(65, 65);
      this.setDepth(depth_default.TILE);
      if (frame) {
        this.frame = frame;
        this.drawBlock(frame);
      }
      this.createExplodeParticle$();
      this.scene.add.existing(this);
      this.setState(STATUS2.READY);
    }
    // Props
    show() {
      this.setVisible(true);
      this.block.setVisible(true);
    }
    setRow(row) {
      this.row = row;
    }
    setColumn(column) {
      this.column = column;
    }
    setIsBreakWhenExplosive(value) {
      this.isBreakWhenExplosive = value;
    }
    // Events
    removeEvents$() {
      this.off(Phaser.Input.Events.GAMEOBJECT_POINTER_UP, this.handleOnUnselect$, this);
      this.off(Phaser.Input.Events.GAMEOBJECT_POINTER_OUT, this.handleOnUnselect$, this);
    }
    // Input
    createInput() {
      this.off(Phaser.Input.Events.GAMEOBJECT_POINTER_DOWN, this.handleOnSelect$, this);
      this.on(Phaser.Input.Events.GAMEOBJECT_POINTER_DOWN, this.handleOnSelect$, this);
    }
    // Methods
    showHighlight() {
      this.scene.effectManager.playTileHighlightEffect(this);
      this.scene.boardManager.boardContainer.bringToTop(this);
    }
    hideHighlight() {
      const { effectManager } = this.scene;
      const highlightedTile = effectManager.getCurrentlyHighlightedTile();
      if (highlightedTile === this) {
        effectManager.stopTileHighlightEffect();
      }
    }
    explosive(_index) {
      if (!this.scene) return;
      if (this.nextX) {
        this.setX(this.nextX);
      }
      if (this.nextY) {
        this.setY(this.nextY);
      }
      this.explosiveAnimation();
    }
    handleOnSelect$() {
      this.removeEvents$();
      this.runSelectAnimation$();
    }
    handleOnUnselect$() {
      this.runUnselectAnimation$();
    }
    getExplosiveAnimationKey = () => {
      return null;
    };
    explosiveAnimation() {
      if (!this.icon?.anims) return;
      if (this.isBreakWhenExplosive) {
        const { effectManager } = this.scene;
        effectManager.playTileBreakEffect(this);
        AudioUtils_default.playSound(soundEffects_default.BOMB_EXPLODE_1);
        this.onExplosive();
        return;
      }
      const animationKey = this.getExplosiveAnimationKey();
      if (!animationKey) {
        const { x, y } = this.getWorldPosition();
        this.explodeParticle.explode(20, x, y, 20);
        this.onExplosive();
        return;
      }
      this.icon.once(Phaser.Animations.Events.ANIMATION_COMPLETE, () => {
        this.onExplosive();
      });
      this.icon.anims.play(animationKey, true);
    }
    onExplosive() {
      this.hideHighlight();
      this.hidePolishEffect();
      this.scene.boardManager.boardContainer.bringToTop(this);
      this.scene.tweens.killTweensOf(this);
      this.scene.tweens.add({
        targets: [this],
        duration: 200,
        ease: Phaser.Math.Easing.Cubic.Out,
        props: {
          alpha: 0
        },
        onComplete: () => {
          this.removeTile();
        }
      });
    }
    enableTile() {
      const tileSize = this.scene.boardManager.getTileSize();
      this.block.setWorldSize(tileSize, tileSize);
      this.revive();
      this.setState(STATUS2.READY);
    }
    changeDeck(deckPrefix) {
      const deckId = deckPrefix.toUpperCase();
      if (!deckId) {
        console.warn(`Tile ${deckId} not found`);
        return;
      }
      const key = TILES[deckId].KEY;
      const frame = `tile-${this.color}`;
      const tileSize = this.scene.boardManager.getTileSize();
      this.icon.setTexture(key);
      this.icon.setFrame(frame);
      const baseWidth = this.icon.displayWidth / this.icon.scaleX;
      const baseHeight = this.icon.displayHeight / this.icon.scaleY;
      const scaleX = tileSize / baseWidth * 0.85;
      const scaleY = tileSize / baseHeight * 0.85;
      this.icon.setScale(Math.min(scaleX, scaleY));
    }
    removeTile() {
      if (!this.scene) return;
      this.setScale(1);
      const { tileManager } = this.scene;
      tileManager.removeTile(this);
    }
    // Draw
    drawBlock(frame) {
      const tileSize = this.scene.boardManager.getTileSize();
      this.block = this.scene.add.image(0, 0, GAMEPLAY2.KEY, GAMEPLAY2.FRAME.TILE_BG);
      this.block.setWorldSize(tileSize, tileSize);
      this.add(this.block);
      const { currentDeckPrefix } = this.scene.tileManager;
      const deckId = currentDeckPrefix.toUpperCase();
      if (!O9.hasOwn(TILES, deckId)) {
        console.warn(`Tile ${deckId} not found`);
        return;
      }
      const tile = TILES[deckId];
      if (!tile) {
        console.warn(`Tile ${deckId} not found`);
        return;
      }
      this.icon = this.scene.make.sprite({ key: tile.KEY, frame });
      const baseWidth = this.icon.displayWidth / this.icon.scaleX;
      const baseHeight = this.icon.displayHeight / this.icon.scaleY;
      const scaleX = tileSize / baseWidth * 0.85;
      const scaleY = tileSize / baseHeight * 0.85;
      this.icon.setScale(Math.min(scaleX, scaleY));
      this.add(this.icon);
    }
    createExplodeParticle$() {
      this.explodeParticle = new TileExplosionParticle_default(this.scene);
    }
    drawPolishEffect$() {
      this.polishEffect = this.scene.add.sprite(0, 0, EFFECTS3.KEY, `${EFFECTS3.FRAME.POLISH_EFFECT}\
0`);
      this.polishEffect.setDisplaySize(40, 40);
      this.polishEffect.setAlpha(0.8);
      this.polishEffect.setVisible(false);
      this.add(this.polishEffect);
    }
    // Tweens
    runSelectAnimation$() {
      if (!this.scene) return;
      this.selectAnimation?.stop();
      this.selectAnimation = this.scene.tweens.add({
        ...ScaleDown_default,
        targets: [this],
        duration: 166,
        yoyo: true,
        ease: Phaser.Math.Easing.Cubic.InOut,
        props: {
          scale: { start: 1, to: 0.8 }
        }
      });
    }
    runUnselectAnimation$() {
      if (!this.scene) return;
      this.unselectAnimation?.stop();
      this.unselectAnimation = this.scene.tweens.add({
        ...ScaleUp_default,
        targets: [this],
        duration: 100,
        props: {
          scale: 1
        }
      });
    }
    runExtraSpawnEffect() {
      this.extraSpawnEffect?.stop();
      const baseScaleX = this.scaleX;
      const baseScaleY = this.scaleY;
      this.setScale(baseScaleX * 0.3, baseScaleY * 0.3);
      this.extraSpawnEffect = this.scene.tweens.add({
        targets: this,
        duration: 200,
        props: {
          scaleX: {
            from: baseScaleX * 0.3,
            to: baseScaleX
          },
          scaleY: {
            from: baseScaleY * 0.3,
            to: baseScaleY
          }
        },
        onComplete: () => {
          this.playPolishEffect$();
        },
        onStop: () => {
          this.playPolishEffect$();
          this.setScale(baseScaleX, baseScaleY);
        }
      });
    }
    playPolishEffect$() {
      if (!this.polishEffect) {
        this.drawPolishEffect$();
      }
      const tileSize = this.scene.boardManager.getTileSize();
      this.polishEffect.setVisible(true);
      this.polishEffect.setWorldSize(tileSize, tileSize);
      this.polishEffect.play(animation_default.POLISH_EFFECT.KEY, true);
    }
    hidePolishEffect() {
      this.polishEffect?.setVisible(false);
    }
    getIcon() {
      return this.icon;
    }
    // Check status
    isReady() {
      return this.state === STATUS2.READY;
    }
    isMoving() {
      return this.state === STATUS2.MOVING;
    }
    isCapturing() {
      return this.state === STATUS2.CAPTURING;
    }
    isCaptured() {
      return this.state === STATUS2.CAPTURED;
    }
  };
  var BaseTile_default = BaseTile;

  // src/game/gameplay/objects/tiles/BombTile.ts
  var { KEY: KEY25, FRAME: FRAME18 } = sprites_default.GAMEPLAY;
  var { SPECIALS } = tile_default;
  var { BOMB_EXPLOSION, BOMB_DEFUSE } = animation_default;
  var { BombCountDownTime, DelayEndGame } = GameSettings_default;
  var BombTile = class extends BaseTile_default {
    bombCountdown;
    bombTimer;
    remainingTime;
    bombIcon;
    bombIconTween;
    reason = "pair";
    isTickingSoundPlaying;
    tickingSoundEvent;
    isPaused;
    constructor(scene, row, column) {
      super(scene, FRAME18.TILE_BOMB, SPECIALS.BOMB);
      this.setName("BombTile");
      this.isTickingSoundPlaying = false;
      this.isPaused = false;
      this.setRow(row);
      this.setColumn(column);
      this.createIconBomb();
      this.createBombCountdownEffect();
      this.runBombIconTween();
      this.listenToBombEvents();
      this.scene.events.on(tile_default.EVENTS.FIRST_INTERACTION, this.startCountdown);
    }
    listenToBombEvents() {
      this.removeBombListeners();
      this.scene.events.on(tile_default.EVENTS.PAUSE_BOMB_TIMER, this.pauseBombTimer);
      this.scene.events.on(tile_default.EVENTS.RESUME_BOMB_TIMER, this.resumeBombTimer);
      this.scene.events.on(tile_default.EVENTS.BOMB_TIMER_RESCUE, this.increaseRemainingTimeOnRescue);
    }
    removeBombListeners() {
      this.scene.events.off(tile_default.EVENTS.PAUSE_BOMB_TIMER, this.pauseBombTimer);
      this.scene.events.off(tile_default.EVENTS.RESUME_BOMB_TIMER, this.resumeBombTimer);
      this.scene.events.off(tile_default.EVENTS.BOMB_TIMER_RESCUE, this.increaseRemainingTimeOnRescue);
    }
    handleInteractionEventAfterRescue() {
      this.scene.events.off(tile_default.EVENTS.INTERACTION, this.startTimer);
      this.scene.events.once(tile_default.EVENTS.INTERACTION, this.startTimer);
    }
    createIconBomb() {
      this.bombIcon = this.scene.add.image(0, 0, KEY25, FRAME18.ICON_BOMB);
      const tileSize = this.scene.boardManager.getTileSize();
      const ratio = tileSize / 35;
      this.bombIcon.setWorldSize(16 * ratio, 17 * ratio);
      this.bombIcon.setPosition(10 * ratio, 5 * ratio);
      this.add(this.bombIcon);
    }
    createBombCountdownEffect() {
      this.bombCountdown = new BombCountdown_default(this.scene);
      this.bombCountdown.setPosition(0, 0);
      this.add(this.bombCountdown);
    }
    enableTile() {
      super.enableTile();
      this.listenToBombEvents();
      this.isPaused = false;
      const tileSize = this.scene.boardManager.getTileSize();
      const ratio = tileSize / 35;
      this.bombIcon.setWorldSize(16 * ratio, 17 * ratio);
      this.bombIcon.setPosition(10 * ratio, 5 * ratio);
      this.reason = "pair";
      this.bombIcon.revive();
      this.isTickingSoundPlaying = false;
    }
    setState(value) {
      super.setState(value);
      if (value === tile_default.STATUS.CAPTURING) {
        this.removeBombListeners();
      }
      return this;
    }
    getExplosiveAnimationKey = () => {
      if (this.reason === "defuse") return BOMB_DEFUSE.KEY;
      if (this.reason === "exploded") return BOMB_EXPLOSION.KEY;
      return null;
    };
    setColor(color, deckPrefix) {
      if (this.isCaptured()) return;
      this.color = color;
      this.changeDeck(deckPrefix);
    }
    startCountdown = () => {
      if (!this.active) return;
      if (this.reason === "defuse") return;
      this.isPaused = false;
      this.remainingTime = BombCountDownTime;
      this.isTickingSoundPlaying = false;
      if (this.remainingTime < 1) {
        this.bombExplodeGrant();
        return;
      }
      this.setUpCountdownEffect();
      this.startTimer();
    };
    setUpCountdownEffect() {
      const { boardContainer } = this.scene.boardManager;
      boardContainer.bringToTop(this);
    }
    setBombEffectWhenGameStarts() {
      const { boardContainer } = this.scene.boardManager;
      boardContainer.bringToTop(this);
      const tileSize = this.scene.boardManager.getTileSize();
      this.bombCountdown.setScale(tileSize * 0.95 / 35);
      this.bombCountdown.drawCountdown(1, 1);
    }
    updateBombCountdownEffect() {
      this.bombCountdown.drawCountdown(this.remainingTime, BombCountDownTime);
    }
    runBombIconTween() {
      this.bringToTop(this.bombIcon);
      this.bombIconTween?.stop();
      const { scaleX, scaleY } = this.bombIcon;
      this.bombIconTween = this.scene.tweens.add({
        targets: this.bombIcon,
        scaleX: scaleX * 1.2,
        scaleY: scaleY * 1.2,
        ease: "Sine.easeInOut",
        duration: 500,
        yoyo: true,
        repeat: -1,
        onStop: () => {
          this.bombIcon.setScale(scaleX, scaleY);
        }
      });
    }
    stopTimer() {
      this.bombTimer?.remove();
      this.tickingSoundEvent?.remove();
      this.bombCountdown.stop();
      this.bombIcon.kill();
      this.bombIconTween?.stop();
      this.isTickingSoundPlaying = false;
    }
    isDefuse() {
      return this.reason === "defuse";
    }
    startTimer = () => {
      this.bombTimer = this.scene.time.addEvent({
        delay: 500,
        callback: () => {
          const scene = this.scene;
          if (!scene.stateManager.isPlaying()) return;
          if (this.isPaused) return;
          this.remainingTime -= 500;
          if (this.remainingTime < 500) {
            this.bombExplodeGrant();
            return;
          }
          this.updateBombCountdownEffect();
          if (this.remainingTime <= 4500 && !this.isTickingSoundPlaying) {
            AudioUtils_default.playSound(soundEffects_default.TICKING_BOMB_BEFORE_EXPLODE);
            this.isTickingSoundPlaying = true;
            this.fireTickingSound();
          }
        },
        loop: true
      });
    };
    fireTickingSound() {
      this.tickingSoundEvent?.remove();
      this.tickingSoundEvent = this.scene.time.addEvent({
        delay: 1500,
        callback: () => {
          if (this.isPaused) return;
          AudioUtils_default.playSound(soundEffects_default.TICKING_BOMB_BEFORE_EXPLODE);
        },
        repeat: 1
      });
    }
    bombExplodeGrant = () => {
      this.stopTimer();
      this.reason = "exploded";
      this.explosive(0);
      const { boardContainer } = this.scene.boardManager;
      boardContainer.bringToTop(this);
      this.block.kill();
      this.icon.scale *= 5;
      AudioUtils_default.playSound(soundEffects_default.BOMB_EXPLODE_1);
      this.scene.itemManager.setIsUseableItem(false);
    };
    handleBombDefuse() {
      this.stopTimer();
      this.reason = "defuse";
      this.explosive(0);
      const { boardContainer } = this.scene.boardManager;
      boardContainer.bringToTop(this);
      this.icon.scale *= 2.4;
      AudioUtils_default.playSound(soundEffects_default.BOMB_DEFUSE);
      this.block?.off(Phaser.Input.Events.GAMEOBJECT_POINTER_DOWN);
      this.block?.disableInteractive();
      this.setState(tile_default.STATUS.CAPTURING);
    }
    onExplosive() {
      super.onExplosive();
      const { tileManager } = this.scene;
      if (this.reason === "exploded") {
        this.scene.time.delayedCall(DelayEndGame, () => {
          tileManager.tilesChangeColor(this.color, [this]);
        });
        this.scene.die("bombExplosive");
      }
      if (this.reason === "defuse") {
        tileManager.tilesChangeColor(this.color, [this]);
      }
    }
    removeTile() {
      super.removeTile();
      if (!this.scene) return;
      this.stopTimer();
      this.bombCountdown.clear();
      const { itemManager } = this.scene;
      itemManager.updateBombDefuseItemState();
    }
    //! DEBUG ONLY
    shortenRemainingTime() {
      this.remainingTime = 2e3;
    }
    pauseBombTimer = () => {
      this.isPaused = true;
    };
    resumeBombTimer = () => {
      this.isPaused = false;
    };
    increaseRemainingTimeOnRescue = () => {
      this.remainingTime = BombCountDownTime;
      this.updateBombCountdownEffect();
      this.isPaused = false;
    };
  };
  var BombTile_default = BombTile;

  // src/game/gameplay/utils/MatchFinder.ts
  init_phaser_custom_min();

  // src/game/gameplay/utils/Pathfinder.ts
  init_phaser_custom_min();
  var Pathfinder = class {
    priorityQueue = [];
    grid = [
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      [0, 1, 0, 0, 0, 1, 0, 0, 1, 0],
      [0, 2, 1, 0, 1, 0, 0, 0, 0, 3],
      [0, 0, 0, 0, 0, 0, 1, 0, 0, 0],
      [1, 0, 1, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 1, 0, 1, 1, 1, 0, 0],
      [0, 0, 0, 1, 0, 1, 0, 1, 0, 0],
      [0, 1, 0, 0, 0, 0, 1, 1, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0, 1, 0],
      [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]
    ];
    width = 10;
    height = 10;
    path = null;
    findPath(start, end, grid) {
      this.grid = grid;
      this.height = grid.length;
      this.width = grid[0].length;
      this.priorityQueue = [];
      this.path = null;
      this.traverse(start, end);
      this.sharpenPath();
      return this.path;
    }
    findWrongPath(start, end, grid) {
      this.grid = grid;
      this.height = grid.length;
      this.width = grid[0].length;
      this.priorityQueue = [];
      this.path = null;
      this.traverseFull(start, end);
      if (!this.path) {
        return [];
      }
      this.sharpenPath();
      return this.path;
    }
    getTurnsOfPath(path) {
      if (path.length <= 2) return 0;
      let turns = 0;
      for (let i = 2; i < path.length; i++) {
        const { x: firstX = 0, y: firstY = 0 } = path[i - 2];
        const { x: secondX = 0, y: secondY = 0 } = path[i - 1];
        const { x: thirdX = 0, y: thirdY = 0 } = path[i];
        const firstVector = new Phaser.Math.Vector2(secondX - firstX, secondY - firstY);
        const secondVector = new Phaser.Math.Vector2(thirdX - secondX, thirdY - secondY);
        const angle = Phaser.Math.Angle.BetweenPoints(firstVector, secondVector);
        if (angle !== 0) {
          turns++;
        }
      }
      return turns;
    }
    traverse(start, end) {
      const { x: x12 = 0, y: y12 = 0 } = start;
      const { x: x2 = 0, y: y2 = 0 } = end;
      if (this.isAllPathBlocked(start, end)) {
        console.log("All paths are blocked on one square");
        return;
      }
      this.priorityQueue.push({
        x: x12,
        y: y12,
        usedTurns: 0,
        direction: "none",
        expectedCostToEnd: this.calculateExpectedCostToEndPoint({ x: x12, y: y12 }, { x: x2, y: y2 }),
        currentPath: [{ x: x12, y: y12 }]
      });
      while (this.priorityQueue.length > 0) {
        const currentSquare = this.getFromPriorityQueue();
        const { x: curX = 0, y: curY = 0 } = currentSquare;
        if (curX === x2 && curY === y2) {
          this.path = currentSquare.currentPath;
          break;
        }
        const adjSquares = this.getAdjacentSquares(currentSquare);
        for (const adjSquare of adjSquares) {
          if (currentSquare.currentPath.includes(adjSquare)) {
            continue;
          }
          const expectedCostToEnd = this.calculateExpectedCostToEndPoint(adjSquare, {
            x: x2,
            y: y2
          });
          this.addToPriorityQueue(adjSquare, currentSquare, expectedCostToEnd);
        }
      }
    }
    traverseFull(start, end) {
      const { x: x12 = 0, y: y12 = 0 } = start;
      const { x: x2 = 0, y: y2 = 0 } = end;
      if (this.isAllPathBlocked(start, end)) {
        const path = this.getSpecialCasePath(start, end);
        if (path.length > 0) {
          this.path = path;
        }
        return;
      }
      this.priorityQueue.push({
        x: x12,
        y: y12,
        usedTurns: 0,
        direction: "none",
        expectedCostToEnd: this.calculateExpectedCostToEndPoint({ x: x12, y: y12 }, { x: x2, y: y2 }),
        currentPath: [{ x: x12, y: y12 }]
      });
      while (this.priorityQueue.length > 0) {
        const currentSquare = this.getFromPriorityQueue();
        const { x: curX = 0, y: curY = 0 } = currentSquare;
        if (curX === x2 && curY === y2) {
          this.path = currentSquare.currentPath;
          break;
        }
        const adjSquares = this.getAdjacentSquares(currentSquare);
        for (const adjSquare of adjSquares) {
          if (currentSquare.currentPath.includes(adjSquare)) {
            continue;
          }
          const expectedCostToEnd = this.calculateExpectedCostToEndPoint(adjSquare, {
            x: x2,
            y: y2
          });
          this.addToGenerousPriorityQueue(adjSquare, currentSquare, expectedCostToEnd);
        }
      }
      if (!this.path) {
        const path = this.getSpecialCasePath(start, end);
        if (path.length > 0) {
          this.path = path;
        }
      }
    }
    getSpecialCasePath(start, end) {
      const { x: x12 = 0, y: y12 = 0 } = start;
      const { x: x2 = 0, y: y2 = 0 } = end;
      if (x12 === x2) {
        const path = this.getYLine(y12, y2, x12);
        return path;
      }
      if (y12 === y2) {
        const path = this.getXLine(x12, x2, y12);
        return path;
      }
      const result = [];
      result.push(...this.getXLine(x12, x2, y12));
      result.pop();
      result.push(...this.getYLine(y12, y2, x2));
      return result;
    }
    /**
     * All path out of the grid will close to the grid
     */
    sharpenPath() {
      if (!this.path) return;
      for (let i = 0; i < this.path.length; i++) {
        const { x = -1, y = -1 } = this.path[i];
        if (x === 0) {
          this.path[i].x = 0.25;
        } else if (x === this.height - 1) {
          this.path[i].x = x - 0.25;
        }
        if (y === 0) {
          this.path[i].y = 0.25;
        } else if (y === this.width - 1) {
          this.path[i].y = y - 0.25;
        }
      }
    }
    getXLine(fromX, toX, y) {
      const result = [];
      if (fromX < toX) {
        for (let i = fromX; i <= toX; i++) {
          result.push({ x: i, y });
        }
      } else {
        for (let i = fromX; i >= toX; i--) {
          result.push({ x: i, y });
        }
      }
      return result;
    }
    getYLine(fromY, toY, x) {
      const result = [];
      if (fromY < toY) {
        for (let i = fromY; i <= toY; i++) {
          result.push({ x, y: i });
        }
      } else {
        for (let i = fromY; i >= toY; i--) {
          result.push({ x, y: i });
        }
      }
      return result;
    }
    addToGenerousPriorityQueue(targetSquare, currentSquare, expectedCostToEnd) {
      const { x: x2 = 0, y: y2 = 0 } = targetSquare;
      const { x: x12 = 0, y: y12 = 0, direction, usedTurns } = currentSquare;
      const movingDirection = this.getMovingDirectionString(x2 - x12, y2 - y12);
      if (movingDirection === direction) {
        this.priorityQueue.push({
          x: x2,
          y: y2,
          usedTurns,
          direction: movingDirection,
          expectedCostToEnd,
          currentPath: [...currentSquare.currentPath, { x: x2, y: y2 }]
        });
      } else {
        const isGoingAwayToTarget = usedTurns >= 2 && expectedCostToEnd > currentSquare.expectedCostToEnd;
        if (usedTurns < 7 && !isGoingAwayToTarget) {
          this.priorityQueue.push({
            x: x2,
            y: y2,
            usedTurns: usedTurns + 1,
            direction: movingDirection,
            expectedCostToEnd,
            currentPath: [...currentSquare.currentPath, { x: x2, y: y2 }]
          });
        }
      }
    }
    getPath() {
      if (!this.path) {
        console.log("No path found");
        return [];
      }
      console.log("Path found: ", this.path);
      return this.path;
    }
    calculateExpectedCostToEndPoint(current, end) {
      const { x: x12 = 0, y: y12 = 0 } = current;
      const { x: x2 = 0, y: y2 = 0 } = end;
      return Math.abs(x12 - x2) + Math.abs(y12 - y2);
    }
    addToPriorityQueue(targetSquare, currentSquare, expectedCostToEnd) {
      const { x: x2 = 0, y: y2 = 0 } = targetSquare;
      const { x: x12 = 0, y: y12 = 0, direction, usedTurns } = currentSquare;
      const movingDirection = this.getMovingDirectionString(x2 - x12, y2 - y12);
      if (movingDirection === direction) {
        this.priorityQueue.push({
          x: x2,
          y: y2,
          usedTurns,
          direction: movingDirection,
          expectedCostToEnd,
          currentPath: [...currentSquare.currentPath, { x: x2, y: y2 }]
        });
      } else {
        const isGoingAwayToTarget = usedTurns >= 2 && expectedCostToEnd > currentSquare.expectedCostToEnd;
        if (usedTurns < 3 && !isGoingAwayToTarget) {
          this.priorityQueue.push({
            x: x2,
            y: y2,
            usedTurns: usedTurns + 1,
            direction: movingDirection,
            expectedCostToEnd,
            currentPath: [...currentSquare.currentPath, { x: x2, y: y2 }]
          });
        }
      }
    }
    getFromPriorityQueue() {
      const lowestHeuristicValue = Math.min(
        ...this.priorityQueue.map((square) => square.expectedCostToEnd + square.currentPath.length)
      );
      const bestSquare = this.priorityQueue.find(
        (square) => lowestHeuristicValue === square.expectedCostToEnd + square.currentPath.length
      );
      if (!bestSquare) {
        return this.priorityQueue.splice(0, 1)[0];
      }
      return this.priorityQueue.splice(this.priorityQueue.indexOf(bestSquare), 1)[0];
    }
    getAdjacentSquares(currentSquare) {
      const { x = 0, y = 0 } = currentSquare;
      const adjacentSquares = [];
      if (x - 1 >= 0) {
        const isObstacle = this.grid[x - 1][y] === 1;
        if (!isObstacle) {
          adjacentSquares.push({
            x: x - 1,
            y
          });
        }
      }
      if (x + 1 < this.height) {
        const isObstacle = this.grid[x + 1][y] === 1;
        if (!isObstacle) {
          adjacentSquares.push({
            x: x + 1,
            y
          });
        }
      }
      if (y - 1 >= 0) {
        const isObstacle = this.grid[x][y - 1] === 1;
        if (!isObstacle) {
          adjacentSquares.push({
            x,
            y: y - 1
          });
        }
      }
      if (y + 1 < this.width) {
        const isObstacle = this.grid[x][y + 1] === 1;
        if (!isObstacle) {
          adjacentSquares.push({
            x,
            y: y + 1
          });
        }
      }
      return adjacentSquares;
    }
    isAllPathBlocked(start, end) {
      const { x: x12 = 0, y: y12 = 0 } = start;
      const { x: x2 = 0, y: y2 = 0 } = end;
      const adjSquareStartPoint = this.getAdjacentSquares({ x: x12, y: y12 });
      const adjSquareEndPoint = this.getAdjacentSquares({ x: x2, y: y2 });
      if (adjSquareStartPoint.length === 0 || adjSquareEndPoint.length === 0) {
        return true;
      }
      return false;
    }
    getMovingDirectionString(x, y) {
      if (x === 1) {
        return "down";
      }
      if (x === -1) {
        return "up";
      }
      if (y === 1) {
        return "right";
      }
      if (y === -1) {
        return "left";
      }
      return "none";
    }
  };
  var Pathfinder_default = Pathfinder;

  // src/game/gameplay/utils/MatchFinder.ts
  var MatchFinder = class {
    scene;
    pathfinder;
    colorGrid = [];
    obstacleGrid = [];
    outerTiles = [];
    availableColors = [];
    pathForAutoplay = null;
    constructor(scene) {
      this.scene = scene;
      this.pathfinder = new Pathfinder_default();
    }
    updateGrids() {
      this.updateColorGrid();
      this.updateObstacleGrid();
      this.createOuterTiles();
      this.pathForAutoplay = null;
    }
    checkForAvailableMatches() {
      this.updateGrids();
      if (this.checkForNearestMatch()) {
        return true;
      }
      if (this.checkOuterTilesMatch()) {
        return true;
      }
      console.log("No matches found");
      return false;
    }
    updateColorGrid() {
      this.colorGrid = [];
      const { boardMap } = this.scene.boardManager;
      const config = this.scene.levelHandler.getConfigs();
      if (!config) return;
      const { rows, columns } = config;
      for (let x = 1; x <= rows; x++) {
        this.colorGrid[x - 1] = [];
        for (let y = 1; y <= columns; y++) {
          if (!boardMap[x]) continue;
          if (!boardMap[x][y]) continue;
          if (boardMap[x][y].isCaptured()) {
            this.colorGrid[x - 1][y - 1] = "0";
            continue;
          }
          const color = boardMap[x][y].color;
          if (!this.availableColors.includes(color)) {
            this.availableColors.push(color);
          }
          this.colorGrid[x - 1][y - 1] = color;
        }
      }
      for (const row of this.colorGrid) {
        row.unshift("0");
        row.push("0");
      }
      this.colorGrid.unshift(new Array(columns + 2).fill("0"));
      this.colorGrid.push(new Array(columns + 2).fill("0"));
    }
    updateObstacleGrid() {
      this.obstacleGrid = [];
      this.colorGrid.forEach((row, x) => {
        this.obstacleGrid[x] = [];
        row.forEach((color, y) => {
          const isObstacle = color !== "0";
          this.obstacleGrid[x][y] = isObstacle ? 1 : 0;
        });
      });
    }
    createOuterTiles() {
      this.outerTiles = [];
      const length = this.availableColors.length;
      for (let i = 0; i < length; i++) {
        this.outerTiles.push([]);
      }
    }
    getAdjacentSquaresData(row, col) {
      const adjSquares = [];
      const { boardMap } = this.scene.boardManager;
      if (row - 1 >= 1) {
        adjSquares.push(boardMap[row - 1][col]);
      }
      if (row + 1 < this.colorGrid.length - 1) {
        adjSquares.push(boardMap[row + 1][col]);
      }
      if (col - 1 >= 1) {
        adjSquares.push(boardMap[row][col - 1]);
      }
      if (col + 1 < this.colorGrid[0].length - 1) {
        adjSquares.push(boardMap[row][col + 1]);
      }
      return adjSquares.filter((tile) => tile && !tile.isCaptured());
    }
    getMaximumSurroundingSlots(row, col) {
      let availableSlots = 4;
      if (row - 1 < 0) {
        availableSlots--;
      }
      if (row + 1 >= this.colorGrid.length) {
        availableSlots--;
      }
      if (col - 1 < 0) {
        availableSlots--;
      }
      if (col + 1 >= this.colorGrid[0].length) {
        availableSlots--;
      }
      return availableSlots;
    }
    checkForNearestMatch() {
      let isMatchFound = false;
      for (let x = 0; x < this.colorGrid.length; x++) {
        for (let y = 0; y < this.colorGrid[0].length; y++) {
          const color = this.colorGrid[x][y];
          if (color === "0") continue;
          const adjSquares = this.getAdjacentSquaresData(x, y);
          const availableSlots = this.getMaximumSurroundingSlots(x, y);
          const adjSquareColors = adjSquares.map((tile) => tile.color);
          if (availableSlots > adjSquares.length) {
            const index = this.availableColors.indexOf(color);
            this.outerTiles[index].push({ x, y });
          }
          if (adjSquareColors.includes(color)) {
            const index = adjSquareColors.indexOf(color);
            const tile2 = adjSquares[index];
            this.pathForAutoplay = [
              { x, y },
              { x: tile2.row, y: tile2.column }
            ];
            isMatchFound = true;
            break;
          }
        }
        if (isMatchFound) break;
      }
      return isMatchFound;
    }
    getAllPossiblePairs(tiles) {
      const pairs = [];
      for (let i = 0; i < tiles.length; i++) {
        for (let j = i + 1; j < tiles.length; j++) {
          pairs.push({
            tile1: tiles[i],
            tile2: tiles[j]
          });
        }
      }
      pairs.sort((a, b) => {
        const aDistance = Math.abs(a.tile1.x - a.tile2.x) + Math.abs(a.tile1.y - a.tile2.y);
        const bDistance = Math.abs(b.tile1.x - b.tile2.x) + Math.abs(b.tile1.y - b.tile2.y);
        return aDistance - bDistance;
      });
      return pairs;
    }
    checkOuterTilesMatch() {
      this.outerTiles.sort((a, b) => b.length - a.length);
      let isMatchFound = false;
      for (let i = 0; i < this.outerTiles.length; i++) {
        const sameColorTiles = this.outerTiles[i];
        if (sameColorTiles.length < 1) {
          continue;
        }
        const pairs = this.getAllPossiblePairs(sameColorTiles);
        for (let j = 0; j < pairs.length; j++) {
          const { tile1, tile2 } = pairs[j];
          this.obstacleGrid[tile1.x][tile1.y] = 0;
          this.obstacleGrid[tile2.x][tile2.y] = 0;
          const path = this.pathfinder.findPath(
            { x: tile1.x, y: tile1.y },
            { x: tile2.x, y: tile2.y },
            this.obstacleGrid
          );
          if (path) {
            isMatchFound = true;
            this.pathForAutoplay = path;
            break;
          }
          this.obstacleGrid[tile1.x][tile1.y] = 1;
          this.obstacleGrid[tile2.x][tile2.y] = 1;
        }
        if (isMatchFound) break;
      }
      return isMatchFound;
    }
  };
  var MatchFinder_default = MatchFinder;

  // src/utils/hash/decodeMap.ts
  init_phaser_custom_min();
  var {
    Utils: { Object: O10, Function: F5 }
  } = Ludex;
  var getValue = F5.memoize((code, valueMap) => {
    if (typeof code === "string") {
      const data = valueMap[code.toLowerCase()];
      if (typeof data === "string") return data;
    }
    if (code[0] === "b") {
      return code;
    }
    return "?";
  });
  var findGroups = F5.memoize((str) => {
    let group = null;
    const groups = [];
    const findGroup = /:([(t|i|b)00-9?]+)/gm;
    while (true) {
      group = findGroup.exec(str);
      if (group === null) break;
      groups.push(group[1]);
    }
    return groups;
  });
  var findHash = F5.memoize((str) => {
    let codes = null;
    const hash = [];
    const findHash2 = /((t|i|b)[0-9]+)/gm;
    while (true) {
      codes = findHash2.exec(str);
      if (codes === null) break;
      const code = codes[0];
      hash.push(code);
    }
    return hash;
  });
  var func = (hash, codeMap) => {
    const str = hash;
    const valueMap = O10.invert(codeMap);
    const data = {};
    let codeIndex = 0;
    let groupIndex = 0;
    const groups = findGroups(str);
    for (const hashList of groups) {
      codeIndex = 0;
      groupIndex++;
      if (!data[groupIndex]) {
        data[groupIndex] = {};
      }
      const hash2 = findHash(hashList);
      for (const code of hash2) {
        codeIndex++;
        data[groupIndex][codeIndex] = getValue(code, valueMap);
      }
    }
    return data;
  };
  var decodeMap_default = func;

  // src/game/gameplay/managers/BoardManager.ts
  var { STATUS: STATUS3 } = manager_default2;
  var {
    Utils: { Valid: V11, Array: A4 }
  } = Ludex;
  var BoardManager = class extends BaseManager_default {
    scene;
    tileMap = {};
    boardMap = {};
    boardContainer;
    boardSizeHandler;
    matchFinder;
    constructor(scene) {
      super(scene);
      this.scene = scene;
      this.boardContainer = this.scene.make.container({});
      this.boardContainer.setDepth(depth_default.TILE);
      this.matchFinder = new MatchFinder_default(this.scene);
      this.boardSizeHandler = new BoardSizeHandler_default(this.scene);
    }
    init() {
      this.clearBoard$();
      this.setState(STATUS3.READY);
    }
    start() {
      if (this.isRunning()) return;
      this.boardSizeHandler.calculateTileSize();
      this.generateBoard$();
      this.setState(STATUS3.RUNNING);
    }
    stop() {
      if (!this.isRunning()) return;
      this.setState(STATUS3.STOPPED);
    }
    loadBoardByFen(fen) {
      const { tileManager } = this.scene;
      this.tileMap = decodeMap_default(fen, tile_default.HASH);
      for (const row in this.tileMap) {
        const columns = this.tileMap[row];
        if (!V11.isObject(columns)) continue;
        for (const col in columns) {
          let color = columns[col];
          let tile;
          if (color[0] === "b") {
            color = parseInt(color.substring(1)).toString();
            this.tileMap[row][col] = tile_default.SPECIALS.BOMB;
            tile = tileManager.createTileByType(tile_default.SPECIALS.BOMB, +row, +col);
            if (tile instanceof BombTile_default) {
              tile.setColor(color, tileManager.getCurrentDeck());
            }
          } else {
            tile = tileManager.createTileByType(color, +row, +col);
          }
          this.setTileToMap(tile, +row, +col);
        }
      }
    }
    clearBoard$() {
      this.tileMap = {};
      this.boardMap = {};
      this.boardContainer.removeAll();
    }
    generateBoard$() {
      this.generateTiles$();
      this.resizeBoard$();
      this.alignBoard$();
      this.placeBoard$();
    }
    generateTiles$() {
      const { tileManager, levelHandler } = this.scene;
      const levelConfig = levelHandler.getConfigs();
      const { rows, columns, specials = {}, customFen } = levelConfig;
      const maxItems = rows * columns;
      if (customFen) {
        this.loadBoardByFen(customFen.code);
      }
      if (Object.keys(this.boardMap).length > 0) return;
      const generatedTiles = this.createListOfTilesByPair$();
      const bombs = specials.bomb || 0;
      const bombIndexes = this.getBombPositions$(bombs, generatedTiles);
      for (let index = 0; index < maxItems; index++) {
        const { row, column } = this.getPositionByIndex(index);
        const tileType = generatedTiles[index];
        let isBomb = false;
        if (bombIndexes.includes(index)) {
          isBomb = true;
        }
        const creatingType = isBomb ? tile_default.SPECIALS.BOMB : tileType;
        const tile = tileManager.createTileByType(creatingType, row, column);
        if (isBomb && tile instanceof BombTile_default) {
          tile.setColor(tileType, tileManager.getCurrentDeck());
        }
        this.setTileToMap(tile, row, column);
      }
    }
    createListOfTilesByPair$() {
      const { levelHandler } = this.scene;
      const levelConfig = levelHandler.getConfigs();
      const { rows, columns, colors, specials = {} } = levelConfig;
      const numberOfTiles = rows * columns;
      const numberOfRockets = specials.rocket || 0;
      const numberOfPairs = Math.floor(numberOfTiles / 2) - numberOfRockets;
      const tiles = [];
      let previousColorId = 0;
      for (let i = 0; i < numberOfPairs; i++) {
        previousColorId = previousColorId >= colors ? 1 : previousColorId + 1;
        const colorId = previousColorId.toString();
        tiles.push(colorId);
        tiles.push(colorId);
      }
      for (let i = 0; i < numberOfRockets; i++) {
        tiles.push("rocket");
        tiles.push("rocket");
      }
      tiles.sort(() => Math.random() - 0.5);
      const firstSort = this.sortTilesByMaxSpace$(tiles);
      const secondSort = this.sortTilesByMaxSpace$(firstSort.reverse());
      const result = secondSort.reverse();
      this.addOnePairNextToEachOther$(result, rows, columns);
      if (tiles.length < numberOfTiles) {
        result.splice(Math.floor(result.length / 2), 0, tile_default.SPECIALS.EMPTY);
      }
      return result;
    }
    sortTilesByMaxSpace$(randomTiles) {
      const { levelHandler } = this.scene;
      const levelConfig = levelHandler.getConfigs();
      const { rows, columns, colors, rules } = levelConfig;
      if (!rules.maxSpaceOfPair) return randomTiles;
      const tileGrid = this.convertSingleListToGrid$(randomTiles, rows, columns);
      const colorList = [];
      for (let i = 1; i <= colors; i++) {
        colorList.push(i.toString());
      }
      const firstSortedColor = this.getSortedColorList$(colorList, randomTiles);
      for (let i = 0; i < firstSortedColor.length; i++) {
        let previousTileRow = null;
        let previousTileColumn = null;
        for (let row = 0; row < rows; row++) {
          for (let column = 0; column < columns; column++) {
            const tile = tileGrid[row][column];
            if (tile === firstSortedColor[i]) {
              if (!previousTileRow || !previousTileColumn) {
                previousTileRow = row;
                previousTileColumn = column;
                continue;
              }
              const allowedDistance = rules.maxSpaceOfPair + 1;
              const distance = Math.abs(previousTileRow - row) + Math.abs(previousTileColumn - column);
              if (distance <= allowedDistance) {
                previousTileColumn = column;
                previousTileRow = row;
                continue;
              }
              const newPosition = this.getTileNewPosition$(previousTileRow, previousTileColumn, row,
              column);
              const temp = tileGrid[newPosition.row][newPosition.column];
              tileGrid[newPosition.row][newPosition.column] = tileGrid[row][column];
              tileGrid[row][column] = temp;
            }
          }
        }
      }
      return this.convertGridToSingleList$(tileGrid);
    }
    addOnePairNextToEachOther$(tiles, rows, columns) {
      const firstIdx = Phaser.Math.Between(0, tiles.length - 1);
      let secondIdx = firstIdx;
      for (let index = 0; index < tiles.length; index++) {
        const element = tiles[index];
        if (index === firstIdx) continue;
        if (element === tiles[firstIdx]) {
          secondIdx = index;
          break;
        }
      }
      if (secondIdx === firstIdx) return;
      const listNeighborIdx = this.getNeighborIndexes$(firstIdx, rows, columns);
      if (listNeighborIdx.length === 0) return;
      const chooseNeighborIdx = Phaser.Math.Between(0, listNeighborIdx.length - 1);
      const neighborIdx = listNeighborIdx[chooseNeighborIdx];
      const temp = tiles[neighborIdx];
      tiles[neighborIdx] = tiles[secondIdx];
      tiles[secondIdx] = temp;
    }
    getNeighborIndexes$(index, rows, columns) {
      const { row: mainRow, column: mainColumn } = this.getPositionByIndex(index);
      const neighborIndexes = [];
      let row = mainRow + 1;
      let column = mainColumn;
      if (row <= rows) {
        neighborIndexes.push(this.getIndexByPosition$(row, column));
      }
      row = mainRow - 1;
      column = mainColumn;
      if (row >= 1) {
        neighborIndexes.push(this.getIndexByPosition$(row, column));
      }
      row = mainRow;
      column = mainColumn + 1;
      if (column <= columns) {
        neighborIndexes.push(this.getIndexByPosition$(row, column));
      }
      row = mainRow;
      column = mainColumn - 1;
      if (column >= 1) {
        neighborIndexes.push(this.getIndexByPosition$(row, column));
      }
      return neighborIndexes;
    }
    getTileNewPosition$(row1, column1, row2, column2) {
      let newRow = row1;
      let newColumn = column1;
      if (row2 > row1) {
        newRow = row1 + 1;
      }
      if (row2 < row1) {
        newRow = row1 - 1;
      }
      if (column2 > column1) {
        newColumn = column1 + 1;
      }
      if (column2 < column1) {
        newColumn = column1 - 1;
      }
      return { row: newRow, column: newColumn };
    }
    convertSingleListToGrid$(list, rows, columns) {
      const grid = [];
      for (let i = 0; i < rows; i++) {
        grid[i] = [];
        for (let j = 0; j < columns; j++) {
          grid[i][j] = list[i * columns + j];
        }
      }
      return grid;
    }
    convertGridToSingleList$(grid) {
      const list = [];
      for (let i = 0; i < grid.length; i++) {
        for (let j = 0; j < grid[i].length; j++) {
          list.push(grid[i][j]);
        }
      }
      return list;
    }
    getSortedColorList$(colors, tiles) {
      const sortedColors = [];
      const ignoredTiles = [tile_default.SPECIALS.BOMB, tile_default.SPECIALS.EMPTY, tile_default.SPECIALS.
      ROCKET];
      for (let i = 0; i < tiles.length; i++) {
        if (sortedColors.length === colors.length) break;
        const tile = tiles[i];
        if (sortedColors.includes(tile) || ignoredTiles.includes(tile)) continue;
        sortedColors.push(tile);
      }
      return sortedColors;
    }
    getBombPositions$(bombs, tileList) {
      const validIndexes = [];
      tileList.forEach((tile, index) => {
        if (tile !== tile_default.SPECIALS.EMPTY && tile !== tile_default.SPECIALS.ROCKET) {
          validIndexes.push(index);
        }
      });
      const length = validIndexes.length > bombs ? bombs : validIndexes.length;
      const bombIndexes = [];
      validIndexes.sort(() => Math.random() - 0.5);
      for (let i = 0; i < length; i++) {
        bombIndexes.push(validIndexes[i]);
      }
      return bombIndexes;
    }
    // private findEmptySlot(row: number, column: number, slots: IPosition[], maxSlot: number): void {
    //     if (slots.length >= maxSlot) return
    //     const { levelHandler } = this.scene
    //     const levelConfig = levelHandler.getConfigs()
    //     const { rows, columns } = levelConfig
    //     if (row < 1 || column < 1) return
    //     if (row > rows || column > columns) return
    //     if (row in this.boardMap) {
    //         if (column in this.boardMap[row]) return
    //     }
    //     slots.push({ row, column })
    //     const rand = Phaser.Math.RND.between(0, 100)
    //     // New
    //     /* if (rand < 40) {
    //   // ←
    //   this.findEmptySlot(row, column - 1, slots, maxSlot);
    // } else if (rand < 80) {
    //   // ← ↓
    //   this.findEmptySlot(row + 1, column - 1, slots, maxSlot);
    // } else {
    //   // ↑
    //   this.findEmptySlot(row - 1, column, slots, maxSlot);
    // } */
    //     // Old
    //     if (rand >= 40) {
    //         this.findEmptySlot(row, column + 1, slots, maxSlot)
    //     } else {
    //         this.findEmptySlot(row + 1, column, slots, maxSlot)
    //     }
    // }
    getTilesByMap$() {
      const tiles = [];
      for (const row in this.boardMap) {
        const columns = this.boardMap[row];
        for (const column in columns) {
          const tile = this.boardMap[row][column];
          tiles.push(tile);
        }
      }
      return tiles;
    }
    resizeBoard$() {
      const { levelHandler } = this.scene;
      const levelConfig = levelHandler.getConfigs();
      const rows = levelConfig.rows;
      const columns = levelConfig.columns;
      const tileSize = this.getTileSizeWithSpacing();
      this.boardContainer.setWorldSize(columns * tileSize, rows * tileSize);
    }
    placeBoard$() {
      const { levelHandler } = this.scene;
      const levelConfig = levelHandler.getConfigs();
      const rows = levelConfig.rows;
      const columns = levelConfig.columns;
      const tileSize = this.getTileSizeWithSpacing();
      const tiles = this.getTilesByMap$();
      const { x, y, width, height } = this.boardContainer;
      console.log({ x, y, width, height });
      const roundTileSize = Math.round(tileSize);
      Phaser.Actions.GridAlign(tiles, {
        width: columns,
        height: rows,
        position: Phaser.Display.Align.CENTER,
        cellWidth: roundTileSize,
        cellHeight: roundTileSize,
        x: -width / 2,
        y: -height / 2
      });
    }
    alignBoard$() {
      const { layoutManager } = this.scene;
      const { objects } = layoutManager;
      const bannerAdHeight = AdsUtils_default.getBannerHeight();
      const headerBgHeight = objects.headerBG.height;
      const footerBGHeight = objects.topFooterBG.height + bannerAdHeight;
      let offsetY = (headerBgHeight - footerBGHeight) / 2;
      if (WorldUtils_default.isLandscape()) {
        offsetY = (headerBgHeight - bannerAdHeight) / 2;
      }
      Phaser.Display.Align.In.Center(this.boardContainer, this.scene.gameZone, 0, offsetY);
    }
    getPositionByIndex(index) {
      const { columns } = this.scene.levelHandler.getConfigs();
      const row = Math.floor(index / columns) + 1;
      const column = index % columns + 1;
      return { row, column };
    }
    getIndexByPosition$(row, column) {
      const { columns } = this.scene.levelHandler.getConfigs();
      const index = (row - 1) * columns + (column - 1);
      return index;
    }
    getTileByIndex(index) {
      const { row, column } = this.getPositionByIndex(index);
      return this.getTileByPosition(row, column);
    }
    getTileByPosition(row, column) {
      if (!(row in this.boardMap)) return null;
      if (!(column in this.boardMap[row])) return null;
      return this.boardMap[row][column];
    }
    setTileToMap(tile, row, column) {
      const { tileManager } = this.scene;
      if (!this.tileMap[row]) {
        this.tileMap[row] = {};
      }
      if (!this.boardMap[row]) {
        this.boardMap[row] = {};
      }
      tile.setRow(row);
      tile.setColumn(column);
      this.tileMap[row][column] = tile.color;
      const oldTile = this.boardMap[row][column];
      oldTile && tileManager.removeTile(oldTile);
      this.boardMap[row][column] = tile;
      this.boardContainer.add(tile);
      tileManager.addTile(tile);
    }
    tileSwap(data) {
      const { fromRow, toRow, fromColumn, toColumn } = data;
      const tileTo = this.boardMap[toRow][toColumn];
      const tileFrom = this.boardMap[fromRow][fromColumn];
      tileTo.setRow(fromRow);
      tileTo.setColumn(fromColumn);
      tileFrom.setRow(toRow);
      tileFrom.setColumn(toColumn);
      this.boardMap[toRow][toColumn] = tileFrom;
      this.boardMap[fromRow][fromColumn] = tileTo;
      this.tileMap[toRow][toColumn] = tileFrom.color;
      this.tileMap[fromRow][fromColumn] = tileTo.color;
    }
    runShuffle = (duration) => {
      const tilesAlive = this.getTilesAlive$();
      const shuffleTiles = this.shuffleTiles$();
      this.shuffleAnimation$(tilesAlive, shuffleTiles, duration);
      this.updateTilesPosition$(tilesAlive, shuffleTiles);
      this.scene.time.delayedCall(300, () => {
        AudioUtils_default.playSound(soundEffects_default.SHUFFLE_ITEM);
      });
    };
    getTilesAlive$() {
      const { tileManager } = this.scene;
      const tiles = tileManager.getTiles();
      const tilesAlive = [];
      for (const tile of tiles) {
        if (tile.isCaptured()) continue;
        if (tile.isCapturing()) continue;
        tilesAlive.push(tile);
      }
      return tilesAlive;
    }
    shuffleTiles$() {
      const tiles = this.getTilesAlive$();
      A4.unique(tiles);
      const tilesMap = [];
      for (const { row, column } of tiles) {
        tilesMap.push({ row, column });
      }
      A4.shuffle(tilesMap);
      return tilesMap;
    }
    shuffleAnimation$(tilesAlive, shuffleTiles, duration) {
      const { animationManager } = this.scene;
      tilesAlive.forEach((tile, index) => {
        const { row: fromRow, column: fromColumn } = tile;
        const { row: toRow, column: toColumn } = shuffleTiles[index];
        animationManager.moveRowsAndColumns({ tile, fromRow, toRow, fromColumn, toColumn }, index * 5,
        duration);
      });
    }
    updateTilesPosition$(tilesAlive, shuffleTiles) {
      tilesAlive.forEach((tile, index) => {
        const { row: fromRow, column: fromColumn } = tile;
        const { row: toRow, column: toColumn } = shuffleTiles[index];
        if (fromRow === toRow && fromColumn === toColumn) return;
        this.tileSwap({ fromRow, toRow, fromColumn, toColumn });
      });
    }
    processNoAvailableMatches = () => {
      if (this.checkIfAllTilesAreCaptured()) {
        this.scene.events.emit(tile_default.EVENTS.NEXT_TURN);
        return;
      }
      const isAvailable = this.matchFinder.checkForAvailableMatches();
      if (isAvailable) {
        this.scene.events.emit(tile_default.EVENTS.NEXT_TURN);
        return;
      }
      const { animationManager, itemManager, tileManager } = this.scene;
      tileManager.isSelectable = false;
      itemManager.setIsUseableItem(false);
      animationManager.isMoveTilesCompleted = false;
      const duration = 500;
      this.runShuffle(duration);
      this.scene.time.delayedCall(duration + 50, this.processNoAvailableMatches);
      return;
    };
    checkIfAllTilesAreCaptured() {
      const { tileManager } = this.scene;
      const tiles = tileManager.getTiles();
      if (tiles.length < 2) return true;
      for (const tile of tiles) {
        if (!tile.isCaptured()) return false;
      }
      return true;
    }
    getTileSize() {
      return this.boardSizeHandler.getTileSize();
    }
    getTileSizeWithSpacing() {
      return this.getTileSize();
    }
  };
  var BoardManager_default = BoardManager;

  // src/game/gameplay/managers/ItemManager.ts
  init_phaser_custom_min();

  // src/game/gameplay/objects/items/GuideBombDefuse.ts
  init_phaser_custom_min();

  // src/game/gameplay/objects/items/BombDefuse.ts
  init_phaser_custom_min();

  // src/game/gameplay/objects/items/BaseItem.ts
  init_phaser_custom_min();

  // src/game/animations/attention/ShakeHorizontal.ts
  init_phaser_custom_min();
  var DEFAULT_SHAKE_HORIZONTAL_ANIM_CONFIG = {
    repeat: -1,
    yoyo: true,
    duration: 33,
    ease: Phaser.Math.Easing.Sine.InOut
  };
  var ShakeHorizontalAnimation = class {
    posX;
    tween;
    constructor(scene, config) {
      const mergedConfig = {
        ...DEFAULT_SHAKE_HORIZONTAL_ANIM_CONFIG,
        ...config,
        props: {
          x: config.shakeX ?? 5,
          ...config.props
        }
      };
      this.posX = typeof mergedConfig.props.x === "number" ? mergedConfig.props.x : 5;
      this.tween = scene.tweens.add(mergedConfig);
      this.tween?.on(Phaser.Tweens.Events.TWEEN_REPEAT, this.handleSwitchPosition, this);
    }
    handleSwitchPosition() {
      this.posX = -this.posX;
      this.tween?.updateTo("x", -this.posX);
    }
  };
  var ShakeHorizontal_default = ShakeHorizontalAnimation;

  // src/game/animations/entrances/ShowItem.ts
  init_phaser_custom_min();
  var DEFAULT_SHOW_ITEM_ANIM_CONFIG = {
    props: {
      alpha: {
        duration: 500,
        value: { start: 0, from: 0, to: 1 },
        ease: Phaser.Math.Easing.Cubic.Out
      },
      scale: {
        duration: 1e3,
        value: { start: 0.8, from: 0.8, to: 1 },
        ease: Phaser.Math.Easing.Elastic.Out,
        easeParams: [0.1, 0.45]
      }
    }
  };
  var ShowItem_default = DEFAULT_SHOW_ITEM_ANIM_CONFIG;

  // src/game/gameplay/objects/items/BaseItem.ts
  var { player: player9 } = codex;
  var { KEY: KEY26, FRAME: FRAME19 } = sprites_default.GAMEPLAY;
  var BaseItem = class extends Phaser.GameObjects.Container {
    scene;
    isActive = true;
    isFree;
    isDisabled;
    amount;
    autoRunUpAnimation = true;
    item;
    bg;
    amountItem;
    amountText;
    amountBg;
    itemLock;
    itemLockText;
    showItemAnimation;
    shakeAnimation;
    coinShakeAnimation;
    callback;
    itemCost;
    coinIcon;
    coinText;
    costContainer;
    constructor(scene, frame, width, height) {
      super(scene);
      this.scene = scene;
      this.isFree = false;
      this.isDisabled = false;
      this.itemCost = 100;
      this.createBg();
      this.createItem(frame, width, height);
      this.createAmountText();
      this.createItemLock();
      this.createAnimations();
      this.setDepth(depth_default.ITEM);
      this.setWorldSize(50, 50);
      this.scene.add.existing(this);
    }
    activeItem() {
      this.isActive = true;
      this.showItemAnimation?.remove();
      this.createShowItemAnimation();
      AnimUtils.runTween(this.showItemAnimation);
    }
    deactivateItem() {
      this.isActive = false;
    }
    enableItem() {
      if (this.isDisabled === false) return;
      this.item.setAlpha(1);
      this.amountBg.setVisible(true);
      this.amountText.setVisible(true);
      this.setAmount(this.amount);
      this.isDisabled = false;
      this.setInteractive({ useHandCursor: true });
    }
    disableItem() {
      if (this.isDisabled === true) return;
      this.deactivateItem();
      this.item.setAlpha(0.4);
      this.costContainer.setVisible(false);
      if (this.amount <= 0) {
        this.amountBg.setVisible(false);
        this.amountText.setVisible(false);
      }
      this.isDisabled = true;
      this.disableInteractive();
    }
    setFreeMode(value, keepVisibleState = false) {
      if (!keepVisibleState) {
        this.amountItem.setVisible(!value);
      }
      this.isFree = value;
    }
    getIsFree() {
      return this.isFree;
    }
    // Input
    set onClick(callback) {
      const { width: barWidth, height: barHeight } = this.bg;
      this.setSize(barWidth, barHeight + 16);
      this.setInteractive({
        useHandCursor: true
      });
      this.callback = callback;
      this.on(Phaser.Input.Events.GAMEOBJECT_POINTER_UP, this.handlePointerUp);
    }
    handlePointerUp = () => {
      this.logItemEvent();
      if (this.callback) {
        AudioUtils_default.playSound(soundEffects_default.GENERAL_BUTTON_CLICK);
        this.callback();
      }
    };
    logItemEvent() {
      if (this.isActive) return;
      AnalyticsUtils_default.trackButtonClick(this.name);
    }
    // Draw
    createBg() {
      this.bg = this.scene.add.image(0, 0, KEY26, FRAME19.ITEM_BG_ITEM);
      this.add(this.bg);
    }
    createItem(frame, width, height) {
      this.item = this.scene.add.image(0, 0, KEY26, frame);
      this.item.setWorldSize(width, height);
      Phaser.Display.Align.In.Center(this.item, this.bg, 0, -3);
      this.add(this.item);
    }
    createAmountText() {
      this.amountItem = this.scene.add.container();
      this.amountText = FontUtils_default.createText(this.scene, "", 12).setTint(8205077);
      this.amountBg = this.scene.make.image({
        key: KEY26,
        frame: FRAME19.ITEM_BG_AMOUNT
      });
      this.createCostContainer();
      Phaser.Display.Align.In.Center(this.amountText, this.amountBg);
      this.amountItem.add([this.amountBg, this.amountText, this.costContainer]);
      Phaser.Display.Align.In.TopRight(this.amountItem, this.bg, -10, -3);
      AlignUtils_default.alignChildCenter(this.amountText, this.amountItem, 0, -1);
      this.costContainer.setPosition(1, 0);
      this.add(this.amountItem);
    }
    createCostContainer() {
      this.costContainer = this.scene.add.container();
      this.costContainer.setSize(100, 14);
      this.coinText = FontUtils_default.createText(this.scene, `${this.itemCost}`, 12).setTint(1731370).
      setAlign("center");
      this.coinIcon = this.scene.make.image({
        key: KEY26,
        frame: FRAME19.ICON_COIN
      });
      this.coinIcon.setWorldSize(14, 14);
      const amountTextWidth = this.coinText.getBounds().width;
      const totalWidth = amountTextWidth + this.coinIcon.displayWidth + 0.5;
      const textOffset = amountTextWidth / 2 - totalWidth / 2;
      this.coinText.setPosition(textOffset + 1.5, -0.5);
      this.coinIcon.setPosition(totalWidth / 2 - this.coinIcon.displayWidth / 2, 0);
      this.costContainer.add([this.coinText, this.coinIcon]);
      this.costContainer.setVisible(false);
    }
    createItemLock() {
      this.itemLock = this.scene.make.image({
        key: KEY26,
        frame: FRAME19.NOTE_LOCK
      });
      Phaser.Display.Align.In.TopRight(this.itemLock, this.bg, 2, 6);
      this.add(this.itemLock);
      this.itemLock.setVisible(false);
      this.itemLockText = FontUtils_default.createText(this.scene, "", 10).setStroke("#2e2e2e", 2);
      Phaser.Display.Align.In.BottomCenter(this.itemLockText, this.bg, 0, 1);
      this.add(this.itemLockText);
      this.itemLockText.setVisible(false);
    }
    switchToNormalMode() {
      this.costContainer.setVisible(false);
      this.amountText.setVisible(true);
    }
    switchToCostMode() {
      this.costContainer.setVisible(true);
      this.amountText.setVisible(false);
    }
    setAmount(value) {
      this.amount = value;
      const isOutOfStock = this.amount <= 0;
      if (this.amountBg) {
        const bgFrame = isOutOfStock ? FRAME19.NOTE_FREE : FRAME19.ITEM_BG_AMOUNT;
        this.amountBg.setFrame(bgFrame);
      }
      if (isOutOfStock) {
        const { coins = 0 } = player9.getGameData() ?? {};
        if (coins >= this.itemCost) {
          this.itemCost = this.itemCost ?? 100;
          this.switchToCostMode();
          this.coinText.setText(`${this.itemCost}`);
          return;
        }
        this.switchToNormalMode();
        this.amountText.setTint(1731370);
        this.amountText.setText("Ads");
        return;
      }
      this.switchToNormalMode();
      this.amountText.setTint(8205077);
      this.amountText.setText(value.toString());
    }
    createAnimations() {
      this.createShowItemAnimation();
      this.shakeAnimation = new ShakeHorizontal_default(this.scene, {
        targets: [this.costContainer, this.amountText],
        repeat: 3,
        shakeX: 4,
        paused: true
      });
    }
    createShowItemAnimation() {
      const { scale } = this.item;
      this.showItemAnimation = this.scene.tweens.add({
        ...ShowItem_default,
        targets: [this.item],
        props: {
          ...ShowItem_default.props,
          scale: {
            ...ShowItem_default.props.scale,
            value: { start: scale * 0.8, from: scale * 0.8, to: scale }
          }
        }
      });
    }
  };
  var BaseItem_default = BaseItem;

  // src/game/gameplay/objects/items/BombDefuse.ts
  var { ID: ID2 } = item_default.BOMB_DEFUSE;
  var { DefuseItemGuideLevel } = GameSettings_default;
  var { FRAME: FRAME20 } = sprites_default.GAMEPLAY;
  var BombDefuseItem = class extends BaseItem_default {
    scene;
    isRunning = false;
    constructor(scene) {
      super(scene, FRAME20.DEFUSE_ITEM, 26, 34.5);
      this.itemCost = 400;
      this.scene = scene;
      this.setName(ID2);
      this.itemLockText.setText(`Level ${DefuseItemGuideLevel}`);
      this.onClick = this.handleUseItem;
    }
    handleUseItem = () => {
      if (this.isRunning) return;
      const { itemManager } = this.scene;
      if (this.isActive) {
        itemManager.deactivateItem(ID2);
        return;
      }
      const success = itemManager.activeItem(ID2);
      if (!success) {
        AnimUtils.runTween(this.shakeAnimation.tween);
        return;
      }
      this.useItem();
    };
    useItem() {
      const { tileManager, itemManager } = this.scene;
      if (!this.isActive || this.isRunning) return;
      this.isRunning = true;
      this.defuseBomb();
      tileManager.emitInteraction();
      itemManager.updateBombDefuseItemState();
      this.showItemAnimation?.once(Phaser.Tweens.Events.TWEEN_COMPLETE, () => {
        this.isRunning = false;
        itemManager.deactivateItem(ID2);
      });
      MissionUtils_default.addUseBombDefuseMissionProgress(1);
    }
    defuseBomb() {
      const { tileManager } = this.scene;
      const tiles = tileManager.getAliveTiles();
      for (let i = 0; i < tiles.length; i++) {
        const element = tiles[i];
        if (element instanceof BombTile_default && !element.isDefuse()) {
          element.handleBombDefuse();
          return;
        }
      }
    }
    disableItem() {
      super.disableItem();
      this.item.setAlpha(1);
      this.item.setFrame(FRAME20.ITEM_DEFUSE_LOCK);
      this.bg.setFrame(FRAME20.ITEM_BG_LOCK);
      this.itemLock.setVisible(false);
      this.itemLockText.setVisible(false);
      this.amountItem.setVisible(true);
    }
    enableItem() {
      super.enableItem();
      this.item.setAlpha(1);
      this.item.setFrame(FRAME20.DEFUSE_ITEM);
      this.bg.setFrame(FRAME20.ITEM_BG_ITEM);
      this.amountItem.setVisible(true);
      this.itemLock.setVisible(false);
      this.itemLockText.setVisible(false);
    }
  };
  var BombDefuse_default = BombDefuseItem;

  // src/game/gameplay/objects/items/GuideBombDefuse.ts
  var { ID: ID3 } = item_default.GUIDE_BOMB_DEFUSE;
  var GuideBombDefuseItem = class extends BombDefuse_default {
    constructor(scene) {
      super(scene);
      this.setName(ID3);
      this.callback = this.handleUseGuideItem;
    }
    handleUseGuideItem = () => {
      if (this.isRunning) return;
      const { itemManager } = this.scene;
      if (this.isActive) {
        itemManager.deactivateItem(ID3);
        return;
      }
      const success = itemManager.activeItem(ID3);
      if (!success) {
        AnimUtils.runTween(this.shakeAnimation.tween);
        return;
      }
      this.useItem();
    };
    useItem() {
      const { tileManager, itemManager, tutorialManager } = this.scene;
      if (!this.isActive || this.isRunning) return;
      this.isRunning = true;
      const tiles = tileManager.getAliveTiles();
      for (let i = 0; i < tiles.length; i++) {
        const element = tiles[i];
        if (element instanceof BombTile_default && !element.isDefuse()) {
          const { x, y } = element.getWorldPosition();
          const width = element.block.displayWidth;
          const height = element.block.displayHeight;
          this.scene.time.delayedCall(0, () => {
            this.scene.tweens.killTweensOf(tutorialManager.background);
            tutorialManager.background.clearMask(true);
            tutorialManager.createMask(x - width / 2, y - height / 2, width, height, 3);
            this.scene.time.delayedCall(1e3, () => {
              element.handleBombDefuse();
              tileManager.emitInteraction();
              tutorialManager.runHideMaskAnimation();
              this.isRunning = false;
              itemManager.deactivateItem(ID3);
            });
          });
          return;
        }
      }
      tileManager.emitInteraction();
    }
  };
  var GuideBombDefuse_default = GuideBombDefuseItem;

  // src/game/gameplay/objects/items/devTools/ChangeColorItem.ts
  init_phaser_custom_min();
  var {
    Utils: { Function: F6 }
  } = Ludex;
  var { ID: ID4 } = item_default.CHANGE_COLOR;
  var { KEY: KEY27, FRAME: FRAME21 } = sprites_default.GAMEPLAY;
  var { SPECIALS: SPECIALS2 } = tile_default;
  var { BOMB: BOMB2, ROCKET: ROCKET2 } = SPECIALS2;
  var ChangeColorItem = class extends BaseItem_default {
    scene;
    index;
    colors;
    color;
    constructor(scene) {
      super(scene, FRAME21.ROCKET_ITEM, 25, 25);
      this.scene = scene;
      this.index = 0;
      this.colors = new Array(28).fill(null).map((_, index) => `${index + 1}`);
      this.colors.push(BOMB2);
      this.colors.push(ROCKET2);
      this.setAmount(999);
      this.onClick = () => {
        const { itemManager } = this.scene;
        console.info("\u{1F680} > this.isActive", this.isActive);
        console.info("\u{1F680} > this.isDisabled", this.isDisabled);
        if (!this.isActive) {
          itemManager.activeItem(ID4);
        } else {
          itemManager.deactivateItem(ID4);
        }
      };
      this.on(Phaser.Input.Events.GAMEOBJECT_POINTER_WHEEL, this.handleWheel);
    }
    handleWheel = F6.debounce(
      (pointer) => {
        if (!this.isActive) return;
        if (this.isDisabled) return;
        if (pointer.deltaY > 0) {
          this.nextColor();
        } else {
          this.prevColor();
        }
      },
      250,
      true
    );
    nextColor() {
      this.color = this.colors[this.index];
      this.index += 1;
      if (this.index >= this.colors.length) {
        this.index = 0;
      }
      this.changeColor(this.color);
    }
    prevColor() {
      this.color = this.colors[this.index];
      this.index -= 1;
      if (this.index <= 0) {
        this.index = this.colors.length - 1;
      }
      this.changeColor(this.color);
    }
    changeColor(color) {
      this.item.setTexture(KEY27);
      if (color === BOMB2) {
        this.item.setFrame(FRAME21.ICON_BOMB);
      } else if (color === ROCKET2) {
        this.item.setFrame(FRAME21.TILE_ROCKET);
      } else {
        const deckPrefix = this.scene.tileManager.getCurrentDeck();
        this.item.setFrame(deckPrefix + color);
      }
    }
    activeItem = () => {
      this.isActive = true;
      this.setAlpha(1);
    };
    deactivateItem = () => {
      super.deactivateItem();
      this.setAlpha(0.7);
    };
    useItem(tile) {
      if (!this.isActive) return false;
      const { tileManager } = this.scene;
      tileManager.tilesChangeColor(this.color, [tile]);
      return true;
    }
  };
  var ChangeColorItem_default = ChangeColorItem;

  // src/game/gameplay/objects/items/RocketItem.ts
  init_phaser_custom_min();
  var { ID: ID5 } = item_default.ROCKET;
  var { FRAME: FRAME22 } = sprites_default.GAMEPLAY;
  var { RocketItemGuideLevel } = GameSettings_default;
  var RocketItem = class extends BaseItem_default {
    scene;
    isRunning = false;
    usingTimer;
    constructor(scene) {
      super(scene, FRAME22.ROCKET_ITEM, 23, 36);
      this.itemCost = 500;
      this.scene = scene;
      this.setName(ID5);
      this.itemLockText.setText(`Level ${RocketItemGuideLevel}}`);
      this.onClick = this.handleUseItem;
    }
    activeItem() {
      super.activeItem();
      this.amountItem.kill();
    }
    deactivateItem() {
      super.deactivateItem();
      this.amountItem.revive();
      this.isRunning = false;
      this.usingTimer?.remove();
      if (this.isDisabled) this.amountItem.setVisible(false);
    }
    handleUseItem = () => {
      if (this.isRunning) return;
      const { itemManager } = this.scene;
      if (this.isActive) {
        itemManager.deactivateItem(ID5);
        return;
      }
      const success = itemManager.activeItem(ID5);
      if (!success) {
        AnimUtils.runTween(this.shakeAnimation.tween);
        return;
      }
      this.useItem();
    };
    useItem() {
      const { tileManager, uiManager } = this.scene;
      if (!this.isActive || this.isRunning) return;
      const tiles = tileManager.getPairsOfTilesCanCapture(2);
      if (tiles.length !== 4) return;
      this.isRunning = true;
      this.scene.events.emit(tile_default.EVENTS.PAUSE_BOMB_TIMER);
      tileManager.isSelectable = false;
      tileManager.emitInteraction();
      tileManager.removeSuggestPairHint();
      uiManager.disablePause();
      this.scene.time.delayedCall(300, () => {
        this.runEffectAndCapture(tiles);
      });
      MissionUtils_default.addUseRocketMissionProgress(1);
    }
    runEffectAndCapture(tiles) {
      const { tileManager, effectManager, itemManager } = this.scene;
      const maskConfig = [];
      const config = [];
      for (const tile of tiles) {
        const { x: fromX, y: fromY } = tile.getWorldPosition();
        const fromW = tile.block.displayWidth;
        const fromH = tile.block.displayHeight;
        config.push({ x: fromX, y: fromY });
        maskConfig.push({
          x: fromX - fromW / 2,
          y: fromY - fromH / 2,
          width: fromW,
          height: fromH,
          radius: 3
        });
      }
      const rocketItem = itemManager.getItem(ID5);
      rocketItem && maskConfig.push({
        x: rocketItem.x - (rocketItem.displayWidth - 4 * rocketItem.scale) / 2,
        y: rocketItem.y - rocketItem.displayHeight / 2 + 7 * rocketItem.scale,
        width: (rocketItem.width - 4) * rocketItem.scale,
        height: (rocketItem.width - 4) * rocketItem.scale,
        radius: (rocketItem.width - 4) * rocketItem.scale / 2
      });
      itemManager.createMultiMask(maskConfig);
      for (const tile of tiles) {
        tile.setState(tile_default.STATUS.CAPTURING);
        tile.setIsBreakWhenExplosive(true);
      }
      this.usingTimer?.remove();
      this.usingTimer = this.scene.time.addEvent({
        delay: 100,
        repeat: -1,
        callback: () => {
          tileManager.isSelectable = false;
        }
      });
      effectManager.playRocketEffect(
        config,
        () => {
          tileManager.tilesCapturing([tiles[0], tiles[1]]);
        },
        () => {
          tileManager.tilesCapturing([tiles[2], tiles[3]]);
          this.isRunning = false;
          this.usingTimer?.remove();
          itemManager.deactivateItem(ID5);
          itemManager.setIsUseableItem(false);
          this.scene.events.emit(tile_default.EVENTS.RESUME_BOMB_TIMER);
        }
      );
    }
    disableItem() {
      super.disableItem();
      this.item.setAlpha(1);
      this.item.setFrame(FRAME22.ITEM_ROCKET_LOCK);
      this.bg.setFrame(FRAME22.ITEM_BG_LOCK);
      this.amountItem.setVisible(true);
      this.itemLock.setVisible(false);
      this.itemLockText.setVisible(false);
    }
    enableItem() {
      super.enableItem();
      const { levelHandler } = this.scene;
      const { level } = levelHandler.getConfigs();
      this.item.setAlpha(1);
      if (level >= RocketItemGuideLevel) this.setVisible(true);
      this.item.setFrame(FRAME22.ROCKET_ITEM);
      this.bg.setFrame(FRAME22.ITEM_BG_ITEM);
      this.amountItem.setVisible(true);
      this.itemLock.setVisible(false);
      this.itemLockText.setVisible(false);
    }
  };
  var RocketItem_default = RocketItem;

  // src/game/gameplay/objects/items/SuperRocketItem.ts
  init_phaser_custom_min();
  var { ID: ID6 } = item_default.SUPER_ROCKET;
  var { KEY: KEY28, FRAME: FRAME23 } = sprites_default.GAMEPLAY;
  var { SuperRocketGuideLevel, SuperRocketConfig } = GameSettings_default;
  var SuperRocketItem = class extends BaseItem_default {
    scene;
    isRunning = false;
    usingTimer;
    rechargeNotificationContainer$;
    rechargeNotificationBubble$;
    rechargeNotificationText$;
    rechargeNotificationAnimation;
    constructor(scene) {
      super(scene, FRAME23.SUPER_ROCKET_ITEM, 42, 50);
      this.scene = scene;
      this.setName(ID6);
      this.itemLockText.setText("");
      this.onClick = this.handleUseItem;
      this.isFree = true;
      this.createRechargeNotification();
      this.amountItem.kill();
      this.amountText.kill();
    }
    createRechargeNotification() {
      this.rechargeNotificationContainer$ = this.scene.add.container(0, 0);
      this.rechargeNotificationBubble$ = this.scene.add.image(0, 0, KEY28, FRAME23.SUPER_ROCKET_NOTIFICATION);
      this.rechargeNotificationContainer$.add(this.rechargeNotificationBubble$);
      this.rechargeNotificationText$ = FontUtils_default.createText(
        this.scene,
        "Rocket is recharging. Beat X more levels to use it again.",
        17
      ).setAlign("center").setTint(8205077).setWordWrapWidth(180);
      this.rechargeNotificationContainer$.add(this.rechargeNotificationText$).setDepth(depth_default.
      PRIORITY).setVisible(false);
    }
    setRechargeNotificationLayout(type) {
      const worldPosition = this.getWorldPosition();
      this.rechargeNotificationContainer$.setScale(0.9);
      if (type === "portrait") {
        this.rechargeNotificationBubble$.flipY = false;
        this.rechargeNotificationContainer$.setPosition(worldPosition.x - 45, worldPosition.y - 80);
        Phaser.Display.Align.In.Center(this.rechargeNotificationText$, this.rechargeNotificationBubble$,
        2, -12);
      } else {
        this.rechargeNotificationBubble$.flipY = true;
        this.rechargeNotificationContainer$.setPosition(worldPosition.x - 45, worldPosition.y + 65);
        Phaser.Display.Align.In.Center(this.rechargeNotificationText$, this.rechargeNotificationBubble$,
        2, 12);
      }
    }
    setAmount(value) {
      this.amount = value;
    }
    handleUseItem = () => {
      const isNotificationShown = this.rechargeNotificationContainer$.visible;
      if (this.isRunning || isNotificationShown) return;
      const { itemManager } = this.scene;
      if (this.isActive) {
        itemManager.deactivateItem(ID6);
        return;
      }
      const success = itemManager.activeItem(ID6);
      if (!success) {
        AnimUtils.runTween(this.shakeAnimation.tween);
        return;
      }
      this.useItem();
    };
    useItem() {
      const { tileManager, itemManager, uiManager } = this.scene;
      const { DestroyPairCount: DestroyPairCount3 } = SuperRocketConfig;
      if (!this.isActive || this.isRunning) return;
      if (this.amount !== 1) {
        this.runRechargeNotificationAnimation();
        return;
      }
      uiManager.disablePause();
      itemManager.updateSuperRocketCountdown();
      this.scene.isSuperRocketUsed = true;
      const tiles = tileManager.getPairsOfTilesCanCapture(DestroyPairCount3);
      this.isRunning = true;
      tileManager.isSelectable = false;
      this.scene.events.emit(tile_default.EVENTS.PAUSE_BOMB_TIMER);
      tileManager.emitInteraction();
      tileManager.removeSuggestPairHint();
      this.scene.time.delayedCall(300, () => {
        this.runEffectAndCapture(tiles);
      });
      MissionUtils_default.addUseRocketMissionProgress(1);
    }
    runEffectAndCapture(tiles) {
      const { tileManager, effectManager, itemManager } = this.scene;
      const maskConfig = [];
      const config = [];
      for (const tile of tiles) {
        const { x: fromX, y: fromY } = tile.getWorldPosition();
        const fromW = tile.block.displayWidth;
        const fromH = tile.block.displayHeight;
        config.push({ x: fromX, y: fromY });
        maskConfig.push({
          x: fromX - fromW / 2,
          y: fromY - fromH / 2,
          width: fromW,
          height: fromH,
          radius: 3
        });
      }
      const rocketItem = itemManager.getItem(ID6);
      rocketItem && maskConfig.push({
        x: rocketItem.x - (rocketItem.displayWidth - 4 * rocketItem.scale) / 2,
        y: rocketItem.y - rocketItem.displayHeight / 2 + 7 * rocketItem.scale,
        width: (rocketItem.width - 4) * rocketItem.scale,
        height: (rocketItem.width - 4) * rocketItem.scale,
        radius: (rocketItem.width - 4) * rocketItem.scale / 2
      });
      itemManager.createMultiMask(maskConfig);
      for (const tile of tiles) {
        tile.setState(tile_default.STATUS.CAPTURING);
        tile.setIsBreakWhenExplosive(true);
      }
      this.usingTimer?.remove();
      this.usingTimer = this.scene.time.addEvent({
        delay: 100,
        repeat: -1,
        callback: () => {
          tileManager.isSelectable = false;
        }
      });
      effectManager.playSuperRocketEffect(tiles, config);
    }
    runRechargeNotificationAnimation() {
      if (this.rechargeNotificationContainer$.visible) return;
      if (this.amount - 1 === 1) {
        this.rechargeNotificationText$.setText("Rocket is recharging. Beat this level to use it agai\
n.");
      } else {
        this.rechargeNotificationText$.setText(
          `Rocket is recharging. Beat ${this.amount - 1} more levels to use it again.`
        );
      }
      this.rechargeNotificationContainer$.setVisible(true);
      this.rechargeNotificationAnimation = this.scene.time.delayedCall(2e3, () => {
        this.rechargeNotificationContainer$.setVisible(false);
      });
      this.isRunning = false;
      this.usingTimer?.remove();
      const { itemManager } = this.scene;
      itemManager.deactivateItem(ID6);
    }
    stopRechargeNotificationAnimation() {
      this.rechargeNotificationContainer$.setVisible(false);
      this.rechargeNotificationAnimation?.remove();
    }
    disableItem() {
      super.disableItem();
      this.item.setAlpha(1);
      this.stopRechargeNotificationAnimation();
      this.item.setFrame(FRAME23.ITEM_SUPER_ROCKET_LOCK);
      this.bg.setFrame(FRAME23.ITEM_BG_LOCK);
    }
    enableItem() {
      super.enableItem();
      const { levelHandler } = this.scene;
      const { level } = levelHandler.getConfigs();
      this.item.setAlpha(1);
      this.item.setFrame(FRAME23.SUPER_ROCKET_ITEM);
      this.bg.setFrame(FRAME23.ITEM_BG_ITEM);
      if (level >= SuperRocketGuideLevel) this.setVisible(true);
      this.setCountdownUI();
    }
    setRunningStatus(value) {
      this.isRunning = value;
    }
    clearTimerEvent() {
      this.usingTimer?.remove();
    }
    setCountdownUI() {
      if (!this.visible) return;
      if (this.amount === 1 && !this.isDisabled) {
        this.item.setFrame(FRAME23.SUPER_ROCKET_ITEM);
        this.bg.setFrame(FRAME23.ITEM_BG_ITEM);
      } else {
        this.item.setFrame(FRAME23.ITEM_SUPER_ROCKET_LOCK);
        this.bg.setFrame(FRAME23.ITEM_BG_LOCK);
      }
    }
    deactivateItem() {
      super.deactivateItem();
      this.isRunning = false;
      this.usingTimer?.remove();
      this.setCountdownUI();
    }
  };
  var SuperRocketItem_default = SuperRocketItem;

  // src/game/gameplay/managers/ItemManager.ts
  var { event: event17, player: player10, analytics: analytics3 } = codex;
  var {
    Utils: { Valid: V12 },
    Plugins: {
      Analytics: { Events: AnalyticsEvents3 }
    }
  } = Ludex;
  var { STATUS: STATUS4 } = manager_default2;
  var { BOMB_DEFUSE: BOMB_DEFUSE2, ROCKET: ROCKET3, AUTO_MATCH, SHUFFLE, HINT } = item_default;
  var { KEY: KEY29, FRAME: FRAME24 } = sprites_default.GAMEPLAY;
  var { SuperRocketGuideLevel: SuperRocketGuideLevel2, SuperRocketConfig: SuperRocketConfig2 } = GameSettings_default;
  var { GameRechargeCount, DestroyPairCount } = SuperRocketConfig2;
  var ItemManager = class extends BaseManager_default {
    scene;
    isUseableItem$ = false;
    items$ = {};
    itemActive = "";
    currentHideableObjects$;
    background$;
    maskGraphics$;
    customAmountItems$ = [item_default.INVITE.ID, item_default.GUIDE_BOMB_DEFUSE.ID];
    constructor(scene) {
      super(scene);
      this.scene = scene;
      this.createBackground$();
      this.createItems$();
      this.currentHideableObjects$ = [];
      event17.on(game_default.TILE_SHOWED_UP, this.handleTileShowedUp$);
      this.scene.events.on(tile_default.EVENTS.CAPTURING, this.handleItemState$);
    }
    init() {
      for (const name in this.items$) {
        this.enableItem(name);
        this.deactivateItem(name);
        this.updateItemAmount(name);
      }
      this.setState(STATUS4.READY);
    }
    start() {
      if (this.isRunning()) return;
      this.updateItemState$();
      this.setIsUseableItem(false);
      this.setState(STATUS4.RUNNING);
    }
    increaseItem(item, amount) {
      const items = player10.getGameData()?.items;
      if (!V12.isObject(items)) return;
      let id2 = "";
      switch (item) {
        case "ItemBombDefuse":
          id2 = BOMB_DEFUSE2.ID;
          break;
        case "ItemHint":
          id2 = item_default.HINT.ID;
          break;
        case "ItemShuffle":
          id2 = item_default.SHUFFLE.ID;
          break;
        case "ItemRocket":
          id2 = ROCKET3.ID;
          break;
        default:
          break;
      }
      const currentAmount = items[id2];
      if (!V12.isNumber(currentAmount)) return;
      const nextAmount = this.items$[id2].amount + amount;
      player10.setGameData({ items: { [this.items$[id2].name]: nextAmount } });
    }
    stop() {
      if (!this.isRunning()) return;
      this.setIsUseableItem(false);
      this.stopSuperRocketNotification$();
      for (const name in this.items$) {
        this.deactivateItem(name);
      }
      this.setState(STATUS4.STOPPED);
    }
    handleTileShowedUp$ = () => {
      this.setIsUseableItem(true);
    };
    handleItemState$ = () => {
      this.setIsUseableItem(false);
      this.updateHintItemState$();
      this.updateRocketItemState$();
      this.updateShuffleItemState$();
      this.updateBombDefuseItemState();
      this.updateSuperRocketItemState$();
    };
    setIsUseableItem(isUseable) {
      if (this.isUseableItem$ === isUseable) return;
      this.isUseableItem$ = isUseable;
    }
    getIsUseableItem() {
      return this.isUseableItem$;
    }
    updateItemAmount(id2) {
      const item = this.items$[id2];
      if (!item) return;
      const items = player10.getGameData()?.items;
      if (!V12.isObject(items)) return;
      const amount = items[id2];
      if (!V12.isNumber(amount)) return;
      if (item instanceof SuperRocketItem_default) {
        const { level } = this.scene.levelHandler.getConfigs();
        if (level === SuperRocketGuideLevel2) {
          item.setAmount(1);
          item.setCountdownUI();
          return;
        }
        item.setAmount(amount + 1);
        item.setCountdownUI();
        return;
      }
      item.setAmount(amount);
    }
    addItemAmount(id2, amount) {
      const item = this.items$[id2];
      if (!item) return;
      if (!V12.isNumber(amount)) return;
      const nextAmount = item.amount + amount;
      item.setAmount(nextAmount);
      player10.setGameData({ items: { [item.name]: nextAmount } });
    }
    updateSuperRocketCountdown() {
      const item = this.items$[item_default.SUPER_ROCKET.ID] ?? {};
      const { amount } = item;
      if (amount === 1) {
        item.setAmount(GameRechargeCount + 1);
      }
      player10.setGameData({ items: { [item.name]: item.amount - 1 } });
    }
    reduceSuperRocketCountdown() {
      const item = this.items$[item_default.SUPER_ROCKET.ID] ?? {};
      const { amount } = item;
      if (amount > 1) {
        item.setAmount(amount - 1);
      }
      player10.setGameData({ items: { [item.name]: item.amount - 1 } });
    }
    resetSuperRocketUsage() {
      const item = this.items$[item_default.SUPER_ROCKET.ID] ?? {};
      item.setAmount(1);
      player10.setGameData({ items: { [item.name]: 0 } });
    }
    updateItemState$() {
      const { levelHandler } = this.scene;
      if (!levelHandler.isLevelHaveBomb()) {
        this.disableItem(item_default.BOMB_DEFUSE.ID);
      }
    }
    activeItem(id2) {
      if (!this.isRunning()) return false;
      const { tutorialManager, tileManager } = this.scene;
      const { tutorialId } = tutorialManager;
      const isInTutorial = tutorialId === id2;
      const isSpecialItem = id2 === AUTO_MATCH.ID;
      if (!this.isUseableItem$ && !isInTutorial && !isSpecialItem) return false;
      if (!this.items$[id2]) return false;
      if (this.itemActive && this.itemActive !== id2) return false;
      this.stopSuperRocketNotification$();
      if (id2 === BOMB_DEFUSE2.ID && !tileManager.isHavingBomb()) {
        return false;
      }
      if (!this.items$[id2].getIsFree() && this.items$[id2].amount < 1 && id2 !== item_default.INVITE.
      ID) {
        const buySuccess = this.buyItem$(id2);
        if (!buySuccess) {
          ScreenUtils_default.openScreen(ScreenKeys_default.REWARD_ITEM_SCREEN, {
            itemId: id2,
            rewardCount: 1
          });
          return false;
        }
        this.items$[id2].setAmount(1);
      }
      for (const name in this.items$) {
        if (name === AUTO_MATCH.ID) continue;
        this.deactivateItem(name, false);
      }
      if (!isSpecialItem) {
        this.itemActive = id2;
      }
      this.items$[id2].activeItem();
      this.setIsUseableItem(false);
      if (!this.items$[id2].getIsFree() && !this.customAmountItems$.includes(id2)) {
        const nextAmount = this.items$[id2].amount - 1;
        this.items$[id2].setAmount(nextAmount);
        player10.setGameData({ items: { [this.items$[id2].name]: nextAmount } });
      }
      analytics3.event(AnalyticsEvents3.USE_ITEM, {
        item_name: id2 === item_default.GUIDE_BOMB_DEFUSE.ID ? item_default.BOMB_DEFUSE.ID : id2
      });
      return true;
    }
    enableItem(id2) {
      if (!this.items$[id2]) return;
      this.items$[id2].enableItem();
    }
    disableItem(id2) {
      if (!this.items$[id2]) return;
      this.items$[id2].disableItem();
    }
    visibleItem(id2) {
      if (!this.items$[id2]) return;
      this.items$[id2].setVisible(true);
    }
    invisibleItem(id2) {
      if (!this.items$[id2]) return;
      this.items$[id2].setVisible(false);
    }
    setFreeItem(id2) {
      if (!this.items$[id2]) return;
      this.items$[id2].setFreeMode(true);
    }
    setPaidItem(id2, keepVisibleState = false) {
      if (!this.items$[id2]) return;
      this.items$[id2].setFreeMode(false, keepVisibleState);
    }
    setDepthItemOnTop(id2) {
      if (!this.items$[id2]) return;
      this.items$[id2].setDepth(depth_default.ON_TOP);
    }
    setDepthItemNormal(id2) {
      if (!this.items$[id2]) return;
      this.items$[id2].setDepth(depth_default.ITEM);
    }
    deactivateItem(id2, hideMask = true) {
      if (!this.items$[id2]) return;
      this.itemActive = "";
      this.items$[id2].deactivateItem();
      hideMask && this.hideMask$();
      this.setIsUseableItem(true);
    }
    getActiveItem$() {
      if (!this.isRunning()) return;
      if (!this.items$[this.itemActive]) return;
      return this.items$[this.itemActive];
    }
    createMultiMask(paramList) {
      this.maskGraphics$?.destroy();
      this.maskGraphics$ = this.scene.make.graphics({
        fillStyle: { color: 16711680, alpha: 1 }
      });
      this.maskGraphics$.setName("MaskGraphics");
      for (const param of paramList) {
        this.maskGraphics$.fillRoundedRect(param.x, param.y, param.width, param.height, param.radius);
      }
      this.background$.revive();
      this.background$.clearMask(true);
      this.background$.setMask(this.maskGraphics$.createGeometryMask());
      this.background$.mask.invertAlpha = true;
      this.showMask$();
    }
    showMask$() {
      if ([item_default.ROCKET.ID, item_default.SUPER_ROCKET.ID].indexOf(this.itemActive) === -1) return;
      this.scene.tweens.killTweensOf(this.currentHideableObjects$);
      this.scene.tweens.killTweensOf([
        // this.itemTitle,
        // this.itemDescription,
        this.background$
      ]);
      const { layoutManager, uiManager } = this.scene;
      const { groups } = layoutManager;
      this.currentHideableObjects$ = groups.gameUI.getMatching("visible", true);
      uiManager.disablePause();
      const item = this.items$[this.itemActive];
      if (item instanceof RocketItem_default || item instanceof SuperRocketItem_default) {
        this.currentHideableObjects$ = this.currentHideableObjects$.filter(
          (object) => object.name !== this.itemActive
        );
      }
      this.scene.add.tween({
        targets: this.currentHideableObjects$,
        duration: 400,
        ease: Phaser.Math.Easing.Quadratic.Out,
        props: {
          alpha: 0
        }
      });
      this.background$.setAlpha(0);
      this.scene.add.tween({
        targets: [this.background$],
        duration: 400,
        ease: Phaser.Math.Easing.Quadratic.Out,
        props: {
          alpha: 0.6
        }
      });
    }
    hideMask$() {
      if (!this.currentHideableObjects$.length) return;
      const targets = [this.scene.background, ...this.currentHideableObjects$];
      this.scene.tweens.killTweensOf(targets);
      this.scene.add.tween({
        targets: this.currentHideableObjects$,
        duration: 400,
        ease: Phaser.Math.Easing.Quadratic.In,
        props: {
          alpha: 1
        },
        onComplete: () => {
          const { uiManager } = this.scene;
          uiManager.showUIByMatchMode();
          this.currentHideableObjects$ = [];
          this.scene.uiManager.enablePause();
        }
      });
      this.scene.add.tween({
        targets: [this.background$],
        duration: 400,
        ease: Phaser.Math.Easing.Quadratic.Out,
        props: {
          alpha: 0
        },
        onComplete: () => {
          this.background$.kill();
        }
      });
    }
    applyItem(tile) {
      if (!this.isRunning()) return false;
      const item = this.getActiveItem$();
      if (!item) return false;
      let success = false;
      switch (this.itemActive) {
        // ! Debug items
        case item_default.CHANGE_COLOR.ID:
          {
            const item2 = this.items$[item_default.CHANGE_COLOR.ID];
            if (item2 instanceof ChangeColorItem_default) {
              success = item2.useItem(tile);
            }
          }
          break;
        default:
          return false;
      }
      return success;
    }
    getItems() {
      const result = [];
      const items = Object.values(this.items$);
      for (const item of items) {
        if (item instanceof GuideBombDefuse_default) continue;
        result.push(item);
      }
      return result;
    }
    getItem(id2) {
      return this.items$[id2] || null;
    }
    // Logics
    updateBombDefuseItemState() {
      const { tileManager, itemManager } = this.scene;
      const isHaveBomb = tileManager.isHavingBomb();
      if (!isHaveBomb) {
        itemManager.disableItem(BOMB_DEFUSE2.ID);
      }
    }
    updateHintItemState$() {
      const { tileManager, itemManager } = this.scene;
      const aliveTiles = tileManager.getAliveTiles();
      if (aliveTiles.length <= 0) {
        itemManager.disableItem(HINT.ID);
      }
    }
    updateRocketItemState$() {
      const { tileManager, itemManager } = this.scene;
      const aliveTiles = tileManager.getAliveTiles();
      if (aliveTiles.length < 4) {
        itemManager.disableItem(ROCKET3.ID);
      }
    }
    updateShuffleItemState$() {
      const { tileManager, itemManager } = this.scene;
      const aliveTiles = tileManager.getAliveTiles();
      if (aliveTiles.length < 4) {
        itemManager.disableItem(SHUFFLE.ID);
      }
    }
    updateSuperRocketItemState$() {
      const { tileManager, itemManager } = this.scene;
      const superRocketItem = this.items$[item_default.SUPER_ROCKET.ID];
      if (!superRocketItem || !(superRocketItem instanceof SuperRocketItem_default)) return;
      const { amount } = superRocketItem;
      if (amount !== 1) return;
      const aliveTiles = tileManager.getAliveTiles();
      if (aliveTiles.length < DestroyPairCount * 2) {
        itemManager.disableItem(item_default.SUPER_ROCKET.ID);
        return;
      }
      superRocketItem.setCountdownUI();
    }
    stopSuperRocketNotification$() {
      const superRocketItem = this.items$[item_default.SUPER_ROCKET.ID];
      if (!superRocketItem || !(superRocketItem instanceof SuperRocketItem_default)) return;
      superRocketItem.stopRechargeNotificationAnimation();
    }
    createBackground$() {
      this.background$ = this.scene.make.image({
        key: KEY29,
        frame: FRAME24.BLANK
      });
      this.background$.setTint(0);
      this.background$.setDepth(depth_default.TILE + 1);
      const { displayWidth, displayHeight } = this.scene.gameZone;
      const width = displayWidth + 100;
      const height = displayHeight + 100;
      this.background$.setDisplaySize(width, height);
      Phaser.Display.Align.In.Center(this.background$, this.scene.gameZone);
      this.background$.kill();
    }
    createItems$() {
      this.createHintItem$();
      this.createRocketItem$();
      this.createInviteItem$();
      this.createDefuseItem$();
      this.createGuideDefuseItem$();
      this.createShuffleItem$();
      this.createSuperRocketItem$();
      this.createNewGameItem$();
      this.createWinGameItem$();
      this.createTimeUpItem$();
      this.createAutoMatchItem$();
      this.createResetDataItem$();
      this.createBackLevelItem$();
      this.createNextLevelItem$();
      this.createOpenLuckyWheelItem$();
      this.createChangeColorItem$();
      this.createBombExplosiveItem$();
    }
    createHintItem$() {
      const { objects } = this.scene.layoutManager;
      this.items$[item_default.HINT.ID] = objects.hintItem;
    }
    createShuffleItem$() {
      const { objects } = this.scene.layoutManager;
      this.items$[item_default.SHUFFLE.ID] = objects.shuffleItem;
    }
    createDefuseItem$() {
      const { objects } = this.scene.layoutManager;
      this.items$[item_default.BOMB_DEFUSE.ID] = objects.defuseItem;
    }
    createGuideDefuseItem$() {
      const { objects } = this.scene.layoutManager;
      this.items$[item_default.GUIDE_BOMB_DEFUSE.ID] = objects.guideDefuseItem;
    }
    createRocketItem$() {
      const { objects } = this.scene.layoutManager;
      this.items$[item_default.ROCKET.ID] = objects.rocketItem;
    }
    createInviteItem$() {
      const { objects } = this.scene.layoutManager;
      this.items$[item_default.INVITE.ID] = objects.inviteItem;
    }
    createSuperRocketItem$() {
      const { objects } = this.scene.layoutManager;
      this.items$[item_default.SUPER_ROCKET.ID] = objects.superRocketItem;
    }
    // ! Debug items
    createWinGameItem$() {
      const { objects } = this.scene.layoutManager;
      if (!objects.winGame) return;
      this.items$[item_default.WIN_GAME.ID] = objects.winGame;
    }
    createNewGameItem$() {
      const { objects } = this.scene.layoutManager;
      if (!objects.newGame) return;
      this.items$[item_default.NEW_GAME.ID] = objects.newGame;
    }
    createChangeColorItem$() {
      const { objects } = this.scene.layoutManager;
      if (!objects.changeColor) return;
      this.items$[item_default.CHANGE_COLOR.ID] = objects.changeColor;
    }
    createResetDataItem$() {
      const { objects } = this.scene.layoutManager;
      if (!objects.resetData) return;
      this.items$[item_default.RESET_DATA.ID] = objects.resetData;
    }
    createBackLevelItem$() {
      const { objects } = this.scene.layoutManager;
      if (!objects.backLevel) return;
      this.items$[item_default.BACK_LEVEL.ID] = objects.backLevel;
    }
    createNextLevelItem$() {
      const { objects } = this.scene.layoutManager;
      if (!objects.nextLevel) return;
      this.items$[item_default.NEXT_LEVEL.ID] = objects.nextLevel;
    }
    createOpenLuckyWheelItem$() {
      const { objects } = this.scene.layoutManager;
      if (!objects.openLuckyWheel) return;
      this.items$[item_default.OPEN_LUCKY_WHEEL.ID] = objects.openLuckyWheel;
    }
    createBombExplosiveItem$() {
      const { objects } = this.scene.layoutManager;
      if (!objects.bombExplosive) return;
      this.items$[item_default.BOMB_EXPLOSIVE.ID] = objects.bombExplosive;
    }
    createTimeUpItem$() {
      const { objects } = this.scene.layoutManager;
      if (!objects.timeUp) return;
      this.items$[item_default.TIME_UP.ID] = objects.timeUp;
    }
    createAutoMatchItem$() {
      const { objects } = this.scene.layoutManager;
      if (!objects.autoMatch) return;
      this.items$[item_default.AUTO_MATCH.ID] = objects.autoMatch;
    }
    buyItem$(id2) {
      const item = this.items$[id2];
      if (!item) return false;
      const { coins = 0 } = player10.getGameData() ?? {};
      if (!V12.isNumber(coins)) return false;
      const { itemCost } = item;
      if (coins < itemCost) return false;
      CoinUtils_default.removeCoin(itemCost);
      const x = item.x;
      const y = item.y;
      this.scene.effectManager.playBuyItemAnimation(x, y);
      return true;
    }
  };
  var ItemManager_default = ItemManager;

  // src/game/gameplay/managers/LevelHandler.ts
  init_phaser_custom_min();

  // src/game/gameplay/constants/configs.ts
  init_phaser_custom_min();
  var GameConfigs = {
    StartLevel: 1,
    Items: {
      Free: 0
    },
    DailyTasks: {
      Duration: 86400
      // 24 hours
    },
    LevelDifficultRate: {
      FromUnder30: 1,
      FromUnder35: 1,
      FromUnder45: 1,
      FromUnder200: 1
    }
  };
  var configs_default = GameConfigs;

  // src/game/gameplay/managers/LevelHandler.ts
  var {
    Utils: { Json: J3 }
  } = Ludex;
  var { StartLevel } = configs_default;
  var LevelHandler = class {
    scene;
    level = 0;
    targetScore = 0;
    gameLevel$;
    levelConfig$;
    constructor(scene) {
      this.scene = scene;
      this.gameLevel$ = gameLevels_default;
    }
    init(level) {
      this.level = level ?? StartLevel;
      this.setConfig(this.level);
    }
    getConfigs() {
      return this.levelConfig$;
    }
    isLevelHaveBomb() {
      if (this.levelConfig$.specials && this.levelConfig$.specials.bomb !== void 0 && this.levelConfig$.
      specials.bomb > 0)
        return true;
      if (this.levelConfig$.customFen?.code.includes("b")) return true;
      return false;
    }
    getConfigByLevel(level) {
      const length = gameLevels_default.length - 1;
      const isAutoLevel = level > length;
      if (isAutoLevel) {
        return this.createNewRandomLevel$(level);
      }
      return this.gameLevel$[level];
    }
    up() {
      const nextLevel = this.canLevelUp$(this.level);
      this.level = nextLevel;
      this.setConfig(nextLevel);
    }
    canLevelUp$(level) {
      const nextLevel = level + 1;
      return nextLevel;
    }
    setConfig(level) {
      const length = gameLevels_default.length - 1;
      const isAutoLevel = level > length;
      const correctLevel = isAutoLevel ? length : level;
      if (isAutoLevel) {
        this.levelConfig$ = this.createNewRandomLevel$(level);
      } else {
        this.levelConfig$ = J3.clone(this.gameLevel$[correctLevel]);
      }
      let preRows = this.levelConfig$.rows;
      let preCols = this.levelConfig$.columns;
      if (!this.levelConfig$) return;
      this.removeButterflyThemeAfterLevel30();
      if (this.levelConfig$.customFen) {
        this.levelConfig$.rows = this.levelConfig$.customFen.rows;
        preRows = this.levelConfig$.rows;
        this.levelConfig$.columns = this.levelConfig$.customFen.columns;
        preCols = this.levelConfig$.columns;
        this.levelConfig$.customFen.code = this.levelConfig$.customFen.portraitCode;
      }
      if (WorldUtils_default.isLandscape()) {
        this.levelConfig$.rows = preCols;
        this.levelConfig$.columns = preRows;
        if (this.levelConfig$.customFen) {
          this.levelConfig$.customFen.code = this.levelConfig$.customFen?.desktopCode;
        }
      }
      const { rows, columns } = this.levelConfig$;
      const scorePerTile = 5;
      const totalTiles = rows * columns;
      const targetScore = scorePerTile * totalTiles;
      this.targetScore = isAutoLevel ? targetScore + 400 : targetScore;
    }
    removeButterflyThemeAfterLevel30() {
      const { theme, level } = this.levelConfig$;
      if (level < 30) return;
      if (theme.includes("butterfly")) {
        this.levelConfig$.theme = this.levelConfig$.theme.filter((t) => t !== "butterfly");
      }
    }
    // LEVEL 1: 5 X 8, 20, 1R, 1B
    // LEVEL 2: 6 X 10, 12-24, 1R, 1B
    // LEVEL 3: 7 X 10, 12-24, 1-3R, 2B
    // LEVEL 4: 7 X 12, 12-24, 1R, 1B
    // LEVEL 5: 7 X 12, 24-28, 1-2R, 2B
    createNewRandomLevel$(level) {
      const length = gameLevels_default.length - 1;
      const levelFromSequence = (level - length) % 5;
      let rows = 8;
      let columns = 5;
      let mode = "normal";
      let time = 100;
      let bomb = 1;
      let rocket = 1;
      let color = 20;
      const extraTiles = Phaser.Math.RND.between(2, 4);
      switch (levelFromSequence) {
        case 1:
          rows = 10;
          columns = 6;
          mode = "fly-up-push-right";
          time = 130;
          color = Phaser.Math.RND.between(12, 24);
          break;
        case 2:
          rows = 10;
          columns = 7;
          mode = "fly-up-push-left";
          time = 160;
          rocket = Phaser.Math.RND.between(1, 3);
          bomb = 2;
          color = Phaser.Math.RND.between(12, 24);
          break;
        case 3:
          rows = 12;
          columns = 7;
          mode = "fall-down-push-left";
          time = 180;
          color = Phaser.Math.RND.between(12, 24);
          break;
        case 4:
          rows = 12;
          columns = 7;
          mode = "fall-down-push-right";
          time = 200;
          rocket = Phaser.Math.RND.between(1, 2);
          bomb = 2;
          color = Phaser.Math.RND.between(24, 28);
          break;
      }
      return {
        level,
        mode,
        time,
        colors: color,
        specials: {
          bomb,
          rocket
        },
        rules: {
          maxSpaceOfPair: 8,
          addRandomTilesPerMove: extraTiles
        },
        columns,
        rows,
        theme: [theme_default.BIRD, theme_default.CAKE, theme_default.FRUIT, theme_default.CANDY]
      };
    }
  };
  var LevelHandler_default = LevelHandler;

  // src/game/gameplay/managers/ModeManager.ts
  init_phaser_custom_min();
  var ModeManager = class extends BaseManager_default {
    scene;
    delayModeTimer$;
    checkApplyModeTimer$;
    constructor(scene) {
      super(scene);
      this.scene = scene;
      this.scene.events.on(tile_default.EVENTS.NEXT_TURN, this.updateNextTurnState$);
    }
    processGravityMode = () => {
      const { modeManager, tileManager, animationManager } = this.scene;
      this.delayModeTimer$?.remove();
      this.checkApplyModeTimer$?.remove();
      animationManager.isMoveTilesCompleted = false;
      this.delayModeTimer$ = this.scene.time.addEvent({
        delay: 300,
        callback: () => {
          this.checkApplyModeTimer$?.remove();
          const remainingTiles = tileManager.getAliveTiles().length;
          if (remainingTiles <= 14) {
            this.processAfterGravityMode$();
            return;
          }
          modeManager.applyMode();
          this.checkApplyModeTimer$ = this.scene.time.addEvent({
            delay: 100,
            repeat: 20,
            callback: () => {
              if (!animationManager.isMoveTilesCompleted) return;
              this.checkApplyModeTimer$.remove();
              this.processAfterGravityMode$();
            }
          });
        }
      });
    };
    processAfterGravityMode$() {
      const { tileManager, boardManager } = this.scene;
      if (!tileManager.isCanMove()) {
        tileManager.processOutOfMove();
        return;
      }
      const success = tileManager.handleExtraSpawn();
      if (success) {
        this.processGravityMode();
        return;
      }
      boardManager.processNoAvailableMatches();
    }
    updateNextTurnState$ = () => {
      const { animationManager, itemManager, tileManager } = this.scene;
      tileManager.isSelectable = true;
      itemManager.setIsUseableItem(true);
      animationManager.isMoveTilesCompleted = true;
    };
    applyMode = () => {
      const { animationManager, levelHandler } = this.scene;
      const { mode } = levelHandler.getConfigs();
      const { moveDuration } = animationManager;
      const delay = moveDuration + 10;
      switch (mode.toString()) {
        case modes_default.NORMAL:
          animationManager.isMoveTilesCompleted = true;
          break;
        case modes_default.FALL_DOWN:
          this.tilesFallDown$(0);
          break;
        case modes_default.FLY_UP:
          this.tilesFlyUp$(0);
          break;
        case modes_default.PUSH_LEFT:
          this.tilesPushLeft$(0);
          break;
        case modes_default.PUSH_RIGHT:
          this.tilesPushRight$(0);
          break;
        case modes_default.FALL_DOWN_PUSH_LEFT:
          this.tilesFallDown$(0);
          this.tilesPushLeft$(delay);
          break;
        case modes_default.FLY_UP_PUSH_RIGHT:
          this.tilesFlyUp$(0);
          this.tilesPushRight$(delay);
          break;
        case modes_default.FALL_DOWN_PUSH_RIGHT:
          this.tilesFallDown$(0);
          this.tilesPushRight$(delay);
          break;
        case modes_default.FLY_UP_PUSH_LEFT:
          this.tilesFlyUp$(0);
          this.tilesPushLeft$(delay);
          break;
        case modes_default.PUT_COLUMNS_MIDDLE:
          this.tilesPutColumnsMiddle$(0);
          break;
        case modes_default.PUT_ROWS_MIDDLE:
          this.tilesPutRowsMiddle$(0);
          break;
        case modes_default.FALL_DOWN_PUT_COLUMNS_MIDDLE:
          this.tilesFallDown$(0);
          this.tilesPutColumnsMiddle$(delay);
          break;
        case modes_default.FLY_UP_PUT_COLUMNS_MIDDLE:
          this.tilesFlyUp$(0);
          this.tilesPutColumnsMiddle$(delay);
          break;
        default:
          animationManager.isMoveTilesCompleted = true;
          break;
      }
    };
    getTiles$() {
      const { boardManager } = this.scene;
      const { boardMap } = boardManager;
      const tiles = [];
      for (const row in boardMap) {
        for (const column in boardMap[row]) {
          const tile = boardMap[row][column];
          tiles.push(tile);
        }
      }
      return tiles;
    }
    // Modes
    tilesFlyUp$(delay = 0) {
      const { boardManager, animationManager } = this.scene;
      const tiles = this.getTiles$();
      let tilesWillMoveCount = 0;
      for (const tile of tiles) {
        const { row, column } = tile;
        if (tile.isCaptured()) continue;
        if (tile.isCapturing()) continue;
        const emptySpaces = this.getEmptySpacesAbove$(row, column);
        if (emptySpaces < 1) continue;
        tilesWillMoveCount++;
        animationManager.moveRows(
          {
            tile,
            fromRow: row,
            toRow: row - emptySpaces
          },
          delay
        );
        boardManager.tileSwap({
          fromRow: row,
          toRow: row - emptySpaces,
          fromColumn: column,
          toColumn: column
        });
      }
      if (tilesWillMoveCount === 0) {
        animationManager.isMoveTilesCompleted = true;
      }
    }
    tilesFallDown$(delay = 0) {
      const { boardManager, animationManager } = this.scene;
      const tiles = this.getTiles$();
      tiles.reverse();
      let tilesWillMoveCount = 0;
      for (const tile of tiles) {
        const { row, column } = tile;
        if (tile.isCaptured()) continue;
        if (tile.isCapturing()) continue;
        const emptySpaces = this.getEmptySpacesBlow$(row, column);
        if (emptySpaces < 1) continue;
        tilesWillMoveCount++;
        animationManager.moveRows(
          {
            tile,
            fromRow: row,
            toRow: row + emptySpaces
          },
          delay
        );
        boardManager.tileSwap({
          fromRow: row,
          toRow: row + emptySpaces,
          fromColumn: column,
          toColumn: column
        });
      }
      if (tilesWillMoveCount === 0) {
        animationManager.isMoveTilesCompleted = true;
      }
    }
    tilesPushLeft$(delay = 0) {
      const { boardManager, animationManager } = this.scene;
      const tiles = this.getTiles$();
      let tilesWillMoveCount = 0;
      for (const tile of tiles) {
        const { row, column } = tile;
        if (tile.isCaptured()) continue;
        if (tile.isCapturing()) continue;
        const emptySpaces = this.getEmptySpacesLeft$(row, column);
        if (emptySpaces < 1) continue;
        tilesWillMoveCount++;
        animationManager.moveColumns(
          {
            tile,
            fromColumn: column,
            toColumn: column - emptySpaces
          },
          delay
        );
        boardManager.tileSwap({
          fromRow: row,
          toRow: row,
          fromColumn: column,
          toColumn: column - emptySpaces
        });
      }
      if (tilesWillMoveCount === 0) {
        animationManager.isMoveTilesCompleted = true;
      }
    }
    tilesPushRight$(delay = 0) {
      const { boardManager, animationManager } = this.scene;
      const tiles = this.getTiles$();
      tiles.reverse();
      let tilesWillMoveCount = 0;
      for (const tile of tiles) {
        const { row, column } = tile;
        if (tile.isCaptured()) continue;
        if (tile.isCapturing()) continue;
        const emptySpaces = this.getEmptySpacesRight$(row, column);
        if (emptySpaces < 1) continue;
        tilesWillMoveCount++;
        animationManager.moveColumns(
          {
            tile,
            fromColumn: column,
            toColumn: column + emptySpaces
          },
          delay
        );
        boardManager.tileSwap({
          fromRow: row,
          toRow: row,
          fromColumn: column,
          toColumn: column + emptySpaces
        });
      }
      if (tilesWillMoveCount === 0) {
        animationManager.isMoveTilesCompleted = true;
      }
    }
    tilesPutColumnsMiddle$(delay = 0) {
      const { boardManager, animationManager } = this.scene;
      const tiles = this.getTiles$();
      let tilesWillMoveCount = 0;
      for (const tile of tiles) {
        const { row, column } = tile;
        if (tile.isCaptured()) continue;
        if (tile.isCapturing()) continue;
        const emptySpacesLeft = this.getEmptySpacesMiddleLeft$(row, column);
        if (emptySpacesLeft < 1) continue;
        tilesWillMoveCount++;
        animationManager.moveColumns(
          {
            tile,
            fromColumn: column,
            toColumn: column - emptySpacesLeft
          },
          delay
        );
        boardManager.tileSwap({
          fromRow: row,
          toRow: row,
          fromColumn: column,
          toColumn: column - emptySpacesLeft
        });
      }
      tiles.reverse();
      for (const tile of tiles) {
        const { row, column } = tile;
        if (tile.isCaptured()) continue;
        if (tile.isCapturing()) continue;
        const emptySpacesRight = this.getEmptySpacesMiddleRight$(row, column);
        if (emptySpacesRight < 1) continue;
        tilesWillMoveCount++;
        animationManager.moveColumns(
          {
            tile,
            fromColumn: column,
            toColumn: column + emptySpacesRight
          },
          delay
        );
        boardManager.tileSwap({
          fromRow: row,
          toRow: row,
          fromColumn: column,
          toColumn: column + emptySpacesRight
        });
      }
      if (tilesWillMoveCount === 0) {
        animationManager.isMoveTilesCompleted = true;
      }
    }
    tilesPutRowsMiddle$(delay = 0) {
      const { boardManager, animationManager } = this.scene;
      const tiles = this.getTiles$();
      let tilesWillMoveCount = 0;
      for (const tile of tiles) {
        const { row, column } = tile;
        if (tile.isCaptured()) continue;
        if (tile.isCapturing()) continue;
        const emptySpacesAbove = this.getEmptySpacesMiddleAbove$(row, column);
        if (emptySpacesAbove < 1) continue;
        tilesWillMoveCount++;
        animationManager.moveRows(
          {
            tile,
            fromRow: row,
            toRow: row - emptySpacesAbove
          },
          delay
        );
        boardManager.tileSwap({
          fromRow: row,
          toRow: row - emptySpacesAbove,
          fromColumn: column,
          toColumn: column
        });
      }
      tiles.reverse();
      for (const tile of tiles) {
        const { row, column } = tile;
        if (tile.isCaptured()) continue;
        if (tile.isCapturing()) continue;
        const emptySpacesBelow = this.getEmptySpacesMiddleBelow$(row, column);
        if (emptySpacesBelow < 1) continue;
        tilesWillMoveCount++;
        animationManager.moveRows(
          {
            tile,
            fromRow: row,
            toRow: row + emptySpacesBelow
          },
          delay
        );
        boardManager.tileSwap({
          fromRow: row,
          toRow: row + emptySpacesBelow,
          fromColumn: column,
          toColumn: column
        });
      }
      if (tilesWillMoveCount === 0) {
        animationManager.isMoveTilesCompleted = true;
      }
    }
    // Get empty space
    getEmptySpacesAbove$(row, column, checkSpace = 0) {
      if (this.isEmptySpaceAbove$(row, column)) {
        const checkRow = row - 1;
        return this.getEmptySpacesAbove$(checkRow, column, checkSpace + 1);
      }
      return checkSpace;
    }
    getEmptySpacesBlow$(row, column, checkSpace = 0) {
      if (this.isEmptySpaceBlow$(row, column)) {
        const checkRow = row + 1;
        return this.getEmptySpacesBlow$(checkRow, column, checkSpace + 1);
      }
      return checkSpace;
    }
    getEmptySpacesLeft$(row, column, checkSpace = 0) {
      if (this.isEmptySpaceLeft$(row, column)) {
        const checkColumn = column - 1;
        return this.getEmptySpacesLeft$(row, checkColumn, checkSpace + 1);
      }
      return checkSpace;
    }
    getEmptySpacesRight$(row, column, checkSpace = 0) {
      if (this.isEmptySpaceRight$(row, column)) {
        const checkColumn = column + 1;
        return this.getEmptySpacesRight$(row, checkColumn, checkSpace + 1);
      }
      return checkSpace;
    }
    getEmptySpacesMiddleLeft$(row, column, checkSpace = 0) {
      if (this.isEmptySpaceMiddleLeft$(row, column)) {
        const checkColumn = column - 1;
        return this.getEmptySpacesMiddleLeft$(row, checkColumn, checkSpace + 1);
      }
      return checkSpace;
    }
    getEmptySpacesMiddleRight$(row, column, checkSpace = 0) {
      if (this.isEmptySpaceMiddleRight$(row, column)) {
        const checkColumn = column + 1;
        return this.getEmptySpacesMiddleRight$(row, checkColumn, checkSpace + 1);
      }
      return checkSpace;
    }
    getEmptySpacesMiddleAbove$(row, column, checkSpace = 0) {
      if (this.isEmptySpaceMiddleAbove$(row, column)) {
        const checkRow = row - 1;
        return this.getEmptySpacesMiddleAbove$(checkRow, column, checkSpace + 1);
      }
      return checkSpace;
    }
    getEmptySpacesMiddleBelow$(row, column, checkSpace = 0) {
      if (this.isEmptySpaceMiddleBelow$(row, column)) {
        const checkRow = row + 1;
        return this.getEmptySpacesMiddleBelow$(checkRow, column, checkSpace + 1);
      }
      return checkSpace;
    }
    // Check empty space
    isEmptySpaceAbove$(row, column) {
      const checkRow = row - 1;
      const { boardManager } = this.scene;
      const { boardMap } = boardManager;
      if (!boardMap[checkRow]) return false;
      if (!boardMap[checkRow][column]) return false;
      const tile = boardMap[checkRow][column];
      return tile.isCaptured() || tile.isCapturing();
    }
    isEmptySpaceBlow$(row, column) {
      const checkRow = row + 1;
      const { boardManager } = this.scene;
      const { boardMap } = boardManager;
      if (!boardMap[checkRow]) return false;
      if (!boardMap[checkRow][column]) return false;
      const tile = boardMap[checkRow][column];
      return tile.isCaptured() || tile.isCapturing();
    }
    isEmptySpaceLeft$(row, column) {
      const checkColumn = column - 1;
      const { boardManager } = this.scene;
      const { boardMap } = boardManager;
      if (!boardMap[row]) return false;
      if (!boardMap[row][checkColumn]) return false;
      const tile = boardMap[row][checkColumn];
      return tile.isCaptured() || tile.isCapturing();
    }
    isEmptySpaceRight$(row, column) {
      const checkColumn = column + 1;
      const { boardManager } = this.scene;
      const { boardMap } = boardManager;
      if (!boardMap[row]) return false;
      if (!boardMap[row][checkColumn]) return false;
      const tile = boardMap[row][checkColumn];
      return tile.isCaptured() || tile.isCapturing();
    }
    isEmptySpaceMiddleLeft$(row, column) {
      const { columns } = this.scene.levelHandler.getConfigs();
      const checkColumn = column - 1;
      if (checkColumn < columns / 2) return false;
      const { boardManager } = this.scene;
      const { boardMap } = boardManager;
      if (!boardMap[row]) return false;
      if (!boardMap[row][checkColumn]) return false;
      const tile = boardMap[row][checkColumn];
      return tile.isCaptured() || tile.isCapturing();
    }
    isEmptySpaceMiddleRight$(row, column) {
      const { columns } = this.scene.levelHandler.getConfigs();
      const checkColumn = column + 1;
      if (checkColumn > columns / 2) return false;
      const { boardManager } = this.scene;
      const { boardMap } = boardManager;
      if (!boardMap[row]) return false;
      if (!boardMap[row][checkColumn]) return false;
      const tile = boardMap[row][checkColumn];
      return tile.isCaptured() || tile.isCapturing();
    }
    isEmptySpaceMiddleAbove$(row, column) {
      const { rows } = this.scene.levelHandler.getConfigs();
      const checkRow = row - 1;
      if (checkRow < rows / 2) return false;
      const { boardManager } = this.scene;
      const { boardMap } = boardManager;
      if (!boardMap[checkRow]) return false;
      if (!boardMap[checkRow][column]) return false;
      const tile = boardMap[checkRow][column];
      return tile.isCaptured() || tile.isCapturing();
    }
    isEmptySpaceMiddleBelow$(row, column) {
      const { rows } = this.scene.levelHandler.getConfigs();
      const checkRow = row + 1;
      if (checkRow > rows / 2) return false;
      const { boardManager } = this.scene;
      const { boardMap } = boardManager;
      if (!boardMap[checkRow]) return false;
      if (!boardMap[checkRow][column]) return false;
      const tile = boardMap[checkRow][column];
      return tile.isCaptured() || tile.isCapturing();
    }
  };
  var ModeManager_default = ModeManager;

  // src/game/gameplay/managers/TileManager.ts
  init_phaser_custom_min();

  // src/game/effects/CaptureHintPath.ts
  init_phaser_custom_min();

  // src/game/effects/CaptureLine.ts
  init_phaser_custom_min();
  var { KEY: KEY30, FRAME: FRAME25 } = sprites_default.EFFECTS;
  var CaptureLine = class extends Phaser.GameObjects.Container {
    start;
    end;
    middle;
    constructor(scene) {
      super(scene);
      this.scene = scene;
      this.createGlowLine();
      this.scene.add.existing(this);
    }
    createGlowLine() {
      this.start = this.scene.add.image(0, 0, KEY30, FRAME25.CAPTURE_PATH_START);
      this.end = this.scene.add.image(0, 0, KEY30, FRAME25.CAPTURE_PATH_END);
      this.middle = this.scene.add.image(0, 0, KEY30, FRAME25.CAPTURE_PATH_MIDDLE);
      this.add([this.start, this.end, this.middle]);
    }
    setGlowLineLength(length, orientation) {
      const actualLength = length + 6;
      this.middle.setWorldSize(actualLength, 18);
      this.start.x = -actualLength / 2;
      this.end.x = actualLength / 2;
      if (orientation === "horizontal") {
        this.angle = 0;
      } else {
        this.angle = 90;
      }
    }
  };
  var CaptureLine_default = CaptureLine;

  // src/game/effects/CaptureHintPath.ts
  var { KEY: KEY31, FRAME: FRAME26 } = sprites_default.GAMEPLAY;
  var DEPTH = depth_default.TILE + 1;
  var CaptureHintPath = class extends Phaser.GameObjects.GameObject {
    whiteCircles;
    lineList;
    firstTilePosition = null;
    fadeTween;
    constructor(scene) {
      super(scene, "captureHintPath");
      this.whiteCircles = scene.add.group();
      this.lineList = scene.add.group();
      this.scene.add.existing(this);
    }
    drawNewPath(path) {
      const pairs = [];
      let firstPoint = path[0];
      let secondPoint = null;
      for (let i = 1; i < path.length; i++) {
        const point = path[i];
        if (!secondPoint) {
          secondPoint = point;
          continue;
        }
        if (firstPoint.x === secondPoint.x && secondPoint.x === point.x) {
          secondPoint = point;
          continue;
        }
        if (firstPoint.y === secondPoint.y && secondPoint.y === point.y) {
          secondPoint = point;
          continue;
        }
        pairs.push([firstPoint, secondPoint]);
        firstPoint = secondPoint;
        secondPoint = point;
      }
      pairs.push([firstPoint, secondPoint]);
      pairs.forEach((pair, index) => {
        if (!pair[0] || !pair[1]) return;
        const pos1 = this.translateGridPositionToScreenPosition(pair[0]);
        const pos2 = this.translateGridPositionToScreenPosition(pair[1]);
        this.assignLine(pos1.x, pos1.y, pos2.x, pos2.y);
        this.assignWhiteCircle(pos1.x, pos1.y);
        if (index === pairs.length - 1) {
          this.assignWhiteCircle(pos2.x, pos2.y);
        }
      });
      this.runFadeInTween();
    }
    updateFirstTilePosition() {
      const scene = this.scene;
      const { boardMap } = scene.boardManager;
      if (!boardMap) return;
      if (!boardMap[1]) return;
      if (!boardMap[1][1]) return;
      const { x, y } = boardMap[1][1].getWorldPosition();
      this.firstTilePosition = new Phaser.Math.Vector2(x, y);
    }
    clearFirstTilePosition() {
      this.firstTilePosition = null;
    }
    setFirstTilePosition(position) {
      this.firstTilePosition = position;
    }
    clear() {
      this.runFadeOutTween();
    }
    hideHintEffect() {
      const whiteCircles = this.whiteCircles.getChildren();
      const lineList = this.lineList.getChildren();
      for (const circle of whiteCircles) {
        circle.setVisible(false);
      }
      for (const line of lineList) {
        line.setVisible(false);
      }
    }
    showHintEffect() {
      const whiteCircles = this.whiteCircles.getChildren();
      const lineList = this.lineList.getChildren();
      for (const circle of whiteCircles) {
        if (circle.active) {
          circle.setVisible(true);
        }
      }
      for (const line of lineList) {
        if (line.active) {
          line.setVisible(true);
        }
      }
    }
    kill() {
      const whiteCircles = this.whiteCircles.getChildren();
      const lineList = this.lineList.getChildren();
      for (const circle of whiteCircles) {
        this.whiteCircles.killAndHide(circle);
      }
      for (const line of lineList) {
        this.lineList.killAndHide(line);
      }
    }
    translateGridPositionToScreenPosition(gridPos) {
      const { x: row = 1, y: column = 1 } = gridPos;
      if (!this.firstTilePosition) {
        this.updateFirstTilePosition();
      }
      const scene = this.scene;
      const tileSize = scene.boardManager.getTileSize() + 1;
      const x = this.firstTilePosition ? this.firstTilePosition.x : 0;
      const y = this.firstTilePosition ? this.firstTilePosition.y : 0;
      return {
        x: x + (column - 1) * tileSize,
        y: y + (row - 1) * tileSize
      };
    }
    assignWhiteCircle(x, y) {
      const inactiveCircle = this.whiteCircles.getFirstDead();
      if (inactiveCircle) {
        inactiveCircle.setPosition(x, y);
        inactiveCircle.setActive(true);
        inactiveCircle.setVisible(true);
        inactiveCircle.setAlpha(0);
        inactiveCircle.setDepth(DEPTH + 1);
        return inactiveCircle;
      }
      const circle = this.scene.make.image({
        key: KEY31,
        frame: FRAME26.HINT_LINE_DOT
      });
      this.whiteCircles.add(circle);
      circle.setPosition(x, y);
      circle.setDepth(DEPTH + 1);
      circle.setScale(circle.scale * 0.5);
      circle.setAlpha(0);
      this.scene.add.existing(circle);
      return circle;
    }
    assignLine(x12, y12, x2, y2) {
      const inactiveLine = this.lineList.getFirstDead();
      const lineX = (x12 + x2) / 2;
      const lineY = (y12 + y2) / 2;
      const orientation = x12 === x2 ? "vertical" : "horizontal";
      const lineLength = Phaser.Math.Distance.Between(x12, y12, x2, y2);
      if (inactiveLine && inactiveLine instanceof CaptureLine_default) {
        inactiveLine.setPosition(lineX, lineY);
        inactiveLine.setGlowLineLength(lineLength, orientation);
        inactiveLine.revive();
        inactiveLine.setAlpha(0);
        inactiveLine.setDepth(DEPTH);
        return inactiveLine;
      }
      const line = new CaptureLine_default(this.scene);
      this.lineList.add(line);
      line.setPosition(lineX, lineY);
      line.setGlowLineLength(lineLength, orientation);
      line.setDepth(DEPTH);
      line.setAlpha(0);
      this.scene.add.existing(line);
      return line;
    }
    runFadeInTween() {
      this.fadeTween?.stop();
      const lineList = this.lineList.getChildren().filter((line) => line.active);
      const whiteCircles = this.whiteCircles.getChildren().filter((circle) => circle.active);
      const fadeInTween = this.scene.tweens.add({
        targets: [...lineList, ...whiteCircles],
        props: {
          alpha: {
            from: 0,
            to: 1
          }
        },
        duration: 200,
        onStop: () => {
          for (const line of lineList) {
            line.setAlpha(1);
          }
          for (const circle of whiteCircles) {
            circle.setAlpha(1);
          }
        }
      });
      this.fadeTween = fadeInTween;
    }
    runFadeOutTween() {
      this.fadeTween?.stop();
      const lineList = this.lineList.getChildren().filter((line) => line.active);
      const whiteCircles = this.whiteCircles.getChildren().filter((circle) => circle.active);
      const fadeOutTween = this.scene.tweens.add({
        targets: [...lineList, ...whiteCircles],
        props: {
          alpha: {
            from: 1,
            to: 0
          }
        },
        duration: 200,
        onComplete: () => {
          this.kill();
        },
        onStop: () => {
          this.kill();
        }
      });
      this.fadeTween = fadeOutTween;
    }
  };
  var CaptureHintPath_default = CaptureHintPath;

  // src/game/effects/CapturePathGroup.ts
  init_phaser_custom_min();

  // src/game/gameplay/animations/animation/CapturePath.ts
  init_phaser_custom_min();

  // src/game/gameplay/animations/particle/CaptureStarTrail.ts
  init_phaser_custom_min();
  var { KEY: KEY32, FRAME: FRAME27 } = sprites_default.GAMEPLAY;
  var {
    Utils: { Device: D5 }
  } = Ludex;
  var CaptureStarTrail = class extends Phaser.GameObjects.Container {
    emitZone;
    isRunning;
    emitter;
    constructor(scene) {
      super(scene);
      this.createEmitZone();
      this.createEmitters();
      this.scene.add.existing(this);
    }
    createEmitZone() {
      this.emitZone = new Phaser.Geom.Rectangle();
    }
    createEmitters() {
      const scale = 1 / D5.pixelRatio();
      this.emitter = this.scene.add.particles(0, 0, KEY32, {
        frame: FRAME27.EFFECT_TRAIL_STAR,
        emitZone: {
          source: this.emitZone,
          type: "random"
        },
        speed: 20,
        timeScale: 1,
        frequency: 50,
        gravityY: 100,
        alpha: { start: 1, end: 0, ease: Phaser.Math.Easing.Expo.Out },
        scale: { start: scale * 1.2, end: scale * 0.1, ease: Phaser.Math.Easing.Expo.Out },
        lifespan: 2666
      });
      this.add(this.emitter);
    }
    run(count, x, y, width, height) {
      this.stop();
      this.reset();
      this.emitZone.setSize(width, height);
      this.emitZone.setPosition(x - width / 2, y - height / 2);
      this.emitter.setQuantity(count);
      this.emitter.start();
      this.isRunning = true;
    }
    explode(count, x, y) {
      if (!this.emitter) {
        this.reset();
      }
      this.isRunning = false;
      this.emitter.explode(count, x, y);
    }
    stop() {
      this.isRunning = false;
      this.emitter?.killAll();
      this.emitter?.stop();
    }
    reset() {
      this.createEmitters();
    }
    moveEmitZone(x, y) {
      this.emitZone.setPosition(x, y);
    }
  };
  var CaptureStarTrail_default = CaptureStarTrail;

  // src/game/gameplay/animations/particle/StarExplodeParticle.ts
  init_phaser_custom_min();
  var { KEY: KEY33, FRAME: FRAME28 } = sprites_default.GAMEPLAY;
  var StarExplodeParticle = class extends Phaser.GameObjects.Container {
    deathZone;
    emitter;
    constructor(scene) {
      super(scene);
      this.createDeathZone();
      this.createEmitters();
      this.kill();
      this.scene.add.existing(this);
    }
    createDeathZone() {
      this.deathZone = new Phaser.Geom.Circle();
    }
    createEmitters() {
      this.emitter = this.scene.add.particles(0, 0, KEY33, {
        frame: FRAME28.EFFECT_TRAIL_STAR,
        speed: { min: 10, max: 80 },
        scale: { start: 1, end: 0 },
        alpha: { start: 1, end: 0.2, ease: Phaser.Math.Easing.Expo.Out },
        deathZone: {
          source: this.deathZone,
          type: "onLeave"
        },
        lifespan: 2e3
      });
      this.add(this.emitter);
    }
    explode(count, x, y, radius) {
      this.revive();
      this.deathZone.radius = radius;
      this.deathZone.setPosition(x, y);
      this.emitter.explode(count, x, y);
    }
  };
  var StarExplodeParticle_default = StarExplodeParticle;

  // src/game/gameplay/animations/animation/CapturePath.ts
  var { KEY: KEY34, FRAME: FRAME29 } = sprites_default.GAMEPLAY;
  var DEPTH2 = depth_default.EFFECT + 1;
  var CapturePath = class extends Phaser.GameObjects.GameObject {
    starList;
    lineList;
    whiteCircles;
    firstTilePosition = null;
    starTweenList = [];
    starExpandTween;
    lineTween;
    captureStarTrails;
    explodeParticle;
    score;
    pathLength;
    constructor(scene) {
      super(scene, "capturePath");
      this.starList = scene.add.group();
      this.lineList = scene.add.group();
      this.whiteCircles = scene.add.group();
      this.createEffects();
      this.score = 0;
    }
    createEffects() {
      this.captureStarTrails = [];
      this.explodeParticle = new StarExplodeParticle_default(this.scene);
      this.explodeParticle.setDepth(depth_default.EFFECT);
    }
    drawNewPath(path, withDot = false) {
      this.pathLength = path.length;
      const lines = this.drawLines(path);
      if (withDot) {
        this.drawDots(lines);
      } else {
        this.drawStars(path);
        this.runStarExpandTween();
      }
      this.runLineTween("fadeIn");
    }
    drawDots(lines) {
      lines.forEach((pair, index) => {
        if (!pair[0] || !pair[1]) return;
        const pos1 = this.translateGridPositionToScreenPosition(pair[0]);
        const pos2 = this.translateGridPositionToScreenPosition(pair[1]);
        this.assignLine(pos1.x, pos1.y, pos2.x, pos2.y);
        this.assignWhiteCircle(pos1.x, pos1.y);
        if (index === lines.length - 1) {
          this.assignWhiteCircle(pos2.x, pos2.y);
        }
      });
    }
    drawLines(path) {
      const pairs = [];
      let firstPoint = path[0];
      let secondPoint = null;
      for (let i = 1; i < path.length; i++) {
        const point = path[i];
        if (!secondPoint) {
          secondPoint = point;
          continue;
        }
        if (firstPoint.x === secondPoint.x && secondPoint.x === point.x) {
          secondPoint = point;
          continue;
        }
        if (firstPoint.y === secondPoint.y && secondPoint.y === point.y) {
          secondPoint = point;
          continue;
        }
        pairs.push([firstPoint, secondPoint]);
        firstPoint = secondPoint;
        secondPoint = point;
      }
      pairs.push([firstPoint, secondPoint]);
      for (let i = 0; i < pairs.length; i++) {
        const pair = pairs[i];
        if (!pair[0] || !pair[1]) continue;
        const pos1 = this.translateGridPositionToScreenPosition(pair[0]);
        const pos2 = this.translateGridPositionToScreenPosition(pair[1]);
        this.assignLine(pos1.x, pos1.y, pos2.x, pos2.y);
      }
      return pairs;
    }
    drawStars(path) {
      for (let i = 0; i < path.length; i++) {
        const point = path[i];
        if (!point) continue;
        const { x, y } = this.translateGridPositionToScreenPosition(point);
        this.assignStar(x, y);
      }
    }
    kill() {
      for (const starTimeline of this.starTweenList) {
        starTimeline.stop();
      }
      this.starTweenList = [];
      const starList = this.starList.getChildren();
      for (let i = 0; i < starList.length; i++) {
        this.starList.killAndHide(starList[i]);
      }
      this.score = 0;
      this.pathLength = 1;
      const captureStarTrails = this.captureStarTrails;
      for (const twinkle of captureStarTrails) {
        twinkle.stop();
      }
      const lineList = this.lineList.getChildren();
      for (let i = 0; i < lineList.length; i++) {
        this.lineList.killAndHide(lineList[i]);
      }
      const whiteCircles = this.whiteCircles.getChildren();
      for (let i = 0; i < whiteCircles.length; i++) {
        this.whiteCircles.killAndHide(whiteCircles[i]);
      }
      this.lineTween?.stop();
      this.setActive(false);
    }
    updateFirstTilePosition() {
      const scene = this.scene;
      const { boardMap } = scene.boardManager;
      if (!boardMap) return;
      if (!boardMap[1]) return;
      if (!boardMap[1][1]) return;
      const { x, y } = boardMap[1][1].getWorldPosition();
      this.firstTilePosition = new Phaser.Math.Vector2(x, y);
    }
    clearFirstTilePosition() {
      this.firstTilePosition = null;
    }
    setFirstTilePosition(position) {
      this.firstTilePosition = position;
    }
    setScore(score) {
      this.score = score;
    }
    handleCaptureEffectEnd() {
      const scene = this.scene;
      const isUsingStars = this.starList.getFirstAlive() !== null;
      if (!isUsingStars) {
        scene.eatScore(this.score);
        this.kill();
        return;
      }
      this.runLineTween("fadeOut");
      this.runStarTween();
      return;
    }
    runLineTween(type) {
      this.lineTween?.stop();
      const lineList = this.lineList.getChildren().filter((line) => line.active);
      const whiteCircles = this.whiteCircles.getChildren().filter((circle) => circle.active);
      const lineTween = this.scene.tweens.add({
        targets: [...lineList, ...whiteCircles],
        duration: 200,
        props: {
          alpha: {
            from: type === "fadeIn" ? 0 : 1,
            to: type === "fadeIn" ? 1 : 0
          }
        },
        onComplete: () => {
          if (type !== "fadeOut") return;
          this.cleanLineWhenFadeOut();
        },
        onStop: () => {
          for (const line of lineList) {
            line.setAlpha(type === "fadeIn" ? 1 : 0);
          }
          for (const circle of whiteCircles) {
            circle.setAlpha(type === "fadeIn" ? 1 : 0);
          }
          if (type !== "fadeOut") return;
          this.cleanLineWhenFadeOut();
        }
      });
      this.lineTween = lineTween;
    }
    cleanLineWhenFadeOut() {
      const lineList = this.lineList.getChildren().filter((line) => line.active);
      const whiteCircles = this.whiteCircles.getChildren().filter((circle) => circle.active);
      for (let i = 0; i < lineList.length; i++) {
        this.lineList.killAndHide(lineList[i]);
      }
      for (let i = 0; i < whiteCircles.length; i++) {
        this.whiteCircles.killAndHide(whiteCircles[i]);
      }
    }
    runStarTween() {
      this.starList.getChildren().forEach((star, index) => {
        if (!star.active) return;
        const scene = this.scene;
        const { objects } = scene.layoutManager;
        let { x, y } = objects.starProgressBar.getStarFlyInPosition();
        if (MatchUtils_default.isChallengeMode()) {
          const { x: x2, y: y2 } = objects.challengeInfo.getWorldPosition();
          x = x2 - 50;
          y = y2;
        }
        const reverseDistance = 25;
        const angle = Phaser.Math.Angle.Between(star.x, star.y, x, y);
        const distance = Phaser.Math.Distance.Between(star.x, star.y, x, y);
        const captureStarTrail = this.requestCaptureStarTrail();
        captureStarTrail.run(1, star.x, star.y, 0, 0);
        const starTimeline = this.scene.tweens.chain({
          targets: star,
          tweens: [
            {
              targets: star,
              x: star.x - Math.cos(angle) * reverseDistance,
              y: star.y - Math.sin(angle) * reverseDistance,
              duration: 250,
              delay: 40 * index,
              ease: Phaser.Math.Easing.Quadratic.In,
              onUpdate: () => {
                captureStarTrail.moveEmitZone(star.x, star.y);
              }
            },
            {
              props: {
                x: {
                  from: star.x,
                  to: x,
                  ease: Phaser.Math.Easing.Quadratic.Out
                },
                y: {
                  from: star.y,
                  to: y,
                  ease: Phaser.Math.Easing.Quadratic.Out
                },
                scale: {
                  from: star.scale,
                  to: star.scale * Math.sqrt(2),
                  ease: Phaser.Math.Easing.Quintic.Out
                }
              },
              duration: (distance + reverseDistance) / 300 * 600,
              onComplete: () => {
                scene.eatScore(this.score / this.pathLength);
                AudioUtils_default.playSound(soundEffects_default.COLLECT_STARS, { volume: 0.7 });
                captureStarTrail.stop();
                this.explodeParticle.explode(15, x, y, 30);
              },
              onUpdate: () => {
                captureStarTrail.moveEmitZone(star.x, star.y);
              },
              onStop: () => {
                scene.eatScore(this.score / this.pathLength);
                captureStarTrail.stop();
              }
            },
            {
              alpha: 0,
              duration: 400,
              ease: Phaser.Math.Easing.Cubic.Out,
              onComplete: () => {
                this.starList.killAndHide(star);
                this.starTweenList = this.starTweenList.filter((tween) => tween !== starTimeline);
                if (this.starTweenList.length === 0) {
                }
              },
              onStop: () => {
                this.starList.killAndHide(star);
                this.starTweenList = this.starTweenList.filter((tween) => tween !== starTimeline);
                if (this.starTweenList.length === 0) {
                }
              }
            }
          ]
        });
      });
    }
    runStarExpandTween() {
      this.starExpandTween?.stop();
      const starList = this.starList.getChildren().filter((star) => star.active);
      if (starList.length < 1) return;
      const baseScaleX = starList[0].scaleX;
      const baseScaleY = starList[0].scaleY;
      const starExpandTween = this.scene.tweens.add({
        targets: starList,
        duration: 200,
        props: {
          scaleX: {
            from: 0,
            to: baseScaleX
          },
          scaleY: {
            from: 0,
            to: baseScaleX
          }
        },
        onStart: () => {
          for (const star of starList) {
            star.setVisible(true);
          }
        },
        onStop: () => {
          for (const star of starList) {
            star.setScale(baseScaleX, baseScaleY);
          }
        }
      });
      this.starExpandTween = starExpandTween;
    }
    translateGridPositionToScreenPosition(gridPos) {
      const { x: row = 1, y: column = 1 } = gridPos;
      if (!this.firstTilePosition) {
        this.updateFirstTilePosition();
      }
      const scene = this.scene;
      const tileSize = scene.boardManager.getTileSizeWithSpacing();
      const x = this.firstTilePosition ? this.firstTilePosition.x : 0;
      const y = this.firstTilePosition ? this.firstTilePosition.y : 0;
      return {
        x: x + (column - 1) * tileSize,
        y: y + (row - 1) * tileSize
      };
    }
    assignStar(x, y) {
      const inactiveStar = this.starList.getFirstDead();
      const starSize = 22;
      if (inactiveStar) {
        inactiveStar.setWorldSize(starSize, starSize);
        inactiveStar.setPosition(x, y);
        inactiveStar.setActive(true);
        inactiveStar.setAlpha(1);
        inactiveStar.setDepth(DEPTH2 + 1);
        return inactiveStar;
      }
      const star = this.scene.make.image({
        key: KEY34,
        frame: FRAME29.ICON_STAR_BIG
      });
      this.starList.add(star);
      star.setWorldSize(starSize, starSize);
      star.setPosition(x, y);
      star.setDepth(DEPTH2 + 1);
      star.setVisible(false);
      star.setAlpha(1);
      this.scene.add.existing(star);
      return star;
    }
    requestCaptureStarTrail() {
      const inactiveCometTwinkle = this.captureStarTrails.find((twinkle) => !twinkle.isRunning);
      if (inactiveCometTwinkle) {
        return inactiveCometTwinkle;
      }
      const captureStarTrail = new CaptureStarTrail_default(this.scene);
      captureStarTrail.setDepth(DEPTH2 - 1);
      this.captureStarTrails.push(captureStarTrail);
      return captureStarTrail;
    }
    assignLine(x12, y12, x2, y2) {
      const inactiveLine = this.lineList.getFirstDead();
      const lineX = (x12 + x2) / 2;
      const lineY = (y12 + y2) / 2;
      const orientation = x12 === x2 ? "vertical" : "horizontal";
      const lineLength = Phaser.Math.Distance.Between(x12, y12, x2, y2);
      if (inactiveLine && inactiveLine instanceof CaptureLine_default) {
        inactiveLine.setPosition(lineX, lineY);
        inactiveLine.setGlowLineLength(lineLength, orientation);
        inactiveLine.revive();
        inactiveLine.setDepth(DEPTH2);
        return inactiveLine;
      }
      const line = new CaptureLine_default(this.scene);
      this.lineList.add(line);
      line.setPosition(lineX, lineY);
      line.setGlowLineLength(lineLength, orientation);
      line.setDepth(DEPTH2);
      this.scene.add.existing(line);
      return line;
    }
    assignWhiteCircle(x, y) {
      const inactiveCircle = this.whiteCircles.getFirstDead();
      if (inactiveCircle) {
        inactiveCircle.setPosition(x, y);
        inactiveCircle.setActive(true);
        inactiveCircle.setVisible(true);
        inactiveCircle.setAlpha(0);
        inactiveCircle.setDepth(DEPTH2 + 1);
        return inactiveCircle;
      }
      const circle = this.scene.make.image({
        key: KEY34,
        frame: FRAME29.HINT_LINE_DOT
      });
      this.whiteCircles.add(circle);
      circle.setPosition(x, y);
      circle.setDepth(DEPTH2 + 1);
      circle.setAlpha(0);
      this.scene.add.existing(circle);
      return circle;
    }
  };
  var CapturePath_default = CapturePath;

  // src/game/effects/CapturePathGroup.ts
  var CapturePathGroup = class extends Phaser.GameObjects.Group {
    firstTilePosition = null;
    constructor(scene) {
      super(scene);
      this.scene.add.existing(this);
    }
    requestPath() {
      const availablePath = this.getFirstDead();
      if (availablePath) {
        availablePath.setActive(true);
        availablePath.setFirstTilePosition(this.firstTilePosition);
        return availablePath;
      }
      const scene = this.scene;
      const newPath = new CapturePath_default(scene);
      newPath.setFirstTilePosition(this.firstTilePosition);
      this.add(newPath);
      return newPath;
    }
    updateFirstTilePosition() {
      const scene = this.scene;
      const { boardMap } = scene.boardManager;
      if (!boardMap) return;
      if (!boardMap[1]) return;
      if (!boardMap[1][1]) return;
      const { x, y } = boardMap[1][1].getWorldPosition();
      this.firstTilePosition = new Phaser.Math.Vector2(x, y);
    }
    clearFirstTilePosition() {
      this.firstTilePosition = null;
    }
    killPath(path) {
      path.handleCaptureEffectEnd();
    }
    killAndHideAll() {
      const paths = this.getChildren();
      for (const path of paths) {
        if (!(path instanceof CapturePath_default)) continue;
        path.kill();
      }
    }
  };
  var CapturePathGroup_default = CapturePathGroup;

  // src/game/effects/CaptureWrongPath.ts
  init_phaser_custom_min();

  // src/game/components/DotNumber.ts
  init_phaser_custom_min();
  var { KEY: KEY35, FRAME: FRAME30 } = sprites_default.TUTORIAL;
  var DotNumber = class extends Phaser.GameObjects.Container {
    number;
    dot;
    constructor(scene) {
      super(scene);
      this.dot = this.scene.make.image({
        key: KEY35,
        frame: FRAME30.DOT_WRONG
      });
      this.add(this.dot);
      this.number = FontUtils_default.createText(this.scene, "0", 15);
      this.add(this.number);
      const { displayWidth, displayHeight } = this.dot;
      this.setSize(displayWidth, displayHeight);
      Phaser.Display.Align.In.Center(this.number, this.dot, 0, -1);
      this.scene.add.existing(this);
    }
    setNumber(number) {
      this.number.setText(number.toString());
    }
  };
  var DotNumber_default = DotNumber;

  // src/game/effects/CaptureWrongPath.ts
  var { KEY: KEY36, FRAME: FRAME31 } = sprites_default.TUTORIAL;
  var CaptureWrongPath = class {
    scene;
    decorList;
    lineList;
    firstTilePosition = null;
    drawX = 0;
    drawY = 0;
    constructor(scene) {
      this.scene = scene;
      this.decorList = scene.add.group();
      this.lineList = scene.add.group();
    }
    drawNewPath(longPath) {
      const path = this.getShortenPath(longPath);
      this.clear();
      const startingPos = this.translateGridPositionToScreenPosition(path[0]);
      this.moveTo(startingPos.x, startingPos.y);
      let turns = 1;
      let lastObj = null;
      for (let index = 1; index < path.length; index++) {
        const point = path[index];
        const { x, y } = this.translateGridPositionToScreenPosition(point);
        this.lineTo(x, y);
        if (index === path.length - 1) continue;
        if (turns <= 2) {
          const newObj = this.assignDot(x + 1, y + 1);
          newObj.setNumber(turns++);
          lastObj = newObj;
        } else {
          lastObj = this.assignCross(x, y);
        }
      }
      if (turns === 2 && lastObj !== null) {
        const { x = 1, y = 1 } = lastObj;
        lastObj.setVisible(false);
        lastObj.setActive(false);
        this.assignCross(x, y);
      } else if (turns === 1) {
        const { x: x12, y: y12 } = this.translateGridPositionToScreenPosition(path[0]);
        const { x: x2, y: y2 } = this.translateGridPositionToScreenPosition(path[path.length - 1]);
        this.assignCross((x2 + x12) / 2, (y2 + y12) / 2);
      }
    }
    getShortenPath(path) {
      if (path.length < 0) return [];
      const result = [];
      result.push(path[0]);
      let preDirection = "none";
      let prePoint = path[0];
      path.forEach((point, index) => {
        if (index === 0) return;
        const { x: row = 1, y: col = 1 } = point;
        const { x: preRow = 1, y: preCol = 1 } = prePoint;
        const direction = this.getMovingDirectionString(row - preRow, col - preCol);
        if (preDirection !== "none" && preDirection !== direction) {
          result.push(prePoint);
        }
        preDirection = direction;
        prePoint = point;
      });
      result.push(path[path.length - 1]);
      return result;
    }
    updateFirstTilePosition() {
      const scene = this.scene;
      const { boardMap } = scene.boardManager;
      if (!boardMap) return;
      if (!boardMap[1]) return;
      if (!boardMap[1][1]) return;
      const { x, y } = boardMap[1][1].getWorldPosition();
      this.firstTilePosition = new Phaser.Math.Vector2(x, y);
    }
    clearFirstTilePosition() {
      this.firstTilePosition = null;
    }
    setFirstTilePosition(position) {
      this.firstTilePosition = position;
    }
    clear() {
      const decorList = this.decorList.getChildren();
      const lineList = this.lineList.getChildren();
      for (const star of decorList) {
        star.setVisible(false);
        star.setActive(false);
      }
      for (const line of lineList) {
        line.setVisible(false);
        line.setActive(false);
      }
      return this;
    }
    translateGridPositionToScreenPosition(gridPos) {
      const { x: row = 1, y: column = 1 } = gridPos;
      if (!this.firstTilePosition) {
        this.updateFirstTilePosition();
      }
      const scene = this.scene;
      const tileSize = scene.boardManager.getTileSizeWithSpacing();
      const x = this.firstTilePosition ? this.firstTilePosition.x : 0;
      const y = this.firstTilePosition ? this.firstTilePosition.y : 0;
      return {
        x: x + (column - 1) * tileSize,
        y: y + (row - 1) * tileSize
      };
    }
    assignDot(x, y) {
      const inactiveStar = this.decorList.getChildren().find((star2) => star2 instanceof DotNumber_default &&
      !star2.active);
      if (inactiveStar) {
        inactiveStar.setPosition(x, y);
        inactiveStar.setActive(true);
        inactiveStar.setVisible(true);
        inactiveStar.setDepth(depth_default.TILE + 2);
        return inactiveStar;
      }
      const star = new DotNumber_default(this.scene);
      this.decorList.add(star);
      star.setPosition(x, y);
      star.setDepth(depth_default.TILE + 2);
      this.scene.add.existing(star);
      return star;
    }
    assignCross(x, y) {
      const inactiveCross = this.decorList.getChildren().find((cross2) => !(cross2 instanceof DotNumber_default) &&
      !cross2.active);
      if (inactiveCross) {
        inactiveCross.setPosition(x, y);
        inactiveCross.setActive(true);
        inactiveCross.setVisible(true);
        return inactiveCross;
      }
      const cross = this.scene.make.image({
        key: KEY36,
        frame: FRAME31.CROSS_WRONG,
        origin: { x: 0.49, y: 0.38 }
      });
      cross.setPosition(x, y);
      cross.setWorldSize(27, 27);
      cross.setDepth(depth_default.TILE + 2);
      this.decorList.add(cross);
      this.scene.add.existing(cross);
      return cross;
    }
    moveTo(x, y) {
      this.drawX = x;
      this.drawY = y;
    }
    lineTo(x, y) {
      const inactiveLine = this.lineList.getChildren().find((line2) => !line2.active);
      const height = 8;
      const width = this.getLineLength(x - this.drawX, y - this.drawY);
      const angle = this.getLineAngle(x - this.drawX, y - this.drawY);
      const posX = this.drawX;
      const posY = this.drawY;
      if (inactiveLine && inactiveLine instanceof Phaser.GameObjects.Image) {
        inactiveLine.revive();
        inactiveLine.setAngle(angle);
        inactiveLine.setPosition(posX, posY);
        inactiveLine.setWorldSize(width, height);
        this.drawX = x;
        this.drawY = y;
        return;
      }
      const line = this.scene.make.image({
        key: KEY36,
        frame: FRAME31.LINE_WRONG,
        origin: { x: 0, y: 0.5 }
      });
      line.setAngle(angle);
      line.setWorldSize(width, height);
      line.setPosition(posX, posY);
      line.setDepth(depth_default.TILE + 1);
      this.lineList.add(line);
      this.scene.add.existing(line);
      this.drawX = x;
      this.drawY = y;
    }
    /**
     * @param x global x in scene
     * @param y global y in scene
     */
    getLineAngle(x, y) {
      const direction = this.getMovingDirectionString(y, x);
      switch (direction) {
        case "down":
          return 90;
        case "up":
          return -90;
        case "right":
          return 0;
        case "left":
          return 180;
        default:
          return 0;
      }
    }
    /**
     * @param x global x in scene
     * @param y global y in scene
     */
    getLineLength(x, y) {
      const direction = this.getMovingDirectionString(y, x);
      switch (direction) {
        case "down":
        case "up":
          return Math.abs(y);
        case "right":
        case "left":
          return Math.abs(x);
        default:
          return 0;
      }
    }
    /**
     * @param x x in map board
     * @param y y in map board
     */
    getMovingDirectionString(x, y) {
      if (x > 0) {
        return "down";
      }
      if (x < 0) {
        return "up";
      }
      if (y > 0) {
        return "right";
      }
      if (y < 0) {
        return "left";
      }
      return "none";
    }
  };
  var CaptureWrongPath_default = CaptureWrongPath;

  // src/game/gameplay/objects/tiles/EmptyTile.ts
  init_phaser_custom_min();
  var EmptyTile = class extends BaseTile_default {
    constructor(scene, row, column) {
      super(scene);
      this.setName("EmptyTile");
      this.setRow(row);
      this.setColumn(column);
      this.setState(tile_default.STATUS.CAPTURED);
      this.hideHighlight();
      this.removeTile();
    }
  };
  var EmptyTile_default = EmptyTile;

  // src/game/gameplay/objects/tiles/RocketTile.ts
  init_phaser_custom_min();
  var { KEY: KEY37, FRAME: FRAME32 } = sprites_default.GAMEPLAY;
  var { SPECIALS: SPECIALS3 } = tile_default;
  var RocketTile = class extends BaseTile_default {
    rocketTailSprite;
    constructor(scene, row, column) {
      super(scene, FRAME32.TILE_ROCKET, SPECIALS3.ROCKET);
      this.setName("RocketTile");
      this.setRow(row);
      this.setColumn(column);
      this.createRocketSparkle();
      this.icon.setScale(this.block.scale);
    }
    createRocketSparkle() {
      const { KEY: KEY94, FRAME: FRAME100 } = sprites_default.EFFECTS;
      this.rocketTailSprite = this.scene.make.sprite({
        key: KEY94,
        frame: `${FRAME100.ROCKET_TAIL}0`,
        origin: { x: 0.5, y: 0.5 }
      });
      this.add(this.rocketTailSprite);
      this.updateRocketTailConfig();
      this.rocketTailSprite.anims.play(animation_default.ROCKET_TAIL.KEY, true);
    }
    onExplosive() {
      this.startExplosive();
      super.onExplosive();
    }
    kill() {
      this.rocketTailSprite.anims.stop();
      super.kill();
    }
    revive() {
      super.revive();
      this.updateRocketTailConfig();
      this.rocketTailSprite.anims.play(animation_default.ROCKET_TAIL.KEY, true);
    }
    updateRocketTailConfig() {
      const size = this.scene.boardManager.boardSizeHandler.getTileSize();
      this.rocketTailSprite.setPosition(-size / 5, size / 5);
      this.rocketTailSprite.setScale(1.3 * this.scene.boardManager.boardSizeHandler.getTileSize() / tile_default.
      SIZE);
    }
    enableTile() {
      super.enableTile();
      this.icon.setScale(this.block.scale);
    }
    startExplosive = () => {
      const { boardManager } = this.scene;
      const { boardContainer } = boardManager;
      const index = boardContainer.count("visible", true) - 1;
      boardContainer.moveTo(this, index);
    };
    changeDeck() {
    }
    drawBlock(frame) {
      const tileSize = this.scene.boardManager.getTileSize();
      this.block = this.scene.add.image(0, 0, KEY37, FRAME32.TILE_BG);
      this.block.setDisplaySize(tileSize, tileSize);
      this.add(this.block);
      this.icon = this.scene.make.sprite({ key: KEY37, frame });
      this.icon.setScale(this.block.scale / 2);
      this.add(this.icon);
    }
  };
  var RocketTile_default = RocketTile;

  // src/game/gameplay/events/combo.ts
  init_phaser_custom_min();
  var COMBO_EVENT = {
    COMBO: "combo",
    RESET: "reset"
  };
  var combo_default = COMBO_EVENT;

  // src/game/gameplay/events/score.ts
  init_phaser_custom_min();
  var SCORE_EVENT = {
    ADD: "add",
    RESET: "reset"
  };
  var score_default = SCORE_EVENT;

  // src/game/gameplay/objects/tiles/NormalTile.ts
  init_phaser_custom_min();
  var NormalTile = class extends BaseTile_default {
    constructor(scene, row, column, color, frame) {
      super(scene, frame, color);
      this.setName("NormalTile");
      this.setRow(row);
      this.setColumn(column);
    }
  };
  var NormalTile_default = NormalTile;

  // src/utils/VibrateUtils.ts
  init_phaser_custom_min();
  var {
    Utils: { Browser: B3 }
  } = Ludex;
  var { player: player11 } = codex;
  var VibrateUtils = class _VibrateUtils {
    static _instance;
    static vibrationProfiles = {
      default: [100]
    };
    static get inst() {
      if (!this._instance) {
        this._instance = new _VibrateUtils();
      }
      return this._instance;
    }
    static addVibrationProfile(name, profile) {
      this.vibrationProfiles[name] = profile;
    }
    static vibrate(value) {
      if (!this.isVibrateEnable()) return;
      this.handleVibrate(value);
    }
    static vibrateUsingProfile(profileName) {
      if (!this.isVibrateEnable()) return;
      let profile = this.vibrationProfiles[profileName];
      if (!profile) {
        console.warn(`Vibration profile ${profileName} not found. Using default profile.`);
        profile = this.vibrationProfiles.default;
      }
      this.handleVibrate(profile);
    }
    static handleVibrate(value) {
      const isSuccess = B3.vibrate(value);
      if (!isSuccess) {
        if ("performHapticFeedbackAsync" in GameSDK.extra) {
          this.useFBInstantHapticFeedback(value);
          return;
        }
        console.warn("Vibrate failed");
      }
    }
    static async useFBInstantHapticFeedback(value) {
      if (!("performHapticFeedbackAsync" in GameSDK.extra)) return;
      const { Time: T15 } = Ludex.Utils;
      const performHapticFeedback = async () => {
        try {
          if ("performHapticFeedbackAsync" in GameSDK.extra) {
            await GameSDK.extra.performHapticFeedbackAsync();
          }
        } catch (error) {
          console.error(error);
        }
      };
      if (Array.isArray(value)) {
        for (let i = 0; i < value.length; i++) {
          const time = value[i];
          if (i % 2 === 0) {
            await performHapticFeedback();
          }
          await T15.sleepAsync(time);
        }
        return;
      }
      await performHapticFeedback();
    }
    static isVibrateEnable() {
      return !!player11.getPlayerSetting("vibrate");
    }
  };
  var VibrateUtils_default = VibrateUtils;

  // src/game/gameplay/managers/TileManager.ts
  var { event: event18, player: player12 } = codex;
  var {
    Utils: { Browser: B5, Valid: V13, Array: A5 }
  } = Ludex;
  var { STATUS: STATUS5 } = manager_default2;
  var { TILES: TILES2 } = sprites_default;
  var { BOMB: BOMB3, ROCKET: ROCKET4 } = tile_default.SPECIALS;
  var { BaseScore, DefaultTheme, EnableVibrate } = GameSettings_default;
  var TileManager = class extends BaseManager_default {
    scene;
    isSelectable = false;
    isFirstInteractionFired$ = false;
    currentDeckPrefix;
    hintTiles = [];
    hintEffect$;
    pathFinder;
    captureWrongPathEffect$;
    capturePathGroup;
    tileShowUpTween$;
    tilesGroup$;
    firstSelectedTile = null;
    isSuggestPairHintShowed;
    matchedPairCount$;
    isExtraPairSpawned$;
    isFirstExtraPairSpawn$;
    remainingExtraTileSpawn$;
    firstTilePosition;
    tilesFadeAnimation$;
    constructor(scene) {
      super(scene);
      this.scene = scene;
      this.pathFinder = new Pathfinder_default();
      this.hintEffect$ = new CaptureHintPath_default(this.scene);
      this.firstTilePosition = new Phaser.Math.Vector2(0, 0);
      this.capturePathGroup = new CapturePathGroup_default(this.scene);
      this.captureWrongPathEffect$ = new CaptureWrongPath_default(this.scene);
      this.tileShowUpTween$ = null;
      this.createGroup$();
      this.listenEvents$();
    }
    init() {
      this.isSelectable = false;
      this.firstSelectedTile = null;
      this.isSuggestPairHintShowed = false;
      this.isFirstInteractionFired$ = false;
      this.clearTiles$();
      const { theme } = this.scene.levelHandler.getConfigs();
      if (!theme || typeof theme === "string") {
        this.currentDeckPrefix = DefaultTheme;
      } else {
        const idx = Phaser.Math.Between(0, theme.length - 1);
        const themeId = theme[idx].toUpperCase();
        const key = TILES2[themeId].KEY;
        if (this.scene.textures.exists(key)) {
          this.currentDeckPrefix = theme[idx];
        } else {
          this.currentDeckPrefix = DefaultTheme;
        }
      }
      this.setState(STATUS5.READY);
    }
    start() {
      if (this.isRunning()) return;
      this.isSelectable = false;
      this.matchedPairCount$ = 0;
      this.isExtraPairSpawned$ = false;
      this.isFirstExtraPairSpawn$ = true;
      this.isFirstInteractionFired$ = false;
      const { rules } = this.scene.levelHandler.getConfigs();
      this.remainingExtraTileSpawn$ = rules.addRandomTilesPerMove || 0;
      this.hintEffect$.clearFirstTilePosition();
      this.capturePathGroup.clearFirstTilePosition();
      this.captureWrongPathEffect$.clearFirstTilePosition();
      if (MatchUtils_default.isChallengeMode()) {
        this.runChallengeModeAnimations$();
      } else {
        this.showUpTilesAnimation$();
      }
      this.setState(STATUS5.RUNNING);
    }
    stop() {
      if (!this.isRunning()) return;
      this.isSelectable = false;
      this.isFirstInteractionFired$ = false;
      this.currentDeckPrefix = "";
      this.removeSuggestPairHint();
      this.clearWrongPath();
      this.capturePathGroup.killAndHideAll();
      this.setState(STATUS5.STOPPED);
    }
    getCurrentDeck() {
      return this.currentDeckPrefix;
    }
    emitInteraction() {
      this.scene.events.emit(tile_default.EVENTS.INTERACTION);
      if (!this.isFirstInteractionFired$) {
        this.isFirstInteractionFired$ = true;
        this.scene.events.emit(tile_default.EVENTS.FIRST_INTERACTION);
      }
    }
    clearWrongPath() {
      this.captureWrongPathEffect$.clear();
    }
    //? tutorial only
    drawWrongPath(path) {
      this.captureWrongPathEffect$.drawNewPath(path);
    }
    createGroup$() {
      this.tilesGroup$ = this.scene.make.group({
        active: false,
        runChildUpdate: false
      });
    }
    listenEvents$() {
      this.scene.events.on(tile_default.EVENTS.ROCKET_EXPLODE, this.handleRocketExplode$);
    }
    getTiles() {
      if (!this.scene || !this.tilesGroup$?.scene) return [];
      const tiles = this.tilesGroup$.getChildren().filter((tile) => {
        return tile instanceof BaseTile_default && tile.active;
      });
      return tiles;
    }
    getAliveTiles() {
      const tiles = this.getTiles();
      const tilesAlive = [];
      for (const tile of tiles) {
        if (tile.isCaptured()) continue;
        if (tile.isCapturing()) continue;
        tilesAlive.push(tile);
      }
      return tilesAlive;
    }
    hideAllTiles() {
      const tiles = this.getAliveTiles();
      if (this.tilesFadeAnimation$) {
        this.tilesFadeAnimation$.stop();
      }
      this.tilesFadeAnimation$ = this.scene.tweens.add({
        targets: tiles,
        props: {
          alpha: 0
        },
        duration: 100
      });
    }
    showAllTiles() {
      const tiles = this.getAliveTiles();
      if (this.tilesFadeAnimation$) {
        this.tilesFadeAnimation$.stop();
      }
      this.tilesFadeAnimation$ = this.scene.tweens.add({
        targets: tiles,
        props: {
          alpha: 1
        },
        duration: 100
      });
    }
    clearTiles$() {
      if (!this.tilesGroup$) return;
      const tiles = this.tilesGroup$.children.getArray();
      for (const tile of tiles) {
        if (tile instanceof BaseTile_default) {
          tile.removeTile();
        }
      }
    }
    getTileExit$(type) {
      const tiles = this.tilesGroup$.getChildren().filter((tile) => {
        return tile instanceof BaseTile_default && tile.active && tile.type === type;
      });
      if (tiles.length < 1) return null;
      return tiles.find((tile) => tile.visible === false && !(tile instanceof BombTile_default)) || null;
    }
    /**
     * @param type number of type string or 'bomb' or 'rocket'
     */
    createTileByType(type, row, column) {
      const tile = this.getTileExit$(type);
      if (tile) {
        tile.changeDeck(this.currentDeckPrefix);
        tile.enableTile();
        tile.setRow(row);
        tile.setColumn(column);
        return tile;
      }
      if (type === ROCKET4) {
        return new RocketTile_default(this.scene, row, column);
      }
      if (type === BOMB3) {
        return new BombTile_default(this.scene, row, column);
      }
      const typeInt = parseInt(type);
      if (typeInt > 28 || typeInt < 1 || !V13.isNumber(typeInt) || type === "empty") {
        return new EmptyTile_default(this.scene, row, column);
      }
      const newTile = new NormalTile_default(this.scene, row, column, type, `tile-${type}`);
      newTile.changeDeck(this.currentDeckPrefix);
      return newTile;
    }
    addTile(tile) {
      this.tilesGroup$.add(tile);
      this.addEventsTile(tile);
    }
    addEventsTile = (tile) => {
      if (!tile.block) return;
      tile.setInteractive({
        useHandCursor: true
      });
      tile.off(Phaser.Input.Events.GAMEOBJECT_POINTER_DOWN);
      tile.on(Phaser.Input.Events.GAMEOBJECT_POINTER_DOWN, this.tileSelect(tile));
      tile.createInput();
    };
    removeEventsAllTiles() {
      const tiles = this.getTiles();
      for (const tile of tiles) {
        tile?.off(Phaser.Input.Events.GAMEOBJECT_POINTER_DOWN);
        tile?.disableInteractive();
      }
    }
    addEventsAllAliveTiles() {
      const tiles = this.getAliveTiles();
      for (const tile of tiles) {
        tile?.setInteractive({
          useHandCursor: true
        });
        tile?.off(Phaser.Input.Events.GAMEOBJECT_POINTER_DOWN);
        tile?.on(Phaser.Input.Events.GAMEOBJECT_POINTER_DOWN, this.tileSelect(tile));
        tile.createInput();
      }
    }
    tileCapture$(tile) {
      if (!this.isTileCapturingAvailable$()) return;
      if (this.firstSelectedTile === tile) {
        this.firstSelectedTile = null;
      }
      tile.setState(tile_default.STATUS.CAPTURED);
    }
    removeTile(tile) {
      if (!tile) return;
      const { boardManager } = this.scene;
      const { boardContainer, tileMap } = boardManager;
      const { row, column } = tile;
      if (tileMap?.[row]?.[column]) {
        tileMap[row][column] = "?";
      }
      tile.nextX = null;
      tile.nextY = null;
      tile.setVisible(false);
      boardContainer.remove(tile);
      this.tilesGroup$.killAndHide(tile);
    }
    runChallengeModeAnimations$() {
      const tiles = [...this.getTiles()];
      tiles.reverse();
      const { animationManager, effectManager } = this.scene;
      effectManager.playChallengeFriendsStartAnimation();
      const originProps = animationManager.prepareStartBoardAnimation(tiles);
      this.scene.time.delayedCall(1600, () => {
        const tween = animationManager.runStartBoardAnimation(tiles, originProps);
        this.tileShowUpTween$ = tween;
        this.handleStartBoardAnimationComplete$(tiles, tween);
      });
    }
    showUpTilesAnimation$() {
      const tiles = [...this.getTiles()];
      tiles.reverse();
      const { animationManager } = this.scene;
      const tween = animationManager.startBoard(tiles);
      this.tileShowUpTween$ = tween;
      this.handleStartBoardAnimationComplete$(tiles, tween);
    }
    handleStartBoardAnimationComplete$(tiles, tween) {
      tween.once(Phaser.Tweens.Events.TWEEN_COMPLETE, () => {
        this.scene.tweens.killTweensOf(tiles);
        for (const tile of tiles) {
          tile.setAlpha(1);
        }
        this.isSelectable = true;
        this.tileShowUpTween$ = null;
        this.hintEffect$.updateFirstTilePosition();
        this.capturePathGroup.updateFirstTilePosition();
        this.captureWrongPathEffect$.updateFirstTilePosition();
        this.getLocalFirstTilePosition$();
        this.setUpAllBombTilesWhenGameStarts$();
        event18.emit(game_default.TILE_SHOWED_UP);
      });
    }
    setUpAllBombTilesWhenGameStarts$() {
      const { boardMap } = this.scene.boardManager;
      if (!boardMap) return;
      if (!boardMap[1]) return;
      const height = Object.keys(boardMap).length;
      const width = Object.keys(boardMap[1]).length;
      for (let row = 1; row <= height; row++) {
        if (!boardMap[row]) continue;
        for (let column = 1; column <= width; column++) {
          if (!boardMap[row][column]) continue;
          const tile = boardMap[row][column];
          if (tile instanceof BombTile_default) {
            tile.setBombEffectWhenGameStarts();
          }
        }
      }
    }
    getLocalFirstTilePosition$() {
      const { boardMap } = this.scene.boardManager;
      if (!boardMap) return;
      if (!boardMap[1]) return;
      if (!boardMap[1][1]) return;
      const { x, y } = boardMap[1][1];
      this.firstTilePosition = new Phaser.Math.Vector2(x, y);
    }
    isCanMove() {
      if (!this.isRunning()) return false;
      if (this.scene.boardManager.checkIfAllTilesAreCaptured()) return false;
      return true;
    }
    processOutOfMove() {
      if (!this.isRunning()) return;
      const tiles = this.getTiles();
      for (const tile of tiles) {
        if (tile.isCaptured()) continue;
        this.tileCapture$(tile);
        this.removeTile(tile);
      }
      this.scene.finishLevel();
    }
    isHavingBomb() {
      const { levelHandler } = this.scene;
      const levelConfig = levelHandler.getConfigs();
      if (levelConfig.specials) {
        if (!levelConfig.specials.bomb) return false;
        if (levelConfig.specials.bomb === 0) return false;
      }
      const tiles = this.getAliveTiles();
      for (let i = 0; i < tiles.length; i++) {
        const element = tiles[i];
        if (element instanceof BombTile_default && !element.isDefuse()) {
          return true;
        }
      }
      return false;
    }
    getPairsOfTilesCanCapture(numOfPairs) {
      const tilesCanCapture = [];
      const tiles = this.getTiles();
      A5.shuffle(tiles);
      for (const tile of tiles) {
        if (tile.isCaptured()) continue;
        if (tile.isCapturing()) continue;
        const tiles2 = this.getPairTilesSameColor$(tile, tilesCanCapture);
        if (tiles2.length !== 2) continue;
        tilesCanCapture.push(tiles2[0], tiles2[1]);
        if (tilesCanCapture.length === numOfPairs * 2) break;
      }
      return tilesCanCapture;
    }
    suggestPairHint() {
      if (!this.isRunning()) return;
      if (this.isSuggestPairHintShowed) return;
      const path = this.getValidPairTilesSameColorPath$();
      if (!path || path.length === 0) return;
      const { x: row1 = 1, y: column1 = 1 } = path[0];
      const { x: row2 = 1, y: column2 = 1 } = path[path.length - 1];
      const { boardMap } = this.scene.boardManager;
      const tile1 = boardMap[row1][column1];
      const tile2 = boardMap[row2][column2];
      this.isSuggestPairHintShowed = true;
      this.hintEffect$.drawNewPath(path);
      this.scene.effectManager.playTileHintEffect(tile1, tile2);
      AudioUtils_default.playSound(soundEffects_default.HINT_ITEM);
    }
    removeSuggestPairHint() {
      this.hintEffect$.clear();
      this.hintTiles = [];
      this.isSuggestPairHintShowed = false;
      this.scene.effectManager.stopTileHintEffect();
    }
    hideHintEffect() {
      if (!this.isSuggestPairHintShowed) return;
      this.scene.effectManager.tileHintEffect.hide();
      this.hintEffect$.hideHintEffect();
    }
    showHintEffect() {
      if (!this.isSuggestPairHintShowed) return;
      this.scene.effectManager.tileHintEffect.show();
      this.hintEffect$.showHintEffect();
    }
    tileSelect = (tile) => () => {
      if (!this.isSelectable) return;
      if (tile.isCapturing() || tile.isCaptured()) return;
      const { itemManager, boardManager, animationManager } = this.scene;
      this.emitInteraction();
      this.removeSuggestPairHint();
      if (itemManager.itemActive !== "") {
        const success = itemManager.applyItem(tile);
        if (success) return;
      }
      itemManager.setIsUseableItem(true);
      let targets = [];
      const path = this.createPathFromTile$(tile);
      if (V13.isBoolean(path)) return;
      if (path === null) {
        const { levelHandler, tutorialManager } = this.scene;
        const { level } = levelHandler;
        if (tutorialManager.isLevelShowWrongPath(level) && !MatchUtils_default.isTournamentMode()) {
          this.createWrongPath$(tile);
        }
        AudioUtils_default.playSound(soundEffects_default.INVALID_MATCH);
        if (animationManager.isMoveTilesCompleted) {
          const tiles = [...this.getTiles()];
          animationManager.pairWrong(tiles);
        }
        this.firstSelectedTile?.hideHighlight();
        this.firstSelectedTile = null;
        return;
      }
      this.captureWrongPathEffect$.clear();
      const { x = 0, y = 0 } = path[0];
      const { boardMap } = boardManager;
      const firstTile = boardMap[x][y];
      targets = [firstTile, tile];
      this.firstSelectedTile = null;
      this.tilesCapturing(targets, path);
      this.startVibrate$(targets.length);
    };
    createPathFromTile$(tile) {
      if (!this.firstSelectedTile) {
        tile.showHighlight();
        this.firstSelectedTile = tile;
        AudioUtils_default.playSound(soundEffects_default.TILE_SELECT);
        return false;
      }
      if (this.firstSelectedTile === tile) {
        tile.hideHighlight();
        this.firstSelectedTile = null;
        AudioUtils_default.playSound(soundEffects_default.TILE_SELECT);
        return false;
      }
      if (this.firstSelectedTile.isCaptured() || this.firstSelectedTile.isCapturing()) {
        this.firstSelectedTile = tile;
        return false;
      }
      const { row: row1, column: column1, color: color1 } = this.firstSelectedTile;
      const { row: row2, column: column2, color: color2 } = tile;
      if (color1 !== color2) {
        this.firstSelectedTile.hideHighlight();
        tile.showHighlight();
        this.firstSelectedTile = tile;
        AudioUtils_default.playSound(soundEffects_default.TILE_SELECT);
        return false;
      }
      const grid = this.getCurrentGrid$(row1, column1, row2, column2);
      for (const row of grid) {
        row.push(0);
        row.unshift(0);
      }
      grid.push(new Array(grid[0].length).fill(0));
      grid.unshift(new Array(grid[0].length).fill(0));
      const path = this.pathFinder.findPath({ x: row1, y: column1 }, { x: row2, y: column2 }, grid);
      return path;
    }
    createWrongPath$(tile) {
      if (!this.firstSelectedTile) return;
      const { levelHandler } = this.scene;
      const { level } = levelHandler;
      let path = null;
      const { row: row1, column: column1 } = this.firstSelectedTile;
      const { row: row2, column: column2 } = tile;
      if (level === 1 && row1 === 1 && column1 === 2 && row2 === 4 && column2 === 2) {
        path = [];
        path.push(new Phaser.Math.Vector2(1, 2));
        path.push(new Phaser.Math.Vector2(4, 2));
        this.scene.events.emit(tile_default.EVENTS.NO_PATH_FOUND, "obstacle");
      } else if (level === 1 && row1 === 4 && column1 === 2 && row2 === 1 && column2 === 2) {
        path = [];
        path.push(new Phaser.Math.Vector2(4, 2));
        path.push(new Phaser.Math.Vector2(1, 2));
        this.scene.events.emit(tile_default.EVENTS.NO_PATH_FOUND, "obstacle");
      } else {
        const grid = this.getCurrentGrid$(row1, column1, row2, column2);
        for (const row of grid) {
          row.push(0);
          row.unshift(0);
        }
        grid.push(new Array(grid[0].length).fill(0));
        grid.unshift(new Array(grid[0].length).fill(0));
        path = this.pathFinder.findWrongPath({ x: row1, y: column1 }, { x: row2, y: column2 }, grid);
        const turns = this.pathFinder.getTurnsOfPath(path);
        if (turns <= 2) {
          this.scene.events.emit(tile_default.EVENTS.NO_PATH_FOUND, "obstacle");
        } else {
          this.scene.events.emit(tile_default.EVENTS.NO_PATH_FOUND, "more_than_turns");
        }
      }
      this.captureWrongPathEffect$.drawNewPath(path);
    }
    getCurrentGrid$(row1 = -1, column1 = -1, row2 = -1, column2 = -1) {
      const grid = [];
      const { boardMap } = this.scene.boardManager;
      const height = Object.keys(boardMap).length;
      for (let i = 1; i <= height; i++) {
        const row = boardMap[i];
        const width = Object.keys(row).length;
        const rowArr = [];
        for (let j = 1; j <= width; j++) {
          const tile = row[j];
          if (tile.isCaptured() || tile.isCapturing() || i === row1 && j === column1 || i === row2 &&
          j === column2) {
            rowArr.push(0);
          } else {
            rowArr.push(1);
          }
        }
        grid.push(rowArr);
      }
      return grid;
    }
    getValidPairTilesSameColorPath$() {
      const tiles = this.getTiles();
      const tilesAlive = [];
      for (const tile of tiles) {
        if (tile.isCaptured()) continue;
        if (tile.isCapturing()) continue;
        tilesAlive.push(tile);
      }
      if (tilesAlive.length < 2) return [];
      const grid = this.getCurrentGrid$();
      for (const row of grid) {
        row.push(0);
        row.unshift(0);
      }
      grid.push(new Array(grid[0].length).fill(0));
      grid.unshift(new Array(grid[0].length).fill(0));
      for (let i = 0; i < tilesAlive.length; i++) {
        const first = tilesAlive[i];
        const { row: row1, column: column1 } = first;
        grid[row1][column1] = 0;
        for (let j = i + 1; j < tilesAlive.length; j++) {
          const second = tilesAlive[j];
          if (first.color !== second.color) continue;
          const { row: row2, column: column2 } = second;
          grid[row2][column2] = 0;
          const path = this.pathFinder.findPath({ x: row1, y: column1 }, { x: row2, y: column2 }, grid);
          if (path) {
            this.hintTiles = [first, second];
            return path;
          }
          grid[row2][column2] = 1;
        }
        grid[row1][column1] = 1;
      }
      return null;
    }
    /**
     * Find tiles with the same color without have a path
     */
    getPairTilesSameColor$(originTile, excludeList = []) {
      if (excludeList.includes(originTile)) return [];
      const targets = [];
      targets.push(originTile);
      for (const tile of this.getTiles()) {
        if (tile.isCaptured()) continue;
        if (tile.isCapturing()) continue;
        if (tile === originTile) continue;
        if (tile.color === originTile.color && !excludeList.includes(tile)) {
          targets.push(tile);
          break;
        }
      }
      return targets;
    }
    tilesChangeColor(color, tiles) {
      const { boardManager } = this.scene;
      for (const tile of tiles) {
        const { row, column, x, y } = tile;
        this.removeTile(tile);
        const newTile = this.createTileByType(color, row, column);
        boardManager.setTileToMap(newTile, row, column);
        newTile.setX(x);
        newTile.setY(y);
      }
    }
    getCapturingTiles$() {
      const tiles = this.getTiles();
      const capturingTiles = [];
      for (const tile of tiles) {
        if (tile.isCapturing()) capturingTiles.push(tile);
      }
      return capturingTiles;
    }
    tilesCapturing(targets, path) {
      if (!this.isTileCapturingAvailable$()) return;
      const { animationManager, modeManager, itemManager } = this.scene;
      this.removeSuggestPairHint();
      itemManager.setIsUseableItem(false);
      for (const tile of targets) {
        this.tileCapture$(tile);
      }
      this.matchedPairCount$ += targets.length / 2;
      const capturePath = this.capturePathGroup.requestPath();
      if (path) {
        capturePath.setScore(5 * targets.length);
        capturePath.drawNewPath(path);
      } else {
        this.scene.eatScore(5 * targets.length);
      }
      this.processRocketTiles$(targets);
      this.scene.events.emit(tile_default.EVENTS.CAPTURING);
      animationManager.capturing(targets);
      this.processButterflyCaptureEffect$(targets);
      this.scene.time.addEvent({
        delay: 400,
        callback: () => {
          this.capturePathGroup.killPath(capturePath);
        }
      });
      const capturingTiles = this.getCapturingTiles$();
      if (capturingTiles.length < 1) {
        modeManager.processGravityMode();
      }
      this.scene.events.emit(combo_default.COMBO);
      this.scene.events.emit(score_default.ADD, BaseScore);
      MissionUtils_default.addMatchPairsMissionProgress(Math.floor(targets.length / 2));
    }
    handleRocketExplode$ = (targets) => {
      this.tilesCapturing(targets);
    };
    processRocketTiles$(targets) {
      if (!this.isTileCapturingAvailable$()) return;
      const numOfRocketTiles = targets.filter((tile) => tile instanceof RocketTile_default).length;
      const isRocketMatch = numOfRocketTiles > 0;
      if (!isRocketMatch) return;
      const { effectManager } = this.scene;
      const extraTargets = this.getPairsOfTilesCanCapture(numOfRocketTiles / 2);
      const matchedRocketTiles = targets.filter((tile) => tile instanceof RocketTile_default);
      for (const tile of extraTargets) {
        tile.setState(tile_default.STATUS.CAPTURING);
      }
      matchedRocketTiles.forEach((tile, index) => {
        if (index >= extraTargets.length) return;
        if (!(tile instanceof RocketTile_default)) return;
        const rocketTarget = extraTargets[index];
        const { x, y } = tile.getWorldPosition();
        const startingPosition = new Phaser.Math.Vector2(x, y);
        effectManager.requestTileRocketEffect(startingPosition, rocketTarget);
      });
      effectManager.playTileRocketEffects();
    }
    processButterflyCaptureEffect$(targets) {
      if (this.currentDeckPrefix !== "butterfly" || !this.isTileCapturingAvailable$()) return;
      const butterflyTiles = /* @__PURE__ */ new Map();
      for (const tile of targets) {
        const frameName = tile.getIcon().frame.name;
        if (frameName.includes("tile-")) {
          if (!butterflyTiles.has(frameName)) {
            butterflyTiles.set(frameName, []);
          }
          const butterflyTileList = butterflyTiles.get(frameName);
          if (butterflyTileList) butterflyTileList.push(tile);
        }
      }
      if (butterflyTiles.size < 1) return;
      const { effectManager } = this.scene;
      for (const tiles of butterflyTiles.values()) {
        if (tiles.length < 2) continue;
        const tilePairLength = Math.floor(tiles.length / 2);
        for (let i = 0; i < tilePairLength; i++) {
          const tile1 = tiles[i * 2];
          const tile2 = tiles[i * 2 + 1];
          effectManager.playButterflyCaptureEffect(tile1, tile2);
        }
      }
    }
    handleExtraSpawn() {
      if (this.remainingExtraTileSpawn$ === 0) return false;
      const { tileManager } = this.scene;
      if (this.isFirstExtraPairSpawn$) {
        if (this.matchedPairCount$ < 5) return false;
        this.isFirstExtraPairSpawn$ = false;
        tileManager.spawnExtraPair$();
        return true;
      }
      const isReadyToSpawn = (this.matchedPairCount$ - 5) % 2 === 0;
      if (!isReadyToSpawn) {
        this.isExtraPairSpawned$ = false;
        return false;
      }
      if (this.isExtraPairSpawned$) return false;
      tileManager.spawnExtraPair$();
      return true;
    }
    spawnExtraPair$() {
      this.remainingExtraTileSpawn$ -= 1;
      const { boardManager, levelHandler } = this.scene;
      const { boardMap, boardContainer } = boardManager;
      const { colors } = levelHandler.getConfigs();
      const freeSpaces = this.findFreeSpacesInBoard$();
      if (freeSpaces.length < 2) {
        this.remainingExtraTileSpawn$++;
        return;
      }
      AudioUtils_default.playSound(soundEffects_default.EXTRA_TILE_SPAWN);
      freeSpaces.sort(() => Math.random() - 0.5);
      const colorId = Phaser.Math.RND.between(1, colors);
      const { row: row1, column: col1 } = freeSpaces[0];
      const { row: row2, column: col2 } = freeSpaces[1];
      const tile1 = this.createTileByType(colorId.toString(), row1, col1);
      const tile2 = this.createTileByType(colorId.toString(), row2, col2);
      this.addTile(tile1);
      this.addTile(tile2);
      boardMap[row1][col1] = tile1;
      boardMap[row2][col2] = tile2;
      const { x, y } = this.firstTilePosition;
      tile1.setVisible(false);
      tile2.setVisible(false);
      boardContainer.add(tile1);
      boardContainer.add(tile2);
      const tileSize = this.scene.boardManager.getTileSizeWithSpacing();
      tile1.setPosition(x + (col1 - 1) * tileSize, y + (row1 - 1) * tileSize);
      tile2.setPosition(x + (col2 - 1) * tileSize, y + (row2 - 1) * tileSize);
      tile1.runExtraSpawnEffect();
      tile2.runExtraSpawnEffect();
      tile1.setVisible(true);
      tile2.setVisible(true);
      this.isExtraPairSpawned$ = true;
    }
    findFreeSpacesInBoard$() {
      const { boardMap } = this.scene.boardManager;
      const freeSpaces = [];
      const height = Object.keys(boardMap).length;
      const width = Object.keys(boardMap[1]).length;
      for (let row = 1; row <= height; row++) {
        for (let column = 1; column <= width; column++) {
          const tile = boardMap[row][column];
          if (!tile.isCaptured()) continue;
          freeSpaces.push({ row, column });
        }
      }
      return freeSpaces;
    }
    startVibrate$(eatCount) {
      try {
        if (!EnableVibrate) return;
        if (eatCount <= 4) return;
        const isEnableVibrate = player12.getPlayerSetting("vibrate");
        if (!isEnableVibrate) return;
        if (eatCount <= 6) {
          VibrateUtils_default.vibrate(340);
          return;
        }
        if (eatCount <= 8) {
          VibrateUtils_default.vibrate(410);
          return;
        }
        if (eatCount <= 9) {
          VibrateUtils_default.vibrate(480);
          return;
        }
        if (eatCount > 9) {
          VibrateUtils_default.vibrate(600);
          return;
        }
      } catch (error) {
        console.warn("Vibrate error", error);
      }
    }
    isTileCapturingAvailable$() {
      return this.isRunning() && (!this.tileShowUpTween$ || !this.tileShowUpTween$.isPlaying());
    }
    handleBombTimerRescue = () => {
      this.scene.events.emit(tile_default.EVENTS.BOMB_TIMER_RESCUE);
      const tiles = this.getAliveTiles();
      for (const tile of tiles) {
        if (tile instanceof BombTile_default) {
          tile.handleInteractionEventAfterRescue();
        }
      }
    };
  };
  var TileManager_default = TileManager;

  // src/game/gameplay/managers/TutorialManager.ts
  init_phaser_custom_min();

  // src/game/components/DoubleTapTutorialHand.ts
  init_phaser_custom_min();
  var { KEY: KEY38, FRAME: FRAME33 } = sprites_default.TUTORIAL;
  var DoubleTapTutorialHand = class extends Phaser.GameObjects.Container {
    hand;
    circleHighlight;
    circleHighlightOriginScale;
    toGlobalX = 0;
    toGlobalY = 0;
    constructor(scene) {
      super(scene);
      this.name = "DoubleTapTutorialHand";
      this.addHand();
      this.addCircleHighlight();
      this.bringToTop(this.hand);
      this.scene.add.existing(this);
    }
    addHand() {
      this.hand = this.scene.make.image({
        key: KEY38,
        frame: FRAME33.HAND,
        origin: { x: 0, y: 0 }
      });
      this.add(this.hand);
    }
    addCircleHighlight() {
      this.circleHighlight = this.scene.make.image({
        key: KEY38,
        frame: FRAME33.CIRCLE_HIGHLIGHT,
        origin: { x: 0.5, y: 0.5 }
      });
      this.circleHighlightOriginScale = this.circleHighlight.scale;
      this.add(this.circleHighlight);
      this.circleHighlight.setAlpha(0);
    }
    setTarget(x, y) {
      this.toGlobalX = x;
      this.toGlobalY = y;
    }
    playAnimation(startDelay, repeatDelay, highLightDiameterMaxSize) {
      this.circleHighlight.setWorldSize(highLightDiameterMaxSize, highLightDiameterMaxSize);
      this.circleHighlightOriginScale = this.circleHighlight.scale;
      this.scene.tweens.killTweensOf(this.hand);
      this.hand.x = 0;
      this.hand.y = 0;
      this.hand.angle = 0;
      this.hand.setPosition(0, 0);
      this.hand.setAlpha(1);
      this.runTapTween(true, startDelay, repeatDelay);
    }
    runTapTween(isGoingToTarget, startDelay = 0, repeatDelay = 800) {
      this.scene?.tweens.add({
        delay: startDelay,
        targets: [this.hand],
        onStart: () => {
          this.scene?.tweens.killTweensOf(this.circleHighlight);
          this.circleHighlight.setScale(this.circleHighlightOriginScale / 4);
          this.circleHighlight.setAlpha(1);
          this.circleHighlight.setPosition(this.hand.x + 5, this.hand.y);
          this.scene?.tweens.add({
            targets: [this.circleHighlight],
            duration: 500,
            props: {
              scale: {
                start: this.circleHighlightOriginScale / 6,
                value: this.circleHighlightOriginScale
              },
              alpha: {
                start: 1,
                value: 0
              }
            },
            ease: Phaser.Math.Easing.Cubic.Out
          });
        },
        ease: Phaser.Math.Easing.Cubic.Out,
        props: {
          scale: {
            duration: 200,
            start: 1,
            to: 0.8
          }
          // angle: { from: 30, value: 0, duration: 200 },
        },
        hold: 84,
        yoyo: true,
        onComplete: () => {
          const toX = this.toGlobalX - this.x;
          const toY = this.toGlobalY - this.y;
          if (isGoingToTarget) {
            this.runMoveTween(0, 0, toX, toY, 300, repeatDelay);
          } else {
            this.runMoveTween(toX, toY, 0, 0, 300, repeatDelay);
          }
        }
      });
    }
    runMoveTween(startX, startY, toX, toY, startDelay = 0, repeatDelay = 800) {
      this.scene?.tweens.add({
        delay: startDelay,
        targets: [this.hand],
        ease: Phaser.Math.Easing.Cubic.Out,
        props: {
          x: {
            from: startX,
            to: toX,
            duration: 284
          },
          y: {
            from: startY,
            to: toY,
            duration: 284
          }
        },
        onComplete: () => {
          this.runTapTween(toX === 0 && toY === 0, 50, repeatDelay);
        }
      });
    }
    stopAnimation() {
      this.scene.tweens.killTweensOf(this.hand);
    }
    kill() {
      super.kill();
    }
    revive() {
      super.revive();
    }
    destroy(fromScene) {
      super.destroy(fromScene);
    }
    preDestroy() {
      this.scene.tweens.killTweensOf(this.hand);
    }
  };
  var DoubleTapTutorialHand_default = DoubleTapTutorialHand;

  // src/game/components/GuideTextBox.ts
  init_phaser_custom_min();
  var { KEY: KEY39, FRAME: FRAME34 } = sprites_default.TUTORIAL;
  var GuideTextBox = class extends Phaser.GameObjects.Container {
    text;
    constructor(scene) {
      super(scene);
      this.createBox();
      this.createText();
      this.scene.add.existing(this);
    }
    createBox() {
      const mid = this.scene.make.image({
        key: KEY39,
        frame: FRAME34.MIDDLE_PANEL,
        origin: { x: 0.5, y: 0.5 }
      });
      mid.setWorldSize(276, 21.5);
      this.add(mid);
      const top = this.scene.make.image({
        key: KEY39,
        frame: FRAME34.TOP_PANEL,
        origin: { x: 0.5, y: 1 }
      });
      top.setWorldSize(276, 21.5);
      top.setY(-mid.displayHeight / 2);
      this.add(top);
      const bottom = this.scene.make.image({
        key: KEY39,
        frame: FRAME34.BOTTOM_PANEL,
        origin: { x: 0.5, y: 0 }
      });
      bottom.setWorldSize(276, 21.5);
      bottom.setY(mid.displayHeight / 2);
      this.add(bottom);
      this.setSize(mid.displayWidth, mid.displayHeight + top.displayHeight + bottom.displayHeight);
    }
    createText() {
      const text = FontUtils_default.createText(this.scene, "", 17).setFontStyle("700").setAlign("ce\
nter");
      FontUtils_default.applyWoodStyle(text);
      text.setY(-2);
      this.add(text);
      this.text = text;
    }
    setText(text, highLightText) {
      this.text.setText(text);
      this.text.charColors = [];
      if (highLightText) {
        for (const text2 of highLightText) {
        }
      }
    }
    playFadeInAnimation() {
      this.scene.tweens.killTweensOf(this);
      this.setAlpha(0);
      this.scene.tweens.add({
        targets: this,
        alpha: 1,
        duration: 316,
        ease: "Linear"
      });
    }
    playFadeOutAnimation() {
      this.scene.tweens.killTweensOf(this);
      this.scene.tweens.add({
        targets: this,
        alpha: 0,
        duration: 316,
        ease: "Linear"
      });
    }
  };
  var GuideTextBox_default = GuideTextBox;

  // src/game/gameplay/tutorials/Guide01Newbie.ts
  init_phaser_custom_min();
  var { event: event19, analytics: analytics4 } = codex;
  var {
    Plugins: {
      Analytics: { Events: AnalyticsEvents4 }
    }
  } = Ludex;
  var Guide01Newbie = class {
    scene;
    manager;
    isStep1Analyzed;
    isStep2Analyzed;
    hintOrder = [
      // [2, 5, 5, 1],
      // [1, 1, 5, 5],
      // [2, 2, 4, 5],
      // [2, 1, 2, 3],
      // [4, 1, 5, 2],
      // [1, 2, 4, 2],
      // [1, 3, 1, 4],
      [1, 2, 4, 2],
      [4, 1, 5, 2],
      [1, 5, 3, 1],
      [2, 4, 3, 5],
      [3, 2, 3, 4]
    ];
    isRunning = false;
    constructor(manager) {
      this.manager = manager;
      this.scene = manager.scene;
    }
    setup() {
      this.isStep1Analyzed = false;
      this.isStep2Analyzed = false;
      event19.once(game_default.TILE_SHOWED_UP, this.startGuide);
      event19.once(game_default.FINISH, this.closeTutorial);
      this.manager.background.setDepth(depth_default.EFFECT);
    }
    startGuide = () => {
      const { tileManager, uiManager, boardManager } = this.scene;
      const { boardContainer } = boardManager;
      this.isRunning = true;
      boardContainer.add(this.manager.background);
      uiManager.disableUILogicForGuide1();
      tileManager.removeEventsAllTiles();
      this.manager.runShowMaskAnimation(0.4);
      this.createHint();
    };
    createHint = () => {
      if (!this.isRunning) return;
      const hint = this.hintOrder.pop();
      if (!hint) {
        this.manager.runHideMaskAnimation();
        this.scene.tileManager.addEventsAllAliveTiles();
        this.setBoxText("Clear all tiles\nto win");
        this.scene.events.once(tile_default.EVENTS.INTERACTION, this.handleCloseTextBox);
        this.scene.events.on(tile_default.EVENTS.CAPTURING, this.handlePlaySound);
        this.scene.events.on(tile_default.EVENTS.NO_PATH_FOUND, this.handleNoPathFoundShowInfo);
        return;
      }
      this.showBoxText();
      const row1 = hint[0];
      const col1 = hint[1];
      const row2 = hint[2];
      const col2 = hint[3];
      const { tileManager } = this.scene;
      const { boardMap, boardContainer } = this.scene.boardManager;
      boardContainer.bringToTop(this.manager.background);
      const currentTile1 = boardMap[row1][col1];
      const { x: fromX, y: fromY } = currentTile1.getWorldPosition();
      tileManager.addEventsTile(currentTile1);
      boardContainer.bringToTop(currentTile1);
      const currentTile2 = boardMap[row2][col2];
      const { x: toX, y: toY } = currentTile2.getWorldPosition();
      tileManager.addEventsTile(currentTile2);
      boardContainer.bringToTop(currentTile2);
      this.createHandAt(fromX, fromY, toX, toY);
      this.scene.events.once(tile_default.EVENTS.INTERACTION, this.handleInteract);
    };
    showBoxText() {
      if (this.hintOrder.length === 4) {
        this.setBoxText("Tap to connect");
      } else if (this.hintOrder.length === 3) {
        this.setBoxText("Connect similar tiles with\nless than 2 turns", ["2"]);
      } else if (this.hintOrder.length === 0) {
        this.manager.textBox.playFadeOutAnimation();
      }
    }
    setBoxText(text, highlightText) {
      const textBox = this.manager.textBox;
      textBox.revive();
      textBox.setText(text, highlightText);
      textBox.setDepth(depth_default.EFFECT);
      const { height } = this.scene.boardManager.boardSizeHandler.getBoardSize();
      if (WorldUtils_default.isLandscape()) {
        Phaser.Display.Align.In.TopCenter(textBox, this.scene.gameZone, 0, -25);
      } else {
        Phaser.Display.Align.In.Center(textBox, this.scene.gameZone, 0, height / 2 + textBox.displayHeight /
        2 + 50);
      }
      textBox.playFadeInAnimation();
    }
    handleCloseTextBox = () => {
      this.manager.textBox.playFadeOutAnimation();
    };
    timer;
    /**
     * event that exist after showing mandatory tutorial
     */
    handleNoPathFoundShowInfo = (reason) => {
      const { tileManager } = this.scene;
      if (reason === "more_than_turns") {
        this.setBoxText("More than 2 turns\nare NOT allowed", ["2", "NOT allowed"]);
      } else if (reason === "obstacle") {
        this.setBoxText("There's obstacle between\nthe tiles", ["obstacle"]);
      }
      this.timer?.remove();
      this.timer = this.scene.time.delayedCall(1966, () => {
        tileManager.clearWrongPath();
        this.manager.textBox.playFadeOutAnimation();
      });
    };
    handlePlaySound = () => {
      AudioUtils_default.playSound(soundEffects_default.COMBO_1);
    };
    handleNoPathFound = (reason) => {
      this.scene.events.off(tile_default.EVENTS.CAPTURING, this.handleCapturing);
      const { tileManager } = this.scene;
      tileManager.removeEventsAllTiles();
      if (!this.isStep2Analyzed) {
        analytics4.event(AnalyticsEvents4.TUTORIAL_STEP, {
          step: 2
        });
        this.isStep2Analyzed = true;
      }
      if (reason === "more_than_turns") {
        this.setBoxText("More than 2 turns\nare NOT allowed", ["2", "NOT allowed"]);
      } else if (reason === "obstacle") {
        this.setBoxText("There's obstacle between\nthe tiles", ["obstacle"]);
      }
      this.scene.time.delayedCall(800, () => {
        tileManager.clearWrongPath();
        let delayTime = 100;
        if (this.hintOrder.length === 1 || this.hintOrder.length === 0) {
          delayTime = 600;
        }
        this.scene.time.delayedCall(delayTime, () => {
          this.createHint();
        });
      });
    };
    handleCapturing = () => {
      this.scene.events.off(tile_default.EVENTS.NO_PATH_FOUND, this.handleNoPathFound);
      AudioUtils_default.playSound(soundEffects_default.COMBO_1);
      if (!this.isStep1Analyzed) {
        analytics4.event(AnalyticsEvents4.TUTORIAL_STEP, {
          step: 1
        });
        this.isStep1Analyzed = true;
      }
      this.scene.time.delayedCall(300, () => {
        this.createHint();
      });
    };
    handleInteract = () => {
      if (this.hintOrder.length !== 3) {
        this.manager.textBox.playFadeOutAnimation();
      }
      this.manager.hand.stopAnimation();
      this.manager.hand.kill();
      this.scene.events.once(tile_default.EVENTS.CAPTURING, this.handleCapturing);
      this.scene.events.once(tile_default.EVENTS.NO_PATH_FOUND, this.handleNoPathFound);
    };
    createHandAt(x, y, toX, toY) {
      if (!this.isRunning) return;
      this.manager.hand.setDepth(depth_default.ON_TOP);
      this.manager.hand.setPosition(x - 5, y);
      this.manager.hand.revive();
      this.manager.hand.setTarget(toX - 5, toY);
      this.manager.hand.stopAnimation();
      const tileSize = this.scene.boardManager.boardSizeHandler.getTileSize();
      this.manager.hand.playAnimation(300, 0, tileSize * 1.2);
    }
    closeTutorial = () => {
      event19.off(game_default.TILE_SHOWED_UP, this.startGuide);
      this.scene.events.off(tile_default.EVENTS.INTERACTION, this.handleInteract);
      this.scene.events.off(tile_default.EVENTS.CAPTURING, this.handleCapturing);
      this.scene.events.off(tile_default.EVENTS.NO_PATH_FOUND, this.handleNoPathFound);
      this.scene.events.off(tile_default.EVENTS.NO_PATH_FOUND, this.handleNoPathFoundShowInfo);
      this.scene.events.off(tile_default.EVENTS.CAPTURING, this.handlePlaySound);
      this.scene.events.off(tile_default.EVENTS.INTERACTION, this.handleCloseTextBox);
      const { boardContainer } = this.scene.boardManager;
      boardContainer.remove(this.manager.background, false);
      Phaser.Display.Align.In.Center(this.manager.background, this.scene.gameZone);
      analytics4.event(AnalyticsEvents4.TUTORIAL_STEP, { step: 3 });
      const { objects } = this.scene.layoutManager;
      objects.skipContainer.kill();
      this.manager.textBox.kill();
      this.manager.hand.kill();
      this.isRunning = false;
      this.manager.stopTutorial();
    };
  };
  var Guide01Newbie_default = Guide01Newbie;

  // src/game/gameplay/tutorials/Guide02NoTimer.ts
  init_phaser_custom_min();
  var { event: event20 } = codex;
  var Guide02NoTimer = class {
    scene;
    manager;
    constructor(manager) {
      this.manager = manager;
      this.scene = manager.scene;
    }
    setup() {
      event20.once(game_default.TILE_SHOWED_UP, this.startGuide);
      event20.once(game_default.FINISH, this.closeTutorial);
      event20.once(game_default.DIE, this.closeTutorial);
      event20.on(game_default.PAUSE, this.handlePause);
      event20.on(game_default.RESUME, this.handleResume);
    }
    startGuide = () => {
      const { uiManager } = this.scene;
      uiManager.disableUILogicForGuide2();
      this.manager.listenAutoHintEvent();
      this.manager.startAutoHint();
    };
    closeTutorial = () => {
      event20.off(game_default.TILE_SHOWED_UP, this.startGuide);
      event20.off(game_default.FINISH, this.closeTutorial);
      event20.off(game_default.DIE, this.closeTutorial);
      event20.off(game_default.PAUSE, this.handlePause);
      event20.off(game_default.RESUME, this.handleResume);
      this.manager.stopListenAutoHintEvent();
      this.manager.stopAutoHint();
      this.manager.stopTutorial();
    };
    handlePause = () => {
      this.manager.stopAutoHint();
    };
    handleResume = () => {
      this.manager.startAutoHint();
    };
  };
  var Guide02NoTimer_default = Guide02NoTimer;

  // src/game/gameplay/tutorials/Guide03Timer.ts
  init_phaser_custom_min();
  var { event: event21, analytics: analytics5 } = codex;
  var {
    Plugins: {
      Analytics: { Events: AnalyticsEvents5 }
    }
  } = Ludex;
  var Guide03Timer = class {
    scene;
    manager;
    constructor(manager) {
      this.manager = manager;
      this.scene = manager.scene;
    }
    setup() {
      event21.once(game_default.TILE_SHOWED_UP, this.startGuide);
      event21.once(game_default.FINISH, this.closeTutorial);
      event21.once(game_default.DIE, this.closeTutorial);
      event21.on(game_default.PAUSE, this.handlePause);
      event21.on(game_default.RESUME, this.handleResume);
    }
    startGuide = () => {
      this.createInfo();
      this.manager.listenAutoHintEvent();
      this.manager.startAutoHint();
    };
    createInfo() {
      const { staticHand, infoText } = this.manager;
      const { layoutManager } = this.scene;
      const { objects } = layoutManager;
      const { width, height, x, y } = objects.playtimeClock;
      const padding = 10;
      this.manager.createMask(
        x - width * 0.6 - padding / 2,
        y - height * 0.45 - padding / 2,
        width * 1.05 + padding / 2,
        height + padding / 2
      );
      this.manager.runShowMaskAnimation();
      staticHand.revive();
      staticHand.angle = 30;
      staticHand.setPosition(x, y + 40);
      infoText.revive();
      infoText.setPosition(x + 130, y + 40);
      infoText.setText("Remove all icon tiles before\nthe end of time");
      infoText.setAlign("left");
      this.scene.input.once(Phaser.Input.Events.POINTER_DOWN, this.handlePointerDown);
    }
    handlePointerDown = () => {
      const { infoText, staticHand } = this.manager;
      this.manager.runHideMaskAnimation();
      infoText.kill();
      staticHand.kill();
      analytics5.event(AnalyticsEvents5.TUTORIAL_STEP, { step: 4 });
    };
    closeTutorial = () => {
      event21.off(game_default.TILE_SHOWED_UP, this.startGuide);
      event21.off(game_default.FINISH, this.closeTutorial);
      event21.off(game_default.DIE, this.closeTutorial);
      event21.off(game_default.PAUSE, this.handlePause);
      event21.off(game_default.RESUME, this.handleResume);
      this.manager.stopListenAutoHintEvent();
      this.manager.stopAutoHint();
      this.manager.stopTutorial();
      analytics5.event(AnalyticsEvents5.TUTORIAL_STEP, { step: 5 });
    };
    handlePause = () => {
      this.manager.stopAutoHint();
    };
    handleResume = () => {
      this.manager.startAutoHint();
    };
  };
  var Guide03Timer_default = Guide03Timer;

  // src/game/gameplay/tutorials/Guide04Magnifier.ts
  init_phaser_custom_min();
  var { event: event22, analytics: analytics6 } = codex;
  var {
    Plugins: {
      Analytics: { Events: AnalyticsEvents6 }
    }
  } = Ludex;
  var Guide04Magnifier = class {
    scene;
    manager;
    constructor(manager) {
      this.manager = manager;
      this.scene = manager.scene;
    }
    setup() {
      event22.once(game_default.TILE_SHOWED_UP, this.startGuide);
      event22.once(game_default.FINISH, this.closeTutorial);
      event22.once(game_default.DIE, this.closeTutorial);
      event22.on(game_default.PAUSE, this.handlePause);
      event22.on(game_default.RESUME, this.handleResume);
    }
    startGuide = () => {
      this.createInfo();
      this.manager.listenAutoHintEvent();
    };
    createInfo() {
      const { itemManager, layoutManager } = this.scene;
      const { staticHand, infoText } = this.manager;
      const { objects } = layoutManager;
      itemManager.setDepthItemOnTop(item_default.HINT.ID);
      const { x, y, scale, width, displayWidth, displayHeight } = objects.hintItem;
      this.manager.createMask(
        x - (displayWidth - 2 * scale) / 2,
        y - displayHeight / 2 + 6 * scale,
        (width - 2) * scale,
        (width - 2) * scale,
        (width - 2) * scale / 2
      );
      this.manager.runShowMaskAnimation();
      const isLandscape = WorldUtils_default.isLandscape();
      const handOffsetY = isLandscape ? 30 : -50;
      const infoOffsetX = isLandscape ? -90 : 0;
      const infoOffsetY = isLandscape ? 50 : -90;
      const angle = isLandscape ? 30 : 210;
      staticHand.revive();
      staticHand.angle = angle;
      staticHand.setPosition(x, y + handOffsetY);
      infoText.revive();
      infoText.setPosition(x + infoOffsetX, y + infoOffsetY);
      infoText.setText("Tap to reveal a\nconnectable pair");
      infoText.setAlign("center");
      this.manager.alignInfoTextWithinScreen(isLandscape);
      this.scene.input.once(Phaser.Input.Events.POINTER_UP, this.handlePointerDown);
    }
    handlePointerDown = () => {
      const { itemManager } = this.scene;
      const { infoText, staticHand } = this.manager;
      this.manager.runHideMaskAnimation();
      infoText.kill();
      staticHand.kill();
      itemManager.setPaidItem(item_default.HINT.ID);
      itemManager.setDepthItemNormal(item_default.HINT.ID);
      analytics6.event(AnalyticsEvents6.TUTORIAL_STEP, { step: 6 });
    };
    closeTutorial = () => {
      event22.off(game_default.TILE_SHOWED_UP, this.startGuide);
      event22.off(game_default.FINISH, this.closeTutorial);
      event22.off(game_default.DIE, this.closeTutorial);
      event22.off(game_default.PAUSE, this.handlePause);
      event22.off(game_default.RESUME, this.handleResume);
      this.manager.stopListenAutoHintEvent();
      this.manager.stopAutoHint();
      this.manager.stopTutorial();
      analytics6.event(AnalyticsEvents6.TUTORIAL_STEP, { step: 7 });
    };
    handlePause = () => {
      this.manager.stopAutoHint();
    };
    handleResume = () => {
      this.manager.startAutoHint();
    };
  };
  var Guide04Magnifier_default = Guide04Magnifier;

  // src/game/gameplay/tutorials/Guide05RocketTiles.ts
  init_phaser_custom_min();

  // src/game/gameplay/tutorials/Guide05Popup.ts
  init_phaser_custom_min();
  var { KEY: KEY40, FRAME: FRAME35 } = sprites_default.TUTORIAL;
  var { KEY: DEFAULT_KEY3, FRAME: DEFAULT_FRAME3 } = sprites_default.DEFAULT;
  var Guide05Popup = class extends Phaser.GameObjects.Container {
    popup;
    content;
    failContent;
    onClick;
    goodText;
    tile1;
    rocket1;
    curve1;
    tile5;
    tile4;
    tile7;
    rocket2;
    curve2;
    constructor(scene) {
      super(scene);
      this.scene = scene;
      this.setDepth(depth_default.POPUP);
      this.createPopup();
      this.updateSize();
      this.createTitle();
      this.createContent();
      this.createText();
      this.createButton();
      this.createFail();
      this.scene.add.existing(this);
    }
    createPopup() {
      const popup = this.scene.make.image({
        key: DEFAULT_KEY3,
        frame: DEFAULT_FRAME3.POPUP
      });
      popup.setWorldSize(291.5, 374);
      this.add(popup);
      this.popup = popup;
    }
    updateSize() {
      const { displayWidth, displayHeight } = this.popup;
      this.setSize(displayWidth / 2, displayHeight / 2);
    }
    createTitle() {
      const text = this.scene.make.image({
        key: DEFAULT_KEY3,
        frame: DEFAULT_FRAME3.ROCKET
      });
      text.setTint(15584418);
      Phaser.Display.Align.In.TopCenter(text, this.popup, 0, -22);
      this.add(text);
    }
    createContent() {
      this.content = this.scene.make.container({});
      this.content.setWorldSize(208, 104);
      this.add(this.content);
      this.content.setPosition(0, -50);
      this.createTiles();
    }
    createTiles() {
      const tiles = [];
      const tile1 = this.createTile(FRAME35.GUIDE_TILE5);
      this.content.add(tile1);
      tiles.push(tile1);
      this.tile1 = tile1;
      const tile2 = this.createTile(FRAME35.GUIDE_TILE4);
      this.content.add(tile2);
      tiles.push(tile2);
      const tile3 = this.createTile(FRAME35.GUIDE_TILE3);
      this.content.add(tile3);
      tiles.push(tile3);
      const tile4 = this.createTile(FRAME35.GUIDE_TILE2);
      this.content.add(tile4);
      tiles.push(tile4);
      this.tile4 = tile4;
      const tile5 = this.createTile(FRAME35.GUIDE_TILE5);
      this.content.add(tile5);
      tiles.push(tile5);
      this.tile5 = tile5;
      const tile6 = this.createTile(FRAME35.GUIDE_TILE1);
      this.content.add(tile6);
      tiles.push(tile6);
      const tile7 = this.createTile(FRAME35.GUIDE_TILE2);
      this.content.add(tile7);
      tiles.push(tile7);
      this.tile7 = tile7;
      const tile8 = this.createTile(FRAME35.GUIDE_TILE1);
      this.content.add(tile8);
      tiles.push(tile8);
      Phaser.Actions.GridAlign(tiles, {
        width: 4,
        height: 2,
        cellWidth: 58,
        cellHeight: 58,
        x: -2 * 58 + 5,
        y: -1 * 58 + 5
      });
      const rocket1 = this.scene.make.image({
        key: KEY40,
        frame: FRAME35.ROCKET
      });
      this.content.add(rocket1);
      this.rocket1 = rocket1;
      this.rocket1.setPosition(tile1.x, tile1.y);
      this.rocket1.kill();
      const rocket2 = this.scene.make.image({
        key: KEY40,
        frame: FRAME35.ROCKET
      });
      this.content.add(rocket2);
      this.rocket2 = rocket2;
      this.rocket2.setPosition(tile5.x, tile5.y);
      this.rocket2.kill();
      const xRadius1 = (tile4.x - tile1.x) / 2;
      const centerX1 = tile1.x + xRadius1;
      const centerY1 = tile1.y;
      this.curve1 = new Phaser.Curves.Ellipse(centerX1, centerY1, xRadius1, 50, 180, 360);
      const xRadius2 = (tile7.x - tile5.x) / 2;
      const centerX2 = tile5.x + xRadius2;
      const centerY2 = tile5.y;
      this.curve2 = new Phaser.Curves.Ellipse(centerX2, centerY2, xRadius2, 30, 180, 360, true);
    }
    createTile(frame, isBomb = false) {
      const container = this.scene.make.container({});
      container.setWorldSize(50, 50);
      const bg = this.scene.make.image({
        key: KEY40,
        frame: FRAME35.TILE_BG
      });
      container.add(bg);
      if (frame) {
        const tile = this.scene.make.image({
          key: KEY40,
          frame
        });
        tile.setWorldSize(41, 43);
        container.add(tile);
      }
      if (isBomb) {
        const graphics = this.scene.add.graphics();
        graphics.fillStyle(0, 0.3);
        graphics.fillPoints(
          [
            { x: 0, y: 0 },
            { x: 0, y: -25 },
            { x: 25, y: -25 }
          ],
          true
        );
        container.add(graphics);
        const bomb = this.scene.make.image({
          key: KEY40,
          frame: FRAME35.BOMB
        });
        Phaser.Display.Align.In.BottomRight(bomb, container, 0, -3);
        container.add(bomb);
      }
      return container;
    }
    createText() {
      const text = FontUtils_default.createText(this.scene, "", 16).setAlign("center");
      FontUtils_default.applyWarningStyle(text);
      text.setText("After the rocket is eliminated,\ntwo more will be eliminated");
      Phaser.Display.Align.In.Center(text, this.popup, 0, 50);
      this.add(text);
    }
    createButton() {
      const button = new Button_default(this.scene, DEFAULT_KEY3, DEFAULT_FRAME3.BUTTON_GREEN);
      button.setName("Guide5Btn");
      const text = FontUtils_default.createText(this.scene, "OK", 24);
      FontUtils_default.applyGreenStyle(text);
      button.add(text);
      Phaser.Display.Align.In.Center(text, button);
      Phaser.Display.Align.In.BottomCenter(button, this.popup, 0, -40);
      button.onClick = this.handleButtonClick;
      const buttonBg = this.scene.make.image({
        key: DEFAULT_KEY3,
        frame: DEFAULT_FRAME3.BUTTON_FRAME
      });
      buttonBg.setPosition(button.x, button.y);
      this.add([buttonBg, button]);
    }
    handleButtonClick = () => {
      this.kill();
      if (this.onClick) {
        this.onClick();
      }
    };
    createFail() {
      this.failContent = this.scene.make.container({});
      Phaser.Display.Align.In.Center(this.failContent, this.content);
      this.add(this.failContent);
      const text = this.scene.make.image({
        key: KEY40,
        frame: FRAME35.TEXT_GOOD
      });
      this.failContent.add(text);
      text.kill();
      this.goodText = text;
    }
    stopAnimation() {
      this.goodText.kill();
      this.scene.tweens.killTweensOf([this.tile1, this.tile4, this.tile5, this.tile7, this.rocket1, this.
      rocket2]);
      this.scene.tweens.killTweensOf(this.goodText);
    }
    playAnimation() {
      this.scene.tweens.killTweensOf(this.goodText);
      this.scene.tweens.killTweensOf([this.tile1, this.tile4, this.tile5, this.tile7, this.rocket1, this.
      rocket2]);
      this.goodText.kill();
      this.goodText.setPosition(0, 0);
      this.rocket1.setPosition(this.tile1.x, this.tile1.y);
      this.rocket1.setAngle(0);
      this.rocket1.setAlpha(1);
      this.rocket1.kill();
      this.rocket2.setPosition(this.tile5.x, this.tile5.y);
      this.rocket2.setAngle(0);
      this.rocket2.setAlpha(1);
      this.rocket2.kill();
      this.tile1.setAlpha(1);
      this.tile4.setAlpha(1);
      this.tile5.setAlpha(1);
      this.tile7.setAlpha(1);
      this.scene.time.delayedCall(600, () => {
        this.rocket1.revive();
        this.rocket2.revive();
      });
      this.scene.tweens.add({
        targets: [this.tile1, this.tile5],
        duration: 500,
        delay: 300,
        props: {
          alpha: {
            from: 1,
            to: 0
          }
        },
        onComplete: () => {
          this.scene.tweens.addCounter({
            from: 0,
            to: 1,
            duration: 500,
            onUpdate: (tween) => {
              const progress = tween.getValue();
              const point = this.curve1.getPoint(progress);
              this.rocket1.setRotation(
                Phaser.Math.Angle.Between(this.rocket1.x, this.rocket1.y, point.x, point.y) + Phaser.
                Math.DegToRad(66)
              );
              this.rocket1.setPosition(point.x, point.y);
              const pos2 = this.curve2.getPoint(progress);
              this.rocket2.setRotation(
                Phaser.Math.Angle.Between(this.rocket2.x, this.rocket2.y, pos2.x, pos2.y) + Phaser.Math.
                DegToRad(66)
              );
              this.rocket2.setPosition(pos2.x, pos2.y);
            },
            onComplete: () => {
              this.scene.tweens.add({
                targets: [this.tile4, this.tile7, this.rocket1, this.rocket2],
                duration: 300,
                props: {
                  alpha: {
                    from: 1,
                    to: 0
                  }
                }
              });
              this.scene.time.delayedCall(200, () => {
                this.playGoodAnimation();
              });
            }
          });
        }
      });
    }
    playGoodAnimation() {
      this.goodText.revive();
      this.scene.tweens.add({
        targets: this.goodText,
        duration: 500,
        ease: Phaser.Math.Easing.Linear,
        props: {
          y: {
            from: 0,
            to: -50
          }
        },
        onComplete: () => {
          this.playAnimation();
        }
      });
    }
  };
  var Guide05Popup_default = Guide05Popup;

  // src/game/gameplay/tutorials/Guide05RocketTiles.ts
  var { event: event23, analytics: analytics7 } = codex;
  var {
    Plugins: {
      Analytics: { Events: AnalyticsEvents7 }
    }
  } = Ludex;
  var Guide05RocketTiles = class {
    scene;
    manager;
    popup;
    constructor(manager) {
      this.manager = manager;
      this.scene = manager.scene;
      this.popup = new Guide05Popup_default(this.scene);
      this.popup.setDepth(depth_default.ON_TOP);
      const bannerHeightOffset = AdsUtils_default.getBannerHeight() / 2;
      if (WorldUtils_default.isLandscape()) {
        this.popup.setScale(0.7);
      }
      Phaser.Display.Align.In.Center(this.popup, this.scene.gameZone, 0, -bannerHeightOffset);
      this.popup.kill();
    }
    setup() {
      event23.once(game_default.TILE_SHOWED_UP, this.startGuide);
      event23.once(game_default.FINISH, this.closeTutorial);
      event23.once(game_default.DIE, this.closeTutorial);
      event23.on(game_default.PAUSE, this.handlePause);
      event23.on(game_default.RESUME, this.handleResume);
    }
    startGuide = () => {
      this.createInfo();
    };
    createInfo() {
      this.manager.runShowMaskAnimation();
      this.popup.revive();
      this.scene.time.delayedCall(500, () => {
        this.popup.playAnimation();
        analytics7.event(AnalyticsEvents7.TUTORIAL_STEP, { step: 8 });
      });
      this.popup.onClick = () => {
        this.manager.runHideMaskAnimation();
        this.popup.stopAnimation();
        this.manager.listenAutoHintEvent();
        this.manager.startAutoHint();
        analytics7.event(AnalyticsEvents7.TUTORIAL_STEP, { step: 9 });
      };
    }
    closeTutorial = () => {
      event23.off(game_default.TILE_SHOWED_UP, this.startGuide);
      event23.off(game_default.FINISH, this.closeTutorial);
      event23.off(game_default.DIE, this.closeTutorial);
      event23.off(game_default.PAUSE, this.handlePause);
      event23.off(game_default.RESUME, this.handleResume);
      this.manager.stopListenAutoHintEvent();
      this.manager.stopAutoHint();
      this.manager.stopTutorial();
      analytics7.event(AnalyticsEvents7.TUTORIAL_STEP, { step: 10 });
    };
    handlePause = () => {
      this.manager.stopAutoHint();
    };
    handleResume = () => {
      this.manager.startAutoHint();
    };
  };
  var Guide05RocketTiles_default = Guide05RocketTiles;

  // src/game/gameplay/tutorials/Guide06BombItem.ts
  init_phaser_custom_min();

  // src/game/gameplay/tutorials/Guide06Popup.ts
  init_phaser_custom_min();
  var { KEY: KEY41, FRAME: FRAME36 } = sprites_default.TUTORIAL;
  var { KEY: DEFAULT_KEY4, FRAME: DEFAULT_FRAME4 } = sprites_default.DEFAULT;
  var Guide06Popup = class extends Phaser.GameObjects.Container {
    popup;
    content;
    contentBg;
    failContent;
    onClick;
    failedText;
    originFailScale;
    leftLeaf;
    originLLeafScale;
    rightLeaf;
    originRLeafScale;
    bombCountDownMask;
    bomb;
    tileBomb;
    bombTween;
    constructor(scene) {
      super(scene);
      this.scene = scene;
      this.setDepth(depth_default.POPUP);
      this.createPopup();
      this.updateSize();
      this.createTitle();
      this.createContent();
      this.createText();
      this.createButton();
      this.createFail();
      this.scene.add.existing(this);
    }
    createPopup() {
      const popup = this.scene.make.image({
        key: DEFAULT_KEY4,
        frame: DEFAULT_FRAME4.POPUP
      });
      this.add(popup);
      this.popup = popup;
    }
    updateSize() {
      const { displayWidth, displayHeight } = this.popup;
      this.setSize(displayWidth / 2, displayHeight / 2);
    }
    createTitle() {
      const text = this.scene.make.image({
        key: DEFAULT_KEY4,
        frame: DEFAULT_FRAME4.BOOM
      });
      text.setTint(15584418);
      Phaser.Display.Align.In.TopCenter(text, this.popup, 0, -22);
      this.add(text);
    }
    createContent() {
      this.content = this.scene.make.container({});
      this.content.setSize(102, 102);
      this.add(this.content);
      this.content.setPosition(0, -20);
      this.createTiles();
      const bg = this.scene.make.image({
        key: KEY41,
        frame: FRAME36.BLANK
      });
      bg.setTint(0);
      bg.setWorldSize(102, 102);
      bg.setY(-20);
      this.content.add(bg);
      bg.kill();
      this.contentBg = bg;
    }
    createTiles() {
      const tile1 = this.createTile(FRAME36.GUIDE_TILE1);
      this.content.add(tile1);
      Phaser.Display.Align.In.TopLeft(tile1, this.content);
      const tile2 = this.createTile(FRAME36.GUIDE_TILE2);
      this.content.add(tile2);
      Phaser.Display.Align.In.TopRight(tile2, this.content);
      const tile3 = this.createTile(FRAME36.GUIDE_TILE1);
      this.content.add(tile3);
      Phaser.Display.Align.In.BottomLeft(tile3, this.content);
      const tile4 = this.createTile(FRAME36.GUIDE_TILE2, true);
      this.content.add(tile4);
      Phaser.Display.Align.In.BottomRight(tile4, this.content);
      this.tileBomb = tile4;
    }
    createTile(frame, isBomb = false) {
      const container = this.scene.make.container({});
      container.setSize(50, 50);
      const bg = this.scene.make.image({
        key: KEY41,
        frame: FRAME36.TILE_BG
      });
      bg.setWorldSize(50, 50);
      container.add(bg);
      const tile = this.scene.make.image({
        key: KEY41,
        frame
      });
      tile.setWorldSize(41, 43.5);
      container.add(tile);
      if (isBomb) {
        const bomb = this.scene.make.image({
          key: KEY41,
          frame: FRAME36.BOMB
        });
        bomb.setWorldSize(20, 21);
        Phaser.Display.Align.In.BottomRight(bomb, container, 0, -3);
        container.add(bomb);
        this.bomb = bomb;
      }
      return container;
    }
    createText() {
      const text = FontUtils_default.createText(this.scene, "", 16).setAlign("center");
      FontUtils_default.applyWarningStyle(text);
      text.setText("Remove this icon tile before\nthe bomb explodes.");
      Phaser.Display.Align.In.Center(text, this.popup, 0, 50);
      this.add(text);
    }
    createButton() {
      const button = new Button_default(this.scene, DEFAULT_KEY4, DEFAULT_FRAME4.BUTTON_GREEN, 180, 46.5);
      button.setName("Guide6Btn");
      const text = FontUtils_default.createText(this.scene, "OK", 24);
      FontUtils_default.applyGreenStyle(text);
      button.add(text);
      Phaser.Display.Align.In.Center(text, button);
      Phaser.Display.Align.In.BottomCenter(button, this.popup, 0, -30);
      button.onClick = this.handleButtonClick;
      const buttonBg = this.scene.make.image({
        key: DEFAULT_KEY4,
        frame: DEFAULT_FRAME4.BUTTON_FRAME
      });
      buttonBg.setPosition(button.x, button.y);
      this.add([buttonBg, button]);
    }
    handleButtonClick = () => {
      this.kill();
      if (this.onClick) {
        this.onClick();
      }
    };
    createFail() {
      this.failContent = this.scene.make.container({});
      Phaser.Display.Align.In.Center(this.failContent, this.content);
      this.add(this.failContent);
      const leftLeaf = this.scene.make.image({
        key: KEY41,
        frame: FRAME36.LEAF_LEFT,
        origin: { x: 1, y: 0.5 }
      });
      leftLeaf.setWorldSize(132.5, 61);
      this.failContent.add(leftLeaf);
      leftLeaf.setY(-17);
      leftLeaf.kill();
      this.leftLeaf = leftLeaf;
      this.originLLeafScale = leftLeaf.scale;
      const rightLeaf = this.scene.make.image({
        key: KEY41,
        frame: FRAME36.LEAF_RIGHT,
        origin: { x: 0, y: 0.5 }
      });
      rightLeaf.setWorldSize(120, 68);
      this.failContent.add(rightLeaf);
      rightLeaf.setY(-17);
      rightLeaf.kill();
      this.rightLeaf = rightLeaf;
      this.originRLeafScale = rightLeaf.scale;
      const text = this.scene.make.image({
        key: KEY41,
        frame: FRAME36.TEXT_FAILED
      });
      text.setWorldSize(167.5, 61.5);
      this.failContent.add(text);
      text.setY(-20);
      text.kill();
      this.failedText = text;
      this.originFailScale = text.scale;
    }
    stopAnimation() {
      this.contentBg.kill();
      this.leftLeaf.kill();
      this.rightLeaf.kill();
      this.failedText.kill();
      this.scene.tweens.killTweensOf(this.content);
      this.scene.tweens.killTweensOf(this.leftLeaf);
      this.scene.tweens.killTweensOf(this.rightLeaf);
      this.scene.tweens.killTweensOf(this.failedText);
    }
    playAnimation() {
      this.scene.tweens.killTweensOf(this.content);
      this.scene.tweens.killTweensOf(this.leftLeaf);
      this.scene.tweens.killTweensOf(this.rightLeaf);
      this.scene.tweens.killTweensOf(this.failedText);
      this.contentBg.revive();
      this.contentBg.setAlpha(0);
      this.bomb.revive();
      this.failedText.revive();
      this.failedText.setScale(0);
      this.leftLeaf.revive();
      this.leftLeaf.setScale(0);
      this.leftLeaf.setAngle(-5);
      this.rightLeaf.revive();
      this.rightLeaf.setScale(0);
      this.rightLeaf.setAngle(5);
      this.runBombIconTween();
      this.scene.tweens.addCounter({
        from: 1,
        to: 0,
        duration: 1e3,
        ease: "Linear",
        onUpdate: (tween) => {
          const value = tween.getValue();
          this.bombCountDownMask.drawCountdown(value, 1);
        },
        onComplete: () => {
          this.bomb.kill();
          this.scene.time.delayedCall(200, () => {
            this.playFailAnimation();
          });
        }
      });
    }
    runBombIconTween() {
      this.bombTween?.stop();
      this.bombTween?.stop();
      const { scaleX, scaleY } = this.bomb;
      this.bombTween = this.scene.tweens.add({
        targets: this.bomb,
        scaleX: scaleX * 1.2,
        scaleY: scaleY * 1.2,
        ease: "Sine.easeInOut",
        duration: 500,
        yoyo: true,
        repeat: -1,
        onStop: () => {
          this.bomb.setScale(scaleX, scaleY);
        }
      });
    }
    /**
     * Because it use world position, make sure the popup has already apply
     */
    createBombCountDown() {
      this.bombCountDownMask = new BombCountdown_default(this.scene, 50, 4);
      this.tileBomb.add(this.bombCountDownMask);
      this.bombCountDownMask.drawCountdown(0, 1);
    }
    playFailAnimation() {
      this.scene.tweens.add({
        targets: this.contentBg,
        duration: 1e3,
        ease: Phaser.Math.Easing.Linear,
        props: {
          alpha: {
            from: 0,
            to: 0.5
          }
        }
      });
      this.scene.tweens.add({
        targets: this.failedText,
        duration: 1e3,
        ease: Phaser.Math.Easing.Expo.InOut,
        props: {
          scale: {
            from: 0,
            to: this.originFailScale
          }
        },
        onComplete: () => {
          const originScale = [this.originLLeafScale, this.originRLeafScale];
          this.scene.tweens.add({
            targets: [this.leftLeaf, this.rightLeaf],
            duration: 500,
            ease: Phaser.Math.Easing.Expo.Out,
            props: {
              scale: {
                getStart: () => {
                  return 0;
                },
                getEnd: (_target, _key, _value, idx) => {
                  return originScale[idx];
                }
              }
            }
          });
          const angles = [-5, 5];
          this.scene.tweens.add({
            targets: [this.leftLeaf, this.rightLeaf],
            delay: 300,
            duration: 500,
            ease: Phaser.Math.Easing.Linear,
            props: {
              angle: {
                getStart: (_target, _key, _value, idx) => {
                  return angles[idx];
                },
                getEnd: () => {
                  return 0;
                }
              }
            },
            onComplete: () => {
              this.playAnimation();
            }
          });
        }
      });
    }
  };
  var Guide06Popup_default = Guide06Popup;

  // src/game/gameplay/tutorials/Guide06BombItem.ts
  var { event: event24, analytics: analytics8 } = codex;
  var {
    Plugins: {
      Analytics: { Events: AnalyticsEvents8 }
    }
  } = Ludex;
  var Guide06BombTile = class {
    scene;
    manager;
    popup;
    constructor(manager) {
      this.manager = manager;
      this.scene = manager.scene;
      this.popup = new Guide06Popup_default(this.scene);
      this.popup.setDepth(depth_default.ON_TOP);
      const bannerHeightOffset = AdsUtils_default.getBannerHeight() / 2;
      if (WorldUtils_default.isLandscape()) {
        this.popup.setScale(0.7);
      }
      Phaser.Display.Align.In.Center(this.popup, this.scene.gameZone, 0, -bannerHeightOffset);
      this.popup.kill();
      this.popup.createBombCountDown();
    }
    setup() {
      event24.once(game_default.TILE_SHOWED_UP, this.startGuide);
      event24.once(game_default.FINISH, this.closeTutorial);
      event24.once(game_default.DIE, this.closeTutorial);
    }
    startGuide = () => {
      this.createInfo();
    };
    createInfo() {
      this.manager.runShowMaskAnimation();
      this.popup.revive();
      this.scene.time.delayedCall(500, () => {
        this.popup.playAnimation();
        analytics8.event(AnalyticsEvents8.TUTORIAL_STEP, { step: 11 });
      });
      this.popup.onClick = () => {
        this.manager.runHideMaskAnimation();
        this.popup.stopAnimation();
        this.manager.listenAutoHintEvent();
        this.manager.startAutoHint();
        analytics8.event(AnalyticsEvents8.TUTORIAL_STEP, { step: 12 });
      };
    }
    closeTutorial = () => {
      event24.off(game_default.TILE_SHOWED_UP, this.startGuide);
      event24.off(game_default.FINISH, this.closeTutorial);
      event24.off(game_default.DIE, this.closeTutorial);
      this.manager.stopListenAutoHintEvent();
      this.manager.stopAutoHint();
      this.manager.stopTutorial();
      analytics8.event(AnalyticsEvents8.TUTORIAL_STEP, { step: 13 });
    };
  };
  var Guide06BombItem_default = Guide06BombTile;

  // src/game/gameplay/tutorials/Guide07DiffuseItem.ts
  init_phaser_custom_min();
  var { event: event25, analytics: analytics9 } = codex;
  var {
    Plugins: {
      Analytics: { Events: AnalyticsEvents9 }
    }
  } = Ludex;
  var Guide07DiffuseItem = class {
    manager;
    constructor(manager) {
      this.manager = manager;
    }
    setup() {
      event25.once(game_default.TILE_SHOWED_UP, this.startGuide$);
      event25.once(game_default.FINISH, this.closeTutorial);
      event25.once(game_default.DIE, this.closeTutorial);
    }
    startGuide$ = () => {
      this.createInfo();
    };
    createInfo() {
      const { itemManager, layoutManager } = this.manager.scene;
      const { staticHand, infoText } = this.manager;
      const { objects } = layoutManager;
      itemManager.setDepthItemOnTop(item_default.GUIDE_BOMB_DEFUSE.ID);
      const { x, y, scale, width, displayWidth, displayHeight } = objects.defuseItem;
      this.manager.createMask(
        x - (displayWidth - 2 * scale) / 2,
        y - displayHeight / 2 + 6 * scale,
        (width - 2) * scale,
        (width - 2) * scale,
        (width - 2) * scale / 2
      );
      this.manager.runShowMaskAnimation();
      const isLandscape = WorldUtils_default.isLandscape();
      const handOffsetY = isLandscape ? 30 : -50;
      const infoOffsetX = isLandscape ? -90 : Math.max(0, 220 - WorldUtils_default.getWorldSize().width /
      2);
      const infoOffsetY = isLandscape ? 50 : -90;
      const angle = isLandscape ? 30 : 210;
      staticHand.revive();
      staticHand.angle = angle;
      staticHand.setPosition(x, y + handOffsetY);
      infoText.revive();
      infoText.setText("Tap to clear a pair of\nbomb tiles");
      infoText.setAlign("center");
      infoText.setPosition(x + infoOffsetX, y + infoOffsetY);
      this.manager.alignInfoTextWithinScreen(isLandscape);
      this.manager.scene.input.once(Phaser.Input.Events.POINTER_UP, this.handlePointerDown);
    }
    handlePointerDown = () => {
      const { itemManager, uiManager } = this.manager.scene;
      const { infoText, staticHand } = this.manager;
      this.manager.runHideMaskAnimation();
      uiManager.changeToDefuseItem();
      infoText.kill();
      staticHand.kill();
      itemManager.setPaidItem(item_default.GUIDE_BOMB_DEFUSE.ID);
      itemManager.setDepthItemNormal(item_default.GUIDE_BOMB_DEFUSE.ID);
      analytics9.event(AnalyticsEvents9.TUTORIAL_STEP, { step: 14 });
    };
    closeTutorial = () => {
      event25.off(game_default.TILE_SHOWED_UP, this.startGuide$);
      event25.off(game_default.FINISH, this.closeTutorial);
      event25.off(game_default.DIE, this.closeTutorial);
      this.manager.stopTutorial();
      analytics9.event(AnalyticsEvents9.TUTORIAL_STEP, { step: 15 });
    };
  };
  var Guide07DiffuseItem_default = Guide07DiffuseItem;

  // src/game/gameplay/tutorials/Guide08ShuffleItem.ts
  init_phaser_custom_min();
  var { event: event26, analytics: analytics10 } = codex;
  var {
    Plugins: {
      Analytics: { Events: AnalyticsEvents10 }
    }
  } = Ludex;
  var Guide08ShuffleItem = class {
    manager;
    constructor(manager) {
      this.manager = manager;
    }
    setup() {
      event26.once(game_default.TILE_SHOWED_UP, this.startGuide);
      event26.once(game_default.FINISH, this.closeTutorial);
      event26.once(game_default.DIE, this.closeTutorial);
    }
    startGuide = () => {
      this.createInfo();
    };
    createInfo() {
      const { itemManager, layoutManager } = this.manager.scene;
      const { staticHand, infoText } = this.manager;
      const { objects } = layoutManager;
      itemManager.setDepthItemOnTop(item_default.SHUFFLE.ID);
      const { x, y, scale, width, displayWidth, displayHeight } = objects.shuffleItem;
      this.manager.createMask(
        x - (displayWidth - 2 * scale) / 2,
        y - displayHeight / 2 + 6 * scale,
        (width - 2) * scale,
        (width - 2) * scale,
        (width - 2) * scale / 2
      );
      const isLandscape = WorldUtils_default.isLandscape();
      const handOffsetY = isLandscape ? 30 : -50;
      const infoOffsetX = isLandscape ? -70 : 0;
      const infoOffsetY = isLandscape ? 50 : -90;
      const angle = isLandscape ? 30 : 210;
      this.manager.runShowMaskAnimation();
      staticHand.revive();
      staticHand.angle = angle;
      staticHand.setPosition(x, y + handOffsetY);
      infoText.revive();
      infoText.setPosition(x + infoOffsetX, y + infoOffsetY);
      infoText.setText("Tap to rearrange\nthe tiles");
      infoText.setAlign("center");
      this.manager.alignInfoTextWithinScreen(isLandscape);
      this.manager.scene.input.once(Phaser.Input.Events.POINTER_UP, this.handlePointerDown);
    }
    handlePointerDown = () => {
      const { itemManager } = this.manager.scene;
      const { infoText, staticHand } = this.manager;
      this.manager.runHideMaskAnimation();
      infoText.kill();
      staticHand.kill();
      itemManager.setPaidItem(item_default.SHUFFLE.ID);
      itemManager.setDepthItemNormal(item_default.SHUFFLE.ID);
      analytics10.event(AnalyticsEvents10.TUTORIAL_STEP, { step: 16 });
    };
    closeTutorial = () => {
      event26.off(game_default.TILE_SHOWED_UP, this.startGuide);
      event26.off(game_default.FINISH, this.closeTutorial);
      event26.off(game_default.DIE, this.closeTutorial);
      this.manager.stopTutorial();
      analytics10.event(AnalyticsEvents10.TUTORIAL_STEP, { step: 17 });
    };
  };
  var Guide08ShuffleItem_default = Guide08ShuffleItem;

  // src/game/gameplay/tutorials/Guide09RocketItem.ts
  init_phaser_custom_min();
  var { event: event27, analytics: analytics11 } = codex;
  var {
    Plugins: {
      Analytics: { Events: AnalyticsEvents11 }
    }
  } = Ludex;
  var Guide09RocketItem = class {
    scene;
    manager;
    constructor(manager) {
      this.manager = manager;
      this.scene = manager.scene;
    }
    setup() {
      event27.once(game_default.TILE_SHOWED_UP, this.startGuide);
      event27.once(game_default.FINISH, this.closeTutorial);
      event27.once(game_default.DIE, this.closeTutorial);
    }
    startGuide = () => {
      this.createInfo();
    };
    createInfo() {
      const { itemManager, layoutManager } = this.scene;
      const { staticHand, infoText } = this.manager;
      const { objects } = layoutManager;
      itemManager.setDepthItemOnTop(item_default.ROCKET.ID);
      const { x, y, scale, width, displayWidth, displayHeight } = objects.rocketItem;
      this.manager.createMask(
        x - (displayWidth - 2 * scale) / 2,
        y - displayHeight / 2 + 6 * scale,
        (width - 2) * scale,
        (width - 2) * scale,
        (width - 2) * scale / 2
      );
      const isLandscape = WorldUtils_default.isLandscape();
      const handOffsetY = isLandscape ? 30 : -50;
      const infoOffsetX = isLandscape ? -70 : 0;
      const infoOffsetY = isLandscape ? 50 : -90;
      const angle = isLandscape ? 30 : 210;
      this.manager.runShowMaskAnimation();
      staticHand.revive();
      staticHand.angle = angle;
      staticHand.setPosition(x, y + handOffsetY);
      infoText.revive();
      infoText.setPosition(x + infoOffsetX, y + infoOffsetY);
      infoText.setText("Tap to eliminate\ntwo pairs");
      infoText.setAlign("center");
      this.manager.alignInfoTextWithinScreen(isLandscape);
      this.scene.input.once(Phaser.Input.Events.POINTER_UP, this.handlePointerDown);
    }
    handlePointerDown = () => {
      const { itemManager } = this.scene;
      const { infoText, staticHand } = this.manager;
      this.manager.runHideMaskAnimation();
      infoText.kill();
      staticHand.kill();
      itemManager.setPaidItem(item_default.ROCKET.ID, true);
      itemManager.setDepthItemNormal(item_default.ROCKET.ID);
      if (itemManager.itemActive !== item_default.ROCKET.ID) {
        itemManager.enableItem(item_default.ROCKET.ID);
      }
      analytics11.event(AnalyticsEvents11.TUTORIAL_STEP, { step: 18 });
    };
    closeTutorial = () => {
      event27.off(game_default.TILE_SHOWED_UP, this.startGuide);
      event27.off(game_default.FINISH, this.closeTutorial);
      event27.off(game_default.DIE, this.closeTutorial);
      this.manager.stopTutorial();
      this.manager.completeTutorial();
      analytics11.event(AnalyticsEvents11.TUTORIAL_STEP, { step: 19 });
    };
  };
  var Guide09RocketItem_default = Guide09RocketItem;

  // src/game/gameplay/tutorials/Guide10SuperRocket.ts
  init_phaser_custom_min();
  var { event: event28, analytics: analytics12 } = codex;
  var {
    Plugins: {
      Analytics: { Events: AnalyticsEvents12 }
    }
  } = Ludex;
  var Guide10SuperRocket = class {
    scene;
    manager;
    constructor(manager) {
      this.manager = manager;
      this.scene = manager.scene;
    }
    setup() {
      event28.once(game_default.TILE_SHOWED_UP, this.startGuide);
      event28.once(game_default.FINISH, this.closeTutorial);
      event28.once(game_default.DIE, this.closeTutorial);
    }
    startGuide = () => {
      this.createInfo();
    };
    createInfo() {
      const { itemManager, layoutManager } = this.scene;
      const { staticHand, infoText } = this.manager;
      const { objects } = layoutManager;
      itemManager.setDepthItemOnTop(item_default.SUPER_ROCKET.ID);
      const { x, y, scale, width, displayWidth, displayHeight } = objects.superRocketItem;
      this.manager.createMask(
        x - (displayWidth - 2 * scale) / 2,
        y - displayHeight / 2 + 6 * scale,
        (width - 2) * scale,
        (width - 2) * scale,
        (width - 2) * scale / 2
      );
      const isLandscape = WorldUtils_default.isLandscape();
      const handOffsetY = isLandscape ? 30 : -50;
      const infoOffsetX = isLandscape ? -90 : 0;
      const infoOffsetY = isLandscape ? 50 : -90;
      const angle = isLandscape ? 30 : 210;
      this.manager.runShowMaskAnimation();
      staticHand.revive();
      staticHand.angle = angle;
      staticHand.setPosition(x, y + handOffsetY);
      infoText.revive();
      infoText.setPosition(x + infoOffsetX, y + infoOffsetY);
      infoText.setText("Use the super rocket to\ndestroy a lot of tiles\non the board.");
      infoText.setAlign("center");
      this.manager.alignInfoTextWithinScreen(isLandscape);
      this.scene.input.once(Phaser.Input.Events.POINTER_UP, this.handlePointerDown);
    }
    handlePointerDown = () => {
      const { itemManager } = this.scene;
      const { infoText, staticHand } = this.manager;
      this.manager.runHideMaskAnimation();
      infoText.kill();
      staticHand.kill();
      itemManager.setDepthItemNormal(item_default.SUPER_ROCKET.ID);
      analytics12.event(AnalyticsEvents12.TUTORIAL_STEP, { step: 20 });
    };
    closeTutorial = () => {
      event28.off(game_default.TILE_SHOWED_UP, this.startGuide);
      event28.off(game_default.FINISH, this.closeTutorial);
      event28.off(game_default.DIE, this.closeTutorial);
      this.manager.stopTutorial();
      this.manager.completeTutorial();
      analytics12.event(AnalyticsEvents12.TUTORIAL_STEP, { step: 21 });
    };
  };
  var Guide10SuperRocket_default = Guide10SuperRocket;

  // src/game/gameplay/managers/TutorialManager.ts
  var { analytics: analytics13, player: player13 } = codex;
  var {
    Plugins: {
      Analytics: { Events: AnalyticsEvents13 }
    },
    Utils: { Valid: V14, Object: O11 }
  } = Ludex;
  var { STATUS: STATUS6 } = manager_default2;
  var { KEY: KEY42, FRAME: FRAME37 } = sprites_default.TUTORIAL;
  var { FinalGuideLevel, DefuseItemGuideLevel: DefuseItemGuideLevel2, RocketItemGuideLevel: RocketItemGuideLevel2,
  SuperRocketGuideLevel: SuperRocketGuideLevel3 } = GameSettings_default;
  var TutorialManager = class extends BaseManager_default {
    scene;
    tutorialId;
    isTutorialEnable$;
    tutorialsDisplayed$ = [];
    isAnalyticFirstSent$ = true;
    hand;
    staticHand;
    infoText;
    textBox;
    background;
    maskGraphics$;
    tutGuide1$;
    tutGuide2$;
    tutGuide3$;
    tutGuide4$;
    tutGuide5$;
    tutGuide6$;
    tutGuide7$;
    tutGuide8$;
    tutGuide9$;
    tutGuide10$;
    autoTimeEvent$;
    guideShownRecord$ = {};
    constructor(scene) {
      super(scene);
      this.scene = scene;
      this.createBackground$();
      this.createHand$();
      this.createStaticHand$();
      this.createInfoText$();
      this.createBoxText$();
      this.checkIsValidForTutorial();
      this.createGuideShownRecord$();
    }
    init() {
      this.hand.kill();
      this.infoText.kill();
      this.background.kill();
      this.staticHand.kill();
      this.setState(STATUS6.READY);
    }
    start() {
      if (this.isRunning()) return;
      if (!this.isTutorialEnable$) return;
      this.setState(STATUS6.RUNNING);
      this.showTutorial$();
    }
    stop() {
      if (!this.isRunning()) return;
      this.checkIsValidForTutorial();
      this.scene.tweens.killTweensOf([this.background, this.hand, this.staticHand, this.infoText]);
      this.setState(STATUS6.STOPPED);
    }
    setTutorialEnable$(enable) {
      this.isTutorialEnable$ = enable;
    }
    isLevelHaveTutorial(level) {
      if ([1, 2, 3, 5, 7, 9, 13, SuperRocketGuideLevel3, RocketItemGuideLevel2, DefuseItemGuideLevel2].
      includes(level)) {
        return true;
      }
      return false;
    }
    isLevelShowWrongPath(level) {
      if (level <= 6) return true;
      return false;
    }
    displayCount(id2) {
      const tutorialDisplayed = this.tutorialsDisplayed$.filter((tutorialId) => tutorialId === id2);
      return tutorialDisplayed.length;
    }
    isNothingToDisplay() {
      const level = this.scene.levelHandler.level;
      if (level > FinalGuideLevel) return true;
      return false;
    }
    showTutorial$() {
      if (!this.isRunning()) return;
      const { levelHandler } = this.scene;
      if (this.isAnalyticFirstSent$) {
        analytics13.event(AnalyticsEvents13.TUTORIAL_BEGIN);
        this.isAnalyticFirstSent$ = false;
      }
      switch (levelHandler.level) {
        case 1:
          this.startTutorial(TUTORIAL_ID.NEWBIE);
          break;
        case 2:
          this.startTutorial(TUTORIAL_ID.NO_TIMER);
          break;
        case 3:
          this.startTutorial(TUTORIAL_ID.TIMER);
          break;
        case 5:
          this.startTutorial(TUTORIAL_ID.MAGNIFIER_ITEM);
          break;
        case 7:
          this.startTutorial(TUTORIAL_ID.ROCKET_TILES);
          break;
        case 9:
          this.startTutorial(TUTORIAL_ID.BOMB_ITEM);
          break;
        case DefuseItemGuideLevel2:
          this.startTutorial(TUTORIAL_ID.DIFFUSE_ITEM);
          break;
        case 13:
          this.startTutorial(TUTORIAL_ID.SHUFFLE_ITEM);
          break;
        case RocketItemGuideLevel2:
          this.startTutorial(TUTORIAL_ID.ROCKET_ITEM);
          break;
        case SuperRocketGuideLevel3:
          this.startTutorial(TUTORIAL_ID.SUPER_ROCKET_ITEM);
          break;
      }
    }
    startTutorial = (id2) => {
      if (!this.isRunning()) return false;
      if (this.isNothingToDisplay()) {
        this.stop();
        this.setTutorialEnable$(false);
        return false;
      }
      this.background.kill();
      if (this.isGuideShown(id2)) return false;
      this.setGuideShown$(id2, true);
      switch (id2) {
        case TUTORIAL_ID.NEWBIE:
          this.tutGuide1$ = new Guide01Newbie_default(this);
          this.tutGuide1$.setup();
          break;
        case TUTORIAL_ID.NO_TIMER:
          this.tutGuide2$ = new Guide02NoTimer_default(this);
          this.tutGuide2$.setup();
          break;
        case TUTORIAL_ID.TIMER:
          this.tutGuide3$ = new Guide03Timer_default(this);
          this.tutGuide3$.setup();
          break;
        case TUTORIAL_ID.MAGNIFIER_ITEM:
          this.tutGuide4$ = new Guide04Magnifier_default(this);
          this.tutGuide4$.setup();
          break;
        case TUTORIAL_ID.ROCKET_TILES:
          this.tutGuide5$ = new Guide05RocketTiles_default(this);
          this.tutGuide5$.setup();
          break;
        case TUTORIAL_ID.BOMB_ITEM:
          this.tutGuide6$ = new Guide06BombItem_default(this);
          this.tutGuide6$.setup();
          break;
        case TUTORIAL_ID.DIFFUSE_ITEM:
          this.tutGuide7$ = new Guide07DiffuseItem_default(this);
          this.tutGuide7$.setup();
          break;
        case TUTORIAL_ID.SHUFFLE_ITEM:
          this.tutGuide8$ = new Guide08ShuffleItem_default(this);
          this.tutGuide8$.setup();
          break;
        case TUTORIAL_ID.ROCKET_ITEM:
          this.tutGuide9$ = new Guide09RocketItem_default(this);
          this.tutGuide9$.setup();
          break;
        case TUTORIAL_ID.SUPER_ROCKET_ITEM:
          this.tutGuide10$ = new Guide10SuperRocket_default(this);
          this.tutGuide10$.setup();
          break;
        default:
          return false;
      }
      if (!this.isRunning()) return false;
      this.tutorialId = id2;
      this.tutorialsDisplayed$.push(this.tutorialId);
      return true;
    };
    stopTutorial() {
      this.tutorialId = "";
      this.hand.kill();
      this.infoText.kill();
      this.staticHand.kill();
      this.background.kill();
      GameSDK.extra.checkAndCreateShortcutAsync().catch(() => {
      });
    }
    completeTutorial() {
      this.scene.time.delayedCall(500, () => {
        analytics13.event(AnalyticsEvents13.TUTORIAL_COMPLETE);
      });
      this.setTutorialEnable$(false);
    }
    // Logic
    checkIsValidForTutorial() {
      const { level } = player13.getGameData() ?? {};
      const correctLevel = V14.isNumber(level) ? level : 0;
      const enable = correctLevel <= FinalGuideLevel;
      this.setTutorialEnable$(enable);
      return enable;
    }
    // Draw
    createHand$() {
      this.hand = new DoubleTapTutorialHand_default(this.scene);
      this.hand.kill();
      this.hand.setDepth(depth_default.PRIORITY);
    }
    createStaticHand$() {
      this.staticHand = this.scene.add.image(0, 0, KEY42, FRAME37.HAND);
      this.staticHand.setWorldSize(21, 21);
      this.staticHand.kill();
      this.staticHand.setDepth(depth_default.PRIORITY);
    }
    createInfoText$() {
      this.infoText = FontUtils_default.createShadowText(this.scene, "", 16);
      this.infoText.setTint(16637882);
      this.infoText.kill();
      this.infoText.setDepth(depth_default.PRIORITY);
    }
    createBoxText$() {
      this.textBox = new GuideTextBox_default(this.scene);
      this.textBox.kill();
    }
    createBackground$() {
      this.background = this.scene.make.image({
        key: KEY42,
        frame: FRAME37.BLANK
      });
      this.background.setInteractive();
      this.background.setTint(0);
      this.background.setAlpha(0.8);
      this.background.setDepth(depth_default.PRIORITY);
      this.setBackgroundToWorldSize();
      Phaser.Display.Align.In.Center(this.background, this.scene.gameZone);
      this.background.kill();
    }
    setBackgroundToWorldSize() {
      const { width, height } = WorldUtils_default.getWorldSize();
      const space = 100;
      this.background.setWorldSize(width + space, height + space);
    }
    createMask(x, y, width, height, radius = 10) {
      this.maskGraphics$?.destroy();
      this.maskGraphics$ = this.scene.make.graphics({
        fillStyle: { color: 16711680, alpha: 1 }
      });
      this.maskGraphics$.setName("MaskGraphics");
      this.maskGraphics$.fillRoundedRect(x, y, width, height, radius);
      this.background.revive();
      this.setBackgroundToWorldSize();
      this.background.clearMask(true);
      this.background.setMask(this.maskGraphics$.createGeometryMask());
      this.background.mask.invertAlpha = true;
    }
    createMultiMask(paramList) {
      this.maskGraphics$?.destroy();
      this.maskGraphics$ = this.scene.make.graphics({
        fillStyle: { color: 16711680, alpha: 1 }
      });
      this.maskGraphics$.setName("MaskGraphics");
      for (const param of paramList) {
        this.maskGraphics$.fillRoundedRect(param.x, param.y, param.width, param.height, param.radius);
      }
      this.background.revive();
      this.setBackgroundToWorldSize();
      this.background.clearMask(true);
      this.background.setMask(this.maskGraphics$.createGeometryMask());
      this.background.mask.invertAlpha = true;
    }
    runShowMaskAnimation(alpha = 0.8) {
      const targets = [this.background];
      this.background.revive();
      this.scene.tweens.killTweensOf(targets);
      this.scene.tweens.add({
        targets,
        duration: 300,
        ease: Phaser.Math.Easing.Quadratic.Out,
        props: {
          alpha: { start: 0, to: alpha }
        }
      });
    }
    runHideMaskAnimation = () => {
      const targets = [this.background];
      this.background.revive();
      this.scene.tweens.killTweensOf(targets);
      this.scene.tweens.add({
        targets,
        duration: 400,
        ease: Phaser.Math.Easing.Quadratic.Out,
        props: {
          alpha: 0
        },
        onComplete: () => {
          this.background.kill();
          this.background.clearMask(true);
        }
      });
    };
    startAutoHint() {
      this.autoTimeEvent$ = this.scene.time.delayedCall(5e3, this.handleAutomaticallyHint$);
    }
    handleAutomaticallyHint$ = () => {
      const { tileManager, itemManager } = this.scene;
      if (tileManager.hintTiles.length > 0 || itemManager.getIsUseableItem() === false) {
        this.stopAutoHint();
        this.startAutoHint();
      } else {
        tileManager.suggestPairHint();
      }
    };
    stopAutoHint() {
      this.autoTimeEvent$?.remove();
    }
    listenAutoHintEvent() {
      this.scene.events.on(tile_default.EVENTS.INTERACTION, this.handlePlayerInteract$);
      this.scene.events.on(tile_default.EVENTS.NO_PATH_FOUND, this.handleNoPathFound$);
    }
    stopListenAutoHintEvent() {
      this.scene.events.off(tile_default.EVENTS.INTERACTION, this.handlePlayerInteract$);
      this.scene.events.off(tile_default.EVENTS.NO_PATH_FOUND, this.handleNoPathFound$);
    }
    clearTimer$ = null;
    handleNoPathFound$ = () => {
      const { tileManager } = this.scene;
      this.clearTimer$?.remove();
      this.clearTimer$ = this.scene.time.delayedCall(1e3, () => {
        tileManager.clearWrongPath();
      });
    };
    handlePlayerInteract$ = () => {
      this.stopAutoHint();
      const { tileManager } = this.scene;
      tileManager.clearWrongPath();
      this.startAutoHint();
    };
    createGuideShownRecord$() {
      this.guideShownRecord$ = DEFAULT_TUTORIAL_DISPLAYED;
      const { tutorialDisplayed } = player13.getGameData() ?? {};
      this.guideShownRecord$ = O11.merge(this.guideShownRecord$, tutorialDisplayed);
    }
    setGuideShown$(id2, shown) {
      if (this.guideShownRecord$[id2] === void 0) return;
      this.guideShownRecord$[id2] = shown;
      player13.setGameData({
        tutorialDisplayed: this.guideShownRecord$
      });
    }
    isGuideShown(id2) {
      return this.guideShownRecord$[id2] ?? false;
    }
    alignInfoTextWithinScreen(isLandscape) {
      const { width: worldWidth } = WorldUtils_default.getWorldSize();
      if (isLandscape) return;
      const textWidth = this.infoText.getBounds().width;
      const isTextOutOfRightBounds = this.infoText.x + textWidth / 2 > worldWidth / 2 - 5;
      const isTextOutOfLeftBounds = this.infoText.x - textWidth / 2 < -worldWidth / 2 + 5;
      if (isTextOutOfRightBounds) {
        this.infoText.x = worldWidth / 2 - textWidth / 2 - 5;
      }
      if (isTextOutOfLeftBounds) {
        this.infoText.x = -worldWidth / 2 + textWidth / 2 + 5;
      }
    }
    isBombDefuseTutorialShown() {
      return this.isGuideShown(TUTORIAL_ID.DIFFUSE_ITEM);
    }
  };
  var TutorialManager_default = TutorialManager;

  // src/game/gameplay/managers/UIManager.ts
  init_phaser_custom_min();
  var { event: event29 } = codex;
  var {
    Utils: { Time: T5 }
  } = Ludex;
  var { FRAME: FRAME38 } = sprites_default.GAMEPLAY;
  var { FinalGuideLevel: FinalGuideLevel2 } = GameSettings_default;
  var UIManager = class extends BaseManager_default {
    scene;
    constructor(scene) {
      super(scene);
      this.scene = scene;
      this.initUILogic$();
    }
    start() {
      if (this.isRunning()) return;
      super.start();
      this.updateUIData();
      this.enablePause();
      this.checkForMissionNotification();
      this.listenToEvents$();
    }
    stop() {
      this.disablePause();
      this.unListenToEvents$();
    }
    unListenToEvents$() {
      event29.off(game_default.GAMEPLAY_PAUSE_NOTIFICATION, this.handleGamplayPauseNotification$);
    }
    listenToEvents$() {
      this.unListenToEvents$();
      event29.on(game_default.GAMEPLAY_PAUSE_NOTIFICATION, this.handleGamplayPauseNotification$);
    }
    handleGamplayPauseNotification$ = () => {
      const status = GameplayNotificationUtils_default.isGameplayPauseNotificationAvailable;
      const { objects } = this.scene.layoutManager;
      if (status) {
        this.checkForMissionNotification();
      } else {
        objects.stopPauseNotification();
      }
    };
    updateUIData = () => {
      const { levelHandler, layoutManager } = this.scene;
      const { objects } = layoutManager;
      const { time } = levelHandler.getConfigs();
      objects.playtimeClock.setDisable(false);
      objects.playtimeClock.setClockText(time);
      objects.playtimeClock.pauseClock();
      if (MatchUtils_default.isChallengeMode()) {
        const matchState = MatchUtils_default.getMatchState();
        const { customData = {}, profiles = {} } = matchState;
        const playerId = customData.playerId ?? "0";
        const opponentId = customData.opponentId ?? "0";
        const playerInfo = profiles[playerId];
        const opponentInfo = profiles[opponentId];
        objects.challengeInfo.setPlayerInfo({
          id: playerId,
          score: playerInfo?.score ?? 0,
          photo: playerInfo?.photo ?? images_default.AVATAR_DEFAULT.FILE
        });
        objects.challengeInfo.setOpponentInfo({
          id: opponentId,
          score: opponentInfo?.score ?? 0,
          photo: opponentInfo?.photo ?? images_default.AVATAR_DEFAULT.FILE
        });
      }
    };
    initUILogic$() {
      const { layoutManager } = this.scene;
      const { objects } = layoutManager;
      objects.skipBtn.onClick = this.handleSkipTutorial$;
      objects.pauseButton.onClick = this.handlePauseButton$;
      this.handleHeaderAndFooterResize();
    }
    handleHeaderAndFooterResize() {
      const { width } = WorldUtils_default.getWorldSize();
      const { objects } = this.scene.layoutManager;
      if (WorldUtils_default.isLandscape()) {
        objects.topFooterBG.kill();
        objects.bottomFooterBG.kill();
        objects.headerBG.setFrame(FRAME38.LAYOUT_HEADER_LANDSCAPE);
        const initialWidth = width > 988 ? 988 : width;
        objects.headerBG.setWorldSize(initialWidth, 65);
      } else {
        objects.topFooterBG.revive();
        objects.bottomFooterBG.revive();
        objects.bottomFooterBG.setWorldSize(width);
        objects.headerBG.setWorldSize(width);
      }
    }
    handleSkipTutorial$ = () => {
      const { tutorialManager, layoutManager } = this.scene;
      const { objects } = layoutManager;
      tutorialManager.stop();
      this.scene.finishLevel();
      objects.skipContainer.kill();
      objects.headerBG.revive();
      if (!WorldUtils_default.isLandscape()) {
        objects.topFooterBG.revive();
        objects.bottomFooterBG.revive();
      }
    };
    handlePauseButton$ = () => {
      GameplayNotificationUtils_default.setGameplayPauseNotificationFlag(false);
      ScreenUtils_default.openScreen(ScreenKeys_default.PAUSE_SCREEN);
    };
    updateLevel(level) {
      const { objects } = this.scene.layoutManager;
      const displayLevel = MatchUtils_default.isTournamentMode() ? level - 1 : level;
      objects.levelText.setText(`Lv ${displayLevel}`);
    }
    showUIForGuide() {
      const { levelHandler, layoutManager } = this.scene;
      const { objects, groups } = layoutManager;
      const { level } = levelHandler;
      if (level > FinalGuideLevel2) return;
      if (level === 1) {
        groups.gameUI.killGroup();
        objects.headerBG.kill();
        if (!WorldUtils_default.isLandscape()) {
          objects.topFooterBG.kill();
          objects.bottomFooterBG.kill();
        }
      } else if (level === 2) {
        const { itemManager } = this.scene;
        objects.headerBG.revive();
        if (!WorldUtils_default.isLandscape()) {
          objects.topFooterBG.revive();
          objects.bottomFooterBG.revive();
        }
        itemManager.invisibleItem(item_default.BOMB_DEFUSE.ID);
        itemManager.invisibleItem(item_default.ROCKET.ID);
        itemManager.invisibleItem(item_default.SUPER_ROCKET.ID);
        if (!MatchUtils_default.isTournamentMode()) {
          objects.playtimeClock.kill();
        }
      } else if ([3, 4, 6, 7, 8, 9, 10].includes(level)) {
        const { itemManager } = this.scene;
        itemManager.invisibleItem(item_default.BOMB_DEFUSE.ID);
        itemManager.invisibleItem(item_default.ROCKET.ID);
        itemManager.invisibleItem(item_default.SUPER_ROCKET.ID);
      } else if (level === 5) {
        const { itemManager, tutorialManager } = this.scene;
        if (!tutorialManager.isGuideShown(TUTORIAL_ID.MAGNIFIER_ITEM)) {
          itemManager.setFreeItem(item_default.HINT.ID);
        }
        itemManager.invisibleItem(item_default.BOMB_DEFUSE.ID);
        itemManager.invisibleItem(item_default.ROCKET.ID);
        itemManager.invisibleItem(item_default.SUPER_ROCKET.ID);
      } else if (level === 11) {
        const { itemManager, tutorialManager } = this.scene;
        if (!tutorialManager.isGuideShown(TUTORIAL_ID.DIFFUSE_ITEM)) {
          this.changeToGuideDefuseItem();
          itemManager.setFreeItem(item_default.GUIDE_BOMB_DEFUSE.ID);
        }
        itemManager.invisibleItem(item_default.ROCKET.ID);
        itemManager.invisibleItem(item_default.SUPER_ROCKET.ID);
      } else if ([12, 14, 15].includes(level)) {
        const { itemManager } = this.scene;
        itemManager.invisibleItem(item_default.ROCKET.ID);
        itemManager.invisibleItem(item_default.SUPER_ROCKET.ID);
      } else if (level === 13) {
        const { itemManager, tutorialManager } = this.scene;
        if (!tutorialManager.isGuideShown(TUTORIAL_ID.SHUFFLE_ITEM)) {
          itemManager.setFreeItem(item_default.SHUFFLE.ID);
        }
        itemManager.invisibleItem(item_default.ROCKET.ID);
        itemManager.invisibleItem(item_default.SUPER_ROCKET.ID);
      } else if (level === 16) {
        const { itemManager, tutorialManager } = this.scene;
        if (!tutorialManager.isGuideShown(TUTORIAL_ID.ROCKET_ITEM)) {
          itemManager.setFreeItem(item_default.ROCKET.ID);
        }
        itemManager.invisibleItem(item_default.SUPER_ROCKET.ID);
      }
    }
    disableUILogicForGuide1() {
      const { objects } = this.scene.layoutManager;
      objects.playtimeClock.setDisable(true);
      objects.skipContainer.revive();
      objects.skipBtn.setDisabled(false);
      this.scene.comboManager.stop();
      objects.comboProgressBar.kill();
    }
    disableUILogicForGuide2() {
      const { objects } = this.scene.layoutManager;
      objects.playtimeClock.setDisable(true);
    }
    changeToGuideDefuseItem() {
      const { itemManager } = this.scene;
      const defuse = itemManager.getItem(item_default.BOMB_DEFUSE.ID);
      defuse?.kill();
      const guideDefuse = itemManager.getItem(item_default.GUIDE_BOMB_DEFUSE.ID);
      guideDefuse?.revive();
    }
    changeToDefuseItem() {
      const { itemManager } = this.scene;
      const defuse = itemManager.getItem(item_default.BOMB_DEFUSE.ID);
      defuse?.revive();
      const guideDefuse = itemManager.getItem(item_default.GUIDE_BOMB_DEFUSE.ID);
      guideDefuse?.kill();
    }
    async showUIByMatchMode() {
      if (MatchUtils_default.isChallengeMode()) {
        this.showUIForChallenge();
        if (MatchUtils_default.isPlayerFinished()) {
          await T5.sleepAsync(1700);
          event29.emit(game_default.SHOW_RESULT_CHALLENGE_SCREEN);
        }
      } else {
        this.showUIForSingle();
      }
    }
    showUIForChallenge() {
      const { objects } = this.scene.layoutManager;
      objects.challengeInfo.revive();
      objects.levelText.kill();
      objects.starProgressBar.kill();
    }
    showUIForSingle() {
      const { objects } = this.scene.layoutManager;
      objects.challengeInfo.kill();
      objects.levelText.revive();
      objects.starProgressBar.revive();
    }
    enablePause() {
      const { objects } = this.scene.layoutManager;
      objects.pauseButton.setDisabled(false);
    }
    disablePause() {
      const { objects } = this.scene.layoutManager;
      objects.pauseButton.setDisabled(true);
      objects.pauseButton.setAlpha(1);
    }
    checkForMissionNotification() {
      if (GameplayNotificationUtils_default.isGameplayPauseNotificationAvailable) {
        const { objects } = this.scene.layoutManager;
        objects.playPauseNotification();
      }
    }
  };
  var UIManager_default = UIManager;

  // src/game/gameplay/managers/EffectManager.ts
  init_phaser_custom_min();

  // src/game/gameplay/animations/animation/ItemRocketFlyEffect.ts
  init_phaser_custom_min();

  // src/game/effects/RocketSmoke.ts
  init_phaser_custom_min();
  var { KEY: KEY43, FRAME: FRAME39 } = sprites_default.EFFECTS;
  var RocketSmoke = class extends Phaser.GameObjects.Container {
    yellowEmitter;
    whiteEmitter;
    constructor(scene) {
      super(scene);
      this.scene.add.existing(this);
    }
    createEmitters() {
      this.yellowEmitter = this.scene.add.particles(0, 0, KEY43, {
        frame: FRAME39.YELLOW_SMOKE,
        // emitZone: {
        //     source: this.emitZone as Phaser.Types.GameObjects.Particles.RandomZoneSource,
        //     type: 'random',
        // },
        // speed: 20,
        timeScale: 1,
        // frequency: 0.0001,
        // frequency: 100,
        // maxParticles: 100,
        alpha: { start: 0.3, end: 0, ease: Phaser.Math.Easing.Expo.Out },
        scale: {
          start: 0.3,
          end: 1,
          ease: Phaser.Math.Easing.Expo.Out
        },
        lifespan: 1500
      });
      this.yellowEmitter.stop(true);
      this.yellowEmitter.setDepth(depth_default.EFFECT);
      this.whiteEmitter = this.scene.add.particles(0, 0, KEY43, {
        frame: FRAME39.WHITE_SMOKE,
        // emitZone: {
        //     source: this.emitZone as Phaser.Types.GameObjects.Particles.RandomZoneSource,
        //     type: 'random',
        // },
        // speed: 20,
        timeScale: 1,
        // frequency: 0.0001,
        // frequency: 100,
        // maxParticles: 100,
        alpha: { start: 0.3, end: 0, ease: Phaser.Math.Easing.Expo.Out },
        scale: {
          start: 0.2,
          end: 1,
          ease: Phaser.Math.Easing.Expo.Out
        },
        rotate: { start: 0, end: 360 * 1, random: true },
        lifespan: 1500
      });
      this.whiteEmitter.stop(true);
      this.whiteEmitter.setDepth(depth_default.EFFECT);
    }
    // public run(count: number, x: number, y: number, width: number, height: number): void {
    //     this.stop()
    //     this.reset()
    //     this.emitZone.setSize(width, height)
    //     this.emitZone.setPosition(x - width / 2, y - height / 2)
    //     this.emitter.setQuantity(count)
    //     this.emitter.start()
    // }
    explodeYellow(count, x, y, velocityX, velocityY) {
      if (!this.yellowEmitter) {
        this.reset();
      }
      this.yellowEmitter.setParticleSpeed(velocityX, velocityY);
      this.yellowEmitter.explode(count, x, y);
    }
    explodeWhite(count, x, y, velocityX, velocityY) {
      if (!this.whiteEmitter) {
        this.reset();
      }
      this.whiteEmitter.setParticleSpeed(velocityX, velocityY);
      this.whiteEmitter.explode(count, x, y);
    }
    stop() {
      this.yellowEmitter?.killAll();
      this.yellowEmitter?.stop();
      this.whiteEmitter?.killAll();
      this.whiteEmitter?.stop();
    }
    reset() {
      this.createEmitters();
    }
  };
  var RocketSmoke_default = RocketSmoke;

  // src/game/gameplay/animations/animation/ItemRocketFlyEffect.ts
  var { KEY: KEY44, FRAME: FRAME40 } = sprites_default.GAMEPLAY;
  var ItemRocketFlyEffect = class {
    scene;
    longRocketList = [];
    rocketList = [];
    tween1 = [];
    tween2 = [];
    rocketTrail;
    explosionSpriteList = [];
    constructor(scene) {
      this.scene = scene;
      this.createRockets();
      this.createRocketTrail();
      this.createExplosion();
    }
    createRockets() {
      for (let i = 0; i < 4; i++) {
        const longRocket = this.scene.add.image(0, 0, KEY44, FRAME40.EFFECT_LONG_ROCKET);
        longRocket.setOrigin(0.5, 0);
        longRocket.setDepth(depth_default.EFFECT);
        longRocket.kill();
        this.longRocketList.push(longRocket);
        const rocket = this.scene.add.image(0, 0, KEY44, FRAME40.EFFECT_SHORT_ROCKET);
        rocket.setOrigin(1, 0.5);
        rocket.setDepth(depth_default.EFFECT);
        rocket.kill();
        this.rocketList.push(rocket);
      }
    }
    createRocketTrail() {
      this.rocketTrail = new RocketSmoke_default(this.scene);
      this.rocketTrail.setDepth(depth_default.EFFECT);
    }
    createExplosion() {
      const zoomRatio = WorldUtils_default.getZoomRatio();
      for (let i = 0; i < 4; i++) {
        const { KEY: KEY94, FRAME: FRAME100 } = sprites_default.EFFECTS;
        const element = this.scene.add.sprite(0, 0, KEY94, `${FRAME100.EFFECT_ROCKET_EXPLOSION}0`);
        element.setScale(1.2 / zoomRatio);
        element.setOrigin(0.5, 0.5);
        element.setDepth(depth_default.EFFECT);
        element.kill();
        this.explosionSpriteList.push(element);
      }
    }
    playExplosion(x, y, idx) {
      this.explosionSpriteList[idx].revive();
      this.explosionSpriteList[idx].setPosition(x, y);
      this.explosionSpriteList[idx].play(animation_default.ROCKET_EXPLOSION.KEY, true);
      this.explosionSpriteList[idx].once(Phaser.Animations.Events.ANIMATION_COMPLETE, () => {
        this.explosionSpriteList[idx].kill();
      });
    }
    playTween1(targetList, callBack1, callBack2) {
      const { width, height } = WorldUtils_default.getWorldSize();
      const airTargets = [
        { x: -100 - width / 2, y: -50 - height / 2 },
        { x: -50 - width / 2, y: -100 - height / 2 },
        { x: 100 + width / 2, y: -50 - height / 2 },
        { x: 100 + width / 2, y: -100 - height / 2 }
      ];
      this.tween1.push(this.getTween1Target(airTargets[0], 0, 867));
      this.tween1.push(
        this.getTween1Target(airTargets[1], 1, 867 + 100, () => {
          this.playTween2([airTargets[0], airTargets[1]], [targetList[0], targetList[1]], [0, 1], 0,
          callBack1);
        })
      );
      this.tween1.push(this.getTween1Target(airTargets[2], 2, 867 + 200));
      this.tween1.push(
        this.getTween1Target(airTargets[3], 3, 867 + 300, () => {
          this.playTween2([airTargets[2], airTargets[3]], [targetList[2], targetList[3]], [2, 3], 100,
          callBack2);
        })
      );
    }
    getTween1Target(airTarget, idx, delay, callback) {
      const { height } = WorldUtils_default.getWorldSize();
      const endY = height / 2 - 67;
      let timeToSmoke = 0.8;
      const timeChain = this.scene.tweens.chain({
        targets: this.longRocketList[idx],
        tweens: [
          {
            props: {
              y: {
                duration: 867,
                getEnd: () => endY
              },
              rotation: {
                delay,
                duration: 200,
                getEnd: (target) => {
                  return Phaser.Math.Angle.Between(airTarget.x, airTarget.y, target.x, endY) - Math.
                  PI / 2;
                }
              }
            }
          },
          {
            duration: 133 + 200,
            ease: Phaser.Math.Easing.Expo.In,
            onStart: () => {
              AudioUtils_default.playSound(soundEffects_default.ROCKET_FLY);
            },
            props: {
              x: {
                getEnd: () => {
                  return airTarget.x;
                }
              },
              y: {
                getEnd: () => {
                  return airTarget.y;
                }
              }
            },
            onUpdate: (_tween, target) => {
              const x = target.x - target.height / 2 * Math.cos(target.rotation - Math.PI / 2);
              const y = target.y - target.height / 2 * Math.sin(target.rotation - Math.PI / 2);
              const preX = target.x - target.height / 1.5 * Math.cos(target.rotation - Math.PI / 2);
              const preY = target.y - target.height / 1.5 * Math.sin(target.rotation - Math.PI / 2);
              if (_tween.progress > timeToSmoke) {
                this.rocketTrail.explodeYellow(1, x, y, x - preX, y - preY);
                timeToSmoke += 0.02;
              }
              const random = Math.random();
              if (random < 0.2) {
                this.rocketTrail.explodeWhite(1, x, y, x - preX, y - preY);
              }
            },
            onComplete: () => {
              if (callback) {
                callback();
              }
            }
          }
        ]
      });
      timeChain.play();
      return timeChain;
    }
    playTween2(airTargets, targetList, idxList, delay, callBack) {
      const longRocketList = [];
      const rocketList = [];
      for (const idx of idxList) {
        longRocketList.push(this.longRocketList[idx]);
        rocketList.push(this.rocketList[idx]);
      }
      let timeToSmoke = 0.3;
      const tween2 = this.scene.tweens.add({
        targets: rocketList,
        delay,
        duration: 800,
        ease: Phaser.Math.Easing.Expo.In,
        onStart: () => {
          for (const rocket of longRocketList) {
            rocket.kill();
          }
          rocketList.forEach((target, index) => {
            target.setPosition(longRocketList[index].x, longRocketList[index].y);
            target.rotation = 0;
            target.revive();
            target.setRotation(
              Phaser.Math.Angle.Between(
                airTargets[index].x,
                airTargets[index].y,
                targetList[index].x,
                targetList[index].y
              )
            );
          });
        },
        props: {
          x: {
            getEnd: (_target, _key, _value, targetIndex) => {
              return targetList[targetIndex].x;
            }
          },
          y: {
            getEnd: (_target, _key, _value, targetIndex) => {
              return targetList[targetIndex].y;
            }
          }
        },
        onUpdate: (tween, target) => {
          const x = target.x - 1.5 * target.height * Math.cos(target.rotation);
          const y = target.y - 1.5 * target.height * Math.sin(target.rotation);
          const preX = target.x - 2 * target.height * Math.cos(target.rotation);
          const preY = target.y - 2 * target.height * Math.sin(target.rotation);
          if (tween.progress > timeToSmoke) {
            this.rocketTrail.explodeYellow(1, x, y, x - preX, y - preY);
            timeToSmoke += 0.05;
          }
          const random = Math.random();
          if (random < 0.1) {
            this.rocketTrail.explodeWhite(1, x, y, x - preX, y - preY);
          }
        },
        onComplete: () => {
          rocketList.forEach((rocket, index) => {
            rocket.kill();
            this.playExplosion(targetList[index].x, targetList[index].y, idxList[index]);
          });
          if (callBack) {
            callBack();
          }
        }
      });
      this.tween2.push(tween2);
    }
    play(targetList, callback1, callback2) {
      if (targetList.length !== 4) return;
      for (const tween of this.tween1) {
        tween.stop();
      }
      this.tween1 = [];
      for (const tween of this.tween2) {
        tween.stop();
      }
      this.tween2 = [];
      const { width, height } = WorldUtils_default.getWorldSize();
      this.longRocketList.forEach((rocket, index) => {
        const x = width / 8 + width / 4 * index - width / 2;
        const y = height / 2 + 133;
        rocket.setPosition(x, y);
        rocket.rotation = 0;
        rocket.revive();
      });
      this.playTween1(targetList, callback1, callback2);
    }
    stop() {
      for (const tween of this.tween1) {
        tween.stop();
      }
      this.tween1 = [];
      for (const tween of this.tween2) {
        tween.stop();
      }
      this.tween2 = [];
      for (const rocket of this.longRocketList) {
        rocket.kill();
      }
      for (const rocket of this.rocketList) {
        rocket.kill();
      }
      this.rocketTrail.stop();
    }
  };
  var ItemRocketFlyEffect_default = ItemRocketFlyEffect;

  // src/game/effects/TileHintEffect.ts
  init_phaser_custom_min();
  var { KEY: KEY45, FRAME: FRAME41 } = sprites_default.EFFECTS;
  var TileHintEffect = class {
    scene;
    glowEffect1;
    glowEffect2;
    glowSpinTween;
    tile1 = null;
    tile2 = null;
    defaultTileValues = null;
    tileTween;
    constructor(scene) {
      this.scene = scene;
      this.createGlowEffect();
    }
    createGlowEffect() {
      this.glowEffect1 = this.scene.add.image(0, 0, KEY45, FRAME41.FX_HINT_GLOW);
      this.glowEffect1.kill();
      this.glowEffect2 = this.scene.add.image(0, 0, KEY45, FRAME41.FX_HINT_GLOW);
      this.glowEffect2.kill();
    }
    play() {
      this.glowSpinTween?.stop();
      this.tileTween?.stop();
      if (!this.tile1 || !this.tile2) {
        return;
      }
      this.playGlowSpinTween();
      this.playTileTween();
    }
    playGlowSpinTween() {
      if (!this.tile1 || !this.tile2) {
        return;
      }
      const { x: x12, y: y12 } = this.tile1.getWorldPosition();
      const { x: x2, y: y2 } = this.tile2.getWorldPosition();
      const { boardContainer } = this.scene.boardManager;
      this.glowEffect1.revive();
      this.glowEffect1.setPosition(x12, y12);
      this.glowEffect1.setDepth(boardContainer.depth - 1);
      this.glowEffect2.revive();
      this.glowEffect2.setPosition(x2, y2);
      this.glowEffect2.setDepth(boardContainer.depth - 1);
      this.glowSpinTween = this.scene.tweens.add({
        targets: [this.glowEffect1, this.glowEffect2],
        duration: 2e3,
        props: {
          angle: {
            from: 0,
            to: 360
          }
        },
        repeat: -1
      });
    }
    playTileTween() {
      if (!this.tile1 || !this.tile2) {
        return;
      }
      const baseScaleX = [this.tile1.scaleX, this.tile2.scaleX];
      const baseScaleY = [this.tile1.scaleY, this.tile2.scaleY];
      const targets = [this.tile1, this.tile2];
      const baseScaleX1 = this.tile1.scaleX;
      const baseScaleY1 = this.tile1.scaleY;
      const baseScaleX2 = this.tile2.scaleX;
      const baseScaleY2 = this.tile2.scaleY;
      this.defaultTileValues = {
        scaleX1: baseScaleX1,
        scaleY1: baseScaleY1,
        scaleX2: baseScaleX2,
        scaleY2: baseScaleY2
      };
      this.tileTween = this.scene.tweens.chain({
        targets,
        tweens: [
          {
            duration: 300,
            props: {
              scaleX: {
                getStart: (_, key, value, targetIndex) => {
                  return baseScaleX[targetIndex];
                },
                getEnd: (_, key, value, targetIndex) => {
                  return baseScaleX[targetIndex] * 0.7;
                }
              },
              scaleY: {
                getStart: (_, key, value, targetIndex) => {
                  return baseScaleY[targetIndex];
                },
                getEnd: (_, key, value, targetIndex) => {
                  return baseScaleX[targetIndex] * 0.7;
                }
              }
            }
          },
          {
            duration: 100,
            props: {
              angle: {
                from: 0,
                to: -30
              }
            }
          },
          {
            duration: 100,
            props: {
              angle: {
                from: -30,
                to: 30
              }
            }
          },
          {
            duration: 100,
            props: {
              angle: {
                from: 30,
                to: -30
              }
            }
          },
          {
            duration: 100,
            props: {
              angle: {
                from: -30,
                to: 0
              }
            }
          },
          {
            duration: 300,
            props: {
              scaleX: {
                getStart: (_, key, value, targetIndex) => {
                  return baseScaleX[targetIndex] * 0.7;
                },
                getEnd: (_, key, value, targetIndex) => {
                  return baseScaleX[targetIndex];
                }
              },
              scaleY: {
                getStart: (_, key, value, targetIndex) => {
                  return baseScaleY[targetIndex] * 0.7;
                },
                getEnd: (_, key, value, targetIndex) => {
                  return baseScaleY[targetIndex];
                }
              }
            }
          }
        ],
        loop: -1,
        loopDelay: 300
      });
      this.tileTween.play();
    }
    hide() {
      this.glowEffect1.setVisible(false);
      this.glowEffect2.setVisible(false);
    }
    show() {
      this.glowEffect1.setVisible(true);
      this.glowEffect2.setVisible(true);
    }
    stop() {
      this.scene.tweens.killTweensOf([this.glowEffect1, this.glowEffect2, this.tile1, this.tile2]);
      this.glowEffect1.kill();
      this.glowEffect2.kill();
      if (this.defaultTileValues) {
        const { scaleX1, scaleY1, scaleX2, scaleY2 } = this.defaultTileValues;
        this.tile1?.setScale(scaleX1, scaleY1);
        this.tile2?.setScale(scaleX2, scaleY2);
      }
      this.tile1?.setAngle(0);
      this.tile2?.setAngle(0);
      this.tile1 = null;
      this.tile2 = null;
      this.defaultTileValues = null;
    }
  };
  var TileHintEffect_default = TileHintEffect;

  // src/game/gameplay/animations/animation/TileRocketFlyEffect.ts
  init_phaser_custom_min();
  var { KEY: KEY46, FRAME: FRAME42 } = sprites_default.GAMEPLAY;
  var TileRocketFlyEffect = class {
    scene;
    startingPosition;
    target;
    rocket;
    flyTween;
    rocketTrail;
    explosionSprite;
    isPlaying;
    isInQueue;
    constructor(scene) {
      this.scene = scene;
      this.target = null;
      this.startingPosition = null;
      this.isPlaying = false;
      this.isInQueue = false;
      this.createRockets();
      this.createRocketTrail();
      this.createExplosion();
    }
    createExplosion() {
      const { KEY: KEY94, FRAME: FRAME100 } = sprites_default.EFFECTS;
      this.explosionSprite = this.scene.add.sprite(0, 0, KEY94, `${FRAME100.EFFECT_ROCKET_EXPLOSION}\
0`);
      this.explosionSprite.setOrigin(0.5, 0.8);
      this.explosionSprite.kill();
      this.explosionSprite.setDepth(depth_default.ROCKET);
      this.explosionSprite.setScale(0.5);
    }
    createRocketTrail() {
      this.rocketTrail = new RocketSmoke_default(this.scene);
      this.rocketTrail.setDepth(depth_default.ROCKET);
    }
    createRockets() {
      const rocket = this.scene.add.image(0, 0, KEY46, FRAME42.EFFECT_TILE_ROCKET);
      rocket.setOrigin(0.5, 0.5);
      rocket.kill();
      rocket.setDepth(depth_default.ROCKET);
      this.rocket = rocket;
    }
    playTween() {
      if (!this.target) return;
      const targetPos = this.getTargetPosition();
      if (!targetPos) return;
      let timeToSmoke = 0.1;
      this.flyTween = this.scene.tweens.add({
        targets: [this.rocket],
        duration: 600,
        ease: Phaser.Math.Easing.Expo.InOut,
        props: {
          x: {
            getEnd: () => {
              const targetPos2 = this.getTargetPosition();
              if (!targetPos2) return;
              return targetPos2.x;
            }
          },
          y: {
            getEnd: () => {
              const targetPos2 = this.getTargetPosition();
              if (!targetPos2) return;
              return targetPos2.y;
            }
          }
        },
        onStart: () => {
          AudioUtils_default.playSound(soundEffects_default.ROCKET_FLY);
        },
        onUpdate: (tween) => {
          const x = this.rocket.x - this.rocket.height / 2 * Math.cos(this.rocket.rotation - Math.PI /
          2);
          const y = this.rocket.y - this.rocket.height / 2 * Math.sin(this.rocket.rotation - Math.PI /
          2);
          const preX = this.rocket.x - this.rocket.height / 1.5 * Math.cos(this.rocket.rotation - Math.
          PI / 2) * 3;
          const preY = this.rocket.y - this.rocket.height / 1.5 * Math.sin(this.rocket.rotation - Math.
          PI / 2) * 3;
          if (tween.progress > timeToSmoke) {
            timeToSmoke += 0.05;
            this.rocketTrail.explodeYellow(1, x, y, preX - x, preY - y);
          }
          const random = Math.random();
          if (random < 0.3) {
            this.rocketTrail.explodeWhite(1, x, y, preX - x, preY - y);
          }
        },
        onComplete: () => {
          this.rocket.kill();
          this.isPlaying = false;
          const targetPos2 = this.getTargetPosition();
          if (targetPos2) {
            const { x, y } = targetPos2;
            this.playExplosion(x, y);
            this.target?.setIsBreakWhenExplosive(true);
          }
        },
        onStop: () => {
          this.rocket.kill();
          this.isPlaying = false;
          const targetPos2 = this.getTargetPosition();
          if (targetPos2) {
            const { x, y } = targetPos2;
            this.playExplosion(x, y);
            this.target?.setIsBreakWhenExplosive(true);
          }
          this.target = null;
        }
      });
    }
    playExplosion(x, y) {
      this.explosionSprite.revive();
      this.explosionSprite.setPosition(x, y);
      this.explosionSprite.once(Phaser.Animations.Events.ANIMATION_COMPLETE, () => {
        this.explosionSprite.kill();
      });
      this.explosionSprite.play(animation_default.ROCKET_EXPLOSION.KEY, true);
    }
    play() {
      this.flyTween?.stop();
      if (!this.target || !this.startingPosition) return;
      this.isPlaying = true;
      const { x: tileX, y: tileY } = this.startingPosition;
      const targetPos = this.getTargetPosition();
      if (!targetPos) return;
      const { x: targetX, y: targetY } = targetPos;
      const angle = Phaser.Math.Angle.Between(tileX, tileY, targetX, targetY);
      const tileSize = this.scene.boardManager.getTileSize();
      this.rocket.setWorldSize(20 * tileSize / 35, 33.5 * tileSize / 35);
      this.rocket.setPosition(tileX, tileY);
      this.rocket.rotation = angle + Math.PI / 2;
      this.rocket.revive();
      this.playTween();
    }
    getTargetPosition() {
      if (!this.target) return null;
      return this.target.getWorldPosition();
    }
    stop() {
      this.flyTween?.stop();
      this.rocket.kill();
      this.target = null;
      this.isPlaying = false;
      this.isInQueue = false;
    }
  };
  var TileRocketFlyEffect_default = TileRocketFlyEffect;

  // src/game/gameplay/animations/text/ComboEffect.ts
  init_phaser_custom_min();
  var {
    Utils: { Signal: S5, Object: O12 }
  } = Ludex;
  var { KEY: KEY47, FRAME: FRAME43 } = sprites_default.EFFECTS;
  var ComboTypes = {
    GOOD: "GOOD",
    GREAT: "GREAT",
    EXCELLENT: "EXCELLENT",
    UNBELIEVABLE: "UNBELIEVABLE"
  };
  var ComboEffectsFrames = {
    [ComboTypes.GOOD]: {
      text: FRAME43.TEXT_GOOD,
      light: FRAME43.TEXT_GOOD_LIGHT
    },
    [ComboTypes.GREAT]: {
      text: FRAME43.TEXT_GREAT,
      light: FRAME43.TEXT_GREAT_LIGHT
    },
    [ComboTypes.EXCELLENT]: {
      text: FRAME43.TEXT_EXCELLENT,
      light: FRAME43.TEXT_EXCELLENT_LIGHT
    },
    [ComboTypes.UNBELIEVABLE]: {
      text: FRAME43.TEXT_UNBELIEVABLE,
      light: FRAME43.TEXT_UNBELIEVABLE_LIGHT
    }
  };
  var ComboEffect = class extends Phaser.GameObjects.Container {
    scene;
    effects;
    constructor(scene) {
      super(scene);
      this.scene = scene;
      this.setWorldSize(250, 80);
      this.effects = this.createEffects();
      this.scene.add.existing(this);
      this.setDepth(depth_default.ENCOURAGING);
      this.alignContainer();
    }
    alignContainer() {
      Phaser.Display.Align.In.TopCenter(this, this.scene.gameZone, 0, -80);
    }
    // Method
    run(combo) {
      if (combo < 2) return;
      this.disableAllEffects();
      const effect = this.getEffect(combo);
      const { text, light, controller } = effect;
      text.revive();
      light.revive();
      text.setDepth(depth_default.ENCOURAGING);
      light.setDepth(depth_default.ENCOURAGING);
      const signal = controller.renew();
      this.alignContainer();
      this.runTextAnimation(signal);
      this.runTextLightAnimation(light, signal);
    }
    getEffect(combo) {
      switch (combo) {
        case 2:
          return this.effects[ComboTypes.GOOD];
        case 3:
          return this.effects[ComboTypes.GREAT];
        case 4:
          return this.effects[ComboTypes.EXCELLENT];
        default:
          return this.effects[ComboTypes.UNBELIEVABLE];
      }
    }
    disableAllEffects() {
      for (const child of O12.vals(this.effects)) {
        child.controller.abort();
        child.text.kill();
        child.light.kill();
      }
    }
    stop() {
      this.disableAllEffects();
    }
    createEffects() {
      const effects = {};
      const texts = [];
      const lights = [];
      for (const key in ComboEffectsFrames) {
        const type = key;
        const { text: textFrame, light: lightFrame } = ComboEffectsFrames[type];
        const text = this.scene.make.image({
          key: KEY47,
          frame: textFrame,
          origin: { x: 0.5, y: 0.5 }
        });
        const light = this.scene.make.image({
          key: KEY47,
          frame: lightFrame,
          origin: { x: 0.5, y: 0.5 }
        });
        const controller = new S5.SignalController();
        effects[type] = { text, light, controller };
        text.kill();
        light.kill();
        texts.push(text);
        lights.push(light);
      }
      this.add(lights);
      this.add(texts);
      return effects;
    }
    // Animation
    runTextLightAnimation(textLight, signal) {
      const tween = this.scene.tweens.add({
        targets: [textLight],
        props: {
          alpha: {
            repeat: 2,
            duration: 250,
            value: { start: 1, to: 0 }
          },
          scale: {
            yoyo: true,
            duration: 100,
            ease: Phaser.Math.Easing.Quintic.Out,
            value: { start: 0.6, to: 0.8 }
          }
        }
      });
      AnimUtils.runTween(tween, signal);
    }
    runTextAnimation(signal) {
      const tween = this.scene.tweens.add({
        targets: [this],
        props: {
          y: {
            delay: 100,
            duration: 600,
            ease: Phaser.Math.Easing.Quintic.InOut,
            value: { start: this.y, to: this.y - 20 }
          },
          scale: {
            duration: 350,
            ease: Phaser.Math.Easing.Circular.Out,
            value: { start: 0.2, to: 1 }
          },
          alpha: {
            duration: 150,
            value: { start: 0, to: 1 }
          }
        },
        onComplete: () => {
          this.runEndAnimation(signal);
        }
      });
      AnimUtils.runTween(tween, signal);
    }
    runEndAnimation(signal) {
      const tween = this.scene.tweens.add({
        targets: [this],
        duration: 300,
        delay: 100,
        props: {
          alpha: { start: 1, to: 0 },
          scale: {
            ease: Phaser.Math.Easing.Sine.Out,
            value: 0.8
          }
        }
      });
      AnimUtils.runTween(tween, signal);
    }
  };
  var ComboEffect_default = ComboEffect;

  // src/game/effects/TileHighlightEffect.ts
  init_phaser_custom_min();
  var { KEY: KEY48, FRAME: FRAME44 } = sprites_default.GAMEPLAY;
  var TileHighlightEffect = class {
    scene;
    currentTile = null;
    tileHighlightSprite;
    tileOutline;
    tileOutlineTween;
    constructor(scene) {
      this.scene = scene;
      this.createTileOutline();
      this.createSpinningImage();
    }
    createTileOutline() {
      this.tileOutline = this.scene.add.image(0, 0, KEY48, FRAME44.EFFECT_TILE_OUTLINE);
      this.tileOutline.setDepth(depth_default.EFFECT - 1);
      this.tileOutline.kill();
    }
    createSpinningImage() {
      this.tileHighlightSprite = this.scene.make.sprite(
        {
          key: KEY48,
          frame: `${FRAME44.EFFECT_TILE_HIGHLIGHT}0`
        },
        true
      );
      this.tileHighlightSprite.setDepth(depth_default.EFFECT);
      this.tileHighlightSprite.kill();
    }
    play(tile) {
      this.tileOutlineTween?.stop();
      this.currentTile = tile;
      const tileSize = this.scene.boardManager.getTileSize();
      this.tileOutline.revive();
      this.tileOutline.setAlpha(1);
      this.tileOutline.setWorldSize(tileSize * 0.95, tileSize * 0.95);
      tile.add(this.tileOutline);
      this.tileHighlightSprite.revive();
      this.tileHighlightSprite.setY(-1);
      this.tileHighlightSprite.setWorldSize(tileSize, tileSize);
      this.tileHighlightSprite.play(animation_default.TILE_HIGHLIGHT.KEY);
      tile.add(this.tileHighlightSprite);
      this.scene.scene.systems.updateList.add(this.tileHighlightSprite);
      this.runFadeInTween();
    }
    runFadeInTween() {
      this.tileOutlineTween = this.scene.tweens.add({
        targets: this.tileOutline,
        duration: 1e3,
        yoyo: true,
        repeat: -1,
        ease: Phaser.Math.Easing.Sine.InOut,
        props: {
          alpha: 0
        }
      });
    }
    stop() {
      this.tileHighlightSprite.anims.stop();
      this.tileHighlightSprite.setFrame(`${FRAME44.EFFECT_TILE_HIGHLIGHT}0`);
      this.tileHighlightSprite.kill();
      this.tileOutlineTween?.stop();
      this.tileOutline.kill();
      this.currentTile?.remove(this.tileHighlightSprite);
      this.currentTile?.remove(this.tileOutline);
      this.currentTile = null;
    }
  };
  var TileHighlightEffect_default = TileHighlightEffect;

  // src/game/effects/TileBreak.ts
  init_phaser_custom_min();
  var { KEY: KEY49, FRAME: FRAME45 } = sprites_default.GAMEPLAY;
  var TileBreak = class extends Phaser.GameObjects.Container {
    isPlaying;
    constructor(scene) {
      super(scene);
      this.setDepth(depth_default.EFFECT - 1);
      this.createBreakFragments();
      this.scene.add.existing(this);
    }
    getIsPlaying() {
      return this.isPlaying;
    }
    createBreakFragments() {
      const left = this.scene.make.image({
        key: KEY49,
        frame: FRAME45.LEF_TILE_FRAGMENT
      });
      this.add(left);
      const right = this.scene.make.image({
        key: KEY49,
        frame: FRAME45.RIGHT_TILE_FRAGMENT
      });
      this.add(right);
      const top = this.scene.make.image({
        key: KEY49,
        frame: FRAME45.TOP_TILE_FRAGMENT
      });
      this.add(top);
      const bottom = this.scene.make.image({
        key: KEY49,
        frame: FRAME45.BOTTOM_TILE_FRAGMENT
      });
      this.add(bottom);
    }
    playAnimation(x, y) {
      this.isPlaying = true;
      const scene = this.scene;
      const tileSize = scene.boardManager.getTileSize();
      this.revive();
      const fragments = this.getAll();
      for (const fragment of fragments) {
        fragment.setPosition(0, 0);
        fragment.setAlpha(1);
        fragment.setAngle(0);
        if (fragment instanceof Phaser.GameObjects.Image) {
          fragment.setWorldSize(tileSize, tileSize);
        }
      }
      this.setPosition(x, y);
      const toPos = [
        { x: -10, y: 0, angle: -10 },
        { x: 10, y: 0, angle: 10 },
        { x: 0, y: -10, angle: 10 },
        { x: 0, y: 10, angle: -10 }
      ];
      this.scene.tweens.add({
        targets: this.getAll(),
        alpha: 1,
        duration: 500,
        props: {
          x: { value: (_target, _key, _value, idx) => toPos[idx].x },
          y: { value: (_target, _key, _value, idx) => toPos[idx].y },
          alpha: { value: 0 },
          angle: { value: (_target, _key, _value, idx) => toPos[idx].angle }
        },
        onComplete: () => {
          this.kill();
          this.isPlaying = false;
        }
      });
    }
    stop() {
      this.scene.tweens.killTweensOf(this.getAll());
      this.kill();
      this.isPlaying = false;
    }
  };
  var TileBreak_default = TileBreak;

  // src/game/gameplay/animations/animation/FlyingStarFromClockEffect.ts
  init_phaser_custom_min();
  var { KEY: KEY50, FRAME: FRAME46 } = sprites_default.GAMEPLAY;
  var FlyingStarFromClockEffect = class {
    scene;
    starList;
    flyingStarCounter;
    flyingStarTweens;
    clockRemainingTime;
    captureStarTrails;
    explodeParticle;
    constructor(scene) {
      this.scene = scene;
      this.starList = this.scene.add.group();
      this.flyingStarTweens = [];
      this.createEffects();
      this.clockRemainingTime = 0;
    }
    createEffects() {
      this.captureStarTrails = [];
      this.explodeParticle = new StarExplodeParticle_default(this.scene);
      this.explodeParticle.setDepth(depth_default.EFFECT + 1);
    }
    play(callback) {
      this.flyingStarCounter?.stop();
      const { layoutManager } = this.scene;
      const { playtimeClock, starProgressBar } = layoutManager.objects;
      if (!playtimeClock.visible || !starProgressBar.visible) {
        if (callback) callback();
        return;
      }
      playtimeClock.pauseClock();
      this.clockRemainingTime = playtimeClock.getRemainingTime();
      const timeRemovalPerStar = this.clockRemainingTime > 78 ? Math.ceil(this.clockRemainingTime / 13) :
      6;
      this.flyingStarCounter = this.scene.tweens.addCounter({
        from: 0,
        to: 100,
        duration: 100,
        onStart: () => {
          this.runStarTweens();
          this.clockRemainingTime = this.clockRemainingTime > timeRemovalPerStar ? this.clockRemainingTime -
          timeRemovalPerStar : 0;
          playtimeClock.setClockText(this.clockRemainingTime);
          if (this.clockRemainingTime === 0) {
            this.flyingStarCounter.stop();
            if (typeof callback === "function") {
              this.scene.time.delayedCall(1e3, callback);
            }
          }
        },
        onLoop: () => {
          this.runStarTweens();
          this.clockRemainingTime = this.clockRemainingTime > timeRemovalPerStar ? this.clockRemainingTime -
          timeRemovalPerStar : 0;
          playtimeClock.setClockText(this.clockRemainingTime);
          if (this.clockRemainingTime === 0) {
            this.flyingStarCounter.stop();
            if (typeof callback === "function") {
              this.scene.time.delayedCall(1e3, callback);
            }
          }
        },
        loop: -1
      });
    }
    stop() {
      this.flyingStarCounter?.stop();
      for (const tween of this.flyingStarTweens) {
        tween.stop();
      }
      for (const star of this.starList.getChildren()) {
        this.starList.killAndHide(star);
      }
      for (const captureStarTrail of this.captureStarTrails) {
        captureStarTrail.stop();
      }
    }
    runStarTweens() {
      const star = this.requestNewStar();
      const captureStarTrail = this.requestCaptureStarTrail();
      const { layoutManager } = this.scene;
      const { playtimeClock, starProgressBar } = layoutManager.objects;
      const { x: x12, y: y12 } = playtimeClock.getWorldPosition();
      const { x: x2, y: y2 } = starProgressBar.getStarFlyInPosition();
      const clockX = x12 - 20;
      const point1 = new Phaser.Math.Vector2(clockX, y12);
      const point3 = new Phaser.Math.Vector2(x2, y2);
      const lerpX = Phaser.Math.FloatBetween(0.2, 0.5);
      const lerpY = Phaser.Math.FloatBetween(0.3, 0.7);
      const point2X = Phaser.Math.Interpolation.Linear([clockX, x2], lerpX);
      const point2Y = WorldUtils_default.isLandscape() ? Phaser.Math.Interpolation.Linear([y2, y2 + 200],
      lerpY) : Phaser.Math.Interpolation.Linear([y2, y2 + 100], lerpY);
      const point2 = new Phaser.Math.Vector2(point2X, point2Y);
      const newSpline = new Phaser.Curves.QuadraticBezier(point1, point2, point3);
      const baseScale = star.scale;
      const tween = this.scene.tweens.addCounter({
        from: 0,
        to: 100,
        duration: 650,
        ease: Phaser.Math.Easing.Sine.Out,
        onStart: () => {
          star.setScale(0);
          star.setPosition(clockX, y12);
          star.setVisible(true);
          captureStarTrail.run(1, star.x, star.y, 0, 0);
        },
        onUpdate: (tween2) => {
          const value = tween2.getValue();
          const point = newSpline.getPoint(value / 100);
          star.setPosition(point.x, point.y);
          captureStarTrail.moveEmitZone(star.x, star.y);
          const scaleModifier = value > 50 ? 1 : value / 50;
          star.setScale(baseScale * scaleModifier);
        },
        onComplete: () => {
          this.starList.killAndHide(star);
          star.setScale(baseScale);
          captureStarTrail.stop();
          this.explodeParticle.explode(5, x2, y2, 20);
          AudioUtils_default.playSound(soundEffects_default.COLLECT_STARS, { volume: 0.7 });
          this.flyingStarTweens = this.flyingStarTweens.filter((t) => t !== tween);
        },
        onStop: () => {
          this.starList.killAndHide(star);
          star.setScale(baseScale);
          captureStarTrail.stop();
          this.flyingStarTweens = this.flyingStarTweens.filter((t) => t !== tween);
        }
      });
      this.flyingStarTweens.push(tween);
    }
    requestNewStar() {
      const inactiveStar = this.starList.getFirstDead();
      if (inactiveStar) {
        inactiveStar.setActive(true);
        inactiveStar.setWorldSize(28, 28);
        return inactiveStar;
      }
      const star = this.scene.make.image({
        key: KEY50,
        frame: FRAME46.ICON_STAR_BIG
      });
      this.starList.add(star);
      star.setWorldSize(28, 28);
      star.setDepth(depth_default.EFFECT);
      star.setVisible(false);
      this.scene.add.existing(star);
      return star;
    }
    requestCaptureStarTrail() {
      const inactiveCometTwinkle = this.captureStarTrails.find((twinkle) => !twinkle.isRunning);
      if (inactiveCometTwinkle) {
        return inactiveCometTwinkle;
      }
      const captureStarTrail = new CaptureStarTrail_default(this.scene);
      captureStarTrail.setDepth(depth_default.EFFECT - 1);
      this.captureStarTrails.push(captureStarTrail);
      return captureStarTrail;
    }
  };
  var FlyingStarFromClockEffect_default = FlyingStarFromClockEffect;

  // src/game/gameplay/animations/animation/ComboExplosionEffect.ts
  init_phaser_custom_min();

  // src/game/gameplay/animations/particle/ComboExplosionParticle.ts
  init_phaser_custom_min();
  var { KEY: KEY51, FRAME: FRAME47 } = sprites_default.GAMEPLAY;
  var ComboExplosionParticle = class extends ExplodeParticle_default {
    explode(count, x, y, radius) {
      super.explode(count, x, y, radius);
      this.runParticleTween();
    }
    createEmitters() {
      const speed = 370;
      this.emitter = this.scene.add.particles(0, 0, KEY51, {
        frame: FRAME47.EFFECT_SPARK,
        speedX: { min: -speed, max: speed },
        speedY: { min: -speed, max: speed },
        scale: { min: 0.8, max: 1.1 },
        alpha: { min: 0.8, max: 1 },
        tint: 16749298,
        deathZone: {
          source: this.deathZone,
          type: "onLeave"
        }
        // lifespan: 50000,
      });
    }
    runParticleTween() {
      const index = 0;
      this.emitter.forEachAlive((particle) => {
        this.scene.tweens.killTweensOf(particle);
        this.scene.tweens.add({
          targets: [particle],
          duration: 400,
          delay: 5 * index,
          ease: Phaser.Math.Easing.Circular.Out,
          props: {
            velocityX: particle.velocityX / 50,
            velocityY: particle.velocityY / 50
          }
        });
        this.scene.add.tween({
          targets: [particle],
          duration: 2e3,
          delay: 300,
          ease: Phaser.Math.Easing.Circular.Out,
          props: {
            alpha: 0,
            scaleX: 0,
            scaleY: 0,
            velocityX: Phaser.Math.RND.between(-20, 20),
            velocityY: Phaser.Math.RND.between(-60, -90)
          },
          onComplete: () => {
            particle.lifeCurrent = 0;
          }
        });
      }, this);
    }
  };
  var ComboExplosionParticle_default = ComboExplosionParticle;

  // src/game/gameplay/animations/animation/ComboExplosionEffect.ts
  var { KEY: KEY52, FRAME: FRAME48 } = sprites_default.EFFECTS;
  var ComboExplosionEffect = class {
    scene;
    comboExplosionParticle;
    explosionCircle;
    explosionCircleTween;
    constructor(scene) {
      this.scene = scene;
      this.createComboExplosionParticle();
      this.createExplosionCircle();
    }
    createComboExplosionParticle() {
      this.comboExplosionParticle = new ComboExplosionParticle_default(this.scene);
      this.comboExplosionParticle.setDepth(depth_default.EFFECT + 1);
    }
    createExplosionCircle() {
      this.explosionCircle = this.scene.add.image(0, 0, KEY52, FRAME48.FX_CIRCLE);
      this.explosionCircle.setTint(16753660);
      this.explosionCircle.setScale(1);
      this.explosionCircle.setDepth(depth_default.EFFECT + 1);
      this.explosionCircle.setVisible(false);
    }
    play() {
      this.explosionCircleTween?.stop();
      const { objects } = this.scene.layoutManager;
      if (!objects.comboProgressBar.visible) return;
      const { x, y } = objects.comboProgressBar.comboNumber.getWorldPosition();
      this.runExplosionCircleTween(x, y);
    }
    runExplosionCircleTween(x, y) {
      const baseScale = this.explosionCircle.scale;
      this.explosionCircleTween = this.scene.tweens.chain({
        targets: this.explosionCircle,
        tweens: [
          {
            scaleX: baseScale,
            scaleY: baseScale,
            alpha: 0.4,
            ease: Phaser.Math.Easing.Cubic.Out,
            duration: 400,
            onStart: () => {
              this.explosionCircle.setScale(0.5 * baseScale);
              this.explosionCircle.setAlpha(0.1);
              this.explosionCircle.setPosition(x, y);
              this.explosionCircle.setVisible(true);
              this.comboExplosionParticle.explode(20, x, y, 1e3);
            },
            onStop: () => {
              this.explosionCircle.setVisible(false);
              this.explosionCircle.setScale(baseScale);
            }
          },
          {
            alpha: 0,
            ease: Phaser.Math.Easing.Cubic.Out,
            duration: 800,
            onComplete: () => {
              this.explosionCircle.setVisible(false);
              this.explosionCircle.setScale(baseScale);
            },
            onStop: () => {
              this.explosionCircle.setVisible(false);
              this.explosionCircle.setScale(baseScale);
            }
          }
        ]
      });
      this.explosionCircleTween.play();
    }
    stop() {
      this.explosionCircleTween?.stop();
      this.explosionCircle.setVisible(false);
    }
  };
  var ComboExplosionEffect_default = ComboExplosionEffect;

  // src/game/gameplay/animations/animation/ButterflyCaptureEffect.ts
  init_phaser_custom_min();

  // src/game/components/ShadowTexture.ts
  init_phaser_custom_min();
  var { KEY: BUTTERFLY_KEY } = sprites_default.TILES.BUTTERFLY;
  var { KEY: KEY53, FRAME: FRAME49 } = sprites_default.GAMEPLAY;
  var ShadowTexture = class extends Phaser.GameObjects.Container {
    config;
    objectHeight;
    targetContainer;
    targetButterflyImage1;
    targetButterflyImage2;
    butterflyImage1;
    butterflyImage2;
    butterflyBody;
    constructor(scene, x, y, config) {
      super(scene, x, y);
      this.setConfig(config);
      this.setVisible(false);
      this.scene.add.existing(this);
    }
    initContainer(targetButterflyImage1, targetButterflyImage2, targetContainer, frame) {
      this.targetContainer = targetContainer;
      this.targetButterflyImage1 = targetButterflyImage1;
      this.targetButterflyImage2 = targetButterflyImage2;
      this.initBody();
      this.initShadowButterflyWings(frame);
      this.setSize(this.targetContainer.width, this.targetContainer.height);
      this.setDepth(depth_default.EFFECT - 1);
      this.setAlpha(0.7);
    }
    initShadowButterflyWings(frame) {
      const { flipX: flipX1, originX: originX1, originY: originY1 } = this.targetButterflyImage1;
      const { flipX: flipX2, originX: originX2, originY: originY2 } = this.targetButterflyImage2;
      if (!this.butterflyImage1) {
        this.butterflyImage1 = this.scene.add.image(0, 0, BUTTERFLY_KEY, frame);
        this.butterflyImage1.kill();
        this.add(this.butterflyImage1);
      }
      this.butterflyImage1.setFrame(frame);
      this.butterflyImage1.setDepth(depth_default.EFFECT);
      this.butterflyImage1.setOrigin(originX1, originY1);
      this.butterflyImage1.setWorldSize(this.targetButterflyImage1.width, this.targetButterflyImage1.
      height);
      this.butterflyImage1.setFlipX(flipX1);
      this.butterflyImage1.setPosition(0, 0);
      this.butterflyImage1.setTint(0);
      if (!this.butterflyImage2) {
        this.butterflyImage2 = this.scene.add.image(0, 0, BUTTERFLY_KEY, frame);
        this.butterflyImage2.kill();
        this.add(this.butterflyImage2);
      }
      this.butterflyImage2.setFrame(frame);
      this.butterflyImage2.setDepth(depth_default.EFFECT);
      this.butterflyImage2.setOrigin(originX2, originY2);
      this.butterflyImage2.setWorldSize(this.targetButterflyImage2.width, this.targetButterflyImage2.
      height);
      this.butterflyImage2.setFlipX(flipX2);
      this.butterflyImage2.setPosition(0, 0);
      this.butterflyImage2.setTint(0);
    }
    initBody() {
      const { displayHeight } = this.targetButterflyImage1;
      if (!this.butterflyBody) {
        this.butterflyBody = this.scene.add.image(0, 0, KEY53, FRAME49.TILE_BUTTERFLY_BODY);
        this.add(this.butterflyBody);
      }
      this.butterflyBody.setPosition(-1, -3.5);
      this.butterflyBody.setDisplaySize(displayHeight * (31 / 59) * 0.75, displayHeight * 0.75);
      this.butterflyBody.setDepth(depth_default.EFFECT);
      this.butterflyBody.setTint(0);
    }
    setConfig(payload) {
      const { width, height } = WorldUtils_default.getWorldSize();
      this.config = {
        sunPosition: new Phaser.Math.Vector2(
          payload.sunPosition?.x || -width / 2,
          payload.sunPosition?.y || -height / 2
        ),
        sunToGroundDistance: payload.sunToGroundDistance || height * 0.1,
        inputObject: payload.inputObject,
        initialHeight: payload.initialHeight || height * 0.05
      };
      this.objectHeight = this.config.initialHeight;
    }
    updateShadow(height) {
      const { sunPosition, sunToGroundDistance, inputObject } = this.config;
      const { x, y } = inputObject;
      const { scale: containerScale, angle: containerAngle } = this.targetContainer;
      const { scaleX: scaleX1, scaleY: scaleY1 } = this.targetButterflyImage1;
      const { scaleX: scaleX2, scaleY: scaleY2 } = this.targetButterflyImage2;
      const newHeight = height || 0;
      let shadowHeightRatio = newHeight / sunToGroundDistance;
      this.setAngle(containerAngle);
      if (shadowHeightRatio > 1) shadowHeightRatio = 1;
      if (shadowHeightRatio <= 0) {
        this.setPosition(x, y);
        this.butterflyImage1.setScale(scaleX1, scaleY1);
        this.butterflyImage2.setScale(scaleX2, scaleY2);
        this.setScale(1);
        return;
      }
      const sunToObjectVector = new Phaser.Math.Vector2(x - sunPosition.x, y - sunPosition.y);
      const ObjectToShadowPosition = new Phaser.Math.Vector2(
        sunToObjectVector.x * shadowHeightRatio / (1 - shadowHeightRatio),
        sunToObjectVector.y * shadowHeightRatio / (1 - shadowHeightRatio)
      );
      this.setScale(1 - shadowHeightRatio);
      this.setPosition(x + ObjectToShadowPosition.x, y + ObjectToShadowPosition.y);
      this.butterflyImage1.setScale(scaleX1, scaleY1);
      this.butterflyImage2.setScale(scaleX2, scaleY2);
      this.setScale(containerScale);
    }
    setNewHeight(height) {
      this.objectHeight = height;
    }
    update() {
      this.updateShadow(this.objectHeight);
    }
    kill() {
      this.butterflyImage1.kill();
      this.butterflyImage2.kill();
      this.butterflyBody.kill();
      super.kill();
    }
    revive() {
      this.butterflyImage1.revive();
      this.butterflyImage2.revive();
      this.butterflyBody.revive();
      super.revive();
    }
  };
  var ShadowTexture_default = ShadowTexture;

  // src/game/gameplay/animations/particle/ButterflyStarTrail.ts
  init_phaser_custom_min();
  var { KEY: KEY54, FRAME: FRAME50 } = sprites_default.GAMEPLAY;
  var {
    Utils: { Device: D6 }
  } = Ludex;
  var ButterflyStarTrail = class extends CaptureStarTrail_default {
    createEmitters() {
      const scale = 1 / D6.pixelRatio();
      this.emitter = this.scene.add.particles(0, 0, KEY54, {
        frame: FRAME50.EFFECT_TRAIL_STAR,
        emitZone: {
          source: this.emitZone,
          type: "random"
        },
        speed: 20,
        timeScale: 1,
        frequency: 100,
        alpha: { start: 1, end: 0, ease: Phaser.Math.Easing.Expo.Out },
        scale: { start: scale * 1.2, end: scale * 0.3, ease: Phaser.Math.Easing.Expo.Out },
        lifespan: 2666
      });
      this.add(this.emitter);
    }
  };
  var ButterflyStarTrail_default = ButterflyStarTrail;

  // src/game/gameplay/animations/animation/ButterflyCaptureEffect.ts
  var { KEY: KEY55, FRAME: FRAME51 } = sprites_default.GAMEPLAY;
  var { KEY: BUTTERFLY_KEY2 } = sprites_default.TILES.BUTTERFLY;
  var BUTTERFLY_SCALE_MAX = 2;
  var BUTTERFLY_SCALE_MIN = 1.5;
  var ButterflyCaptureEffect = class extends Phaser.GameObjects.GameObject {
    butterflyImage1;
    butterflyImage2;
    butterflyBody;
    captureStarTrail;
    butterflyContainer;
    combineTween;
    flyTween;
    flapTween;
    shadowTexture;
    constructor(scene) {
      super(scene, "butterflyCaptureEffect");
    }
    init(tile1, tile2) {
      this.initCaptureStarTrail();
      this.initSprites(tile1, tile2);
      this.scene.time.delayedCall(50, () => {
        this.runCombineTween();
      });
    }
    initCaptureStarTrail() {
      this.captureStarTrail = new ButterflyStarTrail_default(this.scene);
      this.captureStarTrail.stop();
    }
    initSprites(tile1, tile2) {
      const icon = tile1.getIcon();
      const frame = icon.frame.name;
      const { x: x12, y: y12 } = this.getTileWorldPosition(tile1.row, tile1.column);
      if (!this.butterflyImage1) {
        this.butterflyImage1 = this.scene.add.image(x12, y12, BUTTERFLY_KEY2, frame);
      }
      this.butterflyImage1.setPosition(x12, y12);
      this.butterflyImage1.setFrame(frame);
      this.butterflyImage1.setDepth(depth_default.EFFECT);
      const { x: x2, y: y2 } = this.getTileWorldPosition(tile2.row, tile2.column);
      if (!this.butterflyImage2) {
        this.butterflyImage2 = this.scene.add.image(x2, y2, BUTTERFLY_KEY2, frame);
      }
      this.butterflyImage2.setPosition(x2, y2);
      this.butterflyImage2.setFrame(frame);
      this.butterflyImage2.setDepth(depth_default.EFFECT);
      if (x12 >= x2) {
        this.butterflyImage2.flipX = true;
        this.butterflyImage2.setOrigin(0, 0.5);
        this.butterflyImage1.flipX = false;
        this.butterflyImage1.setOrigin(1, 0.5);
      } else {
        this.butterflyImage1.flipX = true;
        this.butterflyImage1.setOrigin(0, 0.5);
        this.butterflyImage2.flipX = false;
        this.butterflyImage2.setOrigin(1, 0.5);
      }
      this.butterflyImage1.revive();
      this.butterflyImage2.revive();
    }
    runCombineTween() {
      this.combineTween?.stop();
      this.combineTween = this.scene.tweens.add({
        targets: this.butterflyImage1,
        x: this.butterflyImage2.x,
        y: this.butterflyImage2.y,
        duration: 500,
        ease: Phaser.Math.Easing.Quartic.Out,
        onComplete: () => {
          this.initContainer();
          this.initShadowTexture();
          this.runFlyTween();
          this.captureStarTrail.setDepth(this.butterflyContainer.depth - 1);
        },
        onStop: () => {
          this.butterflyImage1.kill();
          this.butterflyImage2.kill();
        }
      });
    }
    runFlyTween() {
      this.flyTween?.stop();
      this.flapTween?.stop();
      const { width, height } = WorldUtils_default.getWorldSize();
      const { y } = this.butterflyContainer;
      const containerScale = this.butterflyContainer.scale;
      const maxScaleDifference = BUTTERFLY_SCALE_MAX - BUTTERFLY_SCALE_MIN;
      const isFlyingLeft = Math.random() > 0.5;
      const offset = this.butterflyContainer.width / 2 * (maxScaleDifference + BUTTERFLY_SCALE_MIN);
      const finalPosX = isFlyingLeft ? -width / 2 - offset : width / 2 + offset;
      const finalPosY = y + Phaser.Math.Between(-height * 0.15, height * 0.15);
      const maxHeight = height * (Math.random() * 0.015 + 5e-3);
      const distanceX = Math.abs(finalPosX - this.butterflyContainer.x);
      const distanceY = Math.abs(finalPosY - this.butterflyContainer.y);
      const offsetAngle = Phaser.Math.RadToDeg(Math.atan(distanceY / distanceX));
      const angle = finalPosY > y ? 90 + offsetAngle : 90 - offsetAngle;
      this.flyTween = this.scene.tweens.add({
        targets: this.butterflyContainer,
        props: {
          x: {
            value: finalPosX,
            duration: 3e3,
            ease: "Linear"
          },
          y: {
            value: finalPosY,
            duration: 3e3,
            ease: "Linear"
          },
          angle: {
            value: isFlyingLeft ? angle * -1 : angle,
            duration: 1e3,
            ease: "Linear"
          },
          scale: {
            value: containerScale * (Math.random() * maxScaleDifference + BUTTERFLY_SCALE_MIN),
            duration: 1e3,
            ease: "Linear"
          }
        },
        onStart: () => {
          const { width: width2, height: height2, x, y: y2 } = this.butterflyContainer;
          this.captureStarTrail.run(1, x - width2 / 2, y2 - height2 / 2, width2, height2);
        },
        onUpdate: (tween) => {
          const elapsedTime = tween.totalElapsed;
          const { width: width2, height: height2, x, y: y2 } = this.butterflyContainer;
          this.captureStarTrail.moveEmitZone(x - width2 / 2, y2 - height2 / 2);
          if (elapsedTime > 1e3) return;
          const flyHeight = maxHeight * (elapsedTime / 1e3);
          this.shadowTexture.setNewHeight(flyHeight);
          this.shadowTexture.update();
          if (!this.shadowTexture.visible) {
            this.shadowTexture.revive();
          }
        },
        onComplete: () => {
          this.butterflyContainer.setScale(containerScale);
          this.captureStarTrail.stop();
          this.kill();
        },
        onStop: () => {
          this.captureStarTrail.stop();
          this.butterflyContainer.setScale(containerScale);
        }
      });
      const baseScaleX = this.butterflyImage1.scaleX;
      const duration = Phaser.Math.Between(150, 350);
      this.flapTween = this.scene.tweens.add({
        targets: [this.butterflyImage1, this.butterflyImage2],
        props: {
          scaleX: {
            value: baseScaleX * 0.4,
            duration
          }
        },
        yoyo: true,
        repeat: -1,
        ease: Phaser.Math.Easing.Sine.InOut,
        onComplete: () => {
          this.butterflyImage1.scaleX = baseScaleX;
          this.butterflyImage2.scaleX = baseScaleX;
        },
        // onYoyo: (tween) => {
        //     if (tween.totalElapsed < 1000) return
        //     const { objectHeight } = this.shadowTexture
        //     this.shadowTexture.setNewHeight(objectHeight / 1.03)
        //     this.shadowTexture.update()
        // },
        onUpdate: (tween) => {
          if (tween.totalElapsed < 1e3) return;
          this.shadowTexture.update();
        },
        // onRepeat: (tween) => {
        //     if (tween.totalElapsed < 1000) return
        //     const { objectHeight } = this.shadowTexture
        //     this.shadowTexture.setNewHeight(objectHeight * 1.03)
        //     this.shadowTexture.update()
        // },
        onStop: () => {
          this.butterflyImage1.scaleX = baseScaleX;
          this.butterflyImage2.scaleX = baseScaleX;
        }
      });
    }
    initContainer() {
      const { x, y, displayHeight, displayWidth } = this.butterflyImage1;
      if (!this.butterflyContainer) {
        this.butterflyContainer = this.scene.add.container(x, y);
      } else {
        this.butterflyContainer.setPosition(x, y);
        this.butterflyContainer.setAngle(0);
        this.butterflyContainer.revive();
      }
      if (!this.butterflyBody) {
        this.butterflyBody = this.scene.add.image(0, 0, KEY55, FRAME51.TILE_BUTTERFLY_BODY);
      }
      this.butterflyContainer.add(this.butterflyBody);
      this.butterflyBody.setPosition(-1, -3.5);
      this.butterflyBody.setDisplaySize(displayHeight * (31 / 59) * 0.75, displayHeight * 0.75);
      this.butterflyBody.revive();
      this.butterflyContainer.add(this.butterflyImage1);
      this.butterflyImage1.setPosition(0, 0);
      this.butterflyContainer.add(this.butterflyImage2);
      this.butterflyImage2.setPosition(0, 0);
      const containerSize = displayHeight > displayWidth ? displayHeight : displayWidth;
      this.butterflyContainer.setSize(containerSize * 2, containerSize * 2);
      this.butterflyContainer.setDepth(depth_default.EFFECT);
    }
    initShadowTexture() {
      const { x, y } = this.butterflyContainer;
      const shadowTextureConfig = {
        inputObject: this.butterflyContainer
      };
      if (!this.shadowTexture) {
        this.shadowTexture = new ShadowTexture_default(this.scene, x, y, shadowTextureConfig);
        this.scene.add.existing(this.shadowTexture);
      } else {
        this.shadowTexture.setPosition(x, y);
        this.shadowTexture.setConfig(shadowTextureConfig);
      }
      const butterflyFrame = this.butterflyImage1.frame.name;
      this.shadowTexture.initContainer(
        this.butterflyImage1,
        this.butterflyImage2,
        this.butterflyContainer,
        butterflyFrame
      );
    }
    kill() {
      if (!this.active) return;
      this.combineTween?.stop();
      this.flapTween?.stop();
      this.flyTween?.stop();
      this.captureStarTrail.stop();
      this.butterflyImage1.kill();
      this.butterflyImage2.kill();
      this.butterflyBody?.kill();
      this.butterflyContainer?.removeAll();
      this.butterflyContainer?.kill();
      this.shadowTexture?.kill();
      this.setActive(false);
    }
    getTileWorldPosition(row, col) {
      const { tileManager, boardManager } = this.scene;
      const { firstTilePosition } = tileManager.capturePathGroup;
      const { x: tileX, y: tileY } = firstTilePosition || { x: 0, y: 0 };
      const tileSize = boardManager.getTileSizeWithSpacing();
      const x = tileX + (col - 1) * tileSize;
      const y = tileY + (row - 1) * tileSize;
      return new Phaser.Math.Vector2(x, y);
    }
  };
  var ButterflyCaptureEffect_default = ButterflyCaptureEffect;

  // src/game/gameplay/animations/animation/RewardItemCurveAnimation.ts
  init_phaser_custom_min();

  // src/game/animations/special/Curve.ts
  init_phaser_custom_min();
  var DEFAULT_CURVE_ANIM_CONFIG = {
    duration: 1e3,
    ease: Phaser.Math.Easing.Quadratic.InOut
  };
  var CurveAnimation = class {
    config;
    scene;
    spline;
    tween;
    constructor(scene, config) {
      this.scene = scene;
      const realConfig = {
        ...DEFAULT_CURVE_ANIM_CONFIG,
        ...config
      };
      this.config = realConfig;
      this.tween = scene.tweens.add(this.config);
      const { curve } = this.config;
      this.spline = new Phaser.Curves.Spline(curve);
      this.tween.on(Phaser.Tweens.Events.TWEEN_START, this.createCounter, this);
    }
    createCounter(tween, objects) {
      const { onCurveUpdate } = this.config;
      const curveUpdate = typeof onCurveUpdate === "function" ? onCurveUpdate : null;
      objects.forEach((target, index) => {
        if (!this.scene) return;
        const { duration, delay } = tween.data[index];
        const position = new Phaser.Math.Vector2();
        this.scene.tweens.addCounter({
          delay,
          duration,
          ease: Phaser.Math.Easing.Quadratic.InOut,
          onUpdate: (tween2) => {
            this.spline.getPoint(tween2.getValue(), position);
            target.x = position.x;
            target.y = position.y;
            curveUpdate?.(target);
          }
        });
      });
    }
  };
  var Curve_default = CurveAnimation;

  // src/game/effects/CometTwinkle.ts
  init_phaser_custom_min();
  var { KEY: KEY56, FRAME: FRAME52 } = sprites_default.EFFECTS;
  var CometTwinkle = class extends Phaser.GameObjects.Container {
    emitZone;
    emitter;
    constructor(scene) {
      super(scene);
      this.createEmitZone();
      this.scene.add.existing(this);
    }
    createEmitZone() {
      this.emitZone = new Phaser.Geom.Rectangle();
    }
    createEmitters() {
      this.emitter = this.scene.add.particles(0, 0, KEY56, {
        frame: FRAME52.FX_COMET,
        emitZone: {
          source: this.emitZone,
          type: "random"
        },
        speed: 20,
        timeScale: 1,
        frequency: 100,
        // maxParticles: 30,
        alpha: { start: 1, end: 0, ease: Phaser.Math.Easing.Expo.Out },
        scale: { start: 2, end: 0.1, ease: Phaser.Math.Easing.Expo.Out },
        lifespan: 2666
      });
      this.add(this.emitter);
    }
    run(count, x, y, width, height) {
      this.stop();
      this.reset();
      this.emitZone.setSize(width, height);
      this.emitZone.setPosition(x - width / 2, y - height / 2);
      this.emitter.setQuantity(count);
      this.emitter.start();
    }
    explode(count, x, y) {
      if (!this.emitter) {
        this.reset();
      }
      this.emitter.explode(count, x, y);
    }
    stop() {
      this.emitter?.killAll();
      this.emitter?.stop();
    }
    reset() {
      this.createEmitters();
    }
  };
  var CometTwinkle_default = CometTwinkle;

  // src/game/effects/SparksExplosive.ts
  init_phaser_custom_min();
  var { KEY: KEY57, FRAME: FRAME53 } = sprites_default.EFFECTS;
  var SparksExplosive = class extends Phaser.GameObjects.Container {
    deathZone;
    emitter;
    constructor(scene) {
      super(scene);
      this.createDeathZone();
      this.createEmitters();
      this.setActive(false);
      this.setVisible(false);
      this.scene.add.existing(this);
    }
    createDeathZone() {
      this.deathZone = new Phaser.Geom.Circle();
    }
    createEmitters() {
      this.emitter = this.scene.add.particles(0, 0, KEY57, {
        frame: FRAME53.FX_SPARK,
        speed: { min: 10, max: 1200 },
        scale: { start: 1.33, end: 0 },
        alpha: { start: 1, end: 0, ease: Phaser.Math.Easing.Expo.Out },
        deathZone: {
          source: this.deathZone,
          type: "onLeave"
        },
        lifespan: 3e3
      });
      this.add(this.emitter);
    }
    explode(count, x, y, radius) {
      this.setActive(true);
      this.setVisible(true);
      this.deathZone.radius = radius;
      this.deathZone.setPosition(x, y);
      this.emitter.explode(count, x, y);
    }
  };
  var SparksExplosive_default = SparksExplosive;

  // src/game/gameplay/animations/animation/RewardItemCurveAnimation.ts
  var { KEY: KEY58, FRAME: FRAME54 } = sprites_default.EFFECTS;
  var RewardItemCurveAnimation = class {
    scene;
    originImage;
    starTail;
    curveAnimation;
    sparkExplosive;
    constructor(scene) {
      this.scene = scene;
      this.createComponents();
    }
    createComponents() {
      this.originImage = this.scene.make.image({
        key: KEY58,
        frame: FRAME54.BLANK
      });
      this.originImage.setVisible(false);
      const effect = new CometTwinkle_default(this.scene);
      effect.setDepth(depth_default.EFFECT);
      this.starTail = effect;
    }
    runRewardItemCurveAnimation(fromX, fromY, toX, toY, callback) {
      const start = { x: fromX, y: fromY };
      const end = { x: toX, y: toY };
      const posX = 100;
      const isLandscape = WorldUtils_default.isLandscape();
      const controlPointDevianceX = Phaser.Math.RND.between(-posX, posX) * -1;
      const controlPointDevianceY = Phaser.Math.RND.between(-140, -100);
      const landscapeCurve = [
        [start.x, start.y],
        [start.x + controlPointDevianceX, start.y + controlPointDevianceY],
        [end.x, end.y]
      ];
      const portraitCurve = [
        [start.x, start.y],
        [end.x, end.y]
      ];
      this.curveAnimation = new Curve_default(this.scene, {
        targets: [this.originImage],
        props: { scale: 0.2 },
        delay: this.scene.tweens.stagger(80, {}),
        duration: 1e3,
        curve: isLandscape ? landscapeCurve : portraitCurve,
        onComplete: () => {
          this.runSparksExplosive(end.x, end.y);
          if (callback !== void 0) {
            callback();
          }
        },
        onStop: () => {
          if (callback !== void 0) {
            callback();
          }
        },
        onCurveUpdate: (target) => {
          const radius = 16;
          const x = target.x + Phaser.Math.RND.between(-radius, radius);
          const y = target.y + Phaser.Math.RND.between(-radius, radius);
          if (!this.isCurveAnimationRunning()) return;
          this.starTail.explode(1, x, y);
        }
      });
      AnimUtils.runTween(this.curveAnimation.tween);
    }
    isCurveAnimationRunning() {
      if (!this.curveAnimation) return false;
      if (!this.curveAnimation.tween) return false;
      return this.curveAnimation.tween.isPlaying();
    }
    runSparksExplosive = (x, y) => {
      const scene = this.scene;
      this.sparkExplosive = new SparksExplosive_default(scene);
      this.sparkExplosive.setDepth(depth_default.EFFECT);
      this.sparkExplosive.explode(100, x, y, 50);
    };
    stopCurveAnimation() {
      if (this.isCurveAnimationRunning()) {
        this.curveAnimation.tween.stop();
        this.starTail?.stop();
      }
    }
  };
  var RewardItemCurveAnimation_default = RewardItemCurveAnimation;

  // src/game/gameplay/animations/animation/ItemSuperRocketFlyEffect.ts
  init_phaser_custom_min();
  var { KEY: KEY59, FRAME: FRAME55 } = sprites_default.GAMEPLAY;
  var { DestroyPairCount: DestroyPairCount2 } = GameSettings_default.SuperRocketConfig;
  var LONG_ROCKET_LIMIT = {
    Landscape: 8,
    Portrait: 6
  };
  var ItemSuperRocketFlyEffect = class {
    scene;
    longRocketList = [];
    rocketList = [];
    tween1 = [];
    tween2 = [];
    rocketTrail;
    explosionSpriteList = [];
    constructor(scene) {
      this.scene = scene;
      this.createRockets();
      this.createRocketTrail();
      this.createExplosion();
    }
    createRockets() {
      const { Landscape: Landscape2, Portrait: Portrait2 } = LONG_ROCKET_LIMIT;
      const longRocketLimit = WorldUtils_default.isLandscape() ? Landscape2 : Portrait2;
      for (let i = 0; i < DestroyPairCount2 * 2; i++) {
        const shortRocketSprite = Math.floor(i / 2) % 2 === 0 ? FRAME55.EFFECT_SHORT_ROCKET : FRAME55.
        EFFECT_SHORT_YELLOW_ROCKET;
        if (i < longRocketLimit) {
          const longRocket = this.scene.add.image(0, 0, KEY59, FRAME55.EFFECT_LONG_ROCKET);
          longRocket.setOrigin(0.5, 0);
          longRocket.setDepth(depth_default.EFFECT);
          longRocket.kill();
          this.longRocketList.push(longRocket);
        }
        const rocket = this.scene.add.image(0, 0, KEY59, shortRocketSprite);
        rocket.setOrigin(1, 0.5);
        rocket.setDepth(depth_default.EFFECT);
        rocket.kill();
        this.rocketList.push(rocket);
      }
    }
    createRocketTrail() {
      this.rocketTrail = new RocketSmoke_default(this.scene);
      this.rocketTrail.setDepth(depth_default.EFFECT);
    }
    createExplosion() {
      const zoomRatio = WorldUtils_default.getZoomRatio();
      for (let i = 0; i < DestroyPairCount2 * 2; i++) {
        const { KEY: KEY94, FRAME: FRAME100 } = sprites_default.EFFECTS;
        const element = this.scene.add.sprite(0, 0, KEY94, `${FRAME100.EFFECT_ROCKET_EXPLOSION}0`);
        element.setScale(1.2 / zoomRatio);
        element.setOrigin(0.5, 0.5);
        element.setDepth(depth_default.EFFECT);
        element.kill();
        this.explosionSpriteList.push(element);
      }
    }
    playExplosion(x, y, idx) {
      this.explosionSpriteList[idx].revive();
      this.explosionSpriteList[idx].setPosition(x, y);
      this.explosionSpriteList[idx].play(animation_default.ROCKET_EXPLOSION.KEY, true);
      this.explosionSpriteList[idx].once(Phaser.Animations.Events.ANIMATION_COMPLETE, () => {
        this.explosionSpriteList[idx].kill();
      });
    }
    generateAirTargets(targetCount) {
      const { width, height } = WorldUtils_default.getWorldSize();
      const { width: rocketWidth = 0, height: rocketHeight = 0 } = this.longRocketList[0];
      const bottomCenterPoint = { x: 0, y: height / 2 };
      const longRocketCount = this.longRocketList.length < targetCount ? this.longRocketList.length :
      targetCount;
      const leftMostPoint = { x: -100 - width / 2, y: -50 - height / 2 };
      const rightMostPoint = { x: 100 + width / 2, y: -50 - height / 2 };
      const spaceBetween = (rightMostPoint.x - leftMostPoint.x) / (longRocketCount - 1);
      const airTargets = [];
      for (let i = 0; i < longRocketCount; i++) {
        const airTarget = {
          x: leftMostPoint.x + spaceBetween * i,
          y: leftMostPoint.y
        };
        const bottomCenterToTargetVector = {
          x: airTarget.x - bottomCenterPoint.x,
          y: airTarget.y - bottomCenterPoint.y
        };
        const normalizedVector = {
          x: bottomCenterToTargetVector.x / Math.sqrt(bottomCenterToTargetVector.x ** 2 + bottomCenterToTargetVector.
          y ** 2),
          y: bottomCenterToTargetVector.y / Math.sqrt(bottomCenterToTargetVector.x ** 2 + bottomCenterToTargetVector.
          y ** 2)
        };
        airTarget.x += rocketWidth * normalizedVector.x;
        airTarget.y += rocketHeight * normalizedVector.y;
        airTargets.push(airTarget);
      }
      return airTargets;
    }
    reorderRocketLaunchTiming() {
      const rocketPairs = this.longRocketList.length / 2;
      const reorderedRocketPairs = [];
      for (let i = 0; i < rocketPairs; i++) {
        const rocketFrame = i % 2 === 0 ? FRAME55.EFFECT_LONG_ROCKET : FRAME55.EFFECT_LONG_YELLOW_ROCKET;
        const idx1 = rocketPairs + i;
        const idx2 = rocketPairs - i - 1;
        this.longRocketList[idx1].setFrame(rocketFrame);
        this.longRocketList[idx2].setFrame(rocketFrame);
        reorderedRocketPairs.push(this.longRocketList[idx1]);
        reorderedRocketPairs.push(this.longRocketList[idx2]);
      }
      this.longRocketList = reorderedRocketPairs;
    }
    reorderAirTargets(airTargets) {
      const airTargetPairs = airTargets.length / 2;
      const reorderedAirTargets = [];
      for (let i = 0; i < airTargetPairs; i++) {
        const idx1 = airTargetPairs + i;
        const idx2 = airTargetPairs - i - 1;
        reorderedAirTargets.push(airTargets[idx1]);
        reorderedAirTargets.push(airTargets[idx2]);
      }
      return reorderedAirTargets;
    }
    playTween1(targets, targetList) {
      const airTargets = this.generateAirTargets(targets.length);
      const { tileManager, itemManager } = this.scene;
      const pairCount = targets.length / 2;
      this.reorderRocketLaunchTiming();
      console.log("airTargets", airTargets);
      const reorderedAirTargets = this.reorderAirTargets(airTargets);
      console.log("reorderedAirTargets", reorderedAirTargets);
      for (let i = 0; i < pairCount; i++) {
        const isFinalPair = i === pairCount - 1;
        const firstIdx = i * 2;
        const secondIdx = i * 2 + 1;
        const firstAirTarget = reorderedAirTargets[firstIdx];
        const secondAirTarget = reorderedAirTargets[secondIdx];
        const firstTilePosition = targetList[firstIdx];
        const secondTilePosition = targetList[secondIdx];
        const firstTile = targets[firstIdx];
        const secondTile = targets[secondIdx];
        const random1 = Math.floor(Math.random() * reorderedAirTargets.length);
        let random2 = Math.floor(Math.random() * reorderedAirTargets.length);
        while (random1 === random2) {
          random2 = Math.floor(Math.random() * reorderedAirTargets.length);
        }
        this.tween1.push(this.getTween1Target(firstAirTarget, firstIdx, 867 + 200 * i));
        this.tween1.push(
          this.getTween1Target(secondAirTarget, secondIdx, 867 + 200 * i + 100, () => {
            this.playTween2(
              [reorderedAirTargets[random1], reorderedAirTargets[random2]],
              [firstTilePosition, secondTilePosition],
              [firstIdx, secondIdx],
              100,
              () => {
                tileManager.tilesCapturing([firstTile, secondTile]);
                if (!isFinalPair) return;
                const superRocketItem = itemManager.getItem(item_default.SUPER_ROCKET.ID);
                if (!superRocketItem || !(superRocketItem instanceof SuperRocketItem_default)) return;
                superRocketItem.setRunningStatus(false);
                superRocketItem.clearTimerEvent();
                itemManager.deactivateItem(item_default.SUPER_ROCKET.ID);
                itemManager.setIsUseableItem(false);
                this.scene.events.emit(tile_default.EVENTS.RESUME_BOMB_TIMER);
              }
            );
          })
        );
      }
    }
    getTween1Target(airTarget, idx, delay, callback) {
      const { height } = WorldUtils_default.getWorldSize();
      const endY = height / 2 - 67;
      const rocket = this.longRocketList[idx];
      if (!rocket) {
        const dummyTweenChain = this.scene.tweens.chain({
          targets: [],
          tweens: [{ duration: 867 + 133 + 200, ease: Phaser.Math.Easing.Expo.In }]
        });
        const totalDelay = 133 + 200 + delay + 200;
        this.scene.time.delayedCall(totalDelay, () => {
          if (callback) callback();
        });
        return dummyTweenChain;
      }
      let timeToSmoke = 0.8;
      const tweenChain = this.scene.tweens.chain({
        targets: rocket,
        tweens: [
          {
            props: {
              y: {
                duration: 867,
                getEnd: () => endY
              },
              rotation: {
                delay,
                duration: 200,
                getEnd: (target) => {
                  return Phaser.Math.Angle.Between(airTarget.x, airTarget.y, target.x, endY) - Math.
                  PI / 2;
                }
              }
            }
          },
          {
            duration: 133 + 200,
            ease: Phaser.Math.Easing.Expo.In,
            onStart: () => {
              AudioUtils_default.playSound(soundEffects_default.ROCKET_FLY);
            },
            props: {
              x: {
                getEnd: () => airTarget.x
              },
              y: {
                getEnd: () => airTarget.y
              }
            },
            onUpdate: (_tween, target) => {
              const x = target.x - target.height / 2 * Math.cos(target.rotation - Math.PI / 2);
              const y = target.y - target.height / 2 * Math.sin(target.rotation - Math.PI / 2);
              const preX = target.x - target.height / 1.5 * Math.cos(target.rotation - Math.PI / 2);
              const preY = target.y - target.height / 1.5 * Math.sin(target.rotation - Math.PI / 2);
              if (_tween.progress > timeToSmoke) {
                this.rocketTrail.explodeYellow(1, x, y, x - preX, y - preY);
                timeToSmoke += 0.02;
              }
              const random = Math.random();
              if (random < 0.2) {
                this.rocketTrail.explodeWhite(1, x, y, x - preX, y - preY);
              }
            },
            onComplete: () => {
              if (callback) callback();
            }
          }
        ]
      });
      return tweenChain;
    }
    playTween2(airTargets, targetList, idxList, delay, callBack) {
      const longRocketList = [];
      const rocketList = [];
      for (const idx of idxList) {
        longRocketList.push(this.longRocketList[idx]);
        rocketList.push(this.rocketList[idx]);
      }
      let timeToSmoke = 0.3;
      const tween2 = this.scene.tweens.add({
        targets: rocketList,
        delay,
        duration: 1300,
        ease: Phaser.Math.Easing.Expo.In,
        onStart: () => {
          for (const rocket of longRocketList) {
            if (!rocket) continue;
            rocket.kill();
          }
          rocketList.forEach((target, index) => {
            target.setPosition(airTargets[index].x, airTargets[index].y);
            target.rotation = 0;
            target.revive();
            target.setRotation(
              Phaser.Math.Angle.Between(
                airTargets[index].x,
                airTargets[index].y,
                targetList[index].x,
                targetList[index].y
              )
            );
          });
        },
        props: {
          x: {
            getEnd: (_target, _key, _value, targetIndex) => {
              return targetList[targetIndex].x;
            }
          },
          y: {
            getEnd: (_target, _key, _value, targetIndex) => {
              return targetList[targetIndex].y;
            }
          }
        },
        onUpdate: (tween, target) => {
          const x = target.x - 1.5 * target.height * Math.cos(target.rotation);
          const y = target.y - 1.5 * target.height * Math.sin(target.rotation);
          const preX = target.x - 2 * target.height * Math.cos(target.rotation);
          const preY = target.y - 2 * target.height * Math.sin(target.rotation);
          if (tween.progress > timeToSmoke) {
            this.rocketTrail.explodeYellow(1, x, y, x - preX, y - preY);
            timeToSmoke += 0.05;
          }
          const random = Math.random();
          if (random < 0.1) {
            this.rocketTrail.explodeWhite(1, x, y, x - preX, y - preY);
          }
        },
        onComplete: () => {
          rocketList.forEach((rocket, index) => {
            rocket.kill();
            this.playExplosion(targetList[index].x, targetList[index].y, idxList[index]);
          });
          if (callBack) {
            callBack();
          }
        }
      });
      this.tween2.push(tween2);
    }
    play(targets, targetPositions) {
      for (const tween of this.tween1) {
        tween.stop();
      }
      this.tween1 = [];
      for (const tween of this.tween2) {
        tween.stop();
      }
      this.tween2 = [];
      const { Landscape: Landscape2, Portrait: Portrait2 } = LONG_ROCKET_LIMIT;
      const longRocketLimit = WorldUtils_default.isLandscape() ? Landscape2 : Portrait2;
      const pairs = longRocketLimit < targets.length ? longRocketLimit / 2 : targets.length / 2;
      const { width, height } = WorldUtils_default.getWorldSize();
      this.longRocketList.forEach((rocket, index) => {
        if (index >= pairs * 2) return;
        const x = width / (pairs * 4) + width / (pairs * 2) * index - width / 2;
        const y = height / 2 + 133;
        rocket.setPosition(x, y);
        rocket.rotation = 0;
        rocket.revive();
      });
      this.playTween1(targets, targetPositions);
    }
    stop() {
      for (const tween of this.tween1) {
        tween.stop();
      }
      this.tween1 = [];
      for (const tween of this.tween2) {
        tween.stop();
      }
      this.tween2 = [];
      for (const rocket of this.longRocketList) {
        rocket.kill();
      }
      for (const rocket of this.rocketList) {
        rocket.kill();
      }
      this.rocketTrail.stop();
    }
  };
  var ItemSuperRocketFlyEffect_default = ItemSuperRocketFlyEffect;

  // src/game/gameplay/animations/animation/challenge-friend-start/ChallengeFriendsStartAnimation.ts
  init_phaser_custom_min();

  // src/game/gameplay/animations/animation/challenge-friend-start/PlayerInfoContainer.ts
  init_phaser_custom_min();
  var { KEY: KEY60, FRAME: FRAME56 } = sprites_default.CHALLENGE;
  var PlayerInfoContainer = class extends Phaser.GameObjects.Container {
    avatar;
    playerName;
    constructor(scene, x, y) {
      super(scene, x, y);
      this.createAvatar();
      this.createName();
      this.setSize(100, 100);
    }
    createAvatar() {
      const avatarConfig = {
        width: 84,
        height: 84,
        radius: 12,
        key: KEY60,
        background: FRAME56.AVATAR_BIG,
        frame: FRAME56.AVATAR_BIG_FRAME
      };
      this.avatar = new AvatarFrame_default(this.scene, avatarConfig);
      this.add(this.avatar);
      this.avatar.setWorldSize(68, 68);
      this.avatar.loading.setWorldSize(50, 50);
    }
    createName() {
      this.playerName = FontUtils_default.createText(this.scene, "Anonymous", 20);
      this.playerName.setTint(16112054);
      this.add(this.playerName);
      Phaser.Display.Align.To.BottomCenter(this.playerName, this.avatar, 0, 15);
    }
    updatePlayerInfo(playerInfo) {
      this.avatar.loadPhoto(playerInfo.id, playerInfo.photo);
      this.playerName.setText(playerInfo.name);
    }
  };
  var PlayerInfoContainer_default = PlayerInfoContainer;

  // src/game/gameplay/animations/animation/challenge-friend-start/ChallengeFriendsStartAnimation.ts
  var { player: player14 } = codex;
  var { KEY: KEY61, FRAME: FRAME57 } = sprites_default.CHALLENGE;
  var ChallengeFriendsStartAnimation = class extends Phaser.GameObjects.Container {
    scene;
    vsText;
    background;
    playerInfoContainer;
    opponentInfoContainer;
    entrancePlayerInfoTween;
    entranceOpponentInfoTween;
    isPlaying = false;
    constructor(scene) {
      super(scene);
      this.scene = scene;
      this.addBackground();
      this.createVsText();
      this.createPlayerInfoContainer();
      this.createOpponentInfoContainer();
      this.scene.add.existing(this);
      this.setVisible(false);
      this.setDepth(depth_default.EFFECT);
    }
    createVsText() {
      this.vsText = this.scene.make.image({
        key: KEY61,
        frame: FRAME57.VS
      });
      this.add(this.vsText);
    }
    createPlayerInfoContainer() {
      this.playerInfoContainer = new PlayerInfoContainer_default(this.scene, 0, 0);
      this.add(this.playerInfoContainer);
    }
    createOpponentInfoContainer() {
      this.opponentInfoContainer = new PlayerInfoContainer_default(this.scene, 0, 0);
      this.add(this.opponentInfoContainer);
    }
    updatePlayerInfoContainer() {
      const playerId = player14.getPlayerId();
      const playerName = player14.getPlayer()?.name ?? "You";
      const playerAvatar = player14.getPlayer()?.photo ?? images_default.AVATAR_DEFAULT.FILE;
      this.playerInfoContainer.updatePlayerInfo({
        id: playerId,
        name: playerName,
        photo: playerAvatar
      });
    }
    updateOpponentInfoContainer() {
      const matchState = MatchUtils_default.getMatchState();
      const { customData = {}, profiles = {} } = matchState;
      const opponentId = customData.opponentId ?? "0";
      const opponentName = profiles[opponentId]?.name ?? "Your Friend";
      const opponentAvatar = profiles[opponentId]?.photo ?? images_default.AVATAR_DEFAULT.FILE;
      this.opponentInfoContainer.updatePlayerInfo({
        id: opponentId,
        name: opponentName,
        photo: opponentAvatar
      });
    }
    addBackground() {
      const texture = "screen-background";
      const { width, height } = WorldUtils_default.getWorldSize();
      if (!this.scene.textures.exists(texture)) {
        const graphics = this.scene.add.graphics();
        graphics.fillStyle(0, 1);
        graphics.fillRect(0, 0, width, height);
        graphics.generateTexture(texture, width, height);
        graphics.destroy();
      }
      this.background = this.scene.add.image(0, 0, texture);
      this.background.setWorldSize(width, height);
      this.background.setAlpha(0.7);
      this.add(this.background);
    }
    play() {
      if (this.isPlaying) {
        return;
      }
      this.updatePlayerInfoContainer();
      this.updateOpponentInfoContainer();
      this.isPlaying = true;
      const { width, height } = WorldUtils_default.getWorldSize();
      this.vsText.setPosition(0, -5);
      this.playerInfoContainer.setPosition(width / 2, -140);
      this.opponentInfoContainer.setPosition(-width / 2, 100);
      this.background.setWorldSize(width, height);
      this.runEntrancePlayerInfoTimeline();
      this.runEntranceOpponentInfoTimeline();
      this.setVisible(true);
      this.setAlpha(1);
    }
    runEntrancePlayerInfoTimeline() {
      const { width } = WorldUtils_default.getWorldSize();
      this.entrancePlayerInfoTween = this.scene.tweens.chain({
        targets: this.playerInfoContainer,
        tweens: [
          {
            x: width / 8,
            duration: 300,
            ease: Phaser.Math.Easing.Sine.In
          },
          {
            x: -width / 8,
            duration: 900,
            ease: Phaser.Math.Easing.Linear
          },
          {
            x: -width,
            duration: 300,
            ease: Phaser.Math.Easing.Sine.In,
            onComplete: () => {
              this.stop();
            }
          }
        ]
      });
      this.entrancePlayerInfoTween.play();
    }
    runEntranceOpponentInfoTimeline() {
      const { width } = WorldUtils_default.getWorldSize();
      this.entranceOpponentInfoTween = this.scene.tweens.chain({
        targets: this.opponentInfoContainer,
        tweens: [
          {
            x: -width / 8,
            duration: 300,
            ease: Phaser.Math.Easing.Sine.In
          },
          {
            x: width / 8,
            duration: 900,
            ease: Phaser.Math.Easing.Linear
          },
          {
            x: width,
            duration: 300,
            ease: Phaser.Math.Easing.Sine.In,
            onComplete: () => {
              this.stop();
            }
          }
        ]
      });
      this.entranceOpponentInfoTween.play();
    }
    stop() {
      if (!this.isPlaying) {
        return;
      }
      this.isPlaying = false;
      this.entrancePlayerInfoTween.stop();
      this.entranceOpponentInfoTween.stop();
      this.scene.tweens.add({
        targets: this,
        alpha: 0,
        duration: 100,
        ease: Phaser.Math.Easing.Sine.In,
        onStop: () => {
          this.setVisible(false);
        },
        onComplete: () => {
          this.setVisible(false);
        }
      });
    }
  };
  var ChallengeFriendsStartAnimation_default = ChallengeFriendsStartAnimation;

  // src/game/gameplay/animations/animation/BuyItemAnimation.ts
  init_phaser_custom_min();
  var { KEY: KEY62, FRAME: FRAME58 } = sprites_default.GAMEPLAY;
  var BuyItemAnimation = class extends Phaser.GameObjects.GameObject {
    scene;
    coinIcon;
    coinTween;
    constructor(scene) {
      super(scene, "buyItemAnimation");
      this.scene = scene;
      this.createCoinIcon();
    }
    createCoinIcon() {
      this.coinIcon = this.scene.add.image(0, 0, KEY62, FRAME58.ICON_COIN);
      this.coinIcon.setVisible(false);
      this.coinIcon.setDepth(depth_default.EFFECT);
    }
    play(x, y) {
      this.coinTween?.stop();
      this.coinIcon.setPosition(x, y);
      this.coinIcon.setVisible(true);
      this.coinIcon.setAlpha(1);
      this.runCoinAnimation();
    }
    stop() {
      if (this.coinTween) {
        this.coinTween.stop();
      }
      this.coinIcon.setVisible(false);
    }
    runCoinAnimation() {
      this.coinTween = this.scene.tweens.add({
        targets: [this.coinIcon],
        props: {
          y: {
            value: "-=50",
            ease: "Sine.Out",
            duration: 400
          },
          alpha: {
            delay: 100,
            value: 0,
            ease: "Sine.In",
            duration: 400
          }
        },
        onComplete: () => {
          this.coinIcon.setVisible(false);
        }
      });
      AnimUtils.runTween(this.coinTween);
    }
  };
  var BuyItemAnimation_default = BuyItemAnimation;

  // src/game/gameplay/managers/EffectManager.ts
  var EffectManager = class extends BaseManager_default {
    scene;
    comboEffect$;
    rocketEffect$;
    superRocketEffect$;
    tileRocketEffects$;
    tileRocketLaunchQueue$;
    tileHintEffect;
    tileHighlightEffect$;
    tileBreakEffects$;
    flyingStarFromClockEffect$;
    comboExplosionEffect$;
    butterflyCaptureEffectGroup$;
    rewardItemCurveAnimation$;
    challengeFriendsStartAnimation$;
    buyItemAnimation$;
    constructor(scene) {
      super(scene);
      this.scene = scene;
      this.tileRocketEffects$ = [];
      this.tileRocketLaunchQueue$ = [];
      this.butterflyCaptureEffectGroup$ = this.scene.add.group();
      this.createComboEffect$();
      this.createRocketEffect$();
      this.createSuperRocketEffect$();
      this.createTileHintEffect$();
      this.createTileHighlightEffect$();
      this.createTileBreakEffect$();
      this.createFlyingStarFromClockEffect$();
      this.createComboExplosionEffect$();
      this.createRewardItemCurveAnimation$();
      this.createChallengeFriendsStartAnimation$();
      this.createBuyItemAnimation$();
    }
    createComboEffect$() {
      this.comboEffect$ = new ComboEffect_default(this.scene);
    }
    createRocketEffect$() {
      this.rocketEffect$ = new ItemRocketFlyEffect_default(this.scene);
    }
    createSuperRocketEffect$() {
      this.superRocketEffect$ = new ItemSuperRocketFlyEffect_default(this.scene);
    }
    createTileHintEffect$() {
      this.tileHintEffect = new TileHintEffect_default(this.scene);
    }
    createTileHighlightEffect$() {
      this.tileHighlightEffect$ = new TileHighlightEffect_default(this.scene);
    }
    createFlyingStarFromClockEffect$() {
      this.flyingStarFromClockEffect$ = new FlyingStarFromClockEffect_default(this.scene);
    }
    createComboExplosionEffect$() {
      this.comboExplosionEffect$ = new ComboExplosionEffect_default(this.scene);
    }
    createTileBreakEffect$() {
      this.tileBreakEffects$ = [];
      for (let i = 0; i < 2; i++) {
        const effect = new TileBreak_default(this.scene);
        effect.setScale(0.8);
        this.tileBreakEffects$.push(effect);
        effect.kill();
      }
    }
    createRewardItemCurveAnimation$() {
      this.rewardItemCurveAnimation$ = new RewardItemCurveAnimation_default(this.scene);
    }
    createChallengeFriendsStartAnimation$() {
      this.challengeFriendsStartAnimation$ = new ChallengeFriendsStartAnimation_default(this.scene);
    }
    createBuyItemAnimation$() {
      this.buyItemAnimation$ = new BuyItemAnimation_default(this.scene);
    }
    playComboEffect(combo) {
      this.comboEffect$.run(combo);
    }
    playRocketEffect(targetList, callBack1, callback2) {
      this.rocketEffect$.play(targetList, callBack1, callback2);
    }
    playSuperRocketEffect(targets, targetPositions) {
      this.superRocketEffect$.play(targets, targetPositions);
    }
    requestTileRocketEffect(startingPosition, tile) {
      let rocketEffect = this.tileRocketEffects$.find((effect) => !effect.isInQueue);
      if (!rocketEffect) {
        rocketEffect = new TileRocketFlyEffect_default(this.scene);
        this.tileRocketEffects$.push(rocketEffect);
      }
      rocketEffect.target = tile;
      rocketEffect.isInQueue = true;
      rocketEffect.startingPosition = startingPosition;
      this.tileRocketLaunchQueue$.push(rocketEffect);
      return;
    }
    playTileRocketEffects() {
      if (this.tileRocketLaunchQueue$.length === 0) return;
      const delay = 200;
      this.scene.time.delayedCall(delay, () => {
        const targets = [];
        for (const effect of this.tileRocketLaunchQueue$) {
          if (effect.isPlaying) continue;
          effect.target && targets.push(effect.target);
          effect.play();
        }
        this.scene.time.delayedCall(700, () => {
          this.scene.events.emit(tile_default.EVENTS.ROCKET_EXPLODE, targets);
        });
        this.tileRocketLaunchQueue$ = [];
      });
    }
    playTileHintEffect(tile1, tile2) {
      this.tileHintEffect.stop();
      this.tileHintEffect.tile1 = tile1;
      this.tileHintEffect.tile2 = tile2;
      this.tileHintEffect.play();
    }
    playRewardItemCurveAnimation(fromX, fromY, toX, toY, callback) {
      this.rewardItemCurveAnimation$.runRewardItemCurveAnimation(fromX, fromY, toX, toY, callback);
    }
    stopTileHintEffect() {
      this.tileHintEffect.stop();
    }
    playTileHighlightEffect(tile) {
      this.tileHighlightEffect$.play(tile);
    }
    stopTileHighlightEffect() {
      this.tileHighlightEffect$.stop();
    }
    stopRewardItemCurveAnimation() {
      this.rewardItemCurveAnimation$.stopCurveAnimation();
    }
    getCurrentlyHighlightedTile() {
      return this.tileHighlightEffect$.currentTile;
    }
    playTileBreakEffect(tile) {
      const { x, y } = tile.getWorldPosition();
      const availableEffect = this.tileBreakEffects$.find((effect) => !effect.getIsPlaying());
      if (availableEffect) {
        availableEffect.playAnimation(x, y);
        return;
      }
      const newEffect = new TileBreak_default(this.scene);
      newEffect.playAnimation(x, y);
      this.tileBreakEffects$.push(newEffect);
    }
    playFlyingStarFromClockEffect(callback) {
      this.flyingStarFromClockEffect$.play(callback);
    }
    playComboExplosionEffect() {
      this.comboExplosionEffect$.stop();
      this.comboExplosionEffect$.play();
    }
    playButterflyCaptureEffect(tile1, tile2) {
      const inactiveEffect = this.butterflyCaptureEffectGroup$.getFirstDead();
      if (inactiveEffect && inactiveEffect instanceof ButterflyCaptureEffect_default) {
        inactiveEffect.setActive(true);
        inactiveEffect.init(tile1, tile2);
        return;
      }
      const newEffect = new ButterflyCaptureEffect_default(this.scene);
      newEffect.init(tile1, tile2);
      this.butterflyCaptureEffectGroup$.add(newEffect);
    }
    playChallengeFriendsStartAnimation() {
      this.challengeFriendsStartAnimation$.play();
    }
    killButterflyCaptureEffects() {
      const children = this.butterflyCaptureEffectGroup$.getChildren();
      for (const effect of children) {
        if (effect instanceof ButterflyCaptureEffect_default) {
          effect.kill();
        }
      }
    }
    playBuyItemAnimation(x, y) {
      this.buyItemAnimation$.play(x, y);
    }
    stopBuyItemAnimation() {
      this.buyItemAnimation$.stop();
    }
    stop() {
      if (!this.isRunning()) return;
      super.stop();
      this.comboEffect$.stop();
      this.rocketEffect$.stop();
      this.superRocketEffect$.stop();
      this.tileHintEffect.stop();
      this.tileHighlightEffect$.stop();
      this.flyingStarFromClockEffect$.stop();
      this.comboExplosionEffect$.stop();
      this.buyItemAnimation$.stop();
      for (const effect of this.tileRocketEffects$) {
        effect.stop();
      }
      for (const effect of this.tileBreakEffects$) {
        effect.stop();
      }
      this.tileRocketLaunchQueue$ = [];
      this.rewardItemCurveAnimation$.stopCurveAnimation();
      this.killButterflyCaptureEffects();
      this.challengeFriendsStartAnimation$.stop();
    }
  };
  var EffectManager_default = EffectManager;

  // src/game/gameplay/managers/ComboManager.ts
  init_phaser_custom_min();
  var {
    Utils: { Browser: B6 }
  } = Ludex;
  var ComboManager = class extends BaseManager_default {
    scene;
    currentCombo$;
    comboTimer$;
    progressTimer$;
    comboDuration$;
    constructor(scene) {
      super(scene);
      this.scene = scene;
      this.currentCombo$ = 0;
      const isLandscape = WorldUtils_default.isLandscape();
      this.comboDuration$ = isLandscape ? 4e3 : 2e3;
    }
    init() {
      this.currentCombo$ = 0;
      this.clearTimer$();
      this.cleanListeners$();
      this.hideComboProgressBar$();
    }
    start() {
      if (this.isRunning()) return;
      super.start();
      this.startComboTimer$();
      this.listenComboEvents$();
    }
    stop() {
      if (!this.isRunning()) return;
      super.stop();
      this.currentCombo$ = 0;
      this.clearTimer$();
      this.cleanListeners$();
      this.hideComboProgressBar$();
    }
    getCombo() {
      return this.currentCombo$;
    }
    startComboTimer$() {
      this.clearTimer$();
      const config = {
        repeat: -1,
        delay: this.comboDuration$,
        callback: this.onReset$
      };
      this.comboTimer$ = this.scene.time.addEvent(config);
    }
    clearTimer$() {
      this.comboTimer$?.remove();
      this.comboTimer$?.destroy();
      this.progressTimer$?.remove();
      this.progressTimer$?.destroy();
    }
    listenComboEvents$() {
      this.scene.events.on(combo_default.COMBO, this.onCombo$);
      this.scene.events.on(combo_default.RESET, this.onReset$);
    }
    cleanListeners$() {
      this.scene.events.off(combo_default.COMBO, this.onCombo$);
      this.scene.events.off(combo_default.RESET, this.onReset$);
    }
    onCombo$ = () => {
      this.progressTimer$?.remove();
      if (!this.isRunning()) return;
      this.currentCombo$ += 1;
      const vibrateTime = Math.min(20 + this.currentCombo$ * 20, 11 * 20);
      VibrateUtils_default.vibrate(vibrateTime);
      this.startComboTimer$();
      const { layoutManager, effectManager } = this.scene;
      const { comboProgressBar } = layoutManager.objects;
      if (this.currentCombo$ > 1) {
        let process2 = 1;
        comboProgressBar.revive();
        comboProgressBar.setDepth(depth_default.EFFECT);
        comboProgressBar.setAlpha(1);
        comboProgressBar.setComboText(this.currentCombo$);
        effectManager.playComboExplosionEffect();
        comboProgressBar.setProcess(process2, true);
        this.progressTimer$ = this.scene.time.addEvent({
          delay: 100,
          repeat: this.comboDuration$ / 100,
          callback: () => {
            process2 -= 1 / (this.comboDuration$ / 100);
            if (process2 < 0) process2 = 0;
            if (process2 <= 0) {
              this.scene.tweens.add({
                targets: comboProgressBar,
                alpha: 0,
                delay: 100,
                duration: 100,
                onComplete: () => {
                  this.hideComboProgressBar$();
                }
              });
            }
            comboProgressBar.setProcess(process2);
          }
        });
      }
      this.scene.time.delayedCall(300, () => {
        this.playComboSound$(this.currentCombo$);
        effectManager.playComboEffect(this.currentCombo$);
      });
    };
    playComboSound$(id2) {
      const soundKey = `combo_${id2 > 5 ? 5 : id2}`;
      AudioUtils_default.playSound(soundKey);
    }
    onReset$ = () => {
      this.currentCombo$ = 0;
      this.hideComboProgressBar$();
    };
    hideComboProgressBar$() {
      const { layoutManager } = this.scene;
      const { comboProgressBar } = layoutManager.objects;
      comboProgressBar.kill();
      this.scene.tweens.killTweensOf(comboProgressBar);
    }
  };
  var ComboManager_default = ComboManager;

  // src/game/scenes/game-scene/layouts/LayoutManager.ts
  init_phaser_custom_min();

  // src/game/scenes/game-scene/layouts/UIObjects.ts
  init_phaser_custom_min();

  // src/game/gameplay/objects/items/devTools/AutoMatchItem.ts
  init_phaser_custom_min();

  // src/game/gameplay/objects/items/HintItem.ts
  init_phaser_custom_min();
  var { ID: ID7 } = item_default.HINT;
  var { FRAME: FRAME59 } = sprites_default.GAMEPLAY;
  var HintItem = class extends BaseItem_default {
    scene;
    constructor(scene) {
      super(scene, FRAME59.HINT_ITEM, 26.5, 36.5);
      this.itemCost = 200;
      this.scene = scene;
      this.setName(ID7);
      this.onClick = this.handleUseItem;
    }
    handleUseItem = () => {
      const { itemManager, tileManager } = this.scene;
      if (tileManager.isSuggestPairHintShowed) {
        AnimUtils.runTween(this.showItemAnimation);
        return;
      }
      if (this.isActive) {
        itemManager.deactivateItem(ID7);
        return;
      }
      const success = itemManager.activeItem(ID7);
      if (!success) {
        AnimUtils.runTween(this.shakeAnimation.tween);
        return;
      }
      this.useItem();
    };
    useItem() {
      const { tileManager, itemManager } = this.scene;
      tileManager.suggestPairHint();
      itemManager.deactivateItem(ID7);
      MissionUtils_default.addUseHintMissionProgress(1);
    }
    disableItem() {
      super.disableItem();
      this.item.setAlpha(1);
      this.item.setFrame(FRAME59.ITEM_HINT_LOCK);
      this.bg.setFrame(FRAME59.ITEM_BG_LOCK);
      this.amountItem.setVisible(false);
      this.itemLock.setVisible(true);
      this.itemLockText.setVisible(true);
    }
    enableItem() {
      super.enableItem();
      this.item.setAlpha(1);
      this.item.setFrame(FRAME59.HINT_ITEM);
      this.bg.setFrame(FRAME59.ITEM_BG_ITEM);
      this.amountItem.setVisible(true);
      this.itemLock.setVisible(false);
      this.itemLockText.setVisible(false);
    }
  };
  var HintItem_default = HintItem;

  // src/game/gameplay/objects/items/ShuffleItem.ts
  init_phaser_custom_min();
  var { ID: ID8 } = item_default.SHUFFLE;
  var { FRAME: FRAME60 } = sprites_default.GAMEPLAY;
  var ShuffleItem = class extends BaseItem_default {
    scene;
    duration;
    isRunning = false;
    costTimer;
    constructor(scene) {
      super(scene, FRAME60.ITEM_SHUFFLE, 26.5, 35.5);
      this.itemCost = 300;
      this.scene = scene;
      this.duration = 1200;
      this.setName(ID8);
      this.onClick = this.handleUseItem;
    }
    handleUseItem = () => {
      if (this.isRunning) return;
      const { itemManager, animationManager } = this.scene;
      if (!animationManager.isMoveTilesCompleted) {
        AnimUtils.runTween(this.shakeAnimation.tween);
      }
      if (this.isActive) {
        itemManager.deactivateItem(ID8);
        return;
      }
      const success = itemManager.activeItem(ID8);
      if (!success) {
        AnimUtils.runTween(this.shakeAnimation.tween);
        return;
      }
      this.useItem();
    };
    useItem = () => {
      const { tileManager } = this.scene;
      this.isRunning = true;
      tileManager.isSelectable = false;
      tileManager.emitInteraction();
      tileManager.removeSuggestPairHint();
      this.costTimer?.remove();
      const delay = 100;
      this.scene.time.delayedCall(delay, this.runShuffle);
      MissionUtils_default.addUseShuffleMissionProgress(1);
    };
    runShuffle = () => {
      const { boardManager } = this.scene;
      boardManager.runShuffle(this.duration);
      this.scene.time.delayedCall(this.duration + 100, this.processNoAvailableMatches);
    };
    processNoAvailableMatches = () => {
      const { boardManager, itemManager, tileManager } = this.scene;
      const { matchFinder } = boardManager;
      const isAvailable = matchFinder.checkForAvailableMatches();
      if (isAvailable) {
        this.isRunning = false;
        itemManager.deactivateItem(ID8);
        tileManager.isSelectable = true;
        return;
      }
      this.runShuffle();
    };
    disableItem() {
      super.disableItem();
      this.item.setAlpha(1);
      this.item.setFrame(FRAME60.ITEM_SHUFFLE_LOCK);
      this.bg.setFrame(FRAME60.ITEM_BG_LOCK);
      this.amountItem.setVisible(false);
      this.itemLock.setVisible(true);
      this.itemLockText.setVisible(true);
    }
    enableItem() {
      super.enableItem();
      this.item.setAlpha(1);
      this.item.setFrame(FRAME60.ITEM_SHUFFLE);
      this.bg.setFrame(FRAME60.ITEM_BG_ITEM);
      this.amountItem.setVisible(true);
      this.itemLock.setVisible(false);
      this.itemLockText.setVisible(false);
    }
  };
  var ShuffleItem_default = ShuffleItem;

  // src/game/gameplay/objects/items/devTools/AutoMatchItem.ts
  var { ID: ID9 } = item_default.AUTO_MATCH;
  var { FRAME: FRAME61 } = sprites_default.GAMEPLAY;
  var AutoMatchItem = class extends BaseItem_default {
    scene;
    isRunning = false;
    matchFinder;
    delayItemTimer;
    delayMatchTimer;
    activeTween;
    constructor(scene) {
      super(scene, FRAME61.DEV_TOOL_HAND, 25, 25);
      this.scene = scene;
      this.matchFinder = new MatchFinder_default(scene);
      this.setAmount(999);
      this.onClick = this.handleUseItem;
    }
    handleUseItem = () => {
      const { itemManager } = this.scene;
      if (this.isActive) {
        itemManager.deactivateItem(ID9);
        return;
      }
      const success = itemManager.activeItem(ID9);
      if (!success) {
        AnimUtils.runTween(this.shakeAnimation.tween);
        return;
      }
      itemManager.setIsUseableItem(true);
      this.useItem();
    };
    deactivateItem() {
      this.cleanState();
      super.deactivateItem();
    }
    useItem = () => {
      this.cleanState();
      if (!this.scene.stateManager.isPlaying()) return;
      this.isRunning = true;
      this.autoMatch();
      this.autoUseItem();
      this.runActiveTween();
    };
    runActiveTween = () => {
      if (this.activeTween?.isPlaying()) return;
      this.activeTween = this.scene.tweens.add({
        targets: [this],
        duration: 400,
        yoyo: true,
        repeat: -1,
        ease: Phaser.Math.Easing.Sine.InOut,
        props: {
          alpha: 0.3
        }
      });
    };
    autoMatch = () => {
      if (!this.isRunning) return;
      const { boardManager, tileManager, itemManager } = this.scene;
      if (!this.scene.stateManager.isPlaying()) {
        this.cleanState();
        itemManager.deactivateItem(ID9);
        return;
      }
      this.runActiveTween();
      tileManager.firstSelectedTile = null;
      if (!tileManager.isCanMove()) {
        this.cleanState();
        itemManager.deactivateItem(ID9);
        return;
      }
      const isMatchFound = this.matchFinder.checkForAvailableMatches();
      if (!isMatchFound) {
        this.nextAutoMatch();
        return;
      }
      const path = this.matchFinder.pathForAutoplay;
      if (!path) {
        this.nextAutoMatch();
        return;
      }
      const { x: r1 = 1, y: c1 = 1 } = path[0];
      const { x: r2 = 1, y: c2 = 1 } = path[path.length - 1];
      const tile1 = boardManager.getTileByPosition(r1, c1);
      const tile2 = boardManager.getTileByPosition(r2, c2);
      if (!tile1 || !tile2) {
        this.nextAutoMatch();
        return;
      }
      const success = this.emuSelectTile(tile1);
      if (!success) {
        this.nextAutoMatch();
        return;
      }
      const rand = Phaser.Math.Between(100, 400);
      this.delayMatchTimer = this.scene.time.delayedCall(rand, () => {
        this.emuSelectTile(tile2);
        this.nextAutoMatch();
      });
    };
    nextAutoMatch = () => {
      const rand = Phaser.Math.Between(300, 2100);
      this.delayMatchTimer = this.scene.time.delayedCall(rand, this.autoMatch);
    };
    autoUseItem = () => {
      if (!this.isRunning) return;
      const { itemManager } = this.scene;
      this.runActiveTween();
      const rand = Phaser.Math.Between(3e3, 5e3);
      this.delayItemTimer = this.scene.time.delayedCall(rand, () => {
        if (!itemManager.getIsUseableItem()) {
          this.autoUseItem();
          return;
        }
        const items = itemManager.getItems();
        Phaser.Utils.Array.Shuffle(items);
        const useableItems = items.filter((item) => {
          if (item.isDisabled) return false;
          if (item.amount <= 0) return false;
          if (item instanceof HintItem_default) return true;
          if (item instanceof RocketItem_default) return true;
          if (item instanceof ShuffleItem_default) return true;
          if (item instanceof BombDefuse_default) return true;
          return false;
        });
        const randItemId = Phaser.Math.Between(0, useableItems.length - 1);
        if (useableItems[randItemId]) useableItems[randItemId].callback();
        this.autoUseItem();
      });
    };
    emuSelectTile = (tile) => {
      const { tileManager } = this.scene;
      if (!tileManager.isSelectable) return false;
      tile.showHighlight();
      tileManager.emitInteraction();
      tileManager.tileSelect(tile)();
      return true;
    };
    cleanState() {
      this.setAlpha(1);
      this.isRunning = false;
      this.activeTween?.remove();
      this.delayItemTimer?.remove();
      this.delayMatchTimer?.remove();
      this.scene.tweens.killTweensOf(this);
    }
  };
  var AutoMatchItem_default = AutoMatchItem;

  // src/game/gameplay/objects/items/devTools/BackLevelItem.ts
  init_phaser_custom_min();
  var { ID: ID10 } = item_default.BACK_LEVEL;
  var { FRAME: FRAME62 } = sprites_default.GAMEPLAY;
  var { event: event30, player: player15 } = codex;
  var {
    Utils: { Time: T6 }
  } = Ludex;
  var BackLevelItem = class extends BaseItem_default {
    scene;
    isRunning = false;
    constructor(scene) {
      super(scene, FRAME62.DEV_TOOL_ARROW, 25, 25);
      this.scene = scene;
      this.setAmount(999);
      this.item.flipX = true;
      this.onClick = this.handleUseItem;
    }
    handleUseItem = () => {
      if (this.isRunning) return;
      const { itemManager } = this.scene;
      if (this.isActive) {
        itemManager.deactivateItem(ID10);
        return;
      }
      const success = itemManager.activeItem(ID10);
      if (!success) {
        AnimUtils.runTween(this.shakeAnimation.tween);
        return;
      }
      this.useItem();
    };
    useItem = async () => {
      const { itemManager, levelHandler } = this.scene;
      const { level } = levelHandler;
      const newLevel = level - 2;
      levelHandler.level = newLevel;
      player15.setGameData({ level: newLevel });
      await T6.sleepAsync(100);
      event30.emit(game_default.NEXT_LEVEL);
      itemManager.deactivateItem(ID10);
    };
  };
  var BackLevelItem_default = BackLevelItem;

  // src/game/gameplay/objects/items/devTools/BombExplosiveItem.ts
  init_phaser_custom_min();
  var { ID: ID11 } = item_default.BOMB_EXPLOSIVE;
  var { FRAME: FRAME63 } = sprites_default.GAMEPLAY;
  var BombExplosiveItem = class extends BaseItem_default {
    scene;
    constructor(scene) {
      super(scene, FRAME63.DEV_TOOL_BOMB, 25, 25);
      this.scene = scene;
      this.setAmount(999);
      this.onClick = this.handleUseItem;
    }
    handleUseItem = () => {
      const { itemManager } = this.scene;
      if (this.isActive) {
        itemManager.deactivateItem(ID11);
        return;
      }
      const success = itemManager.activeItem(ID11);
      if (!success) {
        AnimUtils.runTween(this.shakeAnimation.tween);
        return;
      }
      this.useItem();
    };
    useItem = () => {
      const { itemManager, tileManager } = this.scene;
      tileManager.emitInteraction();
      const aliveTiles = tileManager.getAliveTiles();
      for (const tile of aliveTiles) {
        if (tile instanceof BombTile_default) {
          tile.shortenRemainingTime();
        }
      }
      itemManager.deactivateItem(ID11);
    };
  };
  var BombExplosiveItem_default = BombExplosiveItem;

  // src/game/gameplay/objects/items/devTools/NewGameItem.ts
  init_phaser_custom_min();
  var { ID: ID12 } = item_default.NEW_GAME;
  var { FRAME: FRAME64 } = sprites_default.GAMEPLAY;
  var {
    Dtos: { Player: Player2 },
    Utils: { Time: T7 }
  } = Ludex;
  var { player: player16 } = codex;
  var NewGameItem = class extends BaseItem_default {
    scene;
    constructor(scene) {
      super(scene, FRAME64.DEV_TOOL_NEW_GAME, 25, 25);
      this.scene = scene;
      this.setAmount(999);
      this.onClick = this.handleUseItem;
    }
    handleUseItem = () => {
      const { itemManager } = this.scene;
      if (this.isActive) {
        itemManager.deactivateItem(ID12);
        return;
      }
      const success = itemManager.activeItem(ID12);
      if (!success) {
        AnimUtils.runTween(this.shakeAnimation.tween);
        return;
      }
      this.useItem();
    };
    useItem = async () => {
      await this.resetData();
      const { itemManager } = this.scene;
      itemManager.deactivateItem(ID12);
    };
    resetData = async () => {
      const defaultPlayerData = Player2.Data.getDefaultData();
      console.log("defaultPlayerData", defaultPlayerData);
      player16.setPlayerData(defaultPlayerData);
      player16.syncDataToSDK();
      await T7.sleepAsync(5e3);
      window.location.reload();
    };
  };
  var NewGameItem_default = NewGameItem;

  // src/game/gameplay/objects/items/devTools/NextLevelItem.ts
  init_phaser_custom_min();
  var { ID: ID13 } = item_default.NEXT_LEVEL;
  var { FRAME: FRAME65 } = sprites_default.GAMEPLAY;
  var { event: event31, player: player17 } = codex;
  var NextLevelItem = class extends BaseItem_default {
    scene;
    constructor(scene) {
      super(scene, FRAME65.DEV_TOOL_ARROW, 25, 25);
      this.scene = scene;
      this.setAmount(999);
      this.onClick = this.handleUseItem;
    }
    handleUseItem = () => {
      const { itemManager } = this.scene;
      if (this.isActive) {
        itemManager.deactivateItem(ID13);
        return;
      }
      const success = itemManager.activeItem(ID13);
      if (!success) {
        AnimUtils.runTween(this.shakeAnimation.tween);
        return;
      }
      this.useItem();
    };
    useItem = () => {
      const { itemManager, levelHandler } = this.scene;
      const { level } = levelHandler;
      player17.setGameData({ level: level + 1 });
      event31.emit(game_default.NEXT_LEVEL);
      itemManager.deactivateItem(ID13);
    };
  };
  var NextLevelItem_default = NextLevelItem;

  // src/game/gameplay/objects/items/devTools/OpenLuckyWheelItem.ts
  init_phaser_custom_min();
  var { ID: ID14 } = item_default.OPEN_LUCKY_WHEEL;
  var { FRAME: FRAME66 } = sprites_default.GAMEPLAY;
  var OpenLuckyWheelItem = class extends BaseItem_default {
    scene;
    constructor(scene) {
      super(scene, FRAME66.DEV_TOOL_HAND, 25, 25);
      this.scene = scene;
      this.setAmount(999);
      this.onClick = this.handleUseItem;
    }
    handleUseItem = () => {
      const { itemManager } = this.scene;
      if (this.isActive) {
        itemManager.deactivateItem(ID14);
        return;
      }
      const success = itemManager.activeItem(ID14);
      if (!success) {
        AnimUtils.runTween(this.shakeAnimation.tween);
        return;
      }
      this.useItem();
    };
    useItem = () => {
      const { itemManager } = this.scene;
      ScreenUtils_default.openScreen(ScreenKeys_default.REWARD_ITEM_SCREEN, {
        itemId: ID14,
        rewardCount: 1
      });
      itemManager.deactivateItem(ID14);
    };
  };
  var OpenLuckyWheelItem_default = OpenLuckyWheelItem;

  // src/game/gameplay/objects/items/devTools/ResetDataItem.ts
  init_phaser_custom_min();
  var { ID: ID15 } = item_default.RESET_DATA;
  var { FRAME: FRAME67 } = sprites_default.GAMEPLAY;
  var { player: player18 } = codex;
  var ResetDataItem = class extends BaseItem_default {
    scene;
    isResetToDefault;
    constructor(scene) {
      super(scene, FRAME67.DEV_TOOL_RESET, 25, 25);
      this.scene = scene;
      this.isResetToDefault = false;
      this.setAmount(999);
      this.onClick = this.handleUseItem;
    }
    handleUseItem = () => {
      const { itemManager } = this.scene;
      if (this.isActive) {
        itemManager.deactivateItem(ID15);
        return;
      }
      const success = itemManager.activeItem(ID15);
      if (!success) {
        AnimUtils.runTween(this.shakeAnimation.tween);
        return;
      }
      this.useItem();
    };
    useItem = async () => {
      await this.resetData();
      this.resetItems();
      const { itemManager } = this.scene;
      itemManager.deactivateItem(ID15);
    };
    resetData = async () => {
      const items = { ...GameSettings_default.StartItems };
      if (!this.isResetToDefault) {
        for (const key in items) {
          items[key] = 0;
        }
      }
      this.isResetToDefault = !this.isResetToDefault;
      await player18.setGameData({ items });
    };
    resetItems() {
      const { itemManager } = this.scene;
      itemManager.init();
      itemManager.start();
    }
  };
  var ResetDataItem_default = ResetDataItem;

  // src/game/gameplay/objects/items/devTools/TimeUpItem.ts
  init_phaser_custom_min();
  var { ID: ID16 } = item_default.TIME_UP;
  var { FRAME: FRAME68 } = sprites_default.GAMEPLAY;
  var TimeUpItem = class extends BaseItem_default {
    scene;
    constructor(scene) {
      super(scene, FRAME68.DEV_TOOL_CLOCK, 25, 25);
      this.scene = scene;
      this.setAmount(999);
      this.onClick = this.handleUseItem;
    }
    handleUseItem = () => {
      const { itemManager } = this.scene;
      if (this.isActive) {
        itemManager.deactivateItem(ID16);
        return;
      }
      const success = itemManager.activeItem(ID16);
      if (!success) {
        AnimUtils.runTween(this.shakeAnimation.tween);
        return;
      }
      this.useItem();
    };
    useItem = () => {
      const { itemManager, layoutManager } = this.scene;
      const { objects } = layoutManager;
      objects.playtimeClock.startClock(0);
      itemManager.deactivateItem(ID16);
    };
  };
  var TimeUpItem_default = TimeUpItem;

  // src/game/gameplay/objects/items/InviteItem.ts
  init_phaser_custom_min();
  var { event: event32 } = codex;
  var { ID: ID17 } = item_default.INVITE;
  var { FRAME: FRAME69 } = sprites_default.GAMEPLAY;
  var InviteItem = class extends BaseItem_default {
    scene;
    constructor(scene) {
      super(scene, FRAME69.ITEM_SHARE, 27, 31);
      Phaser.Display.Align.In.Center(this.item, this, 2, -2);
      this.scene = scene;
      this.setName("InviteFriends");
      this.amountText.setText("Invite");
      this.onClick = this.handleUseItem;
    }
    createAmountText() {
      super.createAmountText();
      this.amountBg.setFrame(FRAME69.NOTE_INVITE);
      this.amountBg.setWorldSize(42, 16);
      this.amountText.setFontSize(11);
      Phaser.Display.Align.In.Center(this.amountText, this.amountBg);
      Phaser.Display.Align.In.TopCenter(this.amountItem, this.bg, 2, -2);
    }
    handleUseItem = async () => {
      const { itemManager } = this.scene;
      if (this.isActive) {
        itemManager.deactivateItem(ID17);
        return;
      }
      const success = itemManager.activeItem(ID17);
      if (!success) {
        AnimUtils.runTween(this.shakeAnimation.tween);
        return;
      }
      try {
        await this.useItem();
      } catch (error) {
        console.warn("InviteItem", error);
      }
    };
    useItem = async () => {
      const { itemManager } = this.scene;
      event32.emit(game_default.PAUSE);
      const success = await MatchUtils_default.startChallengeChooseOpponentAsync();
      event32.emit(game_default.RESUME);
      this.scene.time.delayedCall(500, () => {
        itemManager.deactivateItem(ID17);
      });
      if (success) {
        event32.emit(game_default.REPLAY);
      } else {
        MatchUtils_default.startSingleModeAsync();
      }
    };
  };
  var InviteItem_default = InviteItem;

  // src/game/gameplay/objects/ui/ComboProgressBar.ts
  init_phaser_custom_min();

  // src/game/gameplay/animations/particle/ComboParticle.ts
  init_phaser_custom_min();
  var { KEY: KEY63, FRAME: FRAME70 } = sprites_default.GAMEPLAY;
  var ComboParticle = class extends Phaser.GameObjects.Container {
    deathZone;
    emitter;
    constructor(scene) {
      super(scene);
      this.createDeathZone();
      this.createEmitters();
      this.kill();
    }
    createDeathZone() {
      this.deathZone = new Phaser.Geom.Circle();
    }
    createEmitters() {
      this.emitter = this.scene.add.particles(0, 0, KEY63, {
        frame: FRAME70.EFFECT_SPARK,
        speed: { min: 20, max: 500 },
        scale: { start: 1.33, end: 0 },
        deathZone: {
          source: this.deathZone,
          type: "onLeave"
        },
        tint: 16259176,
        lifespan: 200
      });
      this.add(this.emitter);
    }
    explode(count, x, y, radius) {
      this.revive();
      this.deathZone.radius = radius;
      this.deathZone.setPosition(x, y);
      this.emitter.explode(count, x, y);
    }
  };
  var ComboParticle_default = ComboParticle;

  // src/game/gameplay/objects/ui/ComboProgressBar.ts
  var { KEY: KEY64, FRAME: FRAME71 } = sprites_default.GAMEPLAY;
  var ComboProgressBar = class extends Phaser.GameObjects.Container {
    process;
    minProcess;
    maxProcess;
    comboText;
    comboNumber;
    progressBox;
    circleLight;
    progressBar;
    comboParticle;
    circleLightTween;
    comboTextTween;
    progressAnimation;
    constructor(scene) {
      super(scene);
      this.setSize(84, 8);
      this.process = 0;
      this.minProcess = 0;
      this.maxProcess = 1;
      this.createComboText();
      this.createComboNumber();
      this.createProgressBG();
      this.createProgressBar();
      this.createCircleLight();
      this.createComboParticle();
      this.createContainer();
    }
    setComboText(value) {
      this.comboNumber.setText(`x${value}`);
      this.comboTextTween?.stop();
      this.circleLightTween?.stop();
      const { x, y } = this.comboNumber;
      this.comboParticle.explode(15, x, y, 45);
      this.circleLightTween = this.scene.add.tween({
        targets: [this.circleLight],
        duration: 200,
        props: {
          alpha: { start: 0.5, to: 0, ease: Phaser.Math.Easing.Expo.In },
          scale: { start: 0, to: 1.5, ease: Phaser.Math.Easing.Cubic.Out }
        }
      });
      this.comboTextTween = this.scene.add.tween({
        targets: [this.comboNumber],
        duration: 100,
        completeDelay: 400,
        ease: Phaser.Math.Easing.Sine.In,
        props: {
          scale: { from: 1, to: 1.3 }
        },
        onComplete: () => {
          this.comboTextTween = this.scene.add.tween({
            targets: [this.comboNumber],
            duration: 100,
            ease: Phaser.Math.Easing.Sine.Out,
            props: {
              scale: { start: 1.3, to: 1 }
            }
          });
        }
      });
    }
    setProcess(value, instance = false) {
      this.process = this.getCorrectValue(value);
      if (!this.scene || instance) {
        this.updateProcess();
        return;
      }
      this.runProcessAnimation(value);
    }
    updateProcess() {
      const { height } = this.progressBar;
      const width = this.getDisplayWidthByProcess(this.process);
      this.progressBar.setWorldSize(width, height);
    }
    getCorrectValue(value) {
      let correctValue = value;
      if (!isFinite(correctValue)) {
        correctValue = 0;
      }
      if (correctValue < this.minProcess) {
        correctValue = this.minProcess;
      }
      if (correctValue > this.maxProcess) {
        correctValue = this.maxProcess;
      }
      return correctValue;
    }
    getDisplayWidthByProcess(process2) {
      const { width: progressWidth } = this;
      const displayWidth = (progressWidth - 1) * process2;
      return displayWidth;
    }
    runProcessAnimation(value) {
      this.progressAnimation?.stop();
      this.progressAnimation = this.scene.add.tween({
        targets: [this.progressBar],
        duration: 100,
        ease: Phaser.Math.Easing.Quadratic.InOut,
        props: {
          displayWidth: () => {
            const process2 = this.getCorrectValue(value);
            return this.getDisplayWidthByProcess(process2);
          }
        },
        onUpdate: () => {
          const { displayWidth, displayHeight } = this.progressBar;
          this.progressBar.setWorldSize(displayWidth, displayHeight);
        },
        onComplete: () => {
          this.updateProcess();
        }
      });
    }
    createComboText() {
      this.comboText = FontUtils_default.createText(this.scene, "Combo", 12);
      FontUtils_default.applyRedStyle(this.comboText);
      Phaser.Display.Align.In.Center(this.comboText, this, -17, -12);
    }
    createComboNumber() {
      this.comboNumber = FontUtils_default.createText(this.scene, "x1", 16);
      FontUtils_default.applyRedStyle(this.comboNumber);
      this.comboNumber.setOrigin(0.5, 0.9);
      Phaser.Display.Align.In.RightCenter(this.comboNumber, this.comboText, 24, -2);
    }
    createCircleLight() {
      this.circleLight = this.scene.make.image({
        key: KEY64,
        frame: FRAME71.EFFECT_CIRCLE
      });
      this.circleLight.setTint(15677098);
      this.circleLight.setAlpha(0);
      Phaser.Display.Align.In.Center(this.circleLight, this.comboNumber);
    }
    createComboParticle() {
      this.comboParticle = new ComboParticle_default(this.scene);
      this.add(this.comboParticle);
    }
    createProgressBG() {
      this.progressBox = this.scene.make.image({
        key: KEY64,
        frame: FRAME71.PROGRESS_BG_COMBO
      });
    }
    createProgressBar() {
      this.progressBar = this.scene.make.image({
        key: KEY64,
        frame: FRAME71.PROGRESS_BAR_COMBO,
        origin: { x: 0, y: 0.5 }
      });
      Phaser.Display.Align.In.LeftCenter(this.progressBar, this.progressBox, -1);
      this.setProcess(0);
    }
    createContainer() {
      this.add([
        this.progressBox,
        this.progressBar,
        this.comboText,
        this.comboNumber,
        this.circleLight,
        this.comboParticle
      ]);
      this.circleLight.setDepth(depth_default.EFFECT);
      this.comboParticle.setDepth(depth_default.EFFECT);
      this.setDepth(depth_default.EFFECT);
      this.scene.add.existing(this);
    }
  };
  var ComboProgressBar_default = ComboProgressBar;

  // src/game/gameplay/objects/ui/PlaytimeClock.ts
  init_phaser_custom_min();
  var { KEY: KEY65, FRAME: FRAME72 } = sprites_default.GAMEPLAY;
  var CLOCK_STATE = {
    PLAY: "play",
    PAUSE: "pause"
  };
  var PlaytimeClock = class extends Phaser.GameObjects.Container {
    scene;
    clockBG;
    clockIcon;
    clockIconOriginScale;
    clockText;
    tickEvent;
    remainingTime;
    tickAnimation;
    tickEventRemainingTime;
    disable = false;
    constructor(scene) {
      super(scene);
      this.scene = scene;
      this.state = CLOCK_STATE.PAUSE;
      this.remainingTime = 0;
      this.setWorldSize(75, 34);
      this.createContents();
      this.scene.add.existing(this);
    }
    createContents() {
      this.createClockBG();
      this.createClockImage();
      this.createClockText();
    }
    handleRescueTimeout = () => {
      const scene = this.scene;
      const { levelHandler } = scene;
      const { time } = levelHandler.getConfigs();
      const currentRemainingTime = this.remainingTime || 0;
      this.startClock(Math.floor(time / 2) + currentRemainingTime);
    };
    startClock(clockTime) {
      this.state = CLOCK_STATE.PLAY;
      this.tickEvent?.destroy();
      this.remainingTime = clockTime;
      this.setClockText(this.remainingTime);
      this.tickEvent = this.scene.time.addEvent({
        delay: 1e3,
        callback: this.updateClock,
        callbackScope: this,
        loop: true
      });
    }
    updateClock = () => {
      const scene = this.scene;
      if (!scene.stateManager.isPlaying()) return;
      if (this.remainingTime <= 31) {
        this.playNotifyAnimation();
      }
      if (this.remainingTime <= 0) {
        this.pauseClock();
        this.scene.die("timeUp");
        return;
      }
      this.remainingTime -= 1;
      this.setClockText(this.remainingTime);
    };
    setClockText(time) {
      const minutes = Math.floor(time / 60);
      const seconds = time % 60;
      const formattedMinutes = minutes < 10 ? `0${minutes}` : minutes;
      const formattedSeconds = seconds < 10 ? `0${seconds}` : seconds;
      this.clockText.setText(`${formattedMinutes}:${formattedSeconds}`);
    }
    pauseClock() {
      if (this.disable || this.state === CLOCK_STATE.PAUSE) return;
      this.stopNotifyAnimation();
      this.state = CLOCK_STATE.PAUSE;
      if (!this.tickEvent) return;
      this.tickEventRemainingTime = 1e3 - this.tickEvent.getElapsed();
      this.tickEvent.destroy();
    }
    resumeClock() {
      if (this.disable || this.state === CLOCK_STATE.PLAY) return;
      this.state = CLOCK_STATE.PLAY;
      this.tickEvent = this.scene.time.addEvent({
        delay: this.tickEventRemainingTime,
        callback: () => {
          this.updateClock();
          this.tickEvent = this.scene.time.addEvent({
            delay: 1e3,
            callback: this.updateClock,
            callbackScope: this,
            loop: true
          });
        },
        callbackScope: this
      });
    }
    createClockBG() {
      this.clockBG = this.scene.make.image({
        key: KEY65,
        frame: FRAME72.TIMER_BG,
        origin: { x: 0.5, y: 0.5 }
      });
      this.add(this.clockBG);
      this.clockBG.setPosition(0, 0);
    }
    createClockText() {
      this.clockText = FontUtils_default.createText(this.scene, "00:00", 12).setFontStyle("700").setTint(
      16763191);
      this.add(this.clockText);
      const { width } = this.clockText;
      const offsetX = width * 0.08;
      Phaser.Display.Align.In.Center(this.clockText, this.clockBG, offsetX, 0.5);
    }
    createClockImage() {
      this.clockIcon = this.scene.make.image({
        key: KEY65,
        frame: FRAME72.ICON_CLOCK
      });
      this.add(this.clockIcon);
      const { width: clockBGWidth } = this.clockBG;
      const { width: clockIconWidth } = this.clockIcon;
      const offsetX = clockIconWidth / 2 + clockBGWidth * 0.05;
      Phaser.Display.Align.In.LeftCenter(this.clockIcon, this.clockBG, offsetX, -2);
      this.clockIconOriginScale = this.clockIcon.scaleX;
    }
    getRemainingTime() {
      return this.remainingTime;
    }
    playNotifyAnimation() {
      if (this.tickAnimation?.isPlaying()) return;
      const startAngle = 15;
      this.tickAnimation?.stop();
      this.tickAnimation = this.scene.tweens.chain({
        targets: this.clockIcon,
        loop: -1,
        tweens: [
          {
            targets: this.clockIcon,
            ease: Phaser.Math.Easing.Linear,
            props: {
              angle: {
                duration: 100,
                start: 0,
                to: startAngle
              }
            }
          },
          {
            targets: this.clockIcon,
            ease: Phaser.Math.Easing.Linear,
            props: {
              scale: {
                duration: 200,
                value: this.clockIconOriginScale * 1.1
              }
            },
            yoyo: true
          },
          {
            targets: this.clockIcon,
            ease: Phaser.Math.Easing.Linear,
            props: {
              angle: {
                duration: 100,
                start: 0,
                to: -startAngle
              }
            }
          },
          {
            targets: this.clockIcon,
            ease: Phaser.Math.Easing.Linear,
            props: {
              scale: {
                duration: 200,
                value: this.clockIconOriginScale * 1.1
              }
            },
            yoyo: true
          }
        ]
      });
      this.tickAnimation.play();
    }
    stopNotifyAnimation() {
      this.tickAnimation?.stop();
      this.clockIcon.setScale(this.clockIconOriginScale);
      this.clockIcon.setAngle(0);
    }
    setDisable(disable) {
      this.disable = disable;
    }
  };
  var PlaytimeClock_default = PlaytimeClock;

  // src/game/gameplay/objects/ui/StarProgressBar.ts
  init_phaser_custom_min();
  var { KEY: KEY66, FRAME: FRAME73 } = sprites_default.GAMEPLAY;
  var StarProgressBar = class extends Phaser.GameObjects.Container {
    stars = [];
    process;
    minProcess;
    maxProcess;
    progressBox;
    progressBarLeft;
    progressBarBg;
    progressBarRight;
    progressAnimation;
    constructor(scene) {
      super(scene);
      this.setWorldSize(165, 30);
      this.process = 0;
      this.minProcess = 0;
      this.maxProcess = 1;
      this.createProgressBox();
      this.createProgressBar();
      this.createStars();
      this.createContainer();
    }
    setProcess(value, instance = false) {
      this.process = this.getCorrectValue(value);
      this.updateStarVisibility();
      if (!this.scene || instance || !this.visible) {
        this.updateProcess();
        return;
      }
      this.runProcessAnimation(value);
    }
    updateProcess() {
      const { displayHeight } = this.progressBarBg;
      const displayWidth = this.getDisplayWidthByProcess(this.process);
      this.progressBarBg.setWorldSize(displayWidth, displayHeight);
      const { x } = this.progressBarBg;
      this.progressBarRight.setX(x + displayWidth);
    }
    getCorrectValue(value) {
      let correctValue = value;
      if (!isFinite(correctValue)) {
        correctValue = 0;
      }
      if (correctValue < this.minProcess) {
        correctValue = this.minProcess;
      }
      if (correctValue > this.maxProcess) {
        correctValue = this.maxProcess;
      }
      return correctValue;
    }
    getDisplayWidthByProcess(process2) {
      const { width: progressWidth } = this;
      const padding = 20;
      const displayWidth = (progressWidth - padding) * process2;
      return displayWidth <= 0 ? 0.01 : displayWidth;
    }
    runProcessAnimation(value) {
      this.progressAnimation?.stop();
      this.progressAnimation = this.scene.add.tween({
        targets: [this.progressBarBg],
        duration: 300,
        ease: Phaser.Math.Easing.Quadratic.InOut,
        props: {
          displayWidth: () => {
            const process2 = this.getCorrectValue(value);
            return this.getDisplayWidthByProcess(process2);
          }
        },
        onUpdate: () => {
          const { x, displayWidth } = this.progressBarBg;
          this.progressBarRight.setX(x + displayWidth);
        },
        onComplete: () => {
          this.updateProcess();
        }
      });
    }
    createProgressBox() {
      this.progressBox = this.scene.make.image({
        key: KEY66,
        frame: FRAME73.PROGRESS_STAR
      });
      this.add(this.progressBox);
    }
    createProgressBar() {
      const width = 6;
      const height = 12.5;
      this.progressBarLeft = this.scene.make.image({
        key: KEY66,
        frame: FRAME73.PROGRESS_BAR_LEFT
        // alpha: 0.8,
      });
      this.progressBarLeft.setOrigin(0, 0);
      this.progressBarLeft.setWorldSize(width, height);
      this.progressBarRight = this.scene.make.image({
        key: KEY66,
        frame: FRAME73.PROGRESS_BAR_RIGHT
        // alpha: 0.8,
      });
      this.progressBarRight.setOrigin(0, 0);
      this.progressBarRight.setWorldSize(width, height);
      this.progressBarBg = this.scene.make.image({
        key: KEY66,
        frame: FRAME73.PROGRESS_BAR_MID
        // alpha: 0.8,
      });
      this.progressBarBg.setOrigin(0, 0);
      this.progressBarBg.setWorldSize(width, height);
      const posX = -2;
      const posY = 0.5;
      const bgPosX = -7.5;
      Phaser.Display.Align.In.LeftCenter(this.progressBarBg, this.progressBox, bgPosX, posY);
      Phaser.Display.Align.In.LeftCenter(this.progressBarLeft, this.progressBox, posX, posY);
      Phaser.Display.Align.In.LeftCenter(this.progressBarRight, this.progressBox, bgPosX, posY);
      this.setProcess(0.01, true);
    }
    createStars() {
      this.stars = [];
      for (let i = 0; i < 3; i++) {
        const star = this.scene.make.image({
          key: KEY66,
          frame: FRAME73.ICON_STAR_BIG
        });
        star.y = 0;
        star.setWorldSize(28, 28);
        star.setVisible(false);
        this.stars.push(star);
      }
      this.stars[0].x = 7;
      this.stars[1].x = 38;
      this.stars[2].x = 67;
    }
    updateStarVisibility() {
      if (this.stars.length === 0) return;
      if (this.process >= 0.92) {
        this.stars[0].setVisible(true);
        this.stars[1].setVisible(true);
        this.stars[2].setVisible(true);
        return;
      }
      if (this.process >= 0.72) {
        this.stars[0].setVisible(true);
        this.stars[1].setVisible(true);
        this.stars[2].setVisible(false);
        return;
      }
      if (this.process >= 0.52) {
        this.stars[0].setVisible(true);
        this.stars[1].setVisible(false);
        this.stars[2].setVisible(false);
        return;
      }
      this.stars[0].setVisible(false);
      this.stars[1].setVisible(false);
      this.stars[2].setVisible(false);
    }
    getStarAmount() {
      if (this.process >= 0.92) return 3;
      if (this.process >= 0.72) return 2;
      if (this.process >= 0.52) return 1;
      return 0;
    }
    getStarFlyInPosition() {
      if (this.process >= 0.72) {
        return this.stars[2].getWorldPosition();
      }
      if (this.process >= 0.52) {
        return this.stars[1].getWorldPosition();
      }
      return this.stars[0].getWorldPosition();
    }
    createContainer() {
      this.add([this.progressBox, this.progressBarBg, this.progressBarLeft, this.progressBarRight]);
      this.add(this.stars);
      this.scene.add.existing(this);
    }
  };
  var StarProgressBar_default = StarProgressBar;

  // src/game/layouts/BaseUIObjects.ts
  init_phaser_custom_min();
  var BaseUIObjects = class {
    scene;
    group;
    constructor(scene) {
      this.scene = scene;
      this.createGroup();
    }
    getAll() {
      return this.group.getChildren();
    }
    createGroup() {
      this.group = this.scene.add.group();
    }
  };
  var BaseUIObjects_default = BaseUIObjects;

  // src/game/gameplay/objects/ui/ChallengeInfo.ts
  init_phaser_custom_min();
  var {
    Utils: { Number: N3 }
  } = Ludex;
  var { KEY: KEY67, FRAME: FRAME74 } = sprites_default.CHALLENGE;
  var ChallengeInfo = class _ChallengeInfo extends Phaser.GameObjects.Container {
    static AVATAR_SIZE = 35;
    // * Only keep private variables needed for updates
    playerScore;
    playerAvatar;
    opponentScore;
    opponentAvatar;
    // private lastPlayerScore: number = 0
    // private lastOpponentScore: number = 0
    constructor(scene) {
      super(scene);
      this.setWorldSize(190, 50);
      this.createPlayerSide();
      this.createOpponentSide();
      this.createContainer();
    }
    setPlayerScore(score) {
      const scoreString = N3.getShortNumber(score, 4);
      this.playerScore.setText(scoreString);
    }
    setOpponentScore(score) {
      const scoreString = N3.getShortNumber(score, 4);
      this.opponentScore.setText(scoreString);
    }
    setPlayerInfo(info) {
      const { id: id2, score, photo = "" } = info;
      this.playerAvatar.loadPhoto(id2, photo, 20);
      if (score) {
        this.setPlayerScore(score);
      } else {
        this.playerScore.setText("0");
      }
    }
    setOpponentInfo(info) {
      const { id: id2, score, photo = "" } = info;
      this.opponentAvatar.loadPhoto(id2, photo, 20);
      if (score) {
        this.setOpponentScore(score);
      } else {
        this.opponentScore.setText("0");
      }
    }
    createPlayerSide() {
      const playerPanel = this.scene.make.image({
        key: KEY67,
        frame: FRAME74.SCORE_PANEL
      });
      Phaser.Display.Align.In.LeftCenter(playerPanel, this, 0, 0);
      const avatarConfig = {
        width: _ChallengeInfo.AVATAR_SIZE,
        height: _ChallengeInfo.AVATAR_SIZE,
        key: KEY67,
        background: FRAME74.AVATAR,
        frame: FRAME74.AVATAR_FRAME
      };
      this.playerAvatar = new AvatarFrame_default(this.scene, avatarConfig);
      Phaser.Display.Align.In.LeftCenter(this.playerAvatar, playerPanel, 20, 0);
      this.playerScore = FontUtils_default.createShadowText(this.scene, "0", 22);
      this.playerScore.setTint(16636588);
      Phaser.Display.Align.In.Center(this.playerScore, playerPanel, 5, 2);
      this.add([playerPanel, this.playerAvatar, this.playerScore]);
    }
    createOpponentSide() {
      const opponentPanel = this.scene.make.image({
        key: KEY67,
        frame: FRAME74.SCORE_PANEL
      });
      Phaser.Display.Align.In.RightCenter(opponentPanel, this, 0, 0);
      const avatarConfig = {
        width: _ChallengeInfo.AVATAR_SIZE,
        height: _ChallengeInfo.AVATAR_SIZE,
        key: KEY67,
        background: FRAME74.AVATAR,
        frame: FRAME74.AVATAR_FRAME
      };
      this.opponentAvatar = new AvatarFrame_default(this.scene, avatarConfig);
      Phaser.Display.Align.In.RightCenter(this.opponentAvatar, opponentPanel, 20, 0);
      this.opponentScore = FontUtils_default.createShadowText(this.scene, "0", 22);
      this.opponentScore.setTint(16636588);
      Phaser.Display.Align.In.Center(this.opponentScore, opponentPanel, -5, 2);
      this.add([opponentPanel, this.opponentAvatar, this.opponentScore]);
    }
    createContainer() {
      this.scene.add.existing(this);
    }
  };
  var ChallengeInfo_default = ChallengeInfo;

  // src/game/gameplay/objects/items/devTools/WinGameItem.ts
  init_phaser_custom_min();
  var { ID: ID18 } = item_default.NEW_GAME;
  var { FRAME: FRAME75 } = sprites_default.GAMEPLAY;
  var WinGameItem = class extends BaseItem_default {
    scene;
    constructor(scene) {
      super(scene, FRAME75.EFFECT_SPARK, 25, 25);
      this.scene = scene;
      this.setAmount(999);
      this.onClick = this.handleUseItem;
    }
    handleUseItem = () => {
      const { itemManager } = this.scene;
      if (this.isActive) {
        itemManager.deactivateItem(ID18);
        return;
      }
      const success = itemManager.activeItem(ID18);
      if (!success) {
        AnimUtils.runTween(this.shakeAnimation.tween);
        return;
      }
      this.useItem();
    };
    useItem = async () => {
      this.scene.finishLevel(true);
    };
  };
  var WinGameItem_default = WinGameItem;

  // src/game/scenes/game-scene/layouts/UIObjects.ts
  var { KEY: KEY68, FRAME: FRAME76 } = sprites_default.GAMEPLAY;
  var { KEY: DEFAULT_KEY5, FRAME: DEFAULT_FRAME5 } = sprites_default.DEFAULT;
  var UIObjects = class extends BaseUIObjects_default {
    scene;
    // ? Always public ui objects
    skipBtn;
    skipContainer;
    pauseButton;
    pauseNotification;
    headerBG;
    footerBG;
    levelText;
    topFooterBG;
    bottomFooterBG;
    playtimeClock;
    starProgressBar;
    comboProgressBar;
    // Challenge
    challengeInfo;
    // Items
    hintItem;
    rocketItem;
    inviteItem;
    shuffleItem;
    defuseItem;
    guideDefuseItem;
    superRocketItem;
    // ! Dev tools
    timeUp = null;
    winGame = null;
    newGame = null;
    resetData = null;
    backLevel = null;
    nextLevel = null;
    openLuckyWheel = null;
    autoMatch = null;
    changeColor = null;
    bombExplosive = null;
    constructor(scene) {
      super(scene);
      this.scene = scene;
      this.createObjects();
    }
    createObjects() {
      this.createHeaderBG();
      this.createFooterBG();
      this.createLevelText();
      this.createSkipButton();
      this.createPauseButton();
      this.createPlaytimeClock();
      this.createStarProgressBar();
      this.createComboProgressBar();
      this.createChallengeInfo();
      this.createHintItem();
      this.createRocketItem();
      this.createInviteItem();
      this.createDefuseItem();
      this.createGuideDefuseItem();
      this.createShuffleItem();
      this.createSuperRocketItem();
      this.createDevTools();
    }
    createHeaderBG() {
      this.headerBG = this.scene.make.image({
        key: KEY68,
        frame: FRAME76.LAYOUT_HEADER
      });
      const { width } = WorldUtils_default.getWorldSize();
      this.headerBG.setWorldSize(width);
      this.group.add(this.headerBG);
    }
    createFooterBG() {
      this.topFooterBG = this.scene.make.image({
        key: KEY68,
        frame: FRAME76.LAYOUT_FOOTER_TOP
      });
      this.bottomFooterBG = this.scene.make.image({
        key: KEY68,
        frame: FRAME76.LAYOUT_FOOTER_BOTTOM
      });
      this.group.add(this.topFooterBG);
      this.group.add(this.bottomFooterBG);
    }
    createLevelText() {
      this.levelText = FontUtils_default.createText(this.scene, "Lv 1", 17);
      FontUtils_default.applyYellowStyle(this.levelText).setStroke("#784225", 1.5).setShadowBlur(2);
      this.group.add(this.levelText);
    }
    createSkipButton() {
      this.skipContainer = this.scene.add.container(0, 0);
      this.skipContainer.setDepth(depth_default.ON_TOP);
      const btnBg = this.scene.make.image({
        key: DEFAULT_KEY5,
        frame: DEFAULT_FRAME5.BUTTON_GREEN_SMALL_BG
      });
      btnBg.setY(-1);
      this.skipContainer.add(btnBg);
      this.skipBtn = new Button_default(this.scene, DEFAULT_KEY5, DEFAULT_FRAME5.BUTTON_GREEN_SMALL);
      this.skipBtn.setName("SkipGuide");
      this.skipContainer.add(this.skipBtn);
      const text = FontUtils_default.createText(this.scene, "Skip", 16).setOrigin(0.5, 0.5);
      FontUtils_default.applyGreenStyle(text);
      text.setY(0);
      this.skipBtn.add(text);
      this.skipContainer.setWorldSize(63, 20);
      this.skipContainer.kill();
      this.group.add(this.skipContainer);
    }
    createPauseButton() {
      this.pauseButton = new Button_default(this.scene, KEY68, FRAME76.BUTTON_YELLOW_CIRCLE);
      this.pauseButton.setName("Pause");
      const pauseIcon = this.scene.make.image({
        key: KEY68,
        frame: FRAME76.ICON_PAUSE
      });
      this.pauseButton.add(pauseIcon);
      const isMinimized = WorldUtils_default.isLandscape();
      this.pauseNotification = new GameplayNotification_default(this.scene, { isMinimized });
      this.pauseButton.add(this.pauseNotification);
      if (!isMinimized) {
        AlignUtils_default.alignChildTopRight(this.pauseNotification, this.pauseButton, -6, -5);
      } else {
        AlignUtils_default.alignChildTopRight(this.pauseNotification, this.pauseButton, -8, -6);
      }
      this.group.add(this.pauseButton);
    }
    createPlaytimeClock() {
      this.playtimeClock = new PlaytimeClock_default(this.scene);
      this.group.add(this.playtimeClock);
    }
    createStarProgressBar() {
      this.starProgressBar = new StarProgressBar_default(this.scene);
      this.group.add(this.starProgressBar);
      this.starProgressBar.setVisible(false);
    }
    createComboProgressBar() {
      this.comboProgressBar = new ComboProgressBar_default(this.scene);
      this.comboProgressBar.setAlpha(0);
      this.comboProgressBar.kill();
      this.group.add(this.comboProgressBar);
    }
    createChallengeInfo() {
      this.challengeInfo = new ChallengeInfo_default(this.scene);
      this.group.add(this.challengeInfo);
    }
    createHintItem() {
      this.hintItem = new HintItem_default(this.scene);
      this.group.add(this.hintItem);
    }
    createShuffleItem() {
      this.shuffleItem = new ShuffleItem_default(this.scene);
      this.group.add(this.shuffleItem);
    }
    createDefuseItem() {
      this.defuseItem = new BombDefuse_default(this.scene);
      this.group.add(this.defuseItem);
    }
    createGuideDefuseItem() {
      this.guideDefuseItem = new GuideBombDefuse_default(this.scene);
      this.guideDefuseItem.kill();
      this.group.add(this.guideDefuseItem);
    }
    createRocketItem() {
      this.rocketItem = new RocketItem_default(this.scene);
      this.group.add(this.rocketItem);
    }
    createInviteItem() {
      this.inviteItem = new InviteItem_default(this.scene);
      this.group.add(this.inviteItem);
    }
    createSuperRocketItem() {
      this.superRocketItem = new SuperRocketItem_default(this.scene);
      this.group.add(this.superRocketItem);
    }
    // ! Debug items
    createDevTools() {
      if (!Ludex.Utils.Valid.isDebugger()) return;
      this.createTimeUpItem();
      this.createWinGameItem();
      this.createNewGameItem();
      this.createAutoMatchItem();
      this.createResetDataItem();
      this.createBackLevelItem();
      this.createNextLevelItem();
      this.createOpenLuckyWheelItem();
      this.createChangeColorItem();
      this.createBombExplosiveItem();
    }
    createWinGameItem() {
      this.winGame = new WinGameItem_default(this.scene);
      this.winGame.setScale(0.7);
      this.group.add(this.winGame);
    }
    createNewGameItem() {
      this.newGame = new NewGameItem_default(this.scene);
      this.newGame.setScale(0.7);
      this.group.add(this.newGame);
    }
    createChangeColorItem() {
      this.changeColor = new ChangeColorItem_default(this.scene);
      this.changeColor.setScale(0.7);
      this.group.add(this.changeColor);
    }
    createResetDataItem() {
      this.resetData = new ResetDataItem_default(this.scene);
      this.resetData.setScale(0.7);
      this.group.add(this.resetData);
    }
    createBackLevelItem() {
      this.backLevel = new BackLevelItem_default(this.scene);
      this.backLevel.setScale(0.7);
      this.group.add(this.backLevel);
    }
    createNextLevelItem() {
      this.nextLevel = new NextLevelItem_default(this.scene);
      this.nextLevel.setScale(0.7);
      this.group.add(this.nextLevel);
    }
    createOpenLuckyWheelItem() {
      this.openLuckyWheel = new OpenLuckyWheelItem_default(this.scene);
      this.openLuckyWheel.setScale(0.7);
      this.group.add(this.openLuckyWheel);
    }
    createBombExplosiveItem() {
      this.bombExplosive = new BombExplosiveItem_default(this.scene);
      this.bombExplosive.setScale(0.7);
      this.group.add(this.bombExplosive);
    }
    createTimeUpItem() {
      this.timeUp = new TimeUpItem_default(this.scene);
      this.timeUp.setScale(0.7);
      this.group.add(this.timeUp);
    }
    createAutoMatchItem() {
      this.autoMatch = new AutoMatchItem_default(this.scene);
      this.autoMatch.setScale(0.7);
      this.group.add(this.autoMatch);
    }
    playPauseNotification() {
      this.pauseNotification.playAlertAnimation();
    }
    stopPauseNotification() {
      this.pauseNotification.stopAlertAnimation();
    }
  };
  var UIObjects_default = UIObjects;

  // src/game/scenes/game-scene/layouts/LandscapeLayout.ts
  init_phaser_custom_min();

  // src/game/scenes/game-scene/layouts/PortraitLayout.ts
  init_phaser_custom_min();

  // src/game/layouts/BaseLayout.ts
  init_phaser_custom_min();
  var BaseLayout = class {
    scene;
    objects;
    allUI;
    groups;
    constructor(scene) {
      this.scene = scene;
      this.objects = null;
      this.createGroups();
    }
    setUIObjects(objects) {
      this.objects = objects;
      this.allUI.addMultiple(this.objects.getAll());
    }
    createGroups() {
      this.groups = {};
      this.allUI = this.scene.add.group();
      this.groups.allUI = this.allUI;
    }
    killAllUI() {
      this.allUI.killGroup();
    }
    reviveAllUI() {
      this.allUI.reviveGroup();
    }
  };
  var BaseLayout_default = BaseLayout;

  // src/game/scenes/game-scene/layouts/PortraitLayout.ts
  var { DefuseItemGuideLevel: DefuseItemGuideLevel3 } = GameSettings_default;
  var {
    Utils: { Valid: V15 }
  } = Ludex;
  var PortraitLayout = class extends BaseLayout_default {
    objects;
    itemUI;
    gameUI;
    guideUI;
    debugUI;
    constructor(scene) {
      super(scene);
      this.objects = null;
    }
    alignUI() {
      if (this.objects === null) return;
      const { headerBG, topFooterBG, bottomFooterBG, levelText, skipContainer } = this.objects;
      const { pauseButton, playtimeClock, starProgressBar, comboProgressBar, challengeInfo } = this.
      objects;
      const { gameZone } = this.scene;
      const bannerAdHeight = AdsUtils_default.getBannerHeight();
      Phaser.Display.Align.In.TopCenter(headerBG, gameZone);
      Phaser.Display.Align.In.BottomCenter(bottomFooterBG, gameZone, 0, -bannerAdHeight + bottomFooterBG.
      height);
      Phaser.Display.Align.In.TopCenter(topFooterBG, bottomFooterBG, 0, topFooterBG.height - 20);
      Phaser.Display.Align.In.TopRight(skipContainer, gameZone, -35, -55);
      Phaser.Display.Align.In.TopRight(comboProgressBar, gameZone, -20, -80);
      Phaser.Display.Align.In.Center(challengeInfo, headerBG, 19, -7);
      Phaser.Display.Align.In.LeftCenter(playtimeClock, headerBG, -17, -7);
      Phaser.Display.Align.In.RightCenter(pauseButton, headerBG, -8, -7);
      Phaser.Display.Align.In.Center(levelText, headerBG, -70, -7);
      Phaser.Display.Align.In.Center(starProgressBar, headerBG, 45, -7);
      this.alignItems();
      this.alignDebugItems();
    }
    alignItems() {
      const { objects } = this;
      if (!objects) return;
      const { topFooterBG: footerBG } = objects;
      const { itemUI } = this.groups;
      const { level } = this.scene.levelHandler.getConfigs();
      const { defuseItem, guideDefuseItem, superRocketItem } = objects;
      const children = itemUI.getChildren();
      const visibleChildren = children.filter((child) => child.visible);
      const isShownDefuseItemGuide = !this.scene.tutorialManager.isBombDefuseTutorialShown() && level ===
      DefuseItemGuideLevel3;
      if (isShownDefuseItemGuide) {
        guideDefuseItem.setScale(1);
      }
      for (const child of visibleChildren) {
        child.setScale(1);
      }
      if (isShownDefuseItemGuide) visibleChildren.unshift(guideDefuseItem);
      AlignUtils_default.alignChildrenContainer(visibleChildren, {
        width: footerBG.width - 90,
        x: footerBG.x - 24,
        y: footerBG.y
      });
      if (isShownDefuseItemGuide) guideDefuseItem.setPosition(defuseItem.x, defuseItem.y);
      superRocketItem.setRechargeNotificationLayout("portrait");
    }
    alignDebugItems() {
      if (!V15.isDebugger()) return;
      if (this.objects === null) return;
      const { debugUI } = this.groups;
      const { gameZone } = this.scene;
      debugUI.reviveGroup();
      Phaser.Actions.GridAlign(debugUI.getChildren(), {
        width: 1,
        cellWidth: 40,
        cellHeight: 40,
        x: -gameZone.width / 2,
        y: -gameZone.height / 2 + 50
      });
    }
    createGroups() {
      super.createGroups();
      this.itemUI = this.scene.add.group();
      this.gameUI = this.scene.add.group();
      this.debugUI = this.scene.add.group();
      this.itemUI.setDepth(depth_default.ITEM);
      this.groups.itemUI = this.itemUI;
      this.groups.gameUI = this.gameUI;
      this.groups.debugUI = this.debugUI;
    }
    setUIObjects(objects) {
      super.setUIObjects(objects);
      this.addUIObjectsToGroups();
    }
    addUIObjectsToGroups() {
      if (this.objects === null) return;
      this.addObjectsForItem();
      this.addObjectsForGame();
      this.addObjectsForDebug();
    }
    addObjectsForItem() {
      if (this.objects === null) return;
      this.groups.itemUI.addMultiple([
        this.objects.defuseItem,
        this.objects.hintItem,
        this.objects.rocketItem,
        this.objects.shuffleItem,
        this.objects.superRocketItem,
        this.objects.inviteItem
      ]);
    }
    addObjectsForGame() {
      if (this.objects === null) return;
      this.groups.gameUI.addMultiple([
        this.objects.levelText,
        this.objects.pauseButton,
        this.objects.playtimeClock,
        this.objects.challengeInfo,
        this.objects.starProgressBar,
        ...this.groups.itemUI.getChildren()
      ]);
    }
    addObjectsForDebug() {
      if (this.objects === null) return;
      const {
        changeColor,
        winGame,
        newGame,
        resetData,
        autoMatch,
        backLevel,
        nextLevel,
        timeUp,
        bombExplosive,
        openLuckyWheel
      } = this.objects;
      const items = [
        changeColor,
        winGame,
        newGame,
        resetData,
        autoMatch,
        backLevel,
        nextLevel,
        timeUp,
        bombExplosive,
        openLuckyWheel
      ].filter((item) => item !== null);
      this.groups.debugUI.addMultiple(items);
      this.groups.debugUI.killGroup();
    }
  };
  var PortraitLayout_default = PortraitLayout;

  // src/game/scenes/game-scene/layouts/LandscapeLayout.ts
  var { DefuseItemGuideLevel: DefuseItemGuideLevel4 } = GameSettings_default;
  var LandscapeLayout = class extends PortraitLayout_default {
    alignUI() {
      if (this.objects === null) return;
      super.alignUI();
      const { gameZone } = this.scene;
      const {
        topFooterBG,
        headerBG,
        pauseButton,
        playtimeClock,
        skipContainer,
        levelText,
        starProgressBar,
        comboProgressBar,
        challengeInfo
      } = this.objects;
      Phaser.Display.Align.In.TopRight(topFooterBG, headerBG, -26, 16);
      Phaser.Display.Align.In.TopRight(pauseButton, headerBG, -30, -5);
      Phaser.Display.Align.In.LeftCenter(playtimeClock, headerBG, -30, -5);
      Phaser.Display.Align.In.TopCenter(skipContainer, gameZone, 200, -45);
      Phaser.Display.Align.To.RightCenter(levelText, playtimeClock, 20, 0);
      Phaser.Display.Align.To.RightCenter(starProgressBar, levelText, 30, 0);
      Phaser.Display.Align.In.Center(comboProgressBar, topFooterBG, 60, 60);
      Phaser.Display.Align.In.Center(challengeInfo, headerBG, 0, -7);
      const fullWidth = WorldUtils_default.getWorldSize().width;
      headerBG.setWorldSize(fullWidth, 65);
      this.alignItems();
    }
    alignItems() {
      const { objects } = this;
      if (!objects) return;
      const { itemUI } = this.groups;
      const { pauseButton, guideDefuseItem, defuseItem, superRocketItem } = objects;
      const scene = this.scene;
      if (!(scene instanceof GameScene_default)) return;
      const { level } = scene.levelHandler.getConfigs();
      const children = itemUI.getMatching("visible", true).reverse();
      const isShownDefuseItemGuide = !scene.tutorialManager.isBombDefuseTutorialShown() && level ===
      DefuseItemGuideLevel4;
      if (isShownDefuseItemGuide) {
        children.push(defuseItem);
        guideDefuseItem.setScale(0.85);
      }
      Phaser.Actions.SetXY(children, pauseButton.x - 70, pauseButton.y + 3, -60);
      for (const child of children) {
        child.setScale(0.85);
      }
      if (isShownDefuseItemGuide) guideDefuseItem.setPosition(defuseItem.x, defuseItem.y);
      superRocketItem.setRechargeNotificationLayout("landscape");
    }
  };
  var LandscapeLayout_default = LandscapeLayout;

  // src/game/layouts/BaseLayoutManager.ts
  init_phaser_custom_min();
  var { STATUS: STATUS7 } = manager_default;
  var BaseLayoutManager = class extends BaseManager_default {
    scene;
    layout;
    objects;
    constructor(scene) {
      super(scene);
      this.scene = scene;
      this.createObjects();
      this.createLayouts();
    }
    init() {
      this.initUILogic();
      this.layout.alignUI();
      this.setState(STATUS7.READY);
    }
    start() {
      if (this.isRunning()) return;
      this.updateUIState();
      this.setState(STATUS7.RUNNING);
    }
    stop() {
      if (!this.isRunning()) return;
      this.setState(STATUS7.STOPPED);
    }
    handleResize = () => {
      this.layout.alignUI();
    };
    handleLayoutChange = () => {
      this.createLayouts();
      this.layout.setUIObjects(this.objects);
      this.layout.alignUI();
    };
  };
  var BaseLayoutManager_default = BaseLayoutManager;

  // src/game/scenes/game-scene/layouts/LayoutManager.ts
  var { event: event33 } = codex;
  var LayoutManager = class extends BaseLayoutManager_default {
    scene;
    groups;
    constructor(scene) {
      super(scene);
      this.scene = scene;
      this.createGroups$();
      this.registerEvents();
    }
    registerEvents() {
      event33.on(GameEvents_default.VIEW_RESIZED, this.handleResize);
      event33.on(GameEvents_default.LAYOUT_CHANGED, this.handleLayoutChange);
    }
    createObjects() {
      this.objects = new UIObjects_default(this.scene);
    }
    /**
     * If the device is in landscape mode, use the LandscapeLayout, otherwise use the PortraitLayout
     */
    createLayouts() {
      if (WorldUtils_default.isLandscape()) {
        this.layout = new LandscapeLayout_default(this.scene);
      } else {
        this.layout = new PortraitLayout_default(this.scene);
      }
      this.layout.setUIObjects(this.objects);
    }
    createGroups$() {
      this.groups = this.layout.groups;
    }
    init() {
      this.scene.uiManager.handleHeaderAndFooterResize();
      this.layout.alignUI();
      this.setState(manager_default2.STATUS.READY);
    }
    start() {
      if (this.isRunning()) return;
      this.updateUIState();
      this.setState(manager_default2.STATUS.RUNNING);
    }
    stop() {
      if (!this.isRunning()) return;
      this.setState(manager_default2.STATUS.STOPPED);
    }
    handleResize = () => {
      this.scene.uiManager.handleHeaderAndFooterResize();
      this.layout.alignUI();
    };
    handleLayoutChange = () => {
      this.createLayouts();
      this.handleResize();
    };
    // * If have more logic, you can create a new class to handle it (UIManager)
    initUILogic() {
    }
    // * If have more state, you can create a new class to handle it (UIManager)
    updateUIState() {
    }
  };
  var LayoutManager_default = LayoutManager;

  // src/game/gameplay/managers/ScoreManager.ts
  init_phaser_custom_min();
  var ScoreManager = class extends BaseManager_default {
    scene;
    bestScore$;
    currentScore$;
    currentLevel$;
    currentCombo$;
    constructor(scene) {
      super(scene);
      this.scene = scene;
      this.bestScore$ = 0;
      this.currentScore$ = 0;
      this.currentLevel$ = 0;
      this.currentCombo$ = 0;
    }
    init() {
      this.currentCombo$ = 0;
      this.currentScore$ = 0;
    }
    start() {
      if (this.isRunning()) return;
      super.start();
      const { level } = this.scene.levelHandler;
      this.currentLevel$ = level;
      this.currentScore$ = this.scene.getSceneData().score ?? 0;
      this.listenEvents$();
    }
    stop() {
      if (!this.isRunning()) return;
      super.stop();
      this.cleanListeners$();
    }
    getScore() {
      return this.currentScore$;
    }
    getBestScore() {
      return this.bestScore$;
    }
    listenEvents$() {
      this.scene.events.on(score_default.ADD, this.onAddScore$);
    }
    cleanListeners$() {
      this.scene.events.off(score_default.ADD, this.onAddScore$);
    }
    onAddScore$ = (score) => {
      this.currentCombo$ = this.scene.comboManager.getCombo();
      const addScore = score * this.currentLevel$ * this.currentCombo$;
      this.currentScore$ += addScore;
      this.bestScore$ = Math.max(this.bestScore$, this.currentScore$);
      console.log("ScoreManager.onAddScore", addScore, this.currentScore$, this.currentCombo$);
    };
  };
  var ScoreManager_default = ScoreManager;

  // src/game/gameplay/managers/StateManager.ts
  init_phaser_custom_min();

  // src/game/gameplay/states/InitializeState.ts
  init_phaser_custom_min();

  // src/game/gameplay/states/BaseState.ts
  init_phaser_custom_min();
  var BaseState = class {
    game;
    manager;
    constructor(manager) {
      this.game = manager.getGame();
      this.manager = manager;
      this.logDebug();
    }
    logDebug() {
      const stateName = this.constructor.name;
      console.debug(`[STATE] ${stateName}`);
    }
  };
  var BaseState_default = BaseState;

  // src/game/gameplay/states/InitializeState.ts
  var { player: player19, analytics: analytics14 } = codex;
  var InitializeState = class extends BaseState_default {
    enter() {
      this.enterAsync();
    }
    async enterAsync() {
      try {
        await this.loadLevel();
        this.game.initManager();
        this.loadUI();
        this.logLevelStartAnalytics();
        this.ready();
      } catch (error) {
        console.error(error);
      }
    }
    async loadLevel() {
      const isTournamentMode = MatchUtils_default.isTournamentMode();
      let correctedLevel = MatchUtils_default.getMatchLevel();
      if (correctedLevel === void 0) {
        correctedLevel = isTournamentMode ? 2 : PlayerUtils_default.getLevelProgress();
      }
      if (!isTournamentMode) {
        this.game.setSceneData({ score: 0 });
      }
      if (player19.isFirstSession() && correctedLevel < 1) {
        correctedLevel = 1;
        player19.setGameData({ level: 2 });
      }
      this.game.levelHandler.init(correctedLevel);
    }
    loadUI() {
      const { layoutManager, uiManager, tutorialManager, levelHandler, tileManager } = this.game;
      const { groups, objects } = layoutManager;
      const { level } = levelHandler;
      groups.gameUI.reviveGroup();
      this.game.uiManager.showUIByMatchMode();
      uiManager.updateLevel(level);
      objects.starProgressBar.setProcess(0);
      objects.playtimeClock.startClock(levelHandler.getConfigs().time);
      objects.playtimeClock.pauseClock();
      if (tutorialManager.checkIsValidForTutorial()) uiManager.showUIForGuide();
      layoutManager.layout.alignItems();
      this.game.startManager();
      tileManager.hideHintEffect();
    }
    logLevelStartAnalytics() {
      const { level = 1 } = MatchUtils_default.getMatchCustomData() ?? {};
      const mode = MatchUtils_default.getMatchMode() ?? void 0;
      const score = this.game.scoreManager.getScore();
      analytics14.levelStart(level, score, mode);
    }
    initialize() {
    }
    ready() {
      AudioUtils_default.playSound(soundEffects_default.LEVEL_START);
      AudioUtils_default.playMusic();
      const state = this.manager.createReadyState(this.manager);
      this.manager.change(state);
    }
    playing() {
    }
    fail() {
    }
    finish() {
    }
  };
  var InitializeState_default = InitializeState;

  // src/game/gameplay/states/FailState.ts
  init_phaser_custom_min();
  var {
    Utils: { Time: T8 },
    Plugins: {
      Ads: { Types: AdsTypes2 }
    }
  } = Ludex;
  var { storage: storage3, player: player20, event: event34, analytics: analytics15 } = codex;
  var { DelayEndGame: DelayEndGame2 } = GameSettings_default;
  var FailState = class extends BaseState_default {
    reason;
    constructor(manager, reason) {
      super(manager);
      this.reason = reason;
    }
    enter() {
      this.enterAsync();
    }
    async enterAsync() {
      try {
        const { tileManager, itemManager, uiManager } = this.game;
        tileManager.isSelectable = false;
        tileManager.removeSuggestPairHint();
        itemManager.setIsUseableItem(false);
        uiManager.disablePause();
        this.updateMatchData();
        this.logLevelFailAnalytics();
        await T8.sleepAsync(DelayEndGame2);
        if (MatchUtils_default.isTournamentMode()) {
          await this.processFinishTournament();
          return;
        }
        if (MatchUtils_default.isChallengeMode()) {
          await this.processFinishChallenge();
          return;
        }
        if (MatchUtils_default.isSingleMode()) {
          await this.processFinishSingle();
          return;
        }
      } catch (error) {
        console.error(error);
      }
    }
    updateMatchData() {
      if (!this.game) return;
      const { scoreManager } = this.game;
      const playerId = player20.getPlayerId();
      const score = scoreManager.getScore();
      if (!playerId || !score) return;
      MatchUtils_default.setProfileMatchDataAsync({ id: playerId, score });
    }
    logLevelFailAnalytics() {
      const {
        mode,
        customData: { level = 1 }
      } = MatchUtils_default.getMatchState();
      const score = this.game.scoreManager.getScore();
      analytics15.levelFail(level, score, mode ?? "Unknown");
    }
    async processFinishTournament() {
      const success = await MatchUtils_default.finishTournamentAsync();
      if (!success) return;
      storage3.setStorageData("Tournament", "showResult", true);
      const { tournamentId = "" } = MatchUtils_default.getMatchCustomData() ?? {};
      if (!tournamentId) return;
      SceneUtils_default.switchToDashboardScene();
    }
    async processFinishChallenge() {
      const success = await MatchUtils_default.finishChallengeModeAsync();
      if (!success) return;
      event34.emit(game_default.SHOW_RESULT_CHALLENGE_SCREEN);
    }
    async processFinishSingle() {
      const { tileManager, levelHandler } = this.game;
      const { level } = levelHandler;
      AudioUtils_default.pauseMusic();
      if (AdsUtils_default.isReadyAdShowable(AdsTypes2.REWARDED_VIDEO)) {
        tileManager.hideAllTiles();
        ScreenUtils_default.openScreen(ScreenKeys_default.CONTINUE_SCREEN, { level, reason: this.reason });
      } else {
        ScreenUtils_default.openScreen(ScreenKeys_default.RESCUE_SCREEN, { level, reason: this.reason });
      }
    }
    initialize() {
      const state = this.manager.createInitializeState(this.manager);
      this.manager.change(state);
    }
    ready() {
      const state = this.manager.createReadyState(this.manager);
      this.manager.change(state);
    }
    playing() {
    }
    fail() {
    }
    finish() {
    }
  };
  var FailState_default = FailState;

  // src/game/gameplay/states/FinishState.ts
  init_phaser_custom_min();
  var {
    Utils: { Time: T9 },
    Configs: { Gameplay },
    Plugins: { Ads: Ads2 }
  } = Ludex;
  var { DelayLevelUp } = GameSettings_default;
  var { player: player21, event: event35, leaderboard: leaderboard3, analytics: analytics16 } = codex;
  var FinishState = class extends BaseState_default {
    isAdReady;
    enter() {
      this.isAdReady = this.isInterstitialAdReady();
      this.enterAsync();
    }
    async enterAsync() {
      try {
        const { effectManager, levelHandler } = this.game;
        const { level: prevLevel } = levelHandler;
        this.handleFinishUI();
        this.updateMission();
        this.updateMatchData();
        this.updateSceneData();
        this.logLevelCompleteAnalytics();
        if (prevLevel === 1) {
          event35.emit(game_default.NEXT_LEVEL);
          return;
        }
        await T9.sleepAsync(DelayLevelUp);
        if (this.isAdReady) {
          AudioUtils_default.setVolumeMusic(0, true);
        }
        await new Promise((resolve) => {
          effectManager.playFlyingStarFromClockEffect(resolve);
        });
        if (MatchUtils_default.isTournamentMode()) {
          try {
            ScreenUtils_default.showLoadingScreen();
            await this.handlePostTournamentScore();
          } catch (error) {
            console.warn("handlePostTournamentScore", error);
          } finally {
            ScreenUtils_default.closeLoadingScreen();
            event35.emit(game_default.NEXT_LEVEL);
          }
          return;
        }
        await this.handleShowResult();
      } catch (error) {
        console.error(error);
      }
    }
    disableCurrentGameplayNotification() {
      GameplayNotificationUtils_default.setGameplayPauseNotificationFlag(false);
      GameplayNotificationUtils_default.setPauseScreenNotificationFlag(false);
    }
    handleFinishUI() {
      const { uiManager, layoutManager, tileManager } = this.game;
      const { objects } = layoutManager;
      uiManager.disablePause();
      tileManager.removeSuggestPairHint();
      objects.playtimeClock.pauseClock();
      objects.starProgressBar.setProcess(1);
    }
    logLevelCompleteAnalytics() {
      const {
        mode,
        customData: { level = 1 }
      } = MatchUtils_default.getMatchState();
      const score = this.game.scoreManager.getScore();
      analytics16.levelComplete(level, score, mode ?? "Unknown");
    }
    updateMission() {
      const result = MissionUtils_default.addFinishLevelMissionProgress(1);
      if (!result.isMissionFinished) {
        this.disableCurrentGameplayNotification();
      }
    }
    updateMatchData() {
      if (!this.game) return;
      const { scoreManager } = this.game;
      const playerId = player21.getPlayerId();
      const score = scoreManager.getScore();
      if (!playerId || !score) return;
      MatchUtils_default.setProfileMatchDataAsync({ id: playerId, score });
    }
    updateSceneData() {
      if (!this.game) return;
      this.game.setSceneData({
        score: this.game.scoreManager.getScore()
      });
    }
    async handlePostTournamentScore() {
      if (!this.game) return;
      const score = this.game?.scoreManager.getScore();
      if (!score) return;
      try {
        await GameSDK.tournament.postScoreAsync(score);
      } catch (error) {
        console.warn("GameSDK post score async", error);
      }
      const customData = MatchUtils_default.getMatchCustomData();
      if (!customData) return;
      const { leaderboardId, playerId } = customData;
      if (!leaderboardId || !playerId) return;
      await leaderboard3.setLeaderboardScoreAsync(leaderboardId, playerId, score);
    }
    async handleShowResult() {
      const { layoutManager, levelHandler, comboManager } = this.game;
      const isAdShownSuccessful = await this.handleShowInterstitialAd();
      const resultDelay = !isAdShownSuccessful ? 1e3 : 0;
      await T9.sleepAsync(resultDelay);
      if (!this.isAdReady) {
        AudioUtils_default.setMinVolumeMusic();
      }
      comboManager.stop();
      if (MatchUtils_default.isChallengeMode()) {
        await this.showChallengeResultScreen();
      } else {
        const { starProgressBar } = layoutManager.objects;
        const { level: nextLevel } = levelHandler;
        const starAmount = starProgressBar.getStarAmount();
        await this.showResultScreen(starAmount, nextLevel);
      }
    }
    showChallengeResultScreen = async () => {
      const success = await MatchUtils_default.finishChallengeModeAsync();
      if (!success) return;
      event35.emit(game_default.SHOW_RESULT_CHALLENGE_SCREEN);
    };
    showResultScreen = async (eatStars, level) => {
      ScreenUtils_default.openScreen(ScreenKeys_default.RESULT_SCREEN, { eatStars, level });
    };
    async handleShowInterstitialAd() {
      if (!this.isAdReady) return false;
      try {
        await AdsUtils_default.showInterstitialAdAsync();
        return true;
      } catch (error) {
        console.warn("handleShowInterstitialAd", error);
        return false;
      } finally {
        AudioUtils_default.setMinVolumeMusic();
      }
    }
    isInterstitialAdReady() {
      const { level: nextLevel } = this.game.levelHandler;
      if (nextLevel < Gameplay.StartAdAtLevel) return false;
      if (!AdsUtils_default.isReadyAdShowable(Ads2.Types.INTERSTITIAL)) return false;
      return true;
    }
    initialize() {
      const state = this.manager.createInitializeState(this.manager);
      this.manager.change(state);
    }
    ready() {
    }
    playing() {
    }
    fail() {
    }
    finish() {
    }
  };
  var FinishState_default = FinishState;

  // src/game/gameplay/states/PlayingState.ts
  init_phaser_custom_min();
  var PlayingState = class extends BaseState_default {
    enter() {
      this.startCountdown();
    }
    startCountdown() {
      const { objects } = this.game.layoutManager;
      const { playtimeClock } = objects;
      playtimeClock.resumeClock();
    }
    initialize() {
      const state = this.manager.createInitializeState(this.manager);
      this.manager.change(state);
    }
    ready() {
    }
    playing() {
    }
    fail(reason) {
      const state = this.manager.createFailState(this.manager, reason);
      this.manager.change(state);
    }
    finish() {
      const state = this.manager.createFinishState(this.manager);
      this.manager.change(state);
    }
  };
  var PlayingState_default = PlayingState;

  // src/game/gameplay/states/ReadyState.ts
  init_phaser_custom_min();
  var ReadyState = class extends BaseState_default {
    enter() {
    }
    initialize() {
      const state = this.manager.createInitializeState(this.manager);
      this.manager.change(state);
    }
    ready() {
    }
    playing() {
      const state = this.manager.createPlayingState(this.manager);
      this.manager.change(state);
    }
    fail() {
    }
    finish() {
      const state = this.manager.createFinishState(this.manager);
      this.manager.change(state);
    }
  };
  var ReadyState_default = ReadyState;

  // src/game/gameplay/managers/StateManager.ts
  var StateManager = class {
    state$;
    game$;
    getGame() {
      return this.game$;
    }
    init(game) {
      this.game$ = game;
      this.state$ = new InitializeState_default(this);
      this.state$.enter();
    }
    change(state) {
      this.state$ = state;
      this.state$.enter();
    }
    initialize() {
      this.state$.initialize();
    }
    /**
     * @public
     * @internal Demo state checking
     */
    isInitialize() {
      return this.state$ instanceof InitializeState_default;
    }
    ready() {
      this.state$.ready();
    }
    /**
     * @public
     * @internal Demo state checking
     */
    isReady() {
      return this.state$ instanceof ReadyState_default;
    }
    playing() {
      this.state$.playing();
    }
    isPlaying() {
      return this.state$ instanceof PlayingState_default;
    }
    fail(reason) {
      this.state$.fail(reason);
    }
    isFail() {
      return this.state$ instanceof FailState_default;
    }
    finish() {
      this.state$.finish();
    }
    /**
     * @public
     * @internal Demo state checking
     */
    isFinished() {
      return this.state$ instanceof FinishState_default;
    }
    createInitializeState(...args) {
      return new InitializeState_default(...args);
    }
    createReadyState(...args) {
      return new ReadyState_default(...args);
    }
    createPlayingState(...args) {
      return new PlayingState_default(...args);
    }
    createFailState(...args) {
      return new FailState_default(...args);
    }
    createFinishState(...args) {
      return new FinishState_default(...args);
    }
  };
  var StateManager_default = StateManager;

  // src/game/scenes/game-scene/GameScene.ts
  var {
    Plugins: {
      Ads: { Types: AdsTypes3 },
      Analytics: { Events: AnalyticsEvents14 }
    },
    Utils: { Valid: V16, Time: T10 },
    Events: Events10
  } = Ludex;
  var { player: player22, analytics: analytics17, event: event36 } = codex;
  var { StartScore, DelayStart } = GameSettings_default;
  var GameScene = class extends BaseScene_default {
    gameStatus;
    prevScore$ = 0;
    currentScore = 0;
    isSuperRocketUsed = false;
    isReachTargetScore = false;
    // Handler
    levelHandler;
    // Manager
    uiManager;
    tileManager;
    modeManager;
    itemManager;
    boardManager;
    scoreManager;
    comboManager;
    effectManager;
    layoutManager;
    tutorialManager;
    animationManager;
    stateManager;
    levelStartAt$;
    levelEndAt$;
    preload() {
      this.events.on(Phaser.Scenes.Events.WAKE, this.run$);
      this.events.on(Phaser.Scenes.Events.CREATE, this.run$);
      this.events.on(Phaser.Scenes.Events.SLEEP, this.handleSleep$);
    }
    create = () => {
      super.create();
      this.levelStartAt$ = 0;
      this.levelEndAt$ = 0;
      this.createBackground(images_default.BACKGROUND.KEY);
      this.createHandler$();
      this.createManager$();
      this.listenEvents$();
    };
    createHandler$() {
      this.levelHandler = new LevelHandler_default(this);
    }
    createManager$() {
      this.layoutManager = new LayoutManager_default(this);
      this.animationManager = new AnimationManager_default(this);
      this.tileManager = new TileManager_default(this);
      this.modeManager = new ModeManager_default(this);
      this.itemManager = new ItemManager_default(this);
      this.boardManager = new BoardManager_default(this);
      this.scoreManager = new ScoreManager_default(this);
      this.comboManager = new ComboManager_default(this);
      this.effectManager = new EffectManager_default(this);
      this.tutorialManager = new TutorialManager_default(this);
      this.stateManager = new StateManager_default();
      this.uiManager = new UIManager_default(this);
    }
    initManager() {
      this.uiManager.init();
      this.boardManager.init();
      this.tileManager.init();
      this.modeManager.init();
      this.itemManager.init();
      this.scoreManager.init();
      this.comboManager.init();
      this.effectManager.init();
      this.tutorialManager.init();
      this.animationManager.init();
      this.layoutManager.init();
    }
    stopManager() {
      this.uiManager.stop();
      this.boardManager.stop();
      this.tileManager.stop();
      this.modeManager.stop();
      this.itemManager.stop();
      this.scoreManager.stop();
      this.comboManager.stop();
      this.effectManager.stop();
      this.tutorialManager.stop();
      this.animationManager.stop();
      this.layoutManager.stop();
    }
    startManager() {
      this.boardManager.start();
      this.tileManager.start();
      this.modeManager.start();
      this.itemManager.start();
      this.scoreManager.start();
      this.comboManager.start();
      this.effectManager.start();
      this.tutorialManager.start();
      this.animationManager.start();
      this.uiManager.start();
      this.layoutManager.start();
    }
    listenEvents$() {
      event36.on(game_default.REPLAY, this.handleReplayLevel$);
      event36.on(game_default.RESCUE, this.rescued$);
      event36.on(game_default.CONTINUE, this.continue$);
      event36.on(game_default.NEXT_LEVEL, this.handleNextLevel$);
      event36.on(game_default.RECEIVE_ITEM, this.handleReceiveItem$);
      event36.on(game_default.PAUSE, this.handlePause$);
      event36.on(game_default.RESUME, this.handleResume$);
      event36.on(game_default.SHOW_RESULT_CHALLENGE_SCREEN, this.showResultChallengeScreen$);
      event36.off(GameEvents_default.LAYOUT_CHANGED, this.handleResize);
      event36.on(GameEvents_default.LAYOUT_CHANGED, this.handleResizeForGameScene$);
      this.events.on(tile_default.EVENTS.INTERACTION, this.handleTileInteraction$);
    }
    run$ = async () => {
      event36.emit(Events10.SCENE_LOADED, { sceneName: this.scene.key });
      await this.initMatchMode$();
      await this.initTournamentMode$();
      this.stateManager.init(this);
      this.startGame$();
      AdsUtils_default.preloadAdsByType(AdsTypes3.INTERSTITIAL);
    };
    async initMatchMode$() {
      if (MatchUtils_default.getMatchMode()) return;
      await MatchUtils_default.startSingleModeAsync();
    }
    async initTournamentMode$() {
      if (!MatchUtils_default.isTournamentMode()) return;
      MissionUtils_default.addJoinTournamentMissionProgress(1);
      if (!this.getSceneData()?.isFromLoader) return;
      await MatchUtils_default.setMatchCustomDataAsync({ level: 2 });
    }
    async startGame$() {
      const isMusicEnabled = !!player22.getPlayerSetting("music");
      if (isMusicEnabled) {
        AudioUtils_default.setDefaultVolumeMusic();
      }
      this.levelStartAt$ = Date.now();
      this.prevScore$ = StartScore;
      this.currentScore = 0;
      this.setScore$(this.prevScore$);
      this.stateManager.initialize();
    }
    setScore$(score) {
      this.currentScore = score;
      const { targetScore } = this.levelHandler;
      this.isReachTargetScore = this.currentScore >= targetScore;
      if (MatchUtils_default.isChallengeMode()) {
        const score2 = this.scoreManager.getScore();
        const { objects } = this.layoutManager;
        objects.challengeInfo.setPlayerScore(score2);
      }
    }
    eatScore = (score) => {
      if (!this.stateManager.isPlaying()) return;
      this.currentScore += score;
      const { targetScore } = this.levelHandler;
      const { objects } = this.layoutManager;
      objects.starProgressBar.setProcess(this.currentScore / targetScore);
      this.setScore$(this.currentScore);
    };
    // // // // // // // //
    die = (reason) => {
      if (!this.stateManager.isPlaying()) return;
      const { objects } = this.layoutManager;
      objects.playtimeClock.pauseClock();
      this.events.emit(tile_default.EVENTS.PAUSE_BOMB_TIMER);
      event36.emit(game_default.DIE);
      this.stateManager.fail(reason);
    };
    rescued$ = (payload) => {
      const {
        mode,
        customData: { level = 1 }
      } = MatchUtils_default.getMatchState();
      analytics17.levelRescue(level, this.currentScore, mode ?? "Unknown");
      this.uiManager.enablePause();
      AudioUtils_default.playSound(soundEffects_default.LEVEL_START);
      AudioUtils_default.playMusic();
      AudioUtils_default.setDefaultVolumeMusic();
      T10.sleepAsync(DelayStart / 2).then(() => {
        this.tileManager.isSelectable = true;
        this.itemManager.setIsUseableItem(true);
      });
      if (!V16.isObject(payload)) return;
      const { objects } = this.layoutManager;
      objects.playtimeClock.handleRescueTimeout();
      this.tileManager.handleBombTimerRescue();
      this.stateManager.ready();
    };
    continue$ = (payload) => {
      this.rescued$(payload);
    };
    finishLevel = (force = false) => {
      if (!force && this.stateManager.isFinished()) return;
      this.stateManager.finish();
      event36.emit(game_default.FINISH);
      this.levelEndAt$ = Date.now();
      this.prevScore$ = this.currentScore;
      this.setScore$(this.currentScore);
    };
    handleReplayLevel$ = async () => {
      if (this.isSuperRocketUsed === true) {
        this.isSuperRocketUsed = false;
        this.itemManager.resetSuperRocketUsage();
      }
      await this.resetTournamentData$();
      this.stopManager();
      this.startGame$();
    };
    resetTournamentData$ = async () => {
      if (!MatchUtils_default.isTournamentMode()) return;
      try {
        ScreenUtils_default.showLoadingScreen();
        this.setSceneData({
          score: 0
        });
        await MatchUtils_default.setMatchCustomDataAsync({
          level: 2
        });
      } catch (error) {
        console.warn("resetTournamentData$ error", error);
      } finally {
        ScreenUtils_default.closeLoadingScreen();
      }
    };
    handleNextLevel$ = async () => {
      if (MatchUtils_default.isChallengeMode()) {
        this.finishLevel(true);
        return;
      }
      if (MatchUtils_default.isSingleMode()) {
        await MatchUtils_default.finishSingleModeAsync();
      }
      this.levelHandler.up();
      if (MatchUtils_default.isSingleMode()) {
        player22.setGameData({ level: this.levelHandler.level });
        await MatchUtils_default.startSingleModeAsync();
      }
      if (MatchUtils_default.isTournamentMode()) {
        ScreenUtils_default.showLoadingScreen();
        await MatchUtils_default.setMatchCustomDataAsync({
          level: this.levelHandler.level
        });
        ScreenUtils_default.closeLoadingScreen();
      }
      this.stopManager();
      this.startGame$();
    };
    handleReceiveItem$ = (payload) => {
      const { itemId, rewardCount } = payload;
      this.itemManager.addItemAmount(itemId, rewardCount);
      analytics17.event(AnalyticsEvents14.EARN_ITEM, {
        item_name: itemId,
        value: rewardCount
      });
    };
    handlePause$ = () => {
      const { objects } = this.layoutManager;
      objects.playtimeClock.pauseClock();
      this.tileManager.hideAllTiles();
      this.tileManager.hideHintEffect();
      this.events.emit(tile_default.EVENTS.PAUSE_BOMB_TIMER);
    };
    handleResume$ = () => {
      this.tileManager.showAllTiles();
      this.tileManager.showHintEffect();
      if (!this.stateManager.isPlaying()) return;
      const { objects } = this.layoutManager;
      objects.playtimeClock.resumeClock();
      this.events.emit(tile_default.EVENTS.RESUME_BOMB_TIMER);
    };
    handleSleep$ = () => {
      this.stopManager();
      AdsUtils_default.hideBannerAds();
    };
    getPlayedTimeSeconds() {
      return Math.floor((this.levelEndAt$ - this.levelStartAt$) / 1e3);
    }
    handleTileInteraction$ = () => {
      this.stateManager.playing();
    };
    showResultChallengeScreen$ = () => {
      const { customData, profiles } = MatchUtils_default.getMatchState();
      const { playerId, opponentId } = customData;
      if (!playerId || !opponentId) return;
      const playerProfile = profiles[playerId];
      const opponentProfile = profiles[opponentId];
      const payload = {
        playerId,
        opponentId,
        playerAvatar: playerProfile.photo,
        opponentAvatar: opponentProfile.photo,
        playerScore: playerProfile.score,
        opponentScore: opponentProfile.score
      };
      event36.emit(game_default.PAUSE);
      ScreenUtils_default.openScreen(ScreenKeys_default.RESULT_CHALLENGE_FRIEND_SCREEN, payload);
    };
    getSceneData() {
      return this.data.get("data");
    }
    setSceneData(data) {
      const currentData = this.data.get("data");
      const mergedData = { ...currentData, ...data };
      this.data.set("data", mergedData);
    }
    handleResizeForGameScene$ = (payload) => {
      this.handleResize(payload);
      if (this.stateManager.isFinished()) {
        return;
      }
      ScreenUtils_default.closeScreen(ScreenKeys_default.CONTINUE_SCREEN);
      ScreenUtils_default.closeScreen(ScreenKeys_default.RESCUE_SCREEN);
      ScreenUtils_default.closeScreen(ScreenKeys_default.PAUSE_SCREEN);
      this.handleResume$();
      this.handleReplayLevel$();
    };
  };
  var GameScene_default = GameScene;

  // src/game/scenes/game-scene/index.ts
  var game_scene_default = GameScene_default;

  // src/game/screens/common/ResultPopup.ts
  init_phaser_custom_min();

  // src/game/animations/attention/ShakeVertical.ts
  init_phaser_custom_min();
  var SHAKE_EASE_OUT_HORIZONTAL = {
    repeat: 3,
    duration: 33,
    ease: Phaser.Math.Easing.Linear,
    props: {
      y: 5
    },
    yoyo: true
  };
  var ShakeVerticalAnimation = class {
    targetY;
    shakeAmount;
    tween;
    /**
     * shake half side down the target position
     */
    constructor(scene, targets, strictConfig) {
      const { endY, amount: amountOverride } = strictConfig;
      const y = amountOverride ? endY + amountOverride : endY + SHAKE_EASE_OUT_HORIZONTAL.props.y;
      const props = {
        ...SHAKE_EASE_OUT_HORIZONTAL.props,
        y
      };
      const config = {
        ...SHAKE_EASE_OUT_HORIZONTAL,
        targets,
        props,
        onRepeat: this.handleSwitchPosition,
        onRepeatScope: this
      };
      this.tween = scene.tweens.create(config);
      this.targetY = endY;
      this.shakeAmount = y - this.targetY;
    }
    handleSwitchPosition() {
      this.shakeAmount *= -0.7;
      this.tween.updateTo("y", this.targetY + this.shakeAmount);
    }
  };
  var ShakeVertical_default = ShakeVerticalAnimation;

  // src/game/effects/StarParticle.ts
  init_phaser_custom_min();
  var { KEY: KEY69, FRAME: FRAME77 } = sprites_default.EFFECTS;
  var { Object: O13 } = Ludex.Utils;
  var StarParticle = class extends Phaser.GameObjects.Container {
    emitter;
    emitZone;
    constructor(scene, config) {
      super(scene);
      this.createEmitZone();
      this.setDepth(depth_default.ON_TOP);
      this.createExplodeAnimation(config);
      this.scene.add.existing(this);
    }
    createEmitZone() {
      this.emitZone = new Phaser.Geom.Circle(0, 0, 25);
    }
    createExplodeAnimation(override) {
      const zoomRatio = WorldUtils_default.getZoomRatio();
      let config = {
        frame: [`${FRAME77.ANIMATION_STAR_X}1`],
        active: false,
        scale: {
          start: 1.5 / zoomRatio,
          end: 2 / zoomRatio,
          random: true
        },
        lifespan: { min: 600, max: 1200 },
        alpha: { start: 0.5, end: 1 },
        speed: { min: 50, max: 60 },
        rotate: {
          start: 0,
          end: 360
        },
        tint: [16777215, 16776960, 16750848],
        emitZone: {
          source: this.emitZone,
          type: "random"
        },
        particleClass: StarParticleClass
      };
      if (override) {
        config = O13.merge(config, override);
      }
      this.emitter = this.scene.add.particles(0, 0, KEY69, config);
      this.add(this.emitter);
    }
    explode(count, x, y) {
      this.emitter.active = true;
      return this.emitter.explode(count, x, y);
    }
  };
  var StarParticleClass = class extends Phaser.GameObjects.Particles.Particle {
    constructor(emitter) {
      super(emitter);
      const randomMaxScale = Math.random() * 0.18 + 0.01;
      this.data = {
        tint: { min: 16777215, max: 16777215 },
        alpha: { min: 1, max: 1 },
        rotate: { min: 0, max: 0 },
        scaleX: { min: 1, max: randomMaxScale },
        scaleY: { min: 1, max: 1 }
      };
    }
    fire(x, y) {
      let _x = x ?? 0;
      let _y2 = y ?? 0;
      super.fire(_x, _y2);
      const { x: eX2, y: eY } = this.emitter;
      if (!x) {
        _x = eX2;
      }
      if (!y) {
        _y2 = eY;
      }
      const speed = Phaser.Math.Distance.Between(0, 0, this.velocityX, this.velocityY);
      const angle = Math.atan2(this.y - _y2, this.x - _x);
      this.velocityX = speed * Math.cos(angle);
      this.velocityY = speed * Math.sin(angle);
      this.rotation = angle;
      return true;
    }
    update(delta, step, processors) {
      const res = super.update(delta, step, processors);
      return res;
    }
  };
  var StarParticle_default = StarParticle;

  // src/game/effects/TreasureTwinkle.ts
  init_phaser_custom_min();
  var { KEY: KEY70, FRAME: FRAME78 } = sprites_default.EFFECTS;
  var { Object: O14 } = Ludex.Utils;
  var TreasureTwinkle = class extends Phaser.GameObjects.Container {
    config;
    emitZone;
    emitter;
    constructor(scene, config) {
      super(scene);
      this.config = config || {};
      this.createEmitZone();
      this.createEmitters();
      this.scene.add.existing(this);
    }
    createEmitZone() {
      this.emitZone = new Phaser.Geom.Rectangle();
    }
    createEmitters() {
      const config = {
        frame: FRAME78.FX_STAR_YELLOW,
        emitZone: {
          source: this.emitZone,
          type: "random"
        },
        timeScale: 1,
        frequency: 150,
        // maxParticles: 30,
        speedY: { min: -20, max: -60 },
        alpha: { start: 1, end: 0, ease: Phaser.Math.Easing.Cubic.Out },
        scale: { start: 1, end: 0, ease: Phaser.Math.Easing.Cubic.Out },
        lifespan: { min: 1500, max: 2500 }
      };
      const newConfig = { ...config, ...this.config };
      this.emitter = this.scene.add.particles(0, 0, KEY70, newConfig);
      this.add(this.emitter);
    }
    run(count, x, y, width, height) {
      this.stop();
      this.emitZone.setSize(width, height);
      this.emitZone.setPosition(x - width / 2, y - height / 2);
      this.emitter.setQuantity(count);
      this.emitter.start();
    }
    stop() {
      this.emitter?.killAll();
      this.emitter?.stop();
    }
    explode() {
      this.emitter.explode(100, 0, 0);
    }
  };
  var TreasureTwinkle_default = TreasureTwinkle;

  // src/game/screens/common/GreenButton.ts
  init_phaser_custom_min();
  var { KEY: KEY71, FRAME: FRAME79 } = sprites_default.DEFAULT;
  var GreenButton = class extends HighlightButton {
    text1;
    icon;
    x2;
    text2;
    constructor(scene, key, frame) {
      super(scene, key, frame);
      this.createAdsICon();
      this.createTexts();
    }
    createAdsICon() {
      const icon = this.scene.make.image({
        key: KEY71,
        frame: FRAME79.ICON_ADS
      });
      icon.setPosition(-60, 0);
      this.content.add(icon);
      this.icon = icon;
    }
    createTexts() {
      const text = FontUtils_default.createText(this.scene, "Get", 22);
      FontUtils_default.applyGreenStyle(text);
      text.setX(-7);
      this.content.add(text);
      this.text1 = text;
      const x2 = this.scene.make.image({
        key: KEY71,
        frame: FRAME79.X2
      });
      x2.setWorldSize(40, 25);
      x2.setPosition(50, 0);
      this.content.add(x2);
      this.x2 = x2;
      const text2 = FontUtils_default.createText(this.scene, "CONTINUE", 20);
      FontUtils_default.applyGreenStyle(text2);
      this.content.add(text2);
      this.text2 = text2;
    }
    setMode(mode) {
      if (mode === "item") {
        this.text1.revive();
        this.icon.revive();
        this.x2.revive();
        this.text2.kill();
      } else {
        this.text1.kill();
        this.icon.kill();
        this.x2.kill();
        this.text2.revive();
      }
    }
  };
  var GreenButton_default = GreenButton;

  // src/game/effects/PaperFireworksCelebration.ts
  init_phaser_custom_min();

  // src/game/animations/frames/RibbonA.ts
  init_phaser_custom_min();

  // src/game/constants/animation.ts
  init_phaser_custom_min();
  var { KEY: KEY72, FRAME: FRAME80 } = sprites_default.EFFECTS;
  var ANIMATIONS2 = {
    CONFETTI_HEXAGON: {
      KEY: "confetti-hexagon-animation",
      TEXTURE: KEY72,
      PREFIX: FRAME80.FX_CONFETTI_HEXAGON,
      FRAME_RATE: 8,
      END: 5,
      ZERO_PAD: 0
    },
    CONFETTI_STAR_X: {
      KEY: "confetti-star-x",
      TEXTURE: KEY72,
      PREFIX: FRAME80.ANIMATION_STAR_X,
      FRAME_RATE: 4,
      END: 4,
      ZERO_PAD: 0
    },
    CONFETTI_STAR_Y: {
      KEY: "confetti-star-y",
      TEXTURE: KEY72,
      PREFIX: FRAME80.ANIMATION_STAR_Y,
      FRAME_RATE: 4,
      END: 4,
      ZERO_PAD: 0
    },
    RIBBON_A: {
      KEY: "animation-ribbon-a",
      TEXTURE: KEY72,
      PREFIX: FRAME80.PREFIX_ANIMATION_RIBBON_CONFETTI_A,
      FRAME_RATE: 16,
      END: 3,
      ZERO_PAD: 0
    },
    RIBBON_B: {
      KEY: "animation-ribbon-b",
      TEXTURE: KEY72,
      PREFIX: FRAME80.PREFIX_ANIMATION_RIBBON_CONFETTI_B,
      FRAME_RATE: 16,
      END: 4,
      ZERO_PAD: 0
    },
    RIBBON_C: {
      KEY: "animation-ribbon-c",
      TEXTURE: KEY72,
      PREFIX: FRAME80.PREFIX_ANIMATION_RIBBON_CONFETTI_C,
      FRAME_RATE: 16,
      END: 4,
      ZERO_PAD: 0
    },
    RIBBON_D: {
      KEY: "animation-ribbon-d",
      TEXTURE: KEY72,
      PREFIX: FRAME80.PREFIX_ANIMATION_RIBBON_CONFETTI_D,
      FRAME_RATE: 16,
      END: 4,
      ZERO_PAD: 0
    }
  };
  var animation_default2 = ANIMATIONS2;

  // src/game/animations/frames/RibbonA.ts
  var { KEY: KEY73, TEXTURE: TEXTURE7, FRAME_RATE: FRAME_RATE7, END: END7, PREFIX: PREFIX7, ZERO_PAD: ZERO_PAD7 } = animation_default2.
  RIBBON_A;
  var RibbonAAnimation = class extends Phaser.Animations.Animation {
    constructor(manager) {
      const animationConfig = {
        repeat: -1,
        frameRate: FRAME_RATE7,
        frames: manager.generateFrameNames(TEXTURE7, {
          prefix: PREFIX7,
          end: END7,
          zeroPad: ZERO_PAD7,
          start: 1
        }),
        yoyo: true,
        showOnStart: true
      };
      super(manager, KEY73, animationConfig);
    }
  };
  var RibbonA_default = RibbonAAnimation;

  // src/game/animations/frames/RibbonB.ts
  init_phaser_custom_min();
  var { KEY: KEY74, TEXTURE: TEXTURE8, FRAME_RATE: FRAME_RATE8, END: END8, PREFIX: PREFIX8, ZERO_PAD: ZERO_PAD8 } = animation_default2.
  RIBBON_B;
  var RibbonBAnimation = class extends Phaser.Animations.Animation {
    constructor(manager) {
      const animationConfig = {
        repeat: -1,
        frameRate: FRAME_RATE8,
        frames: manager.generateFrameNames(TEXTURE8, {
          prefix: PREFIX8,
          end: END8,
          zeroPad: ZERO_PAD8,
          start: 1
        }),
        yoyo: true,
        showOnStart: true
      };
      super(manager, KEY74, animationConfig);
    }
  };
  var RibbonB_default = RibbonBAnimation;

  // src/game/animations/frames/RibbonC.ts
  init_phaser_custom_min();
  var { KEY: KEY75, TEXTURE: TEXTURE9, FRAME_RATE: FRAME_RATE9, END: END9, PREFIX: PREFIX9, ZERO_PAD: ZERO_PAD9 } = animation_default2.
  RIBBON_C;
  var RibbonCAnimation = class extends Phaser.Animations.Animation {
    constructor(manager) {
      const animationConfig = {
        repeat: -1,
        frameRate: FRAME_RATE9,
        frames: manager.generateFrameNames(TEXTURE9, {
          prefix: PREFIX9,
          end: END9,
          zeroPad: ZERO_PAD9,
          start: 1
        }),
        yoyo: true,
        showOnStart: true
      };
      super(manager, KEY75, animationConfig);
    }
  };
  var RibbonC_default = RibbonCAnimation;

  // src/game/animations/frames/RibbonD.ts
  init_phaser_custom_min();
  var { KEY: KEY76, TEXTURE: TEXTURE10, FRAME_RATE: FRAME_RATE10, END: END10, PREFIX: PREFIX10, ZERO_PAD: ZERO_PAD10 } = animation_default2.
  RIBBON_D;
  var RibbonDAnimation = class extends Phaser.Animations.Animation {
    constructor(manager) {
      const animationConfig = {
        repeat: -1,
        frameRate: FRAME_RATE10,
        frames: manager.generateFrameNames(TEXTURE10, {
          prefix: PREFIX10,
          end: END10,
          zeroPad: ZERO_PAD10,
          start: 1
        }),
        yoyo: true,
        showOnStart: true
      };
      super(manager, KEY76, animationConfig);
    }
  };
  var RibbonD_default = RibbonDAnimation;

  // src/game/animations/frames/StarRotateX.ts
  init_phaser_custom_min();
  var { KEY: KEY77, TEXTURE: TEXTURE11, FRAME_RATE: FRAME_RATE11, END: END11, PREFIX: PREFIX11, ZERO_PAD: ZERO_PAD11 } = animation_default2.
  CONFETTI_STAR_X;
  var StarRotateXAnimation = class extends Phaser.Animations.Animation {
    constructor(manager) {
      const animationConfig = {
        repeat: -1,
        frameRate: FRAME_RATE11,
        frames: manager.generateFrameNames(TEXTURE11, {
          prefix: PREFIX11,
          end: END11,
          zeroPad: ZERO_PAD11,
          start: 1
        }),
        yoyo: true,
        showOnStart: true
      };
      super(manager, KEY77, animationConfig);
    }
  };
  var StarRotateX_default = StarRotateXAnimation;

  // src/game/animations/frames/StarRotateY.ts
  init_phaser_custom_min();
  var { KEY: KEY78, TEXTURE: TEXTURE12, FRAME_RATE: FRAME_RATE12, END: END12, PREFIX: PREFIX12, ZERO_PAD: ZERO_PAD12 } = animation_default2.
  CONFETTI_STAR_Y;
  var StarRotateYAnimation = class extends Phaser.Animations.Animation {
    constructor(manager) {
      const animationConfig = {
        repeat: -1,
        frameRate: FRAME_RATE12,
        frames: manager.generateFrameNames(TEXTURE12, {
          prefix: PREFIX12,
          end: END12,
          zeroPad: ZERO_PAD12,
          start: 1
        }),
        showOnStart: true
      };
      super(manager, KEY78, animationConfig);
    }
  };
  var StarRotateY_default = StarRotateYAnimation;

  // src/game/effects/particle/RibbonGraphicsParticle.ts
  init_phaser_custom_min();
  var RibbonGraphicsParticle = class extends Phaser.GameObjects.Particles.Particle {
    ribbon;
    graphics;
    colorUse;
    lastChange;
    currentFrame;
    isYoyo;
    isGravityChanged;
    points;
    constructor(emitter) {
      super(emitter);
      const { x, y } = this.emitter;
      this.points = new Array(10).fill(null).map(() => ({ x: this.x + x, y: this.y + y }));
      this.isYoyo = false;
      this.isGravityChanged = false;
      this.lastChange = 0;
      this.currentFrame = -1;
      this.createGraphics();
      this.randomRibbonUsedWhenFall();
    }
    randomRibbonUsedWhenFall() {
      const choice = Phaser.Math.Between(0, 3);
      switch (choice) {
        case 0:
          this.ribbon = this.scene.anims.get(animation_default2.RIBBON_A.KEY);
          break;
        case 1:
          this.ribbon = this.scene.anims.get(animation_default2.RIBBON_B.KEY);
          break;
        case 2:
          this.ribbon = this.scene.anims.get(animation_default2.RIBBON_C.KEY);
          break;
        case 3:
          this.ribbon = this.scene.anims.get(animation_default2.RIBBON_D.KEY);
          break;
        default:
          this.ribbon = this.scene.anims.get(animation_default2.RIBBON_A.KEY);
          break;
      }
    }
    setRibbonPosition(x, y) {
      this.points.map((point) => {
        point.x = x;
        point.y = y;
      });
    }
    createGraphics() {
      const tint = [8443204, 2928867, 12013036, 16376097, 15285798];
      this.colorUse = tint[Phaser.Math.Between(0, tint.length - 1)];
      this.graphics = this.scene.add.graphics({
        lineStyle: { width: 3, color: this.colorUse }
      });
      const { x, y, depth } = this.emitter;
      this.graphics.setDepth(depth);
      this.graphics.setPosition(x, y);
      this.emitter.parentContainer.add(this.graphics);
    }
    update(delta, step, processors) {
      const result = super.update(delta, step, processors);
      this.updateFrames(delta);
      this.updatePoints();
      this.updateGraphics();
      this.updateGravity();
      this.updateVelocity();
      this.updateColor();
      return result;
    }
    updateFrames(delta) {
      this.lastChange += delta;
      if (this.lastChange >= this.ribbon.msPerFrame) {
        if (this.isYoyo) {
          this.currentFrame--;
        } else {
          this.currentFrame++;
        }
        if (this.currentFrame < 0) {
          this.isYoyo = false;
          this.currentFrame = 1;
        }
        if (this.currentFrame >= this.ribbon.frames.length) {
          this.isYoyo = true;
          this.currentFrame -= 1;
        }
        this.frame = this.ribbon.frames[this.currentFrame].frame;
        this.lastChange -= this.ribbon.msPerFrame;
      }
    }
    updatePoints() {
      if (!this.graphics.visible) return;
      this.points.shift();
      this.points.push({ x: this.x, y: this.y });
    }
    updateGraphics() {
      if (!this.graphics.visible) return;
      this.graphics.clear();
      this.graphics.strokePoints(this.points);
    }
    updateGravity() {
      if (this.lifeCurrent > this.life - 2e3 || this.isGravityChanged) return;
      this.isGravityChanged = true;
      this.graphics.destroy();
      this.emitter.setVisible(true);
      this.emitter.setParticleGravity(0, 45);
    }
    updateVelocity() {
      if (!this.graphics.visible) return;
      if (this.lifeCurrent > this.life - 1800) {
        this.velocityX += Phaser.Math.Between(-12, 12);
        return;
      }
      if (this.velocityX > 0) {
        this.velocityX += Phaser.Math.Between(-10, 6);
      } else {
        this.velocityX += Phaser.Math.Between(-6, 10);
      }
    }
    updateColor() {
      if (this.graphics.visible) return;
      this.tint = this.colorUse;
    }
  };
  var RibbonGraphicsParticle_default = RibbonGraphicsParticle;

  // src/game/effects/particle/StarConfettiParticle.ts
  init_phaser_custom_min();
  var StarConfettiParticle = class extends Phaser.GameObjects.Particles.Particle {
    isYoyo;
    isGravityChanged;
    lastChange;
    currentFrame;
    star;
    starX;
    starY;
    constructor(emitter) {
      super(emitter);
      this.isYoyo = false;
      this.isGravityChanged = false;
      this.lastChange = 0;
      this.currentFrame = -1;
      this.starX = this.scene.anims.get(animation_default2.CONFETTI_STAR_X.KEY);
      this.starY = this.scene.anims.get(animation_default2.CONFETTI_STAR_Y.KEY);
      this.star = this.starX;
    }
    update(delta, step, processors) {
      const result = super.update(delta, step, processors);
      this.updateGravity();
      this.updateVelocity();
      this.updateFrameRate();
      this.updateFrames(delta);
      return result;
    }
    updateGravity() {
      if (this.lifeCurrent > this.life - 2e3 || this.isGravityChanged) return;
      this.isGravityChanged = true;
      this.emitter.setParticleGravity(0, 15);
      this.emitter.setParticleSpeed(0);
    }
    updateVelocity() {
      if (this.lifeCurrent > this.life - 2e3) return;
      if (this.velocityX > 0) {
        this.velocityX += Phaser.Math.Between(-6, 3);
      } else {
        this.velocityX += Phaser.Math.Between(-3, 6);
      }
    }
    updateFrames(delta) {
      this.lastChange += delta;
      if (this.lastChange >= this.star.msPerFrame) {
        const rand = Phaser.Math.RND.between(0, 1);
        this.star = rand > 0 ? this.starX : this.starY;
        if (this.isYoyo) {
          this.currentFrame--;
        } else {
          this.currentFrame++;
        }
        if (this.currentFrame < 0) {
          this.isYoyo = false;
          this.currentFrame = 1;
          this.emitter.setAlpha(1);
        }
        if (this.currentFrame >= this.star.frames.length) {
          this.isYoyo = true;
          this.currentFrame -= 1;
          this.emitter.setAlpha(0.8);
        }
        this.frame = this.star.frames[this.currentFrame].frame;
        this.lastChange -= this.star.msPerFrame;
      }
    }
    updateFrameRate() {
      if (this.lifeCurrent < this.life - 2e3) {
        this.star.msPerFrame = 150;
      } else {
        this.star.msPerFrame = Phaser.Math.RND.between(300, 600);
      }
    }
  };
  var StarConfettiParticle_default = StarConfettiParticle;

  // src/game/effects/PaperFireworksCelebration.ts
  var { KEY: KEY79, FRAME: FRAME81 } = sprites_default.EFFECTS;
  var PaperFireworksCelebration = class extends Phaser.GameObjects.Container {
    emitterConfetti;
    emitterRibbons;
    ribbonConfig;
    confettiConfig;
    constructor(scene) {
      super(scene);
      this.emitterRibbons = [];
      this.emitterConfetti = [];
      this.createConfigs();
      this.createAnimations();
      this.scene.add.existing(this);
    }
    createConfigs() {
      const colors = [8443204, 2928867, 12013036, 16376097, 15285798];
      this.ribbonConfig = {
        duration: 100,
        visible: false,
        timeScale: 1.5,
        frame: FRAME81.BLANK,
        // use Particle class frame
        particleBringToTop: true,
        speedY: {
          min: -480,
          max: -560
        },
        gravityY: 290,
        // tint: colors,    // use Particle class colors
        lifespan: { min: 4e3, max: 6e3 },
        rotate: { start: 0, end: 360 * 5, random: true },
        scale: { min: 0.6, max: 1 },
        particleClass: RibbonGraphicsParticle_default
      };
      const frame = FRAME81.PREFIX_ANIMATION_RIBBON_CONFETTI_A;
      this.confettiConfig = {
        duration: 100,
        delay: 200,
        timeScale: 2,
        tint: colors,
        particleBringToTop: true,
        frame: `${frame}1`,
        speedY: {
          min: -460,
          max: -580
        },
        gravityY: 280,
        lifespan: { min: 5e3, max: 8e3 },
        rotate: { start: 0, end: 360 * 3 },
        scale: { min: 0.6, max: 1 },
        particleClass: StarConfettiParticle_default
      };
    }
    createAnimations() {
      if (!this.scene.anims.get(animation_default2.CONFETTI_STAR_X.KEY)) {
        const anim = new StarRotateX_default(this.scene.anims);
        this.scene.anims.add(animation_default2.CONFETTI_STAR_X.KEY, anim);
      }
      if (!this.scene.anims.get(animation_default2.CONFETTI_STAR_Y.KEY)) {
        const anim = new StarRotateY_default(this.scene.anims);
        this.scene.anims.add(animation_default2.CONFETTI_STAR_Y.KEY, anim);
      }
      if (!this.scene.anims.get(animation_default2.RIBBON_A.KEY)) {
        const anim = new RibbonA_default(this.scene.anims);
        this.scene.anims.add(animation_default2.RIBBON_A.KEY, anim);
      }
      if (!this.scene.anims.get(animation_default2.RIBBON_B.KEY)) {
        const anim = new RibbonB_default(this.scene.anims);
        this.scene.anims.add(animation_default2.RIBBON_B.KEY, anim);
      }
      if (!this.scene.anims.get(animation_default2.RIBBON_C.KEY)) {
        const anim = new RibbonC_default(this.scene.anims);
        this.scene.anims.add(animation_default2.RIBBON_C.KEY, anim);
      }
      if (!this.scene.anims.get(animation_default2.RIBBON_D.KEY)) {
        const anim = new RibbonD_default(this.scene.anims);
        this.scene.anims.add(animation_default2.RIBBON_D.KEY, anim);
      }
    }
    run(x, y, width, height) {
      this.setPosition(x, y);
      this.width = width;
      this.height = height;
      this.createEmitters();
      for (const emitter of this.emitterConfetti) {
        emitter.emitParticle(25);
      }
      for (const emitter of this.emitterRibbons) {
        emitter.emitParticle(20);
      }
    }
    stop() {
      for (const emitter of this.emitterConfetti) {
        emitter.killAll();
      }
      for (const emitter of this.emitterRibbons) {
        emitter.killAll();
      }
      this.kill();
    }
    createEmitters() {
      this.emitterRibbons = [];
      this.emitterConfetti = [];
      this.createConfettiLeftEmitter();
      this.createConfettiRightEmitter();
      this.createRibbonLeftEmitter();
      this.createRibbonRightEmitter();
    }
    createConfettiLeftEmitter() {
      const { height } = this;
      const speedModifierY = height / 667 * 1.1;
      const config = {
        ...this.confettiConfig,
        speedX: {
          min: 5,
          max: 90
        },
        speedY: {
          min: -460 * speedModifierY,
          max: -580 * speedModifierY
        },
        gravityY: 280 * speedModifierY
      };
      const emitter = this.scene.add.particles(0, 0, KEY79, config);
      this.add(emitter);
      this.emitterConfetti.push(emitter);
    }
    createConfettiRightEmitter() {
      const { width, height } = this;
      const speedModifierY = height / 667 * 1.1;
      const config = {
        ...this.confettiConfig,
        speedX: {
          min: -5,
          max: -90
        },
        speedY: {
          min: -460 * speedModifierY,
          max: -580 * speedModifierY
        },
        gravityY: 280 * speedModifierY
      };
      const emitter = this.scene.add.particles(width, 0, KEY79, config);
      this.add(emitter);
      this.emitterConfetti.push(emitter);
    }
    createRibbonLeftEmitter() {
      const { height } = this;
      const speedModifierY = height / 667 * 1.1;
      const config = {
        ...this.ribbonConfig,
        speedX: {
          min: 20,
          max: 80
        },
        speedY: {
          min: -480 * speedModifierY,
          max: -560 * speedModifierY
        },
        gravityY: 290 * speedModifierY
      };
      const emitter = this.scene.add.particles(0, 0, KEY79, config);
      this.add(emitter);
      this.emitterRibbons.push(emitter);
    }
    createRibbonRightEmitter() {
      const { width, height } = this;
      const speedModifierY = height / 667 * 1.1;
      const config = {
        ...this.ribbonConfig,
        speedX: {
          min: -20,
          max: -80
        },
        speedY: {
          min: -480 * speedModifierY,
          max: -560 * speedModifierY
        },
        gravityY: 290 * speedModifierY
      };
      const emitter = this.scene.add.particles(width, 0, KEY79, config);
      this.add(emitter);
      this.emitterRibbons.push(emitter);
    }
  };
  var PaperFireworksCelebration_default = PaperFireworksCelebration;

  // src/game/screens/common/ResultPopup.ts
  var { KEY: KEY80, FRAME: FRAME82 } = sprites_default.DEFAULT;
  var { KEY: GAME_KEY, FRAME: GAME_FRAME } = sprites_default.GAMEPLAY;
  var ResultPopup = class extends Phaser.GameObjects.Container {
    popup$;
    ribbon$;
    listStars$ = [];
    levelStars$ = 0;
    levelText$;
    button;
    getContinueBtn$;
    itemContainer$;
    itemIcon$;
    currentItem$;
    bigGlow$;
    bigGlowTween$;
    glow$;
    glowTween$;
    onGreenClick;
    onGetContinueClick;
    confettiAnimation$;
    starsParticle$ = [];
    listTimeLine$ = [];
    twinkle$;
    constructor(scene) {
      super(scene);
      this.createPopup$();
      this.updateSize$();
      this.createRibbon$();
      this.createBigGlow$();
      this.createStarsParticle$();
      this.createStars$();
      this.createLevelText$();
      this.createWinText$();
      this.createButton$();
      this.createItem$();
      this.createGetContinueBtn$();
      this.createEffect$();
      this.setDepth(depth_default.POPUP);
      this.scene.add.existing(this);
    }
    createEffect$() {
      this.confettiAnimation$ = new PaperFireworksCelebration_default(this.scene);
      this.confettiAnimation$.setDepth(depth_default.ON_TOP);
      this.add(this.confettiAnimation$);
      this.twinkle$ = new TreasureTwinkle_default(this.scene, {
        scale: { start: 0.5, end: 0, ease: Phaser.Math.Easing.Cubic.Out }
      });
      this.twinkle$.setDepth(depth_default.EFFECT);
      this.add(this.twinkle$);
    }
    createStarsParticle$() {
      for (let i = 0; i < 3; i++) {
        const starParticle = new StarParticle_default(this.scene);
        this.starsParticle$.push(starParticle);
      }
      this.add(this.starsParticle$);
    }
    createPopup$() {
      this.popup$ = this.scene.make.image({
        key: KEY80,
        frame: FRAME82.POPUP
      });
      this.add(this.popup$);
    }
    createRibbon$() {
      const ribbon = this.scene.make.image({
        key: KEY80,
        frame: FRAME82.RESULT_RIBBON
      });
      ribbon.setPosition(0, -40);
      this.add(ribbon);
      this.ribbon$ = ribbon;
    }
    createBigGlow$() {
      const glow = this.scene.make.image({
        key: KEY80,
        frame: FRAME82.ART_WHITE_GLOW
      });
      glow.setScale(glow.scale * 2);
      glow.setPosition(0, -70);
      this.add(glow);
      this.bigGlow$ = glow;
      glow.kill();
    }
    createStars$() {
      const star1 = this.scene.make.image({
        key: KEY80,
        frame: FRAME82.RESULT_STAR
      });
      star1.setPosition(-85, -60);
      star1.setAngle(-12);
      this.listStars$.push(star1);
      const star2 = this.scene.make.image({
        key: KEY80,
        frame: FRAME82.RESULT_STAR
      });
      star2.setPosition(0, -70);
      star2.setAngle(0);
      this.listStars$.push(star2);
      const star3 = this.scene.make.image({
        key: KEY80,
        frame: FRAME82.RESULT_STAR
      });
      star3.setPosition(85, -60);
      star3.setAngle(12);
      this.listStars$.push(star3);
      this.add([star1, star3, star2]);
    }
    updateSize$() {
      const { width, height } = this.popup$;
      this.setSize(width, height);
    }
    createLevelText$() {
      this.levelText$ = FontUtils_default.createText(this.scene, "Level 1", 20);
      FontUtils_default.applyWarningStyle(this.levelText$);
      this.add(this.levelText$);
    }
    createWinText$() {
      const winText = this.scene.make.image({
        key: KEY80,
        frame: FRAME82.VICTORY
      });
      winText.setPosition(0, -152);
      this.add(winText);
    }
    createButton$() {
      this.button = new GreenButton_default(this.scene, KEY80, FRAME82.BUTTON_GREEN);
      this.button.onClick = this.handleOnGreenBtnClick$;
      const buttonBg = this.scene.make.image({
        key: KEY80,
        frame: FRAME82.BUTTON_FRAME
      });
      this.button.add(buttonBg);
      this.button.moveTo(buttonBg, 0);
      this.add(this.button);
      Phaser.Display.Align.In.BottomCenter(this.button, this.popup$, 0, -30);
    }
    createItem$() {
      this.itemContainer$ = this.scene.make.container({});
      this.add(this.itemContainer$);
      this.itemContainer$.setPosition(0, 50);
      const glow = this.scene.make.image({
        key: KEY80,
        frame: FRAME82.ART_WHITE_GLOW
      });
      glow.setPosition(-15, 0);
      this.itemContainer$.add(glow);
      this.glow$ = glow;
      const item = this.scene.make.image({
        key: GAME_KEY,
        frame: GAME_FRAME.BLANK
      });
      item.setPosition(-17, 0);
      this.itemContainer$.add(item);
      this.itemIcon$ = item;
      const text = FontUtils_default.createStrokeText(this.scene, "+1", 22);
      text.setOrigin(0.5, 0.57);
      text.setPosition(17, 0);
      this.itemContainer$.add(text);
    }
    createGetContinueBtn$() {
      this.getContinueBtn$ = new TextButton_default(this.scene, "Get & Continue", 16);
      this.getContinueBtn$.setAlpha(0.8);
      this.getContinueBtn$.onClick = this.handleOnGetContinueBtnClick$;
      this.getContinueBtn$.kill();
      Phaser.Display.Align.In.BottomCenter(this.getContinueBtn$, this.popup$, 0, 40);
      this.add(this.getContinueBtn$);
    }
    setLevel(level, type = "normal") {
      this.levelText$.setText(`Level ${level}`);
      if (type === "mini") {
        this.levelText$.setPosition(0, -5);
      } else {
        this.levelText$.setPosition(0, 40);
      }
    }
    setStars(stars) {
      this.levelStars$ = stars;
    }
    setItem(item) {
      if (this.currentItem$ === item) return;
      this.currentItem$ = item;
      switch (item) {
        case "defuse":
          this.itemIcon$.setFrame(GAME_FRAME.DEFUSE_ITEM);
          break;
        case "hint":
          this.itemIcon$.setFrame(GAME_FRAME.HINT_ITEM);
          break;
        case "shuffle":
          this.itemIcon$.setFrame(GAME_FRAME.ITEM_SHUFFLE);
          break;
        case "rocket":
          this.itemIcon$.setFrame(GAME_FRAME.ROCKET_ITEM);
          break;
        case "none":
          this.itemContainer$.kill();
      }
      if (item !== "none") {
        this.button.setMode("item");
      } else {
        this.button.setMode("continue");
      }
    }
    handleOnGreenBtnClick$ = () => {
      if (this.onGreenClick) {
        this.onGreenClick();
      }
    };
    handleOnGetContinueBtnClick$ = () => {
      if (this.onGetContinueClick) {
        this.onGetContinueClick();
      }
    };
    playAnimation(delay = 0) {
      this.playShowUpAnimation$(delay);
    }
    playShowUpAnimation$(delay) {
      for (const timeline of this.listTimeLine$) {
        timeline.stop();
      }
      this.listTimeLine$ = [];
      this.bigGlow$.kill();
      this.twinkle$.stop();
      const winDuration = delay;
      this.listStars$.forEach((star, index) => {
        if (index >= this.levelStars$) {
          star.kill();
          return;
        }
        star.revive();
      });
      this.listStars$[0].setAngle(-10);
      this.listStars$[1].setAngle(0);
      this.listStars$[2].setAngle(10);
      const t1 = this.playStarAnimation$(this.listStars$[0], winDuration, 200, 400, 366, "-=10", "+=\
10");
      const t2 = this.playStarAnimation$(this.listStars$[1], winDuration + 166, 200, 233, 566, "+=0",
      "+=0");
      const t32 = this.playStarAnimation$(this.listStars$[2], winDuration + 333, 200, 100, 466, "+=1\
0", "-=10");
      this.listTimeLine$?.push(t1, t2, t32);
      this.scaleObject$(winDuration, 400, this.listStars$[0], 0.1, 1, Phaser.Math.Easing.Sine.In, () => {
        AudioUtils_default.playSound(soundEffects_default.PROGRESS_STAR, {
          volume: 0.7
        });
      });
      this.scaleObject$(winDuration + 166, 366, this.listStars$[1], 0.1, 1, Phaser.Math.Easing.Sine.
      In);
      this.scaleObject$(winDuration + 333, 200, this.listStars$[2], 0.1, 1, Phaser.Math.Easing.Sine.
      In);
      this.scaleObject$(
        winDuration + 400,
        400,
        this.listStars$[0],
        1,
        0.5,
        Phaser.Math.Easing.Cubic.In,
        void 0,
        () => {
          const { x, y } = this.listStars$[0];
          this.starsParticle$[0].explode(50, x, y);
        }
      );
      this.scaleObject$(
        winDuration + 533,
        266,
        [this.listStars$[1], this.listStars$[2]],
        1,
        0.5,
        Phaser.Math.Easing.Cubic.In,
        void 0,
        () => {
          const { x: x12, y: y12 } = this.listStars$[1];
          this.starsParticle$[1].explode(50, x12, y12);
          const { x: x2, y: y2 } = this.listStars$[2];
          this.starsParticle$[2].explode(50, x2, y2);
          const anims = new ShakeVertical_default(this.scene, [this.ribbon$], {
            endY: this.ribbon$.y,
            amount: 5
          });
          AnimUtils.runTween(anims.tween);
          this.runEffect3Stars$();
          AudioUtils_default.playSound(soundEffects_default.THREE_STARS, {
            volume: 0.5
          });
        }
      );
      this.scaleObject$(winDuration + 800, 166, this.listStars$, 0.5, 0.6, void 0, void 0, () => {
        AudioUtils_default.playSound(soundEffects_default.LEVEL_COMPLETE, {
          volume: 0.8
        });
      });
      const starsDuration = 800 + 166;
      const targets = [this.levelText$];
      const isItemRewarded = this.currentItem$ !== "none";
      const tweens = [
        {
          targets,
          delay: starsDuration + winDuration,
          duration: 800,
          props: {
            scale: {
              // @ts-expect-error - pass
              start: 0,
              to: 1,
              ease: Phaser.Math.Easing.Elastic.Out
            }
          },
          easeParams: [0.1, 0.45]
        }
      ];
      if (isItemRewarded) {
        this.getContinueBtn$.revive();
        this.itemContainer$.revive();
        this.glow$.kill();
        tweens.push({
          targets: this.itemContainer$,
          duration: 800,
          props: {
            scale: {
              // @ts-expect-error - pass
              start: 0,
              to: 1,
              ease: Phaser.Math.Easing.Elastic.Out
            }
          },
          easeParams: [0.1, 0.45],
          onStart: () => {
            AudioUtils_default.playSound(soundEffects_default.HINT_ITEM, { volume: 1.5 });
          }
        });
      } else {
        this.getContinueBtn$.kill();
        this.itemContainer$.kill();
      }
      tweens.push({
        targets: [this.button],
        duration: 800,
        props: {
          scale: {
            // @ts-expect-error - pass
            start: 0,
            to: 1,
            ease: Phaser.Math.Easing.Elastic.Out
          }
        },
        easeParams: [0.1, 0.45],
        onComplete: () => {
          this.runContinueButtonAnimation();
        }
      });
      if (isItemRewarded) {
        const getContinueTween = this.scene.tweens.add({
          targets: this.getContinueBtn$,
          // ? 1600 is the duration of the item animation
          delay: starsDuration + winDuration + 1600,
          duration: 300,
          props: {
            scale: {
              start: 0,
              to: 1
            }
          }
        });
        this.listTimeLine$.push(getContinueTween);
        getContinueTween.play();
      }
      const chain = this.scene.tweens.chain({ targets, tweens });
      chain.play();
      this.listTimeLine$.push(chain);
    }
    scaleObject$(delay, duration, targets, from, to, ease, onStart, onComplete) {
      this.scene.tweens.add({
        targets,
        duration,
        delay,
        props: {
          scale: { start: from, to }
        },
        ease,
        onStart,
        onComplete
      });
    }
    playStarAnimation$(target, delay, phase1Duration, phase2Duration, phase3Delay, phase3Angle, phase4Angle) {
      const star1Angle = this.scene.tweens.chain({
        targets: target,
        tweens: [
          {
            delay,
            duration: phase1Duration,
            props: {
              angle: "-=15"
            }
          },
          {
            delay: phase2Duration,
            duration: phase2Duration,
            props: {
              angle: "+=15"
            }
          },
          {
            delay: phase3Delay,
            duration: 1300,
            props: {
              angle: phase3Angle,
              scale: "+=0.1"
            }
          },
          {
            targets: target,
            duration: 2333,
            props: {
              angle: phase4Angle,
              scale: "-=0.1"
            },
            yoyo: true,
            repeat: -1,
            ease: Phaser.Math.Easing.Sine.InOut
          }
        ]
      });
      star1Angle.play();
      return star1Angle;
    }
    runEffect3Stars$() {
      const scale = this.bigGlow$.scale;
      this.bigGlow$.revive();
      this.bigGlow$.setScale(0);
      this.scene.tweens.add({
        targets: this.bigGlow$,
        scale: {
          from: 0,
          to: scale
        },
        duration: 500,
        ease: Phaser.Math.Easing.Sine.Out
      });
      this.bigGlowTween$ = this.scene.tweens.add({
        targets: this.bigGlow$,
        rotation: {
          from: 0,
          to: Math.PI * 2
        },
        duration: 5e3,
        repeat: -1
      });
      this.twinkle$.run(2, this.x, this.y - 20, 300, 100);
      this.runConfetti$();
    }
    runConfetti$() {
      const { displayWidth, displayHeight } = this.scene.gameZone;
      this.confettiAnimation$.setVisible(true);
      this.confettiAnimation$.run(-displayWidth / 2, displayHeight / 2, displayWidth, displayHeight);
    }
    stopAnimation() {
      this.bigGlowTween$?.remove();
      this.glowTween$?.remove();
      this.twinkle$.stop();
      this.confettiAnimation$.setVisible(false);
      this.button.stopHighlightAnimation();
      this.button.setScale(1);
      for (const timeLine of this.listTimeLine$) {
        timeLine.stop();
      }
      this.listTimeLine$ = [];
    }
    runContinueButtonAnimation() {
      this.button.playHighlightAnimation();
    }
  };
  var ResultPopup_default = ResultPopup;

  // src/game/screens/ResultScreen.ts
  var { analytics: analytics18, event: event37 } = codex;
  var {
    Plugins: {
      Analytics: { Events: AnalyticsEvents15 }
    }
  } = Ludex;
  var { RewardItemResultPopupRatio, DefuseItemGuideLevel: DefuseItemGuideLevel5, RocketItemGuideLevel: RocketItemGuideLevel3 } = GameSettings_default;
  var ResultScreen = class extends Screen_default {
    popup$;
    item$ = "none";
    rewardAmount$;
    constructor(scene, name) {
      super(scene, name);
      this.createPopup$();
      this.setDepth(ScreenDepth_default.POPUP);
    }
    open = (data) => {
      super.open(data);
      this.updateData$();
      AudioUtils_default.setMinVolumeMusic();
      this.runOpenAnimation$();
    };
    updateData$() {
      const level = this.getData("level");
      const eatStars = this.getData("eatStars");
      const correctLevel = level ? level : 1;
      this.popup$.setStars(eatStars ? eatStars : 0);
      const itemWinRoll = Math.random();
      this.updateSuperRocketCountdown$();
      if (itemWinRoll > RewardItemResultPopupRatio) {
        this.item$ = "none";
        this.popup$.setItem("none");
        this.popup$.setLevel(correctLevel, "normal");
        return;
      }
      this.popup$.setLevel(correctLevel, "mini");
      const possibleItems = ["ItemHint", "ItemShuffle"];
      const popupItemCodes = ["hint", "shuffle"];
      let randomMaxValues = [0.54, 1];
      if (level >= DefuseItemGuideLevel5) {
        possibleItems.push("ItemBombDefuse");
        popupItemCodes.push("defuse");
        randomMaxValues = [0.4, 0.73, 1];
      }
      if (level >= RocketItemGuideLevel3) {
        possibleItems.push("ItemRocket");
        popupItemCodes.push("rocket");
        randomMaxValues = [0.29, 0.54, 0.74, 1];
      }
      const itemRoll = Math.random();
      const itemIndex = randomMaxValues.findIndex((value) => itemRoll <= value);
      const itemType = possibleItems[itemIndex];
      const popupItemCode = popupItemCodes[itemIndex];
      this.item$ = itemType;
      this.popup$.setItem(popupItemCode);
    }
    updateSuperRocketCountdown$() {
      const scene = SceneUtils_default.getCurrentScene();
      if (!(scene instanceof game_scene_default)) return;
      scene.isSuperRocketUsed = false;
      const { itemManager } = scene;
      itemManager.reduceSuperRocketCountdown();
    }
    createPopup$() {
      this.popup$ = new ResultPopup_default(this.scene);
      this.add(this.popup$);
      this.popup$.onGreenClick = this.handleGreenBtnClick$;
      this.popup$.onGetContinueClick = this.handleContinueLevel$;
      Phaser.Display.Align.In.Center(this.popup$, this.zone, 0, -50);
    }
    handleGreenBtnClick$ = async () => {
      if (this.item$ === "none") {
        this.handleContinueLevel$();
      } else {
        try {
          await this.handleShowRewardedVideoAd$();
        } catch (error) {
          console.log(error);
        }
      }
    };
    handleContinueLevel$ = () => {
      this.rewardItem$(1);
      this.closeAndNextLevel$();
    };
    async closeAndNextLevel$() {
      if (this.item$ !== "none") {
        analytics18.event(AnalyticsEvents15.GET_FREE_ITEM, {
          item_name: this.item$,
          value: this.rewardAmount$
        });
      }
      this.popup$.stopAnimation();
      await this.runCloseAnimation$();
      ScreenUtils_default.closeScreen(this.name);
      event37.emit(game_default.NEXT_LEVEL);
    }
    handleShowRewardedVideoAd$ = async () => {
      try {
        const isRewarded = await AdsUtils_default.showRewardVideoAdAsync();
        if (isRewarded) {
          AudioUtils_default.playSound(soundEffects_default.DAILY_REWARD);
          this.rewardItem$(2);
          this.closeAndNextLevel$();
        } else {
          this.popup$.runContinueButtonAnimation();
        }
      } catch (error) {
        this.popup$.runContinueButtonAnimation();
      }
    };
    rewardItem$(amount) {
      if (this.item$ === "none") return;
      this.rewardAmount$ = amount;
      const scene = SceneUtils_default.getCurrentScene();
      if (!(scene instanceof game_scene_default)) return;
      const { itemManager } = scene;
      itemManager.increaseItem(this.item$, this.rewardAmount$);
    }
    // Animations
    runOpenAnimation$() {
      this.background.setAlpha(0);
      this.animateBackgroundAlpha(0.6);
      this.runPopupEntrancesAnimation$(0, 300);
      this.popup$.playAnimation(300);
    }
    // Entrances animations
    runPopupEntrancesAnimation$(delay, duration) {
      const bannerHeightOffset = AdsUtils_default.getBannerHeight() / 2;
      const tweenShowPopup = this.scene.tweens.add({
        ...ShowUp_default,
        targets: [this.popup$],
        delay,
        duration,
        props: {
          ...ShowUp_default.props,
          y: { from: 350 - bannerHeightOffset, to: -bannerHeightOffset },
          alpha: { start: 1, from: 1, to: 1 },
          scale: { start: 0, from: 0, to: 1 }
        }
      });
      AnimUtils.runTween(tweenShowPopup);
    }
    async runPopupExitsAnimation$(delay, duration) {
      const bannerHeightOffset = AdsUtils_default.getBannerHeight() / 2;
      const tweenFadeOutPopup = this.scene.tweens.add({
        ...FadeOut_default,
        targets: [this.popup$],
        delay,
        duration,
        props: {
          ...FadeOut_default.props,
          y: 250 - bannerHeightOffset,
          scale: 0
        },
        pause: true
      });
      await AnimUtils.runTweenAsync(tweenFadeOutPopup);
    }
    async runCloseAnimation$() {
      await Promise.all([this.animateBackgroundAlpha(0, 200), this.runPopupExitsAnimation$(0, 200)]);
    }
  };
  var ResultScreen_default = ResultScreen;

  // src/game/screens/RewardCoinsScreen.ts
  init_phaser_custom_min();

  // src/game/components/TapTutorialHand.ts
  init_phaser_custom_min();
  var { KEY: KEY81, FRAME: FRAME83 } = sprites_default.TUTORIAL;
  var {
    Utils: { Device: D7 }
  } = Ludex;
  var TapTutorialHand = class extends Phaser.GameObjects.Container {
    hand;
    constructor(scene) {
      super(scene);
      this.name = "TapTutorialHand";
      this.addHand();
      this.scene.add.existing(this);
    }
    addHand() {
      this.hand = this.scene.make.image({
        key: KEY81,
        frame: FRAME83.HAND,
        origin: { x: 0.5, y: 0.5 }
      });
      this.add(this.hand);
    }
    playAnimation(startDelay = 0, repeatDelay = 800) {
      const scale = 1 / D7.pixelRatio();
      this.hand.angle = 30;
      this.scene?.tweens.add({
        delay: startDelay,
        targets: [this.hand],
        ease: Phaser.Math.Easing.Cubic.Out,
        props: {
          alpha: {
            start: 0,
            value: 1,
            duration: 200
          },
          scale: {
            duration: 400,
            start: scale * 1.6,
            to: scale * 1.2
          },
          angle: { from: 30, value: 0, duration: 400 }
        },
        onComplete: () => {
          this.scene?.tweens.add({
            targets: [this.hand],
            delay: 200,
            duration: 200,
            ease: Phaser.Math.Easing.Cubic.Out,
            props: {
              alpha: 0
            },
            onComplete: () => {
              this.hand.x = 0;
              this.hand.y = 0;
              this.hand.scale = scale;
              this.playAnimation(repeatDelay);
            }
          });
        }
      });
    }
    stopAnimation() {
      this.scene.tweens.killTweensOf(this.hand);
    }
    preDestroy() {
      this.scene.tweens.killTweensOf(this.hand);
    }
  };
  var TapTutorialHand_default = TapTutorialHand;

  // src/game/screens/RewardCoinsScreen.ts
  var { player: player23 } = codex;
  var { DEFAULT: DEFAULT2, DASHBOARD } = sprites_default;
  var RewardCoinsScreen = class extends Screen_default {
    hand$;
    popup$;
    coinIcon$;
    descText$;
    quantityText$;
    viewAdButton$;
    firstClaimButton$;
    closeButton$;
    glow$;
    popupContents$;
    glowSpinTween$;
    starSparkleUp$;
    coinBar$ = null;
    coinExplosiveEffects$ = [];
    constructor(scene, name) {
      super(scene, name);
      this.setDepth(ScreenDepth_default.POPUP);
      this.createPopup$();
      this.createEffects$();
      this.createHand$();
      this.createContentsGroup$();
    }
    // Method
    open = (data) => {
      super.open(data);
      if (data?.coinBar instanceof CoinsBar_default) {
        this.coinBar$ = data.coinBar;
      }
      this.runGlowSpinTween$();
      this.runOpenAnimation$();
    };
    handleDailyRewardsUIChange() {
      const { lastReceiveGift = 0 } = player23.getGameData() || {};
      if (this.isSameDay(lastReceiveGift, Date.now())) {
        this.firstClaimButton$.kill();
        this.viewAdButton$.revive();
        this.viewAdButton$.setDisabled(false);
        return;
      }
      this.firstClaimButton$.revive();
      this.viewAdButton$.kill();
    }
    isSameDay(date1, date2) {
      const firstDate = new Date(date1);
      const secondDate = new Date(date2);
      return firstDate.toDateString() === secondDate.toDateString();
    }
    // Input
    handleClosePopup$ = () => {
      this.glowSpinTween$?.stop();
      this.runCloseAnimation$();
    };
    handleShowRewardedVideoAd$ = async () => {
      try {
        this.viewAdButton$.setDisabled(true);
        const isWatched = await AdsUtils_default.showRewardVideoAdAsync();
        if (!isWatched) return;
        this.runClaimCoinAnimation$(500);
        this.handleClosePopup$();
      } catch (error) {
        console.warn("RewardItemScreen.handleShowRewardedVideoAd", error);
      } finally {
        this.viewAdButton$.setDisabled(false);
      }
    };
    // Animations
    runOpenAnimation$() {
      this.hand$.kill();
      this.popupContents$.setActive(true);
      this.popupContents$.setVisible(true);
      this.background.setAlpha(0);
      this.animateBackgroundAlpha(0.8);
      this.runPopupContentEntrancesAnimation$(100, 400);
      this.bringCoinBarToTop$();
    }
    bringCoinBarToTop$() {
      if (!this.coinBar$) return;
      this.coinBar$.bringThisToTop();
    }
    revertCoinBarDepth$() {
      if (!this.coinBar$) return;
      this.coinBar$.revertDepth();
    }
    runCloseAnimation$ = () => {
      this.animateBackgroundAlpha(0, 200);
      this.runExitsAnimation$(0, 200);
    };
    runClaimCoinAnimation$(value) {
      if (!this.coinBar$) return;
      AudioUtils_default.playSound(soundEffects_default.DAILY_REWARD);
      const barPosition = this.coinBar$.getWorldPosition();
      const buttonPosition = this.viewAdButton$.getWorldPosition();
      const coinExplosive = this.requestCoinExplosive$();
      const allTweens = coinExplosive.explode(10, buttonPosition.x, buttonPosition.y, barPosition.x,
      barPosition.y);
      for (const tween of allTweens) {
        tween.on(Phaser.Tweens.Events.TWEEN_COMPLETE, () => {
          const rewardCoins = Math.floor(value / 10);
          CoinUtils_default.addCoin(rewardCoins);
        });
      }
    }
    runPopupContentEntrancesAnimation$(delay, duration) {
      this.viewAdButton$.setDisabled(true);
      this.handleDailyRewardsUIChange();
      const contentShowUpAnimation = this.scene.tweens.add({
        ...BubbleTouch_default,
        targets: this.popupContents$.getChildren(),
        duration,
        delay: this.scene.tweens.stagger(100, { start: delay }),
        props: {
          scale: {
            getStart: (target) => {
              if (target === this.descText$) return 1;
              if (target === this.coinIcon$) return 1;
              return 0.7;
            },
            getEnd: (_target) => 1
          },
          alpha: { start: 0, from: 0, to: 1 }
        },
        onComplete: () => {
          this.viewAdButton$.setDisabled(false);
        }
      });
      AnimUtils.runTween(contentShowUpAnimation);
    }
    // Exit animations
    runExitsAnimation$(delay, duration) {
      const popupFadeOutAnimation = this.scene.tweens.add({
        ...FadeOut_default,
        targets: this.getAll(),
        delay,
        duration
      });
      AnimUtils.runTweenAsync(popupFadeOutAnimation).then(() => {
        this.descText$.setText("");
        this.revertCoinBarDepth$();
        ScreenUtils_default.closeScreen(this.name);
      });
    }
    requestCoinExplosive$() {
      const inactiveCoinExplosive = this.coinExplosiveEffects$.find((effect) => !effect.isActive);
      if (inactiveCoinExplosive) {
        return inactiveCoinExplosive;
      }
      const newCoinExplosive = new CoinExplosive_default(this.coinBar$?.scene ?? this.scene);
      this.coinExplosiveEffects$.push(newCoinExplosive);
      return newCoinExplosive;
    }
    // Draw
    createHand$() {
      this.hand$ = new TapTutorialHand_default(this.scene);
      this.add(this.hand$);
    }
    createContentsGroup$() {
      this.popupContents$ = this.scene.make.group({});
      this.popupContents$.addMultiple([
        this.popup$,
        this.glow$,
        this.coinIcon$,
        this.quantityText$,
        this.descText$,
        this.viewAdButton$,
        this.firstClaimButton$,
        this.closeButton$
      ]);
    }
    createPopup$() {
      this.popup$ = this.scene.add.container(0, 0);
      this.popup$.setWorldSize(283, 345.5);
      this.add(this.popup$);
      this.createCoinIcon$();
      this.createQuantityText$();
      this.createDescriptionText$();
      this.createViewAdsButton$();
      this.createFirstClaimButton$();
      this.createCloseButton$();
      const bannerHeightOffset = AdsUtils_default.getBannerHeight() / 2;
      Phaser.Display.Align.In.Center(this.popup$, this.zone, 0, -bannerHeightOffset);
    }
    createCoinIcon$() {
      this.glow$ = this.scene.make.image({
        key: DEFAULT2.KEY,
        frame: DEFAULT2.FRAME.ART_YELLOW_GLOW
      });
      this.popup$.add(this.glow$);
      const coinIcon = this.scene.make.image({
        key: DASHBOARD.KEY,
        frame: DASHBOARD.FRAME.ICON_COIN
      });
      coinIcon.setSize(150, 150);
      this.popup$.add(coinIcon);
      AlignUtils_default.alignChildCenter(coinIcon, this.popup$, 0, -75);
      this.glow$.setPosition(coinIcon.x, coinIcon.y);
      this.coinIcon$ = coinIcon;
    }
    createQuantityText$() {
      const text = FontUtils_default.createText(this.scene, "x500", 24).setFontStyle("700").setShadow(
      0, 3, "#000000", 0.5);
      this.popup$.add(text);
      AlignUtils_default.alignChildCenter(text, this.popup$, 0, -30);
      this.quantityText$ = text;
    }
    createDescriptionText$() {
      const text = FontUtils_default.createText(this.scene, "", 20);
      this.popup$.add(text);
      AlignUtils_default.alignChildCenter(text, this.popup$, 0, 10);
      this.descText$ = text;
    }
    createViewAdsButton$() {
      const button = new Button_default(this.scene, DEFAULT2.KEY, DEFAULT2.FRAME.BUTTON_GREEN);
      button.setName("Ads");
      const iconAds = this.scene.make.image({
        key: DEFAULT2.KEY,
        frame: DEFAULT2.FRAME.ICON_ADS
      });
      Phaser.Display.Align.In.Center(iconAds, button);
      iconAds.setX(button.x - 50);
      button.add(iconAds);
      const viewText = FontUtils_default.createText(this.scene, "Get Now", 18).setFontStyle("900");
      FontUtils_default.applyGreenStyle(viewText);
      button.add(viewText);
      Phaser.Display.Align.In.Center(viewText, button, 10, 0);
      AlignUtils_default.alignChildCenter(button, this.popup$, 0, 110);
      this.popup$.add(button);
      this.viewAdButton$ = button;
      button.onClick = this.handleShowRewardedVideoAd$;
    }
    createFirstClaimButton$() {
      const button = new Button_default(this.scene, DEFAULT2.KEY, DEFAULT2.FRAME.BUTTON_GREEN);
      button.setName("Claim");
      const viewText = FontUtils_default.createText(this.scene, "Claim", 18).setFontStyle("900");
      FontUtils_default.applyGreenStyle(viewText);
      button.add(viewText);
      Phaser.Display.Align.In.Center(viewText, button, 0, 0);
      AlignUtils_default.alignChildCenter(button, this.popup$, 0, 110);
      this.popup$.add(button);
      this.firstClaimButton$ = button;
      button.onClick = () => {
        player23.setGameData({
          lastReceiveGift: Date.now()
        });
        this.runClaimCoinAnimation$(500);
        this.firstClaimButton$.kill();
        this.viewAdButton$.revive();
        this.viewAdButton$.setDisabled(false);
      };
    }
    createCloseButton$() {
      this.closeButton$ = new TextButton_default(this.scene, "Close", 16);
      this.closeButton$.setName("Close");
      this.closeButton$.setButtonHitSoundEffect(soundEffects_default.CLOSE_POPUP_CLICK);
      this.popup$.add(this.closeButton$);
      Phaser.Display.Align.To.BottomCenter(this.closeButton$, this.viewAdButton$, 0, 0);
      this.closeButton$.onClick = this.handleClosePopup$;
    }
    createEffects$() {
      this.starSparkleUp$ = new StarSparkle_default(this.scene);
      this.starSparkleUp$.run(2, 0, -140, 180, 180);
      this.popup$.add(this.starSparkleUp$);
    }
    runGlowSpinTween$() {
      this.glowSpinTween$?.stop();
      this.glow$.angle = 0;
      this.glow$.setPosition(this.coinIcon$.x, this.coinIcon$.y);
      this.glowSpinTween$ = this.scene.tweens.add({
        targets: this.glow$,
        angle: 360,
        duration: 5e3,
        repeat: -1,
        ease: "Linear"
      });
    }
  };
  var RewardCoinsScreen_default = RewardCoinsScreen;

  // src/game/screens/RewardItemScreen.ts
  init_phaser_custom_min();

  // src/game/animations/attention/PulsateBubble.ts
  init_phaser_custom_min();

  // src/game/animations/easing/BubbleInOut.ts
  init_phaser_custom_min();
  var import_bezier_easing2 = __toESM(require_src());
  var EaseBubbleInOut = (0, import_bezier_easing2.default)(0.55, 0.47, 0.43, 0.91);
  var BubbleInOut_default = EaseBubbleInOut;

  // src/game/animations/attention/PulsateBubble.ts
  var DEFAULT_PULSTATE_BUBBLE_ANIM_CONFIG = {
    yoyo: true,
    repeat: -1,
    duration: 600,
    repeatDelay: 50,
    ease: BubbleInOut_default,
    easeParams: [0, 0.9]
  };

  // src/game/effects/StarTwinkleUp.ts
  init_phaser_custom_min();
  var { KEY: KEY82, FRAME: FRAME84 } = sprites_default.EFFECTS;
  var StarTwinkleUp = class extends Phaser.GameObjects.Container {
    emitZone;
    emitter;
    constructor(scene) {
      super(scene);
      this.createEmitZone();
      this.createEmitters();
      this.scene.add.existing(this);
    }
    createEmitZone() {
      this.emitZone = new Phaser.Geom.Rectangle();
    }
    createEmitters() {
      this.emitter = this.scene.add.particles(0, 0, KEY82, {
        frame: FRAME84.FX_COMET,
        emitZone: {
          source: this.emitZone,
          type: "random"
        },
        deathZone: {
          source: this.emitZone,
          type: "onLeave"
        },
        timeScale: 1,
        frequency: 150,
        // maxParticles: 30,
        speedY: { min: -20, max: -60 },
        alpha: { start: 1, end: 0, ease: Phaser.Math.Easing.Cubic.Out },
        scale: { start: 1, end: 0, ease: Phaser.Math.Easing.Cubic.Out },
        lifespan: { min: 1500, max: 2500 }
      });
      this.add(this.emitter);
    }
    run(count, x, y, width, height) {
      this.stop();
      this.emitZone.setSize(width, height);
      this.emitZone.setPosition(x - width / 2, y - height / 2);
      this.emitter.setQuantity(count);
      this.emitter.start();
    }
    stop() {
      this.emitter?.killAll();
      this.emitter?.stop();
    }
  };
  var StarTwinkleUp_default = StarTwinkleUp;

  // src/game/screens/common/GiftButton.ts
  init_phaser_custom_min();
  var GiftButton = class extends Phaser.GameObjects.Container {
    isClicked = false;
    // * Default scale is 1, scale down to 0.8 when pressed
    scaleUp = 1;
    scaleDown = 0.985;
    button;
    isUsePixelPerfect = false;
    hitArea;
    hitZone;
    constructor(scene, key, frame, width, height, usePixelPerfect = false) {
      super(scene);
      this.name = "OpenGift";
      this.isUsePixelPerfect = usePixelPerfect;
      this.setDepth(depth_default.BUTTON);
      this.createButton(key, frame, width, height);
      this.updateSize();
      this.listenEvents();
      this.scene.add.existing(this);
    }
    listenEvents() {
      this.scene.events.on(Phaser.Scenes.Events.SLEEP, this.handleSceneSleep);
      this.once(Phaser.GameObjects.Events.DESTROY, this.handelObjectDestroy);
    }
    handelObjectDestroy = () => {
      if (!this.scene) return;
      this.scene.events.off(Phaser.Scenes.Events.SLEEP, this.handleSceneSleep);
    };
    handleSceneSleep = () => {
      if (!this.scene) return;
      this.scene.tweens.killTweensOf(this);
    };
    set onClick(callback) {
      if (this.isUsePixelPerfect) {
        this.hitArea = this.button;
        this.hitArea.setInteractive({
          useHandCursor: true,
          pixelPerfect: true
        });
      } else {
        this.hitArea = this.hitZone;
        this.updateSize();
        this.hitArea.setInteractive({
          useHandCursor: true
        });
      }
      this.hitArea.off(Phaser.Input.Events.GAMEOBJECT_POINTER_DOWN);
      this.hitArea.off(Phaser.Input.Events.GAMEOBJECT_POINTER_UP);
      this.hitArea.off(Phaser.Input.Events.GAMEOBJECT_POINTER_OUT);
      this.hitArea.on(Phaser.Input.Events.GAMEOBJECT_POINTER_DOWN, this.handlePointerDown);
      this.hitArea.on(Phaser.Input.Events.GAMEOBJECT_POINTER_UP, this.handleOnClick(callback));
      this.hitArea.on(Phaser.Input.Events.GAMEOBJECT_POINTER_OUT, this.handlePointerOut);
    }
    get isUsePixelPerFect() {
      return this.isUsePixelPerfect;
    }
    handlePointerDown = () => {
      if (this.isClicked) return;
      this.isClicked = true;
    };
    handleOnClick = (callback) => () => {
      if (!this.isClicked) return;
      this.isClicked = false;
      AnalyticsUtils_default.trackButtonClick(this.name);
      callback();
    };
    handlePointerOut = () => {
      if (!this.isClicked) return;
      this.isClicked = false;
    };
    setDisabled(disable) {
      if (disable) {
        this.hitArea?.disableInteractive();
      } else {
        this.hitArea?.setInteractive();
      }
    }
    createButton(key, frame, width, height) {
      this.button = this.scene.add.image(0, 0, key, frame);
      if (width && height) {
        this.button.setWorldSize(width, height);
      }
      const { displayWidth, displayHeight } = this.button;
      this.hitZone = this.scene.make.zone({
        width: displayWidth,
        height: displayHeight
      });
      this.add([this.button, this.hitZone]);
    }
    // This method can be change on child classes for specific buttons
    updateSize() {
      const { width, height } = this.button;
      const padMax = 10;
      const padWidth = width / 100 * 10;
      const padHeight = height / 100 * 10;
      const bounceWidth = padWidth < padMax ? padWidth : padMax;
      const bounceHeight = padHeight < padMax ? padHeight : padMax;
      this.setSize(width + bounceWidth, height + bounceHeight);
      this.hitZone.setSize(width + bounceWidth, height + bounceHeight);
    }
  };
  var GiftButton_default = GiftButton;

  // src/game/screens/RewardItemScreen.ts
  var { event: event38 } = codex;
  var { DEFAULT: DEFAULT3, GAMEPLAY: GAMEPLAY3 } = sprites_default;
  var RewardItemScreen = class extends Screen_default {
    hand$;
    giftIcon$;
    giftIconWhite$;
    popup$;
    itemIcon$;
    descText$;
    quantityText$;
    viewAdButton$;
    closeButton$;
    viewAdBg$;
    whiteGlow$;
    itemId$;
    popupContents$;
    cometTwinkle$;
    starTwinkleUp$;
    sparksExplosive$;
    popupFadeOutAnimation$;
    giftEntrancesAnimation$;
    giftAttentionAnimation$;
    giftShakeAnimation$;
    giftOpenAnimation$;
    glowSpinTween$;
    constructor(scene, name) {
      super(scene, name);
      this.setDepth(ScreenDepth_default.POPUP);
      this.createPopup$();
      this.createEffects$();
      this.createGiftIcon$();
      this.createHand$();
      this.createContentsGroup$();
    }
    // Method
    open = (data) => {
      super.open(data);
      event38.emit(game_default.PAUSE);
      this.itemId$ = data?.itemId;
      this.updateScreen$();
      this.runGlowSpinTween$();
      this.runOpenAnimation$();
    };
    updateScreen$() {
      if (!this.itemId$) return;
      switch (this.itemId$) {
        case item_default.HINT.ID:
          this.itemIcon$.setTexture(GAMEPLAY3.KEY, GAMEPLAY3.FRAME.HINT_ITEM);
          this.descText$.setText(item_default.HINT.REWARD_DESC);
          break;
        case item_default.ROCKET.ID:
          this.itemIcon$.setTexture(GAMEPLAY3.KEY, GAMEPLAY3.FRAME.ROCKET_ITEM);
          this.descText$.setText(item_default.ROCKET.REWARD_DESC);
          break;
        case item_default.BOMB_DEFUSE.ID:
          this.itemIcon$.setTexture(GAMEPLAY3.KEY, GAMEPLAY3.FRAME.DEFUSE_ITEM);
          this.descText$.setText(item_default.BOMB_DEFUSE.REWARD_DESC);
          break;
        case item_default.SHUFFLE.ID:
          this.itemIcon$.setTexture(GAMEPLAY3.KEY, GAMEPLAY3.FRAME.ITEM_SHUFFLE);
          this.descText$.setText(item_default.SHUFFLE.REWARD_DESC);
          break;
      }
      this.updateItemIconSize$();
    }
    updateItemIconSize$() {
      this.itemIcon$.setWorldSize(100);
      this.whiteGlow$.setWorldSize(150);
      const { x, y } = this.itemIcon$;
      this.whiteGlow$.setPosition(x, y);
    }
    // Input
    handleClosePopup$ = () => {
      this.glowSpinTween$?.stop();
      this.runCloseAnimation$();
    };
    handleShowRewardedVideoAd$ = async () => {
      try {
        this.viewAdButton$.setDisabled(true);
        const isWatched = await AdsUtils_default.showRewardVideoAdAsync();
        if (!isWatched) return;
        this.starTwinkleUp$.stop();
        AudioUtils_default.playSound(soundEffects_default.DAILY_REWARD);
        this.popupContents$.setActive(false);
        this.popupContents$.setVisible(false);
        this.runTheGiftEntrancesAnimation$(0, 1500);
      } catch (error) {
        console.warn("RewardItemScreen.handleShowRewardedVideoAd", error);
      } finally {
        this.viewAdButton$.setDisabled(false);
      }
    };
    handleTheGiftClick$ = () => {
      this.giftIcon$.setDisabled(true);
      this.hand$.kill();
      this.giftIconWhite$.revive();
      this.scene.tweens.killTweensOf(this.giftIcon$);
      Phaser.Display.Align.In.Center(this.giftIconWhite$, this.giftIcon$);
      AudioUtils_default.playSound(soundEffects_default.GIFT_CHARGE);
      this.runShakeTheGift$();
      this.runOpenTheGift$();
    };
    // Animations
    runOpenAnimation$() {
      this.hand$.kill();
      this.popupContents$.setActive(true);
      this.popupContents$.setVisible(true);
      this.starTwinkleUp$.stop();
      this.background.setAlpha(0);
      this.animateBackgroundAlpha(0.8);
      this.runPopupContentEntrancesAnimation$(100, 400);
    }
    runCloseAnimation$ = () => {
      event38.emit(game_default.RESUME);
      this.animateBackgroundAlpha(0, 200);
      this.runExitsAnimation$(0, 200);
    };
    runPopupContentEntrancesAnimation$(delay, duration) {
      this.viewAdButton$.setDisabled(true);
      this.viewAdButton$.setAlpha(0);
      this.viewAdBg$.setAlpha(0);
      const tweenShowContents = this.scene.tweens.add({
        ...BubbleTouch_default,
        targets: this.popupContents$.getChildren(),
        duration,
        delay: this.scene.tweens.stagger(100, { start: delay }),
        props: {
          ...BubbleTouch_default.props,
          scale: {
            getStart: (target) => {
              if (target === this.descText$) return 1;
              return 0.7;
            },
            getEnd: (_target) => 1
          },
          alpha: { start: 0, from: 0, to: 1 }
        },
        onComplete: () => {
          this.viewAdBg$.setAlpha(1);
          this.viewAdButton$.setDisabled(false);
          this.runViewAdButtonAnimation$();
        }
      });
      AnimUtils.runTween(tweenShowContents);
    }
    runTheGiftEntrancesAnimation$(delay, duration) {
      this.giftIcon$.revive();
      this.giftIcon$.setAlpha(1);
      this.cometTwinkle$.setAlpha(1);
      this.sparksExplosive$.setAlpha(1);
      Phaser.Display.Align.In.TopRight(this.giftIcon$, this.zone);
      this.giftEntrancesAnimation$?.tween.remove();
      const { x: sourceX, y: sourceY } = this.giftIcon$;
      const { x: targetX, y: targetY } = this.popup$;
      const start = { x: sourceX, y: sourceY };
      const end = { x: targetX, y: targetY };
      this.giftEntrancesAnimation$ = new Curve_default(this.scene, {
        targets: [this.giftIcon$],
        delay,
        duration,
        curve: [
          [start.x, start.y],
          [start.x - 80, start.y + 80],
          [end.x, end.y]
        ],
        props: {
          scale: { start: 0.5, to: 1 },
          angle: { start: 20, to: 0 }
        },
        onCurveUpdate: (target) => {
          const radius = 40;
          const x = target.x + Phaser.Math.RND.between(-radius, radius);
          const y = target.y + Phaser.Math.RND.between(-radius, radius);
          this.cometTwinkle$.explode(1, x, y);
        },
        onComplete: () => {
          AudioUtils_default.playSound(soundEffects_default.GIFT_REVEAL);
          const scale = 1.5;
          this.starTwinkleUp$.setScale(scale);
          const { x, y, width, height } = this.giftIcon$;
          this.starTwinkleUp$.run(1, x, y, width / scale, height / scale);
          this.moveTo(this.starTwinkleUp$, this.length - 1);
          this.runTheGiftAttentionAnimation$();
        }
      });
      AnimUtils.runTween(this.giftEntrancesAnimation$.tween);
    }
    runTheGiftAttentionAnimation$() {
      this.giftAttentionAnimation$?.stop();
      this.giftAttentionAnimation$ = this.scene.tweens.add({
        ...DEFAULT_PULSTATE_BUBBLE_ANIM_CONFIG,
        targets: [this.giftIcon$],
        props: {
          scale: "+=0.05"
        }
      });
      this.hand$.revive();
      this.hand$.setAlpha(1);
      this.hand$.playAnimation();
      Phaser.Display.Align.In.Center(this.hand$, this.giftIcon$, 20, 20);
      this.giftIcon$.setDisabled(false);
      AnimUtils.runTween(this.giftAttentionAnimation$);
    }
    runShakeTheGift$() {
      this.giftShakeAnimation$ = new ShakeHorizontal_default(this.scene, {
        targets: [this.giftIcon$, this.giftIconWhite$],
        duration: 22,
        shakeX: 5
      });
      AnimUtils.runTween(this.giftShakeAnimation$.tween);
    }
    runOpenTheGift$() {
      this.giftOpenAnimation$ = this.scene.tweens.add({
        ...ScaleDown_default,
        targets: [this.giftIcon$, this.giftIconWhite$],
        duration: 1500,
        props: {
          alpha: 0
        },
        onUpdate: () => {
          this.giftIconWhite$.setAlpha(1);
        },
        onComplete: () => {
          this.giftShakeAnimation$.tween.stop();
          this.giftIcon$.kill();
          this.giftIconWhite$.kill();
          this.sparksExplosive$.explode(100, this.giftIcon$.x, this.giftIcon$.y, 230);
          AudioUtils_default.playSound(soundEffects_default.GIFT_EXPLODE);
          this.scene.time.delayedCall(500, this.runCloseAnimation$);
          this.runRewardItemCurveAnimation$();
        }
      });
      AnimUtils.runTween(this.giftOpenAnimation$);
    }
    runRewardItemCurveAnimation$() {
      const scene = SceneUtils_default.getCurrentScene();
      if (!scene || !(scene instanceof game_scene_default)) return;
      const giftIconPos = this.giftIcon$.getWorldPosition();
      const [itemId, rewardCount] = this.getData(["itemId", "rewardCount"]);
      const itemPos = this.getCorrectItemButton$(itemId);
      if (!itemPos) return;
      const { effectManager } = scene;
      const { x: x12, y: y12 } = giftIconPos;
      const { x: x2, y: y2 } = itemPos;
      const emitReceiveItemCallback = () => {
        event38.emit(game_default.RECEIVE_ITEM, { itemId, rewardCount });
      };
      effectManager.playRewardItemCurveAnimation(x12, y12, x2, y2, emitReceiveItemCallback);
    }
    getCorrectItemButton$(itemId) {
      const scene = SceneUtils_default.getCurrentScene();
      if (!scene || !(scene instanceof game_scene_default)) return null;
      const { layoutManager } = scene;
      const { objects } = layoutManager;
      switch (itemId) {
        case item_default.SHUFFLE.ID:
          return objects.shuffleItem.getWorldPosition();
        case item_default.HINT.ID:
          return objects.hintItem.getWorldPosition();
        case item_default.ROCKET.ID:
          return objects.rocketItem.getWorldPosition();
        case item_default.BOMB_DEFUSE.ID:
          return objects.defuseItem.getWorldPosition();
        default:
          return null;
      }
    }
    // Exit animations
    runExitsAnimation$(delay, duration) {
      this.popupFadeOutAnimation$ = this.scene.tweens.add({
        ...FadeOut_default,
        targets: this.getAll(),
        delay,
        duration
      });
      AnimUtils.runTweenAsync(this.popupFadeOutAnimation$).then(() => {
        this.descText$.setText("");
        ScreenUtils_default.closeScreen(this.name);
      });
    }
    // Draw
    createHand$() {
      this.hand$ = new TapTutorialHand_default(this.scene);
      this.add(this.hand$);
    }
    createContentsGroup$() {
      this.popupContents$ = this.scene.make.group({});
      this.popupContents$.addMultiple([
        this.popup$,
        this.closeButton$,
        this.whiteGlow$,
        this.itemIcon$,
        this.quantityText$,
        this.descText$,
        this.viewAdButton$
      ]);
    }
    createPopup$() {
      this.popup$ = this.scene.add.container(0, 0);
      const board = this.scene.make.image({
        key: DEFAULT3.KEY,
        frame: DEFAULT3.FRAME.POPUP
      });
      this.popup$.setWorldSize(board.width, board.height);
      this.popup$.add(board);
      this.add(this.popup$);
      this.createItemIcon$();
      this.createQuantityText$();
      this.createDescriptionText$();
      this.createViewAdsButton$();
      this.createCloseButton$();
      const bannerHeightOffset = AdsUtils_default.getBannerHeight() / 2;
      Phaser.Display.Align.In.Center(this.popup$, this.zone, 0, -bannerHeightOffset);
    }
    createItemIcon$() {
      this.whiteGlow$ = this.scene.make.image({
        key: DEFAULT3.KEY,
        frame: DEFAULT3.FRAME.ART_WHITE_GLOW
      });
      this.popup$.add(this.whiteGlow$);
      const itemIcon = this.scene.make.image({
        key: GAMEPLAY3.KEY,
        frame: GAMEPLAY3.FRAME.HINT_ITEM
      });
      this.popup$.add(itemIcon);
      AlignUtils_default.alignChildCenter(itemIcon, this.popup$, 0, -40);
      this.itemIcon$ = itemIcon;
      this.updateItemIconSize$();
    }
    createQuantityText$() {
      const text = FontUtils_default.createText(this.scene, "x1", 28).setFontStyle("700");
      FontUtils_default.applyYellowStyle(text).setStroke("#4a260f", 3);
      this.popup$.add(text);
      AlignUtils_default.alignChildCenter(text, this.popup$);
      this.quantityText$ = text;
    }
    createDescriptionText$() {
      const text = FontUtils_default.createText(this.scene, "", 18).setWordWrapWidth(200).setAlign("\
center");
      FontUtils_default.applyYellowStyle(text).setStroke("#4a260f", 2);
      this.popup$.add(text);
      AlignUtils_default.alignChildCenter(text, this.popup$, 0, 50);
      this.descText$ = text;
    }
    createViewAdsButton$() {
      const button = new HighlightButton(this.scene, DEFAULT3.KEY, DEFAULT3.FRAME.BUTTON_GREEN);
      const iconAds = this.scene.make.image({
        key: DEFAULT3.KEY,
        frame: DEFAULT3.FRAME.ICON_ADS
      });
      Phaser.Display.Align.In.Center(iconAds, button);
      iconAds.setX(button.x - 60);
      button.content.add(iconAds);
      const viewText = FontUtils_default.createText(this.scene, "Get Now", 20).setFontStyle("900");
      FontUtils_default.applyGreenStyle(viewText);
      const viewAdsBg = this.scene.make.image({
        key: DEFAULT3.KEY,
        frame: DEFAULT3.FRAME.BUTTON_FRAME
      });
      button.content.add(viewText);
      AlignUtils_default.alignChildCenter(viewText, button, 18);
      AlignUtils_default.alignChildCenter(button, this.popup$, 0, 110);
      this.popup$.add(viewAdsBg);
      this.popup$.add(button);
      Phaser.Display.Align.In.Center(viewAdsBg, button, 0, -1);
      this.viewAdButton$ = button;
      this.viewAdBg$ = viewAdsBg;
      button.onClick = this.handleShowRewardedVideoAd$;
    }
    createCloseButton$() {
      const button = new Button_default(this.scene, DEFAULT3.KEY, DEFAULT3.FRAME.BUTTON_CLOSE);
      const icon = this.scene.make.image({
        key: DEFAULT3.KEY,
        frame: DEFAULT3.FRAME.ICON_X
      });
      button.add(icon);
      button.setName("Close");
      AlignUtils_default.alignChildTopRight(button, this.popup$, -15, -15);
      this.popup$.add(button);
      button.onClick = this.handleClosePopup$;
      this.closeButton$ = button;
    }
    createGiftIcon$() {
      this.giftIconWhite$ = this.scene.make.image({
        key: DEFAULT3.KEY,
        frame: DEFAULT3.FRAME.LOGO_GIFT_WHITE,
        visible: false
      });
      this.giftIconWhite$.setDepth(depth_default.PRIORITY);
      this.add(this.giftIconWhite$);
      this.giftIcon$ = new GiftButton_default(this.scene, DEFAULT3.KEY, DEFAULT3.FRAME.LOGO_GIFT);
      this.giftIcon$.onClick = this.handleTheGiftClick$;
      this.giftIcon$.setDisabled(true);
      this.giftIcon$.kill();
      this.add(this.giftIcon$);
    }
    createEffects$() {
      this.cometTwinkle$ = new CometTwinkle_default(this.scene);
      this.starTwinkleUp$ = new StarTwinkleUp_default(this.scene);
      this.sparksExplosive$ = new SparksExplosive_default(this.scene);
      this.add([this.cometTwinkle$, this.starTwinkleUp$, this.sparksExplosive$]);
    }
    runGlowSpinTween$() {
      this.glowSpinTween$?.stop();
      this.whiteGlow$.angle = 0;
      this.whiteGlow$.setPosition(this.itemIcon$.x, this.itemIcon$.y);
      this.glowSpinTween$ = this.scene.tweens.add({
        targets: this.whiteGlow$,
        angle: 360,
        duration: 5e3,
        repeat: -1,
        ease: "Linear"
      });
    }
    runViewAdButtonAnimation$() {
      this.viewAdButton$.playHighlightAnimation();
    }
  };
  var RewardItemScreen_default = RewardItemScreen;

  // src/game/screens/journey-screen/JourneyScreen.ts
  init_phaser_custom_min();

  // src/game/scenes/dashboard-scene/components/PlayButton.ts
  init_phaser_custom_min();

  // src/game/components/NineSliceButton.ts
  init_phaser_custom_min();
  var NineSliceButton = class extends Phaser.GameObjects.Container {
    useSound = true;
    isClicked = false;
    // * Default scale is 1, scale down to 0.8 when pressed
    scaleUp = 1;
    scaleDown = 0.985;
    button;
    upAnimation;
    downAnimation;
    isUsePixelPerfect = false;
    hitArea;
    hitZone;
    hitSoundEffectKey = soundEffects_default.GENERAL_BUTTON_CLICK;
    scaleDownPress;
    constructor(scene, config) {
      super(scene);
      this.isUsePixelPerfect = config.usePixelPerfect ?? false;
      this.setDepth(depth_default.BUTTON);
      this.createButton(config);
      this.updateSize();
      this.listenEvents();
      this.scene.add.existing(this);
    }
    listenEvents() {
      this.scene.events.on(Phaser.Scenes.Events.SLEEP, this.handleSceneSleep);
      this.once(Phaser.GameObjects.Events.DESTROY, this.handelObjectDestroy);
    }
    handelObjectDestroy = () => {
      if (!this.scene) return;
      this.scene.events.off(Phaser.Scenes.Events.SLEEP, this.handleSceneSleep);
    };
    handleSceneSleep = () => {
      if (!this.scene) return;
      this.scene.tweens.killTweensOf(this);
    };
    set onClick(callback) {
      if (this.isUsePixelPerfect) {
        this.hitArea = this.button;
        this.hitArea.setInteractive({
          useHandCursor: true,
          pixelPerfect: true
        });
      } else {
        this.hitArea = this.hitZone;
        this.updateSize();
        this.hitArea.setInteractive({
          useHandCursor: true
        });
      }
      this.hitArea.on(Phaser.Input.Events.GAMEOBJECT_POINTER_DOWN, this.handlePointerDown);
      this.hitArea.on(Phaser.Input.Events.GAMEOBJECT_POINTER_UP, this.handleOnClick(callback));
      this.hitArea.on(Phaser.Input.Events.GAMEOBJECT_POINTER_OUT, this.handlePointerOut);
    }
    get isUsePixelPerFect() {
      return this.isUsePixelPerfect;
    }
    handlePointerDown = () => {
      if (this.isClicked) return;
      if (this.upAnimation?.isPlaying()) return;
      this.isClicked = true;
      this.runDownAnimation();
    };
    handleOnClick = (callback) => () => {
      if (!this.isClicked) return;
      if (this.upAnimation?.isPlaying()) return;
      this.isClicked = false;
      this.runUpAnimation();
      this.upAnimation?.once(Phaser.Tweens.Events.TWEEN_COMPLETE, () => {
        AnalyticsUtils_default.trackButtonClick(this.name);
        this.processCallback(callback);
      });
    };
    handlePointerOut = () => {
      if (!this.isClicked) return;
      if (this.upAnimation?.isPlaying()) return;
      this.isClicked = false;
      this.runUpAnimation();
    };
    processCallback(callback) {
      this.upAnimation?.stop();
      this.downAnimation?.stop();
      this.scene?.tweens.killTweensOf(this);
      this.setScale(this.scaleUp);
      callback();
    }
    setDisabled(disable) {
      if (disable) {
        this.setAlpha(0.5);
        this.hitArea?.disableInteractive();
      } else {
        this.setAlpha(1);
        this.hitArea?.setInteractive();
      }
    }
    createButton(config) {
      this.button = this.scene.make.nineslice(config);
      const { displayWidth, displayHeight } = this.button;
      this.hitZone = this.scene.make.zone({
        width: displayWidth,
        height: displayHeight
      });
      this.add([this.button, this.hitZone]);
    }
    // This method can be change on child classes for specific buttons
    updateSize() {
      const { width, height } = this.button;
      const padMax = 10;
      const padWidth = width / 100 * 10;
      const padHeight = height / 100 * 10;
      const bounceWidth = padWidth < padMax ? padWidth : padMax;
      const bounceHeight = padHeight < padMax ? padHeight : padMax;
      this.setSize(width + bounceWidth, height + bounceHeight);
      this.hitZone.setSize(width + bounceWidth, height + bounceHeight);
    }
    runDownAnimation() {
      if (this.useSound) {
        AudioUtils_default.playSound(this.hitSoundEffectKey);
      }
      this.downAnimation?.remove();
      this.downAnimation = this.scene.tweens.add({
        ...ScaleDown_default,
        targets: [this],
        duration: 150,
        props: {
          scale: this.scaleDown
        },
        onUpdate: () => {
          this.hitZone.scale = 1 / this.scale;
        }
      });
      AnimUtils.runTween(this.downAnimation);
    }
    runUpAnimation() {
      this.upAnimation?.remove();
      this.upAnimation = this.scene.tweens.add({
        ...ScaleUp_default,
        targets: [this],
        duration: 150,
        props: {
          scale: this.scaleUp
        },
        onUpdate: () => {
          this.hitZone.scale = 1 / this.scale;
        }
      });
      AnimUtils.runTween(this.upAnimation);
    }
    setButtonHitSoundEffect(key) {
      this.hitSoundEffectKey = key;
    }
  };
  var NineSliceButton_default = NineSliceButton;

  // src/game/scenes/dashboard-scene/components/PlayButton.ts
  var {
    Utils: { Signal: S6 }
  } = Ludex;
  var { KEY: KEY83, FRAME: FRAME85 } = sprites_default.DASHBOARD;
  var PlayButton = class extends NineSliceButton_default {
    text;
    shine;
    shineAlpha;
    shineScale;
    useShine = false;
    scaleDown = 0.985;
    shineAnimController = new S6.SignalController();
    constructor(scene, playButtonConfig) {
      const config = {
        key: KEY83,
        frame: FRAME85.BUTTON_GREEN,
        width: 200,
        height: 50,
        leftWidth: 30,
        rightWidth: 30,
        topHeight: 20,
        bottomHeight: 20,
        ...playButtonConfig
      };
      super(scene, config);
      this.shineAlpha = config.shineAlpha ?? 0.2;
      this.shineScale = config.shineScale ?? 1.05;
      this.setName("PlayButton");
      this.createText();
      this.createShine(config);
    }
    createText() {
      this.text = FontUtils_default.createText(this.scene, "Level 1", 26);
      FontUtils_default.applyGreenStyle(this.text);
      this.text.setShadow(0, 6, "#27710e", 3);
      this.add(this.text);
    }
    createShine(config) {
      if (!config.key || !config.frame) return;
      this.shine = this.scene.add.nineslice(
        0,
        0,
        config.key,
        config.frame,
        config.width,
        config.height,
        config.leftWidth,
        config.rightWidth,
        config.topHeight,
        config.bottomHeight
      );
      BlendModeUtils.inst.setBlendModeWithPerf(this.shine, Phaser.BlendModes.ADD);
      this.shine.setAlpha(this.shineAlpha);
      this.add(this.shine);
      this.shine.kill();
    }
    setLevel(level) {
      this.text.setText(`Level ${level}`);
    }
    setButtonSize(width, height) {
      this.button.setSize(width, height);
    }
    playShineAnimation() {
      this.useShine = true;
      this.startShineAnimation();
    }
    startShineAnimation() {
      this.shine.revive();
      const signal = this.shineAnimController.renew();
      const alpha = this.scene.tweens.add({
        targets: this.shine,
        props: {
          alpha: { from: 0, to: this.shineAlpha }
        },
        paused: true,
        duration: 600,
        ease: Phaser.Math.Easing.Cubic.InOut,
        repeatDelay: 200,
        yoyo: true,
        repeat: -1
      });
      const scale = this.scene.tweens.add({
        targets: [this.shine, this.button, this.text],
        props: {
          scale: { from: 1, to: this.shineScale }
        },
        paused: true,
        duration: 600,
        ease: Phaser.Math.Easing.Cubic.InOut,
        repeatDelay: 200,
        yoyo: true,
        repeat: -1
      });
      AnimUtils.runTween(alpha, signal);
      AnimUtils.runTween(scale, signal);
    }
    stopShineAnimation() {
      this.startShineExitAnimation();
      this.useShine = false;
    }
    startShineExitAnimation() {
      const signal = this.shineAnimController.renew();
      const alpha = this.scene.tweens.add({
        targets: this.shine,
        props: {
          alpha: 0
        },
        paused: true,
        duration: 150,
        ease: Phaser.Math.Easing.Cubic.Out
      });
      const scale = this.scene.tweens.add({
        targets: [this.shine, this.button, this.text],
        props: {
          scale: 1
        },
        paused: true,
        duration: 150,
        ease: Phaser.Math.Easing.Cubic.Out,
        onComplete: () => {
          this.shine.kill();
        }
      });
      AnimUtils.runTween(alpha, signal);
      AnimUtils.runTween(scale, signal);
    }
    runDownAnimation() {
      super.runDownAnimation();
      this.startShineExitAnimation();
    }
    runUpAnimation() {
      super.runUpAnimation();
      if (this.useShine) {
        this.startShineAnimation();
      }
    }
  };
  var PlayButton_default = PlayButton;

  // src/game/screens/journey-screen/JourneyRoad.ts
  init_phaser_custom_min();
  var { KEY: JOURNEY_KEY, FRAME: JOURNEY_FRAME } = sprites_default.JOURNEY;
  var RoadTypes = {
    TOP_LEFT: "top-left",
    TOP_RIGHT: "top-right",
    BOTTOM_LEFT: "bottom-left",
    BOTTOM_RIGHT: "bottom-right",
    MIDDLE_LTR: "middle-ltr",
    MIDDLE_RTL: "middle-rtl"
  };
  var RoadStates = {
    EMPTY: "empty",
    FILLED: "filled"
  };
  var JourneyRoad = class _JourneyRoad extends Phaser.GameObjects.Container {
    border;
    road;
    config;
    constructor(scene, config) {
      super(scene);
      this.config = config;
      this.create(config);
      this.setSize(this.border.width, this.border.height);
      this.scene.add.existing(this);
    }
    setRoadState(state) {
      this.config.state = state;
      if (state === RoadStates.EMPTY) {
        this.road.kill();
      } else {
        this.road.revive();
      }
    }
    static createLinkingRoad(scene, road, config) {
      const newType = this.getNextRoadType(road.config.type);
      const newRoad = new _JourneyRoad(scene, {
        ...config,
        type: newType
      });
      return newRoad;
    }
    static getNextRoadType(lastRoadType) {
      switch (lastRoadType) {
        case RoadTypes.TOP_LEFT:
          return RoadTypes.MIDDLE_LTR;
        case RoadTypes.TOP_RIGHT:
          return RoadTypes.MIDDLE_RTL;
        case RoadTypes.BOTTOM_LEFT:
          return RoadTypes.TOP_LEFT;
        case RoadTypes.BOTTOM_RIGHT:
          return RoadTypes.TOP_RIGHT;
        case RoadTypes.MIDDLE_LTR:
          return RoadTypes.BOTTOM_RIGHT;
        case RoadTypes.MIDDLE_RTL:
          return RoadTypes.BOTTOM_LEFT;
      }
    }
    static alignRoad(prev, next) {
      const { type: prevType } = prev.config;
      switch (prevType) {
        case RoadTypes.TOP_LEFT:
          Phaser.Display.Align.To.RightTop(next, prev, 0, 0);
          break;
        case RoadTypes.TOP_RIGHT:
          Phaser.Display.Align.To.LeftTop(next, prev, 0, 0);
          break;
        case RoadTypes.BOTTOM_LEFT:
          Phaser.Display.Align.To.TopLeft(next, prev, 0, 0);
          break;
        case RoadTypes.BOTTOM_RIGHT:
          Phaser.Display.Align.To.TopRight(next, prev, 0, 0);
          break;
        case RoadTypes.MIDDLE_LTR:
          Phaser.Display.Align.To.RightBottom(next, prev, 0, 0);
          break;
        case RoadTypes.MIDDLE_RTL:
          Phaser.Display.Align.To.LeftBottom(next, prev, 0, 0);
          break;
      }
    }
    setConfig(config) {
      this.config.type = config.type;
      this.config.state = config.state;
      const borderFrame = this.getBorderFrame(config.type);
      this.border.setFrame(borderFrame);
      this.border.setFlipX(config.type === RoadTypes.TOP_LEFT || config.type === RoadTypes.BOTTOM_RIGHT);
      const roadFrame = this.getRoadFrame(config.type);
      this.road.setFrame(roadFrame);
      this.road.setFlipX(false);
      this.road.setPosition(0, 0);
      switch (config.type) {
        case RoadTypes.TOP_LEFT:
          this.road.setFlipX(true);
          this.road.setPosition(3.5, 2.75);
          break;
        case RoadTypes.TOP_RIGHT:
          this.road.setPosition(-3.5, 2.75);
          break;
        case RoadTypes.BOTTOM_LEFT:
          this.road.setPosition(3.5, -2.75);
          break;
        case RoadTypes.BOTTOM_RIGHT:
          this.road.setFlipX(true);
          this.road.setPosition(-3.5, -2.75);
          break;
      }
      if (config.state === RoadStates.EMPTY) {
        this.road.kill();
      } else {
        this.road.revive();
      }
    }
    create(config) {
      const { type, state } = config;
      this.border = this.createBorder(type);
      this.add(this.border);
      this.road = this.createRoad(type);
      this.add(this.road);
      if (state === RoadStates.EMPTY) {
        this.road.kill();
      }
    }
    createBorder(type) {
      const frame = this.getBorderFrame(type);
      const border = this.scene.make.image({
        key: JOURNEY_KEY,
        frame
      });
      if (type === RoadTypes.TOP_LEFT || type === RoadTypes.BOTTOM_RIGHT) {
        border.setFlipX(true);
      }
      return border;
    }
    getBorderFrame(type) {
      switch (type) {
        case RoadTypes.TOP_LEFT:
        case RoadTypes.TOP_RIGHT:
          return JOURNEY_FRAME.BORDER_RIGHT;
        case RoadTypes.BOTTOM_LEFT:
        case RoadTypes.BOTTOM_RIGHT:
          return JOURNEY_FRAME.BORDER_LEFT;
        case RoadTypes.MIDDLE_LTR:
        case RoadTypes.MIDDLE_RTL:
          return JOURNEY_FRAME.BORDER_MIDDLE;
      }
    }
    getRoadFrame(type) {
      switch (type) {
        case RoadTypes.TOP_LEFT:
        case RoadTypes.TOP_RIGHT:
          return JOURNEY_FRAME.ROAD_RIGHT;
        case RoadTypes.BOTTOM_LEFT:
        case RoadTypes.BOTTOM_RIGHT:
          return JOURNEY_FRAME.ROAD_LEFT;
        case RoadTypes.MIDDLE_LTR:
        case RoadTypes.MIDDLE_RTL:
          return JOURNEY_FRAME.ROAD_MIDDLE;
      }
    }
    createRoad(type) {
      const frame = this.getRoadFrame(type);
      const road = this.scene.make.image({
        key: JOURNEY_KEY,
        frame
      });
      switch (type) {
        case RoadTypes.TOP_LEFT:
          road.setFlipX(true);
          road.setPosition(road.x + 3.5, road.y + 2.75);
          break;
        case RoadTypes.TOP_RIGHT:
          road.setPosition(road.x - 3.5, road.y + 2.75);
          break;
        case RoadTypes.BOTTOM_LEFT:
          road.setPosition(road.x + 3.5, road.y - 2.75);
          break;
        case RoadTypes.BOTTOM_RIGHT:
          road.setFlipX(true);
          road.setPosition(road.x - 3.5, road.y - 2.75);
          break;
      }
      return road;
    }
  };

  // src/game/screens/journey-screen/JourneyKnob.ts
  init_phaser_custom_min();
  var { KEY: JOURNEY_KEY2, FRAME: JOURNEY_FRAME2 } = sprites_default.JOURNEY;
  var KnobStates = {
    ACTIVE: "active",
    INACTIVE: "inactive",
    COMPLETED: "completed"
  };
  var JourneyKnob = class extends Phaser.GameObjects.Container {
    background;
    label;
    glow;
    config;
    scaleUpAnimation;
    glowScaleUpLoopAnimation;
    glowOriginScale;
    constructor(scene, config) {
      super(scene);
      this.config = config;
      this.create(config);
      this.scene.add.existing(this);
    }
    setKnobState(state) {
      this.config.state = state;
      if (state === KnobStates.INACTIVE) {
        this.background.setFrame(JOURNEY_FRAME2.LEVEL_INACTIVE);
      } else if (state === KnobStates.ACTIVE) {
        this.background.setFrame(JOURNEY_FRAME2.LEVEL_ACTIVE);
      } else if (state === KnobStates.COMPLETED) {
        this.background.setFrame(JOURNEY_FRAME2.LEVEL_COMPLETED);
      }
    }
    static getKnobPositionOffset(index, lowerBound) {
      const offsetIndex = index - lowerBound + 1;
      const KNOB_Y_OFFSET = 74;
      const SIDE_KNOB_X_OFFSET = 80;
      const SIDE_KNOB_FIRST_Y_OFFSET = 75;
      const MIDDLE_KNOB_X_OFFSET = 35;
      const MIDDLE_KNOB_FIRST_Y_OFFSET = 35;
      const isSideKnob = index % 3 === 0;
      if (isSideKnob) {
        const isLeftKnob2 = index % 2 === 0;
        const isFirstKnob = offsetIndex === 3;
        const x2 = isLeftKnob2 ? -SIDE_KNOB_X_OFFSET : SIDE_KNOB_X_OFFSET;
        const y2 = isFirstKnob ? SIDE_KNOB_FIRST_Y_OFFSET : SIDE_KNOB_FIRST_Y_OFFSET + KNOB_Y_OFFSET *
        (Math.floor(offsetIndex / 3) - 1);
        return { x: x2, y: y2 };
      }
      const isLeftKnob = index % 2 === 1;
      const areFirstKnobs = offsetIndex === 1 || offsetIndex === 2;
      const x = isLeftKnob ? -MIDDLE_KNOB_X_OFFSET : MIDDLE_KNOB_X_OFFSET;
      const y = areFirstKnobs ? MIDDLE_KNOB_FIRST_Y_OFFSET : MIDDLE_KNOB_FIRST_Y_OFFSET + KNOB_Y_OFFSET *
      Math.floor(offsetIndex / 3);
      return { x, y };
    }
    setConfig(config) {
      this.config.state = config.state;
      this.config.label = config.label;
      const backgroundFrame = this.getBackgroundFrame(config.state);
      this.background.setFrame(backgroundFrame);
      this.label.setText(config.label);
      Phaser.Display.Align.In.Center(this.label, this.background, 0, -5);
      if (config.state === KnobStates.ACTIVE) {
        this.glow.revive();
        this.runGlowScaleUpLoopAnimation(0, 700);
      } else {
        this.glow.kill();
        this.glowScaleUpLoopAnimation?.stop();
      }
    }
    create(config) {
      const { state, label } = config;
      this.glow = this.createGlow();
      this.background = this.createBackground(state);
      this.label = this.createText(label);
      this.add([this.glow, this.background, this.label]);
      if (state !== KnobStates.ACTIVE) {
        this.glow.kill();
      }
      this.setSize(this.background.width, this.background.height);
    }
    createGlow() {
      const glow = this.scene.make.image({
        key: JOURNEY_KEY2,
        frame: JOURNEY_FRAME2.GLOW
      });
      this.glowOriginScale = glow.scale;
      return glow;
    }
    createBackground(state) {
      const frame = this.getBackgroundFrame(state);
      const background = this.scene.make.image({
        key: JOURNEY_KEY2,
        frame
      });
      return background;
    }
    getBackgroundFrame(state) {
      switch (state) {
        case KnobStates.INACTIVE:
          return JOURNEY_FRAME2.LEVEL_INACTIVE;
        case KnobStates.ACTIVE:
          return JOURNEY_FRAME2.LEVEL_ACTIVE;
        case KnobStates.COMPLETED:
          return JOURNEY_FRAME2.LEVEL_COMPLETED;
      }
    }
    createText(label) {
      const text = FontUtils_default.createShadowText(this.scene, label, 15);
      text.setFontStyle("900");
      return text;
    }
    runEntranceAnimation(delay, duration, signal) {
      this.scaleUpAnimation = this.scene.tweens.add({
        targets: [this],
        delay,
        duration,
        props: {
          scale: { from: 0, to: 1 }
        },
        ease: Phaser.Math.Easing.Back.Out
      });
      this.setScale(0);
      this.scaleUpAnimation.stop();
      AnimUtils.runTween(this.scaleUpAnimation, signal);
      if (this.config.state === KnobStates.ACTIVE) {
        this.runGlowScaleUpLoopAnimation(delay, 700, signal);
      }
    }
    runGlowScaleUpLoopAnimation(delay, duration, signal) {
      this.glowScaleUpLoopAnimation = this.scene.tweens.add({
        targets: [this.glow],
        delay,
        duration,
        repeat: -1,
        props: {
          scale: { from: this.glowOriginScale, to: this.glowOriginScale * 1.5 },
          alpha: { from: 1, to: 0 }
        },
        ease: Phaser.Math.Easing.Expo.Out
      });
      AnimUtils.runTween(this.glowScaleUpLoopAnimation, signal);
    }
  };

  // src/utils/ThemeUtils.ts
  init_phaser_custom_min();

  // src/constants/Themes.ts
  init_phaser_custom_min();
  var { FRAME: JOURNEY_FRAME3 } = sprites_default.JOURNEY;
  var { FRAME: DASHBOARD_FRAME } = sprites_default.DASHBOARD;
  var ThemeKeys = {
    BANGKOK: "BANGKOK",
    BARCELONA: "BARCELONA",
    DUBAI: "DUBAI",
    LAS_VEGAS: "LAS_VEGAS",
    LONDON: "LONDON",
    NEW_YORK: "NEW_YORK",
    PARIS: "PARIS",
    ROME: "ROME",
    SINGAPORE: "SINGAPORE",
    TOKYO: "TOKYO",
    ARGENTINA: "ARGENTINA",
    INDIA: "INDIA",
    AUSTRALIA: "AUSTRALIA",
    BRAZIL: "BRAZIL",
    CANADA: "CANADA",
    DENMARK: "DENMARK",
    EGYPT: "EGYPT"
  };
  var ThemeKeyArray = [
    ThemeKeys.PARIS,
    ThemeKeys.LONDON,
    ThemeKeys.TOKYO,
    ThemeKeys.DUBAI,
    ThemeKeys.NEW_YORK,
    ThemeKeys.BANGKOK,
    ThemeKeys.BARCELONA,
    ThemeKeys.LAS_VEGAS,
    ThemeKeys.ROME,
    ThemeKeys.SINGAPORE,
    ThemeKeys.ARGENTINA,
    ThemeKeys.INDIA,
    ThemeKeys.AUSTRALIA,
    ThemeKeys.BRAZIL,
    ThemeKeys.CANADA,
    ThemeKeys.DENMARK,
    ThemeKeys.EGYPT
  ];
  function validateThemeKeyArray() {
    const missingKeys = { ...ThemeKeys };
    for (const key of ThemeKeyArray) {
      delete missingKeys[key];
    }
    if (Object.keys(missingKeys).length > 0) {
      console.warn(`Missing theme keys: ${Object.keys(missingKeys).join(", ")}`);
    }
  }
  validateThemeKeyArray();
  var ThemeNames = {
    [ThemeKeys.BANGKOK]: "Bangkok",
    [ThemeKeys.BARCELONA]: "Barcelona",
    [ThemeKeys.DUBAI]: "Dubai",
    [ThemeKeys.LAS_VEGAS]: "Las Vegas",
    [ThemeKeys.LONDON]: "London",
    [ThemeKeys.NEW_YORK]: "New York",
    [ThemeKeys.PARIS]: "Paris",
    [ThemeKeys.ROME]: "Rome",
    [ThemeKeys.SINGAPORE]: "Singapore",
    [ThemeKeys.TOKYO]: "Tokyo",
    [ThemeKeys.ARGENTINA]: "Argentina",
    [ThemeKeys.INDIA]: "India",
    [ThemeKeys.AUSTRALIA]: "Australia",
    [ThemeKeys.BRAZIL]: "Brazil",
    [ThemeKeys.CANADA]: "Canada",
    [ThemeKeys.DENMARK]: "Denmark",
    [ThemeKeys.EGYPT]: "Egypt"
  };
  var ThemeFramesJourney = {
    [ThemeKeys.BANGKOK]: JOURNEY_FRAME3.THEME_BANGKOK,
    [ThemeKeys.BARCELONA]: JOURNEY_FRAME3.THEME_BARCELONA,
    [ThemeKeys.DUBAI]: JOURNEY_FRAME3.THEME_DUBAI,
    [ThemeKeys.LAS_VEGAS]: JOURNEY_FRAME3.THEME_LAS_VEGAS,
    [ThemeKeys.LONDON]: JOURNEY_FRAME3.THEME_LONDON,
    [ThemeKeys.NEW_YORK]: JOURNEY_FRAME3.THEME_NEW_YORK,
    [ThemeKeys.PARIS]: JOURNEY_FRAME3.THEME_PARIS,
    [ThemeKeys.ROME]: JOURNEY_FRAME3.THEME_ROME,
    [ThemeKeys.SINGAPORE]: JOURNEY_FRAME3.THEME_SINGAPORE,
    [ThemeKeys.TOKYO]: JOURNEY_FRAME3.THEME_TOKYO,
    [ThemeKeys.ARGENTINA]: JOURNEY_FRAME3.THEME_ARGENTINA,
    [ThemeKeys.INDIA]: JOURNEY_FRAME3.THEME_INDIA,
    [ThemeKeys.AUSTRALIA]: JOURNEY_FRAME3.THEME_AUSTRALIA,
    [ThemeKeys.BRAZIL]: JOURNEY_FRAME3.THEME_BRAZIL,
    [ThemeKeys.CANADA]: JOURNEY_FRAME3.THEME_CANADA,
    [ThemeKeys.DENMARK]: JOURNEY_FRAME3.THEME_DENMARK,
    [ThemeKeys.EGYPT]: JOURNEY_FRAME3.THEME_EGYPT
  };
  var ThemeFramesDashboard = {
    [ThemeKeys.BANGKOK]: DASHBOARD_FRAME.THEME_BANGKOK,
    [ThemeKeys.BARCELONA]: DASHBOARD_FRAME.THEME_BARCELONA,
    [ThemeKeys.DUBAI]: DASHBOARD_FRAME.THEME_DUBAI,
    [ThemeKeys.LAS_VEGAS]: DASHBOARD_FRAME.THEME_LAS_VEGAS,
    [ThemeKeys.LONDON]: DASHBOARD_FRAME.THEME_LONDON,
    [ThemeKeys.NEW_YORK]: DASHBOARD_FRAME.THEME_NEW_YORK,
    [ThemeKeys.PARIS]: DASHBOARD_FRAME.THEME_PARIS,
    [ThemeKeys.ROME]: DASHBOARD_FRAME.THEME_ROME,
    [ThemeKeys.SINGAPORE]: DASHBOARD_FRAME.THEME_SINGAPORE,
    [ThemeKeys.TOKYO]: DASHBOARD_FRAME.THEME_TOKYO,
    [ThemeKeys.ARGENTINA]: DASHBOARD_FRAME.THEME_ARGENTINA,
    [ThemeKeys.INDIA]: DASHBOARD_FRAME.THEME_INDIA,
    [ThemeKeys.AUSTRALIA]: DASHBOARD_FRAME.THEME_AUSTRALIA,
    [ThemeKeys.BRAZIL]: DASHBOARD_FRAME.THEME_BRAZIL,
    [ThemeKeys.CANADA]: DASHBOARD_FRAME.THEME_CANADA,
    [ThemeKeys.DENMARK]: DASHBOARD_FRAME.THEME_DENMARK,
    [ThemeKeys.EGYPT]: DASHBOARD_FRAME.THEME_EGYPT
  };

  // src/utils/ThemeUtils.ts
  var ThemeUtils = class {
    static getThemeFrameForJourneyScreen(theme) {
      const themeKey = theme ?? this.getThemeKey();
      return ThemeFramesJourney[themeKey];
    }
    static getThemeFrameForDashboardComponent(theme) {
      const themeKey = theme ?? this.getThemeKey();
      return ThemeFramesDashboard[themeKey];
    }
    static getThemeName(theme) {
      const themeKey = theme ?? this.getThemeKey();
      return ThemeNames[themeKey];
    }
    static getThemeKey(level) {
      const currentLevel = level ?? PlayerUtils_default.getLevelProgress();
      const themeIndex = currentLevel <= 0 ? 0 : Math.floor((currentLevel - 1) / 10);
      const clampedThemeIndex = themeIndex % ThemeKeyArray.length;
      const themeKey = ThemeKeyArray[clampedThemeIndex];
      return themeKey;
    }
    static getThemeProgress(level) {
      const currentLevel = level ?? PlayerUtils_default.getLevelProgress();
      const finishedLevel = currentLevel - 1;
      const lowerBound = finishedLevel - finishedLevel % 10;
      return Phaser.Math.Clamp((finishedLevel - lowerBound) / 10, 0, 1);
    }
    static isLastLevelOfTheme(level) {
      const currentLevel = level ?? PlayerUtils_default.getLevelProgress();
      if (currentLevel <= 0) return false;
      return currentLevel % 10 === 0;
    }
  };

  // src/game/screens/journey-screen/JourneyGroupOfThree.ts
  init_phaser_custom_min();

  // src/game/screens/journey-screen/JourneyFrame.ts
  init_phaser_custom_min();

  // src/game/animations/lerp/remap.ts
  init_phaser_custom_min();
  function remap(value, min, max, newMin, newMax) {
    return newMin + (newMax - newMin) * (value - min) / (max - min);
  }

  // src/game/screens/journey-screen/JourneyFrame.ts
  var { KEY: JOURNEY_KEY3, FRAME: JOURNEY_FRAME4 } = sprites_default.JOURNEY;
  var JourneyFrame = class extends Phaser.GameObjects.Container {
    frame;
    theme;
    label;
    check;
    frameScale = 1;
    frameAngle = 0;
    constructor(scene, config) {
      super(scene);
      this.create(config);
    }
    static getFramePositionOffset(index, lowerBound) {
      const { x: knobX, y: knobY } = JourneyKnob.getKnobPositionOffset(index, lowerBound);
      const isSideKnob = index % 3 === 0;
      if (isSideKnob) {
        const isLeftKnob2 = index % 2 === 0;
        const x2 = isLeftKnob2 ? knobX - 4 : knobX + 4;
        const y2 = knobY - 50;
        return { x: x2, y: y2 };
      }
      const isLeftKnob = index % 2 === 1;
      const x = isLeftKnob ? knobX - 4 : knobX + 4;
      const y = knobY - 50;
      return { x, y };
    }
    static getFrameScale(index) {
      const isSideKnob = index % 3 === 0;
      const scale = isSideKnob ? 1 : 0.7;
      return scale;
    }
    static getFrameAngle(index) {
      const isSideKnob = index % 3 === 0;
      if (isSideKnob) {
        const isLeftKnob2 = index % 2 === 0;
        const angle2 = isLeftKnob2 ? Phaser.Math.FloatBetween(-20, -15) : Phaser.Math.FloatBetween(15,
        20);
        return angle2;
      }
      const isLeftKnob = index % 2 === 1;
      const angle = isLeftKnob ? Phaser.Math.FloatBetween(-15, -10) : Phaser.Math.FloatBetween(10, 15);
      return angle;
    }
    setFrameScale(scale) {
      this.frameScale = scale;
      this.setScale(this.frameScale);
    }
    setFrameAngle(angle) {
      this.frameAngle = angle;
      this.setAngle(this.frameAngle);
    }
    create(config) {
      this.frame = this.createFrame();
      this.add(this.frame);
      this.theme = this.createTheme(config.theme);
      this.add(this.theme);
      this.label = this.createLabel(config.theme);
      this.add(this.label);
      this.check = this.createCheck();
      this.add(this.check);
      if (!config.checked) {
        this.check.kill();
      }
      this.setSize(this.frame.width, this.frame.height);
    }
    createFrame() {
      const frame = this.scene.make.image({
        key: JOURNEY_KEY3,
        frame: JOURNEY_FRAME4.THEME_FRAME
      });
      return frame;
    }
    createTheme(theme) {
      const frameKey = ThemeUtils.getThemeFrameForJourneyScreen(theme);
      const themeImage = this.scene.make.image({
        key: JOURNEY_KEY3,
        frame: frameKey,
        origin: { x: 0.5, y: 0.5 }
      });
      return themeImage;
    }
    createLabel(theme) {
      const name = ThemeUtils.getThemeName(theme);
      const capitalized = name.toUpperCase();
      const text = FontUtils_default.createText(this.scene, capitalized, 10).setFontStyle("800");
      FontUtils_default.applyWoodStyle(text);
      return text;
    }
    createCheck() {
      const check = this.scene.make.image({
        key: JOURNEY_KEY3,
        frame: JOURNEY_FRAME4.ICON_CHECK
      });
      return check;
    }
    setConfig(config) {
      const frameKey = ThemeUtils.getThemeFrameForJourneyScreen(config.theme);
      this.theme.setFrame(frameKey);
      const name = ThemeUtils.getThemeName(config.theme);
      const capitalized = name.toUpperCase();
      this.label.setText(capitalized);
      if (config.checked) {
        this.check.revive();
      } else {
        this.check.kill();
      }
      Phaser.Display.Align.In.Center(this.theme, this.frame, 0, -10);
      Phaser.Display.Align.In.BottomLeft(this.label, this.frame, -4, -10);
      const isLabelLong = this.label.text.length > 5;
      if (isLabelLong) {
        Phaser.Display.Align.In.BottomRight(this.check, this.frame, -6, -30);
      } else {
        Phaser.Display.Align.In.BottomRight(this.check, this.frame, -6, -10);
      }
    }
    setHiddenPercentage(value) {
      const scale = remap(value, 0, 1, this.frameScale, 0);
      this.setScale(scale);
      const angle = remap(value, 0, 1, this.frameAngle, 0);
      this.setAngle(angle);
    }
  };

  // src/game/screens/journey-screen/JourneyGroupOfThree.ts
  var {
    Utils: { Signal: S7 }
  } = Ludex;
  var DEFAULT_CONFIG = {
    type: "full",
    playerLevel: 1,
    currentLevel: 1,
    frame: {
      checked: false,
      theme: ThemeKeyArray[0]
    },
    roads: [
      {
        type: RoadTypes.TOP_LEFT,
        state: RoadStates.EMPTY
      },
      {
        type: RoadTypes.MIDDLE_LTR,
        state: RoadStates.EMPTY
      },
      {
        type: RoadTypes.BOTTOM_RIGHT,
        state: RoadStates.EMPTY
      }
    ],
    knobs: [
      {
        label: "1",
        state: KnobStates.ACTIVE
      },
      {
        label: "2",
        state: KnobStates.INACTIVE
      },
      {
        label: "3",
        state: KnobStates.INACTIVE
      }
    ]
  };
  var JourneyGroupOfThree = class extends Phaser.GameObjects.Container {
    config;
    frame;
    roads;
    knobs;
    entranceAnimController = new S7.SignalController();
    lastLevelOfTheme;
    constructor(scene) {
      super(scene);
      this.config = DEFAULT_CONFIG;
      this.roads = this.config.roads.map((road) => new JourneyRoad(this.scene, road));
      this.knobs = this.config.knobs.map((knob) => new JourneyKnob(this.scene, knob));
      this.frame = new JourneyFrame(this.scene, this.config.frame);
      this.add([...this.roads, ...this.knobs, this.frame]);
      this.alignRoads();
      this.alignKnobs();
      this.lastLevelOfTheme = this.findLastLevelOfTheme();
      this.alignFrame();
      this.setSize(this.getWidth(), 72);
    }
    setConfig(config) {
      this.config = config;
      if (this.config.type === "full") {
        this.setFullConfig(this.config);
      } else {
        this.setRoadOnlyConfig(this.config);
      }
    }
    setFullConfig(config) {
      for (let i = 0; i < this.roads.length; i++) {
        const road = this.roads[i];
        road.revive();
        road.setConfig(config.roads[i]);
      }
      for (let i = 0; i < this.knobs.length; i++) {
        const knob = this.knobs[i];
        knob.revive();
        knob.setConfig(config.knobs[i]);
      }
      this.frame.revive();
      this.frame.setConfig(config.frame);
      this.alignRoads();
      this.alignKnobs();
      this.lastLevelOfTheme = this.findLastLevelOfTheme();
      this.alignFrame();
    }
    setRoadOnlyConfig(config) {
      for (let i = 0; i < this.roads.length; i++) {
        this.roads[i].setConfig(config.roads[i]);
      }
      for (const knob of this.knobs) {
        knob.kill();
      }
      this.frame.kill();
      this.alignRoads();
      this.lastLevelOfTheme = this.findLastLevelOfTheme();
    }
    getWidth() {
      let sum = 0;
      for (const road of this.roads) {
        sum += road.width;
      }
      return sum;
    }
    alignRoads() {
      const startsFromTheLeft = this.config.currentLevel >= 0 ? Math.floor(this.config.currentLevel %
      6) < 3 : -Math.floor(this.config.currentLevel % 6) >= 3;
      const firstRoad = this.roads[0];
      firstRoad.setPosition(startsFromTheLeft ? -62 : 62, -10);
      for (let i = 1; i < this.roads.length; i++) {
        const prevRoad = this.roads[i - 1];
        const currentRoad = this.roads[i];
        JourneyRoad.alignRoad(prevRoad, currentRoad);
      }
      for (const road of this.roads) {
        road.setY(road.y + 22);
      }
    }
    alignKnobs() {
      const SIDE_KNOB_X_OFFSET = 85;
      const MIDDLE_KNOB_X_OFFSET = 35;
      const SIDE_KNOB_Y_OFFSET = -65;
      const MIDDLE_KNOB_Y_OFFSET = -25;
      const flipped = Math.floor(this.config.currentLevel % 6) < 3;
      this.knobs[0].setPosition(flipped ? -MIDDLE_KNOB_X_OFFSET : MIDDLE_KNOB_X_OFFSET, MIDDLE_KNOB_Y_OFFSET);
      this.knobs[1].setPosition(flipped ? MIDDLE_KNOB_X_OFFSET : -MIDDLE_KNOB_X_OFFSET, MIDDLE_KNOB_Y_OFFSET);
      this.knobs[2].setPosition(flipped ? SIDE_KNOB_X_OFFSET : -SIDE_KNOB_X_OFFSET, SIDE_KNOB_Y_OFFSET);
      for (const knob of this.knobs) {
        knob.setY(knob.y + 22);
      }
    }
    findLastLevelOfTheme() {
      const levels = [this.config.currentLevel, this.config.currentLevel + 1, this.config.currentLevel +
      2];
      return levels.find((level) => ThemeUtils.isLastLevelOfTheme(level));
    }
    alignFrame() {
      if (this.lastLevelOfTheme === void 0) {
        this.frame.setVisible(false);
        return;
      }
      this.frame.setVisible(true);
      const { x, y } = JourneyFrame.getFramePositionOffset(this.lastLevelOfTheme, this.lastLevelOfTheme);
      this.frame.setPosition(x, y);
      this.frame.setFrameScale(JourneyFrame.getFrameScale(this.lastLevelOfTheme));
      this.frame.setFrameAngle(JourneyFrame.getFrameAngle(this.lastLevelOfTheme));
    }
    runEntranceAnimation(delayIndex = 0) {
      if (this.config.type === "road-only") return;
      const signal = this.entranceAnimController.renew();
      const delay = delayIndex * 30;
      for (let i = 0; i < this.knobs.length; i++) {
        this.knobs[i].runEntranceAnimation(delay + i * 30, 200, signal);
      }
    }
    runExitAnimation(_listIndex = 0) {
      if (this.config.type === "road-only") return;
      this.entranceAnimController.abort();
    }
  };

  // src/game/components/scroller/InfiniteScroller.ts
  init_phaser_custom_min();
  var InfiniteScroller = class extends ReuseScroller {
    configGenerator;
    configChecker;
    constructor(scene, config) {
      super(scene, config);
      this.configGenerator = config.infinite.generate;
      this.configChecker = config.infinite.check;
    }
    getConfigs() {
      return this.configs;
    }
    scrollToConfig(index, immediate = false, snapToBounds = true) {
      if (index < 0 || index >= this.configs.length) return;
      const maxObjHeight = this.getMaxObjectHeight();
      const yAfterMargin = -this.content.height / 2 + this.visualConfig.margin.top;
      const objHeightWithSpacing = maxObjHeight + this.visualConfig.spacing;
      const targetY = yAfterMargin + index * objHeightWithSpacing + maxObjHeight / 2;
      this.scrollTo(-targetY, immediate, snapToBounds);
    }
    addConfigs(configs, where) {
      if (where === "before") {
        this.configs = [...configs, ...this.configs];
        this.contentGameObjects = [
          ...configs.map((c) => ({ config: c, gameObject: void 0 })),
          ...this.contentGameObjects
        ];
      } else {
        this.configs = [...this.configs, ...configs];
        this.contentGameObjects = [
          ...this.contentGameObjects,
          ...configs.map((c) => ({ config: c, gameObject: void 0 }))
        ];
      }
      const contentHeight = this.calcContentHeight();
      this.setInfiniteContentHeight(contentHeight, where);
      this.updateObjectPosition();
    }
    setInfiniteContentHeight(height, where) {
      this.isScrolling = true;
      const currentY = this.content.y;
      const offsetY = (height - this.content.height) / 2;
      const newY = where === "before" ? currentY - offsetY : currentY + offsetY;
      const newTargetY = where === "before" ? this.targetY - offsetY : this.targetY + offsetY;
      this.content.setWorldSize(this.width, height);
      this.content.setY(newY);
      this.targetY = newTargetY;
    }
    updateObjectVisibility() {
      super.updateObjectVisibility();
      if (this.contentGameObjects.length === 0) return;
      const hasUsedTopConfig = this.contentGameObjects[0]?.gameObject !== void 0 && this.configChecker(
      this.configs[0], -1);
      const hasUsedBottomConfig = this.contentGameObjects[this.contentGameObjects.length - 1]?.gameObject !==
      void 0 && this.configChecker(this.configs[this.configs.length - 1], 1);
      if (hasUsedTopConfig) {
        const generated = this.configGenerator(this.configs[0], -1);
        if (generated.length === 0) return;
        this.addConfigs(generated, "before");
        return;
      }
      if (hasUsedBottomConfig) {
        const generated = this.configGenerator(this.configs[this.configs.length - 1], 1);
        if (generated.length === 0) return;
        this.addConfigs(generated, "after");
      }
    }
    calcDistUnderTop(y) {
      if (this.configs.length === 0) return super.calcDistUnderTop(y);
      const canGenerate = this.configChecker(this.configs[0], -1);
      if (canGenerate) return 0;
      return super.calcDistUnderTop(y);
    }
    calcDistAboveBottom(y) {
      if (this.configs.length === 0) return super.calcDistAboveBottom(y);
      const canGenerate = this.configChecker(this.configs[this.configs.length - 1], 1);
      if (canGenerate) return 0;
      return super.calcDistAboveBottom(y);
    }
  };

  // src/game/screens/journey-screen/JourneyScreen.ts
  var {
    Utils: { Valid: V17, Array: A6 }
  } = Ludex;
  var { KEY: KEY84, FRAME: FRAME86 } = sprites_default.DEFAULT;
  var { KEY: JOURNEY_KEY4, FRAME: JOURNEY_FRAME5 } = sprites_default.JOURNEY;
  var { event: event39 } = codex;
  var JourneyScreen = class extends Screen_default {
    popup;
    scroller;
    backButton;
    playButton;
    sceneObjectsOriginalY = [];
    popupFadeInAnimation;
    popupFadeOutAnimation;
    incY(y) {
      super.incY(y);
      this.popup.y -= y;
    }
    incX(x) {
      super.incX(x);
      this.popup.x -= x;
    }
    incScale(scale) {
      super.incScale(scale);
      this.popup.scale -= scale ^ scale * (100 / scale);
    }
    constructor(scene, name) {
      super(scene, name);
      this.createPopup();
      this.createButtons();
      this.createJourney();
      this.popup.bringToTop(this.playButton);
      this.popup.bringToTop(this.backButton);
      this.createInput();
      this.background.setAlpha(0);
      this.setDepth(ScreenDepth_default.POPUP);
      this.listenToEvents();
    }
    open() {
      super.open();
      this.scrollToPlayerLevelConfig();
      this.updatePlayButton();
      this.runOpenAnimation();
    }
    preDestroy() {
      this.unlistenToEvents();
      super.preDestroy();
    }
    listenToEvents() {
      event39.on(GameEvents_default.VIEW_RESIZED, this.onViewResized);
      event39.on(GameEvents_default.LAYOUT_CHANGED, this.onViewResized);
    }
    unlistenToEvents() {
      event39.off(GameEvents_default.VIEW_RESIZED, this.onViewResized);
      event39.off(GameEvents_default.LAYOUT_CHANGED, this.onViewResized);
    }
    onViewResized = (payload) => {
      if (!this.scene.scene.isActive()) return;
      const { width, height } = payload;
      this.popup.setWorldSize(width, height);
      Phaser.Display.Align.In.Center(this.popup, this.zone);
      Phaser.Display.Align.In.Center(this.scroller, this.popup);
      Phaser.Display.Align.In.TopLeft(this.backButton, this.popup, -15, -15);
      Phaser.Display.Align.In.BottomCenter(this.playButton, this.popup, 0, -65);
    };
    scrollToPlayerLevelConfig() {
      const isConfigInRange = (config) => {
        const { playerLevel, currentLevel } = config;
        return playerLevel <= currentLevel && currentLevel <= playerLevel + 2;
      };
      const index = A6.searchIndex(this.scroller.getConfigs(), isConfigInRange);
      if (index === -1) return;
      this.scroller.scrollToConfig(index, true);
    }
    getPlayerLevel() {
      const { player: player33 } = codex;
      const { level } = player33.getGameData() ?? {};
      return V17.isNumber(level) ? level : 1;
    }
    createInput() {
      this.backButton.setButtonHitSoundEffect(soundEffects_default.CLOSE_POPUP_CLICK);
      this.backButton.onClick = this.handleClose.bind(this);
    }
    handleClose() {
      this.runCloseAnimation();
    }
    createPopup() {
      const { width } = WorldUtils_default.getWorldSize();
      const maxWidth = Math.min(width, 600);
      this.popup = this.scene.add.container(0, 0);
      this.popup.setWorldSize(maxWidth, this.zone.height);
      this.add(this.popup);
      Phaser.Display.Align.In.Center(this.popup, this.zone);
    }
    createButtons() {
      this.createBackButton();
      this.createPlayButton();
    }
    createScroller() {
      const scrollerHeight = this.zone.height;
      this.scroller = new InfiniteScroller(this.scene, {
        size: { width: 300, height: scrollerHeight },
        maxOverScroll: {
          bottom: 0
        },
        visual: {
          boundDetectionPadding: {
            top: -50,
            bottom: -100
          },
          margin: {
            bottom: -25
          },
          onEnterViewport: (obj) => {
            const group = obj;
            group.runEntranceAnimation();
          },
          onExitViewport: (obj) => {
            const group = obj;
            group.runExitAnimation();
          }
        },
        reuse: {
          depthStrategy: "bottom-to-top",
          ClassType: JourneyGroupOfThree,
          configs: [],
          update: (obj, config) => {
            obj.setConfig(config);
          }
        },
        infinite: {
          generate: (lastConfig, direction) => {
            return this.generateGroupOfThreeConfigs(lastConfig.playerLevel, lastConfig.currentLevel,
            direction);
          },
          check: (lastConfig, direction) => {
            return this.hasGroupsOfThreeAvailable(lastConfig.currentLevel, direction);
          }
        }
      });
      this.popup.add(this.scroller);
      Phaser.Display.Align.In.Center(this.scroller, this.popup);
      this.scroller.setEnabled();
    }
    createJourney() {
      const playerLevel = this.getPlayerLevel();
      const levelsToSubtract = 11;
      const correctLevelsToSubtract = levelsToSubtract - (levelsToSubtract + 1) % 3 + playerLevel % 3;
      const levelsToAddToLowerBound = 40;
      const correctLevelsToAddToLowerBound = levelsToAddToLowerBound - (levelsToAddToLowerBound + 1) %
      3 + playerLevel % 3 % 3;
      const lowerBound = Phaser.Math.MinSub(playerLevel, correctLevelsToSubtract, 1);
      const upperBound = lowerBound + correctLevelsToAddToLowerBound;
      this.createScroller();
      const configs = this.createGroupOfThreeConfigs(playerLevel, lowerBound, upperBound);
      configs.reverse();
      this.scroller.setConfigs(configs);
      this.scrollToPlayerLevelConfig();
    }
    generateGroupOfThreeConfigs(playerLevel, currentLevel, direction) {
      const isGettingBottomConfigs = direction === 1;
      if (currentLevel === -5 && isGettingBottomConfigs) return [];
      const count = 10;
      const startLevel = Math.max(isGettingBottomConfigs ? currentLevel - 3 * count : currentLevel +
      3, -5);
      const endLevel = isGettingBottomConfigs ? currentLevel - 3 : currentLevel + 3 * count;
      const configs = this.createGroupOfThreeConfigs(playerLevel, startLevel, endLevel);
      configs.reverse();
      return configs;
    }
    hasGroupsOfThreeAvailable(currentLevel, direction) {
      const isGettingBottomConfigs = direction === 1;
      if (currentLevel === -5 && isGettingBottomConfigs) return false;
      return true;
    }
    createGroupOfThreeConfigs(level, lowerBound, upperBound) {
      const configs = [];
      for (let index = lowerBound; index <= upperBound; index += 3) {
        if (index <= 0) {
          const roads2 = this.createRoadConfigs(level, index, index + 2);
          configs.push({
            type: "road-only",
            playerLevel: level,
            currentLevel: index,
            roads: roads2
          });
          continue;
        }
        const knobs = this.createLevelKnobConfigs(level, index, index + 2);
        const frame = this.createThemeFrameConfig(level, index);
        const roads = this.createRoadConfigs(level, index, index + 2);
        configs.push({
          type: "full",
          playerLevel: level,
          currentLevel: index,
          frame,
          roads,
          knobs
        });
      }
      return configs;
    }
    createLevelKnobConfigs(level, lowerBound, upperBound) {
      const configs = [];
      for (let index = lowerBound; index <= upperBound; index++) {
        const isActive = index === level;
        const isCompleted = index < level;
        let state = KnobStates.INACTIVE;
        if (isActive) state = KnobStates.ACTIVE;
        if (isCompleted) state = KnobStates.COMPLETED;
        const label = index.toString();
        configs.push({
          state,
          label
        });
      }
      return configs;
    }
    createRoadConfigs(level, lowerBound, upperBound) {
      const configs = [];
      const startsFromTheLeft = lowerBound >= 0 ? Math.floor(lowerBound % 6) < 3 : -Math.floor(lowerBound %
      6) >= 3;
      let last = {
        state: level >= lowerBound ? RoadStates.FILLED : RoadStates.EMPTY,
        type: startsFromTheLeft ? RoadTypes.TOP_LEFT : RoadTypes.TOP_RIGHT
      };
      configs.push({
        state: level >= lowerBound ? RoadStates.FILLED : RoadStates.EMPTY,
        type: startsFromTheLeft ? RoadTypes.TOP_LEFT : RoadTypes.TOP_RIGHT
      });
      for (let i = lowerBound + 1; i <= upperBound; i++) {
        const road = {
          type: JourneyRoad.getNextRoadType(last.type),
          state: i - 1 < level ? RoadStates.FILLED : RoadStates.EMPTY
        };
        configs.push(road);
        last = road;
      }
      return configs;
    }
    createThemeFrameConfig(playerLevel, level) {
      const isCompleted = level < playerLevel;
      const theme = ThemeUtils.getThemeKey(level);
      return {
        theme,
        checked: isCompleted
      };
    }
    createBackButton() {
      this.backButton = new Button_default(this.scene, KEY84, FRAME86.BUTTON_YELLOW_CIRCLE, 36, 36);
      const icon = this.scene.make.image({
        key: JOURNEY_KEY4,
        frame: JOURNEY_FRAME5.ICON_BACK
      });
      this.backButton.add(icon);
      this.backButton.setName("Back");
      this.popup.add(this.backButton);
      Phaser.Display.Align.In.TopLeft(this.backButton, this.popup, -15, -15);
    }
    createPlayButton() {
      this.playButton = new PlayButton_default(this.scene);
      this.playButton.button.setSize(215, this.playButton.button.height);
      Phaser.Display.Align.In.BottomCenter(this.playButton, this.popup, 0, -65);
      this.popup.add(this.playButton);
      this.playButton.onClick = this.handlePlay;
    }
    updatePlayButton() {
      const playerLevel = this.getPlayerLevel();
      this.playButton.setLevel(playerLevel);
    }
    handlePlay = async () => {
      const success = await MatchUtils_default.startSingleModeAsync();
      if (!success) return;
      SceneUtils_default.switchToGameScene();
    };
    // Animations
    runOpenAnimation() {
      if (this.popupFadeInAnimation?.isPlaying()) return;
      this.runSceneTransitionOutAnimation();
      this.runPopupEntrancesAnimation(0, 400);
      this.runPopupContentEntrancesAnimation();
    }
    runSceneTransitionOutAnimation() {
      const isDashboardScene = this.scene.scene.key === SceneKeys_default.DASHBOARD_SCENE;
      if (!isDashboardScene) return;
      const objectGroup = this.scene.layoutManager.objects;
      const objects = objectGroup.getAll();
      for (const object of objects) {
        this.sceneObjectsOriginalY.push({ object, y: object.y });
      }
      const tw = this.scene.tweens.add({
        targets: objects,
        props: {
          y: "-=100",
          alpha: 0
        },
        duration: 150,
        ease: Phaser.Math.Easing.Cubic.Out
      });
      AnimUtils.runTween(tw);
    }
    runCloseAnimation() {
      if (this.popupFadeOutAnimation?.isPlaying()) return;
      this.runSceneTransitionInAnimation();
      this.runPopupExitsAnimation(0, 200);
    }
    runSceneTransitionInAnimation() {
      const isDashboardScene = this.scene.scene.key === SceneKeys_default.DASHBOARD_SCENE;
      if (!isDashboardScene) return;
      const objectGroup = this.scene.layoutManager.objects;
      const objects = objectGroup.getAll();
      for (const object of objects) {
        const originalY = this.sceneObjectsOriginalY.find((item) => item.object === object)?.y;
        if (!originalY) continue;
        const tw = this.scene.tweens.add({
          targets: [object],
          props: { y: originalY, alpha: 1 },
          duration: 150,
          ease: Phaser.Math.Easing.Cubic.Out
        });
        AnimUtils.runTween(tw);
      }
    }
    // Entrances animations
    runPopupEntrancesAnimation(delay, duration) {
      this.popupFadeInAnimation = this.scene.tweens.add({
        ...FadeIn_default,
        targets: [this.popup],
        delay,
        duration,
        props: {
          y: { from: 350, to: 0 },
          alpha: { from: 0, to: 1 },
          scale: { from: 0.7, to: 1 }
        }
      });
    }
    runPopupContentEntrancesAnimation() {
      const children = this.scroller.getChildren();
      const ordered = [...children].sort((a, b) => b.y - a.y);
      for (let i = 0; i < ordered.length; i++) {
        const group = ordered[i];
        group.runEntranceAnimation(i);
      }
    }
    // Exits animations
    runPopupExitsAnimation(delay, duration) {
      this.popupFadeOutAnimation = this.scene.tweens.add({
        ...FadeOut_default,
        targets: [this.popup],
        delay,
        duration,
        props: {
          ...FadeOut_default.props,
          y: 350,
          scale: { from: 1, to: 0.7 }
        },
        onComplete: () => {
          this.popup.setY(0);
          ScreenUtils_default.closeScreen(this.name);
        }
      });
    }
  };
  var JourneyScreen_default = JourneyScreen;

  // src/game/screens/lucky-wheel-screen/LuckyWheelScreen.ts
  init_phaser_custom_min();

  // src/game/screens/lucky-wheel-screen/HighlightItemContainer.ts
  init_phaser_custom_min();
  var {
    Utils: { Signal: S8 }
  } = Ludex;
  var { KEY: DEFAULT_KEY6, FRAME: DEFAULT_FRAME6 } = sprites_default.DEFAULT;
  var { KEY: DASHBOARD_KEY, FRAME: DASHBOARD_FRAME2 } = sprites_default.DASHBOARD;
  var HighlightItemContainer = class extends Phaser.GameObjects.Container {
    darkenBackground;
    glowBackground;
    highlightItems = [];
    starSparkle;
    animController = new S8.SignalController();
    constructor(scene, width, height, items) {
      super(scene, 0, 0);
      this.setSize(width, height);
      this.createDarkenBackground();
      this.createGlowBackground();
      this.createHighlightItem(items);
      this.createEffects();
    }
    preDestroy() {
      this.animController.abort();
    }
    createDarkenBackground() {
      this.darkenBackground = this.scene.make.image({
        key: DEFAULT_KEY6,
        frame: DEFAULT_FRAME6.BLANK
      });
      this.darkenBackground.setTintFill(0);
      this.darkenBackground.setWorldSize(this.width, this.height);
      this.darkenBackground.kill();
      this.add(this.darkenBackground);
    }
    createGlowBackground() {
      this.glowBackground = this.scene.make.image({
        key: DEFAULT_KEY6,
        frame: DEFAULT_FRAME6.ART_YELLOW_GLOW,
        origin: { x: 0.5, y: 0.5 }
      });
      this.add(this.glowBackground);
      this.glowBackground.kill();
    }
    createHighlightItem(items) {
      this.highlightItems = [];
      for (const element of items) {
        const item = element;
        const info = this.createItem(item);
        if (!info) continue;
        const { icon, label } = info;
        this.highlightItems.push({ icon, label });
        this.add([icon, label]);
        Phaser.Display.Align.In.Center(label, icon, 0, 90);
        icon.kill();
        label.kill();
      }
    }
    createItem(item) {
      const image = this.createItemImage(item);
      if (!image) return null;
      const text = this.createItemText(item);
      this.add([image, text]);
      return { icon: image, label: text };
    }
    createItemImage(item) {
      let frame = null;
      if (item.type === "coin") {
        frame = DASHBOARD_FRAME2.LUCKY_WHEEL_ICON_COIN;
      } else {
        switch (item.id) {
          case item_default.HINT.ID:
            frame = DASHBOARD_FRAME2.LUCKY_WHEEL_ICON_HINT;
            break;
          case item_default.SHUFFLE.ID:
            frame = DASHBOARD_FRAME2.LUCKY_WHEEL_ICON_SHUFFLE;
            break;
          case item_default.BOMB_DEFUSE.ID:
            frame = DASHBOARD_FRAME2.LUCKY_WHEEL_ICON_DEFUSE;
            break;
          case item_default.ROCKET.ID:
            frame = DASHBOARD_FRAME2.LUCKY_WHEEL_ICON_ROCKET;
            break;
          default:
            return null;
        }
      }
      return this.scene.make.image({
        key: DASHBOARD_KEY,
        frame
      });
    }
    createItemText(_item) {
      return FontUtils_default.createShadowText(this.scene, "Item Received", 14).setOrigin(0.5, 0);
    }
    createEffects() {
      this.starSparkle = new StarSparkle_default(this.scene);
      this.add(this.starSparkle);
    }
    runHighlightItemAnimation(index, onComplete) {
      this.runShowHighlightItemAnimation(index, () => {
        this.runHideHighlightItemAnimation(onComplete);
      });
    }
    runShowHighlightItemAnimation(index, onComplete) {
      this.darkenBackground.setAlpha(0);
      this.starSparkle.run(2, 0, 0, 200, 200);
      this.darkenBackground.revive();
      this.glowBackground.revive();
      for (let i = 0; i < this.highlightItems.length; i++) {
        if (i === index) {
          this.highlightItems[i].icon.revive();
          this.highlightItems[i].label.revive();
        } else {
          this.highlightItems[i].icon.kill();
          this.highlightItems[i].label.kill();
        }
      }
      const signal = this.animController.renew();
      AnimUtils.runTween(
        this.scene.tweens.add({
          ...FadeIn_default,
          targets: [this.darkenBackground],
          duration: 300,
          props: {
            alpha: { from: 0, to: 0.8 }
          }
        }),
        signal
      );
      const targets = this.highlightItems.reduce((acc, { icon, label }) => {
        acc.push(icon, label);
        return acc;
      }, []);
      targets.push(this.glowBackground);
      targets.push(this.starSparkle);
      AnimUtils.runTween(
        this.scene.tweens.add({
          ...ScaleUp_default,
          targets,
          duration: 300,
          props: {
            scale: { from: 0, to: 1.4 }
          },
          ease: Phaser.Math.Easing.Cubic.Out
        }),
        signal
      );
      AnimUtils.runTween(
        this.scene.tweens.add({
          targets: [this.glowBackground],
          duration: 2e3,
          props: {
            angle: { from: 0, to: 360 }
          },
          ease: Phaser.Math.Easing.Linear,
          onComplete
        }),
        signal
      );
    }
    runHideHighlightItemAnimation(onComplete) {
      const signal = this.animController.renew();
      AnimUtils.runTween(
        this.scene.tweens.add({
          ...FadeOut_default,
          targets: [this.darkenBackground],
          duration: 300,
          onComplete: () => {
            this.darkenBackground.kill();
          }
        }),
        signal
      );
      const targets = this.highlightItems.reduce((acc, { icon, label }) => {
        acc.push(icon, label);
        return acc;
      }, []);
      targets.push(this.glowBackground);
      targets.push(this.starSparkle);
      AnimUtils.runTween(
        this.scene.tweens.add({
          ...ScaleDown_default,
          targets,
          duration: 300,
          props: {
            scale: 0
          },
          ease: Phaser.Math.Easing.Cubic.In,
          onComplete: () => {
            this.glowBackground.kill();
            for (const item of this.highlightItems) {
              item.icon.kill();
              item.label.kill();
            }
            this.starSparkle.stop();
            onComplete?.();
          }
        }),
        signal
      );
    }
  };

  // src/game/screens/lucky-wheel-screen/NextFreeSpinIndicator.ts
  init_phaser_custom_min();
  var {
    Utils: { Time: T11, Signal: S9 }
  } = Ludex;
  var { player: player24 } = codex;
  var NextFreeSpinIndicator = class extends Phaser.GameObjects.Container {
    label;
    lastUpdate = 0;
    animController = new S9.SignalController();
    constructor(scene) {
      super(scene);
      this.label = this.createLabel();
      this.listenToEvents();
    }
    update(time) {
      if (time - this.lastUpdate > 1e3) {
        this.lastUpdate = time;
        this.updateLabel();
      }
    }
    revive() {
      super.revive();
      this.runFlashingAnimation();
    }
    kill() {
      this.animController.abort();
      super.kill();
    }
    preDestroy() {
      super.preDestroy();
      this.animController.abort();
      this.unlistenToEvents();
    }
    listenToEvents() {
      this.scene.events.on(Phaser.Scenes.Events.UPDATE, this.update, this);
    }
    unlistenToEvents() {
      this.scene.events.off(Phaser.Scenes.Events.UPDATE, this.update, this);
    }
    createLabel() {
      const label = FontUtils_default.createText(this.scene, "Now", 16).setFontStyle("700").setAlign(
      "center");
      this.add(label);
      return label;
    }
    runFlashingAnimation() {
      const signal = this.animController.renew();
      AnimUtils.runTween(
        this.scene.tweens.add({
          targets: [this.label],
          yoyo: true,
          duration: 700,
          ease: Phaser.Math.Easing.Sine.InOut,
          repeat: -1,
          props: {
            alpha: { from: 0.5, to: 1 }
          }
        }),
        signal
      );
    }
    getNextDailySpinTimeStamp() {
      const { lastDailySpin = 0 } = player24.getGameData() ?? {};
      const startOfLastDailySpinDate = new Date(lastDailySpin);
      startOfLastDailySpinDate.setHours(0, 0, 0, 0);
      const nextDailySpinDate = new Date(startOfLastDailySpinDate);
      nextDailySpinDate.setDate(nextDailySpinDate.getDate() + 1);
      return nextDailySpinDate.getTime();
    }
    updateLabel() {
      const nextSpin = this.getNextDailySpinTimeStamp();
      const seconds = nextSpin / 1e3;
      const timeString = T11.getRelativeTime(seconds, "en", void 0, "soon");
      const text = `Next Free Spin
${timeString}`;
      this.label.setText(text);
    }
  };

  // src/game/screens/lucky-wheel-screen/LuckyWheelScreen.ts
  var { player: player25 } = codex;
  var {
    Utils: { Valid: V18 }
  } = Ludex;
  var { KEY: DEFAULT_KEY7, FRAME: DEFAULT_FRAME7 } = sprites_default.DEFAULT;
  var { KEY: DASHBOARD_KEY2, FRAME: DASHBOARD_FRAME3 } = sprites_default.DASHBOARD;
  var DEV_ITEMS = [
    { type: "coin", amount: 500, weight: 0.6 / 4, rarity: "common" },
    { type: "item", id: item_default.BOMB_DEFUSE.ID, amount: 1, weight: 0.4 / 4, rarity: "special" },
    { type: "coin", amount: 500, weight: 0.6 / 4, rarity: "common" },
    { type: "item", id: item_default.HINT.ID, amount: 1, weight: 0.4 / 4, rarity: "special" },
    { type: "coin", amount: 500, weight: 0.6 / 4, rarity: "common" },
    { type: "item", id: item_default.SHUFFLE.ID, amount: 1, weight: 0.4 / 4, rarity: "special" },
    { type: "coin", amount: 500, weight: 0.6 / 4, rarity: "common" },
    { type: "item", id: item_default.ROCKET.ID, amount: 1, weight: 0.4 / 4, rarity: "special" }
  ];
  var WHEEL_ITEM_RANGE_PADDING = 0.15;
  var WHEEL_ITEM_IMAGE_RADIUS = 100;
  var WHEEL_ITEM_LABEL_RADIUS = 70;
  var ITEMS = DEV_ITEMS;
  var ONE_REVOLUTION_RAD = 2 * Math.PI;
  var LIGHT_BULB_COUNT = 12;
  var LENGTH_OF_ONE_DAY = 1e3 * 60 * 60 * 24;
  var MenuButton3 = class extends Button_default {
    scaleDown = 0.98;
  };
  var LuckyWheelScreen = class extends Screen_default {
    woodenBackground$;
    popup$;
    coinBar$;
    wheel$;
    highlightContainer$;
    buttonClose$;
    spinButton$;
    getSpinButton$;
    nextFreeSpinLabel$;
    ribbon$;
    itemImages$ = [];
    coinExplosiveEffects$ = [];
    bulbs$ = [];
    // ? for weighted randomizer
    itemsCdf$ = [];
    // Animations
    spinAnimation$;
    bulbFlashingAnimation1$;
    bulbFlashingAnimation2$;
    incY(y) {
      super.incY(y);
      this.highlightContainer$.y -= y;
      this.woodenBackground$.y -= y;
    }
    incX(x) {
      super.incX(x);
      this.highlightContainer$.x -= x;
      this.woodenBackground$.x -= x;
    }
    incScale(scale) {
      super.incScale(scale);
      this.highlightContainer$.scale -= scale ^ scale * (100 / scale);
      this.woodenBackground$.scale -= scale ^ scale * (100 / scale);
    }
    constructor(scene, name) {
      super(scene, name);
      this.addWoodenBackground$();
      this.createPopup$();
      this.createRibbon$();
      this.createButtons$();
      this.createNextFreeSpinIndicator$();
      this.createItems$();
      this.createHighlightContainer$();
      this.createInput$();
      this.setDepth(ScreenDepth_default.POPUP);
      Phaser.Display.Align.In.Center(this.popup$, this.zone, 0, -40);
    }
    addWoodenBackground$() {
      this.woodenBackground$ = this.scene.make.image({
        key: images_default.BACKGROUND.KEY
      });
      this.woodenBackground$.setName(images_default.BACKGROUND.KEY);
      this.woodenBackground$.setWorldSize(this.zone.width, this.zone.height);
      this.woodenBackground$.setAlpha(0);
      this.add(this.woodenBackground$);
      Phaser.Display.Align.In.Center(this.woodenBackground$, this.zone);
      this.moveAbove(this.background, this.woodenBackground$);
    }
    createPopup$() {
      this.popup$ = this.scene.add.container(0, 0);
      this.popup$.setWorldSize(375, 667);
      const arrow = this.scene.make.image({
        key: DASHBOARD_KEY2,
        frame: DASHBOARD_FRAME3.LUCKY_WHEEL_ARROW
      });
      const knob = this.scene.make.image({
        key: DASHBOARD_KEY2,
        frame: DASHBOARD_FRAME3.LUCKY_WHEEL_KNOB
      });
      this.wheel$ = this.scene.add.container(0, 0);
      this.wheel$.setWorldSize(360, 350);
      this.createLightBulbs$();
      const board = this.scene.make.image({
        key: DASHBOARD_KEY2,
        frame: DASHBOARD_FRAME3.LUCKY_WHEEL_BG
      });
      this.wheel$.add(board);
      this.popup$.add([this.wheel$, arrow, knob]);
      this.add(this.popup$);
      const bannerHeightOffset = AdsUtils_default.getBannerHeight() / 2;
      Phaser.Display.Align.In.Center(this.popup$, this.zone, 0, -bannerHeightOffset);
      AlignUtils_default.alignChildCenter(this.wheel$, this.popup$);
      AlignUtils_default.alignChildCenter(board, this.wheel$);
      AlignUtils_default.alignChildTopCenter(arrow, this.wheel$);
      AlignUtils_default.alignChildCenter(knob, this.wheel$);
    }
    createLightBulbs$() {
      for (let index = 0; index < LIGHT_BULB_COUNT; index++) {
        const bulbOn = this.scene.make.image({
          key: DASHBOARD_KEY2,
          frame: DASHBOARD_FRAME3.LUCKY_WHEEL_ICON_BULB_ON
        });
        const bulbOff = this.scene.make.image({
          key: DASHBOARD_KEY2,
          frame: DASHBOARD_FRAME3.LUCKY_WHEEL_ICON_BULB_OFF
        });
        bulbOff.setAlpha(0);
        this.bulbs$.push({ on: bulbOn, off: bulbOff });
        this.wheel$.add([bulbOn, bulbOff]);
        const rad = index * ONE_REVOLUTION_RAD / LIGHT_BULB_COUNT;
        Phaser.Math.RotateAroundDistance(bulbOn, this.wheel$.x, this.wheel$.y, rad, 166);
        Phaser.Math.RotateAroundDistance(bulbOff, this.wheel$.x, this.wheel$.y, rad, 166);
        const rotation = rad + Math.PI / 2;
        bulbOn.setRotation(rotation);
        bulbOff.setRotation(rotation);
      }
    }
    createRibbon$() {
      this.ribbon$ = this.scene.make.image({
        key: DASHBOARD_KEY2,
        frame: DASHBOARD_FRAME3.LUCKY_WHEEL_RIBBON
      });
      Phaser.Display.Align.To.TopCenter(this.ribbon$, this.wheel$, 0, 20);
      this.popup$.add(this.ribbon$);
    }
    createButtons$() {
      this.createCloseButton$();
      this.createSpinButton$();
      this.createGetSpinButton$();
    }
    createNextFreeSpinIndicator$() {
      this.nextFreeSpinLabel$ = new NextFreeSpinIndicator(this.scene);
      this.popup$.add(this.nextFreeSpinLabel$);
      Phaser.Display.Align.To.BottomCenter(this.nextFreeSpinLabel$, this.spinButton$, 0, 30);
      this.nextFreeSpinLabel$.kill();
    }
    createItems$() {
      const items = ITEMS;
      let cdf = 0;
      this.itemsCdf$ = [];
      this.itemImages$ = [];
      for (let i = 0; i < items.length; i++) {
        const item = items[i];
        const { weight } = item;
        const objects = this.createItem$(item, i % 2 === 0);
        if (!objects) continue;
        cdf += weight;
        if (cdf > 1) {
          console.warn("cdf > 1. Make sure item weights sum to 1");
          cdf = 1;
        }
        this.itemsCdf$.push(cdf);
        const { icon, label } = objects;
        this.itemImages$.push(icon);
        const { mid: rad } = this.getItemRotation$(i);
        Phaser.Math.RotateAroundDistance(icon, this.wheel$.x, this.wheel$.y, rad, WHEEL_ITEM_IMAGE_RADIUS);
        Phaser.Math.RotateAroundDistance(label, this.wheel$.x, this.wheel$.y, rad, WHEEL_ITEM_LABEL_RADIUS);
        const itemRad = rad + Math.PI / 2;
        icon.setRotation(itemRad);
        label.setRotation(itemRad);
      }
    }
    createHighlightContainer$() {
      this.highlightContainer$ = new HighlightItemContainer(this.scene, this.zone.width, this.zone.height,
      ITEMS);
      this.popup$.add(this.highlightContainer$);
      Phaser.Display.Align.In.Center(this.highlightContainer$, this.popup$);
    }
    createInput$() {
      this.buttonClose$.setButtonHitSoundEffect(soundEffects_default.CLOSE_POPUP_CLICK);
      this.buttonClose$.onClick = this.handleClose$.bind(this);
      this.getSpinButton$.setButtonHitSoundEffect(soundEffects_default.GENERAL_BUTTON_CLICK);
      this.getSpinButton$.onClick = this.spinOrGetSpin$.bind(this);
      this.spinButton$.setButtonHitSoundEffect(soundEffects_default.GENERAL_BUTTON_CLICK);
      this.spinButton$.onClick = this.spinOrGetSpin$.bind(this);
    }
    createItemImage$(item) {
      if (item.type === "coin") {
        const image = this.scene.make.image({
          key: DASHBOARD_KEY2,
          frame: DASHBOARD_FRAME3.LUCKY_WHEEL_ICON_COIN
        });
        return image;
      }
      switch (item.id) {
        case item_default.HINT.ID: {
          const image = this.scene.make.image({
            key: DASHBOARD_KEY2,
            frame: DASHBOARD_FRAME3.LUCKY_WHEEL_ICON_HINT
          });
          return image;
        }
        case item_default.SHUFFLE.ID: {
          const image = this.scene.make.image({
            key: DASHBOARD_KEY2,
            frame: DASHBOARD_FRAME3.LUCKY_WHEEL_ICON_SHUFFLE
          });
          return image;
        }
        case item_default.BOMB_DEFUSE.ID: {
          const image = this.scene.make.image({
            key: DASHBOARD_KEY2,
            frame: DASHBOARD_FRAME3.LUCKY_WHEEL_ICON_DEFUSE
          });
          return image;
        }
        case item_default.ROCKET.ID: {
          const image = this.scene.make.image({
            key: DASHBOARD_KEY2,
            frame: DASHBOARD_FRAME3.LUCKY_WHEEL_ICON_ROCKET
          });
          return image;
        }
      }
      return null;
    }
    createItemText$(item, invertTextColor) {
      const text = item.type === "coin" ? item.amount.toString() : `x${item.amount}`;
      const label = FontUtils_default.createText(this.scene, text, 16).setFontStyle("700").setOrigin(
      0.5, 0);
      label.setTint(invertTextColor ? 10243599 : 16777215);
      return label;
    }
    createItem$(item, invertTextColor) {
      const image = this.createItemImage$(item);
      if (!image) return null;
      const text = this.createItemText$(item, invertTextColor);
      this.wheel$.add(image);
      this.wheel$.add(text);
      return { icon: image, label: text };
    }
    createCloseButton$() {
      this.buttonClose$ = new Button_default(this.scene, DEFAULT_KEY7, DEFAULT_FRAME7.BUTTON_CLOSE);
      this.buttonClose$.setName("Close");
      this.popup$.add(this.buttonClose$);
      Phaser.Display.Align.To.RightCenter(this.buttonClose$, this.ribbon$, 5, 0);
    }
    createSpinButton$() {
      this.spinButton$ = new MenuButton3(this.scene, DEFAULT_KEY7, DEFAULT_FRAME7.BUTTON_GREEN);
      this.spinButton$.setName("Spin");
      const label = FontUtils_default.createText(this.scene, "Spin Now", 18).setFontStyle("900");
      FontUtils_default.applyGreenStyle(label);
      this.spinButton$.add(label);
      Phaser.Display.Align.In.Center(label, this.spinButton$);
      this.popup$.add(this.spinButton$);
      Phaser.Display.Align.In.BottomCenter(this.spinButton$, this.wheel$, 0, 80);
    }
    createGetSpinButton$() {
      this.getSpinButton$ = new MenuButton3(this.scene, DEFAULT_KEY7, DEFAULT_FRAME7.BUTTON_GREEN);
      const label = FontUtils_default.createText(this.scene, "Get Spin", 18).setFontStyle("900");
      FontUtils_default.applyGreenStyle(label);
      const icon = this.scene.make.image({
        key: DEFAULT_KEY7,
        frame: DEFAULT_FRAME7.ICON_ADS
      });
      this.getSpinButton$.add([icon, label]);
      Phaser.Display.Align.In.Center(label, this.getSpinButton$, 15);
      Phaser.Display.Align.In.Center(icon, this.getSpinButton$, -45, 0);
      this.getSpinButton$.setName("GetSpin");
      this.popup$.add(this.getSpinButton$);
      Phaser.Display.Align.In.BottomCenter(this.getSpinButton$, this.wheel$, 0, 80);
    }
    open(data) {
      super.open(data);
      if (data?.coinBar instanceof CoinsBar_default) {
        this.coinBar$ = data.coinBar;
      }
      this.wheel$.setRotation(0);
      this.runOpenAnimation$();
      this.updateSpinButton$();
    }
    handleClose$() {
      this.runCloseAnimation$();
    }
    spin() {
      this.getSpinButton$.setDisabled(true);
      this.spinButton$.setDisabled(true);
      this.buttonClose$.setDisabled(true);
      const { index, item } = this.getRandomItem$();
      this.addItemToPlayerData$(item);
      const { min, max } = this.getItemRotation$(index);
      const target = Phaser.Math.FloatBetween(
        -max + WHEEL_ITEM_RANGE_PADDING - Math.PI / 2,
        -min - WHEEL_ITEM_RANGE_PADDING - Math.PI / 2
      );
      const extra = Phaser.Math.Between(6, 8) * ONE_REVOLUTION_RAD;
      const curr = this.wheel$.rotation;
      const from = Phaser.Math.Angle.Normalize(curr);
      const to = target + extra;
      const fromDeg = Phaser.Math.RadToDeg(from);
      const toDeg = Phaser.Math.RadToDeg(to);
      const finishCallback = () => {
        this.buttonClose$.setDisabled(false);
        this.updateSpinButton$();
      };
      this.runSpinAnimation$(fromDeg, toDeg, () => {
        this.playItemRewardSound$(item);
        if (item.type === "item") {
          this.highlightContainer$.runHighlightItemAnimation(index, finishCallback);
        } else {
          this.runClaimCoinAnimation$(index, item, finishCallback);
        }
      });
    }
    playItemRewardSound$(item) {
      switch (item.rarity) {
        case "common":
          AudioUtils_default.playSound(soundEffects_default.WHEEL_GET_COMMON);
          break;
        case "special":
          AudioUtils_default.playSound(soundEffects_default.WHEEL_GET_SPECIAL);
          break;
      }
    }
    async getSpin$() {
      const success = await this.requestMoreSpin$();
      if (success) {
        this.spin();
      }
    }
    spinOrGetSpin$() {
      if (this.isAvailable$()) {
        this.spin();
      } else {
        this.getSpin$();
      }
    }
    updateSpinButton$() {
      const isAvailable = this.isAvailable$();
      if (isAvailable) {
        this.spinButton$.setDisabled(false);
        this.spinButton$.revive();
        this.getSpinButton$.setDisabled(true);
        this.getSpinButton$.kill();
        this.nextFreeSpinLabel$.kill();
      } else {
        this.spinButton$.setDisabled(true);
        this.spinButton$.kill();
        this.getSpinButton$.setDisabled(false);
        this.getSpinButton$.revive();
        this.nextFreeSpinLabel$.revive();
      }
    }
    addItemToPlayerData$(item) {
      const now = Date.now();
      player25.setGameData({ lastDailySpin: now });
      if (item.type === "coin") {
        CoinUtils_default.addCoin(item.amount);
        return;
      }
      const { items = {} } = player25.getGameData() ?? {};
      if (!V18.isObject(items)) return;
      const curr = items[item.id];
      if (!V18.isNumber(curr)) return;
      player25.setGameData({ items: { ...items, [item.id]: curr + item.amount } });
    }
    getItemRotation$(index) {
      const items = ITEMS;
      const mid = index * (Math.PI * 2) / items.length;
      const rotationDistance = Math.PI * 2 / items.length;
      return {
        min: mid - rotationDistance / 2,
        mid,
        max: mid + rotationDistance / 2
      };
    }
    getRandomItem$() {
      const items = ITEMS;
      const random = Math.random();
      for (let i = 0; i < this.itemsCdf$.length; i++) {
        const cdf = this.itemsCdf$[i];
        if (random <= cdf) {
          return { index: i, item: items[i] };
        }
      }
      return { index: items.length - 1, item: items[items.length - 1] };
    }
    async requestMoreSpin$() {
      try {
        const success = await AdsUtils_default.showRewardVideoAdAsync();
        if (!success) return false;
        AudioUtils_default.playSound(soundEffects_default.DAILY_REWARD);
        return true;
      } catch (error) {
        return false;
      }
    }
    // Animations
    runOpenAnimation$() {
      this.background.setAlpha(0);
      this.animateBackgroundAlpha(0.8, 500);
      this.runWoodenBackgroundEntrancesAnimation$(0, 200);
      this.runPopupEntrancesAnimation$();
      this.runPopupContentEntrancesAnimation$();
      this.runBulbsFlashingAnimation$();
    }
    isAvailable$() {
      const { lastDailySpin = 0 } = player25.getGameData() ?? {};
      const startOfLastDailySpinDate = new Date(lastDailySpin);
      startOfLastDailySpinDate.setHours(0, 0, 0, 0);
      const now = Date.now();
      const diff = now - startOfLastDailySpinDate.getTime();
      if (diff > LENGTH_OF_ONE_DAY) {
        return true;
      }
      return false;
    }
    runCloseAnimation$() {
      this.animateBackgroundAlpha(0, 150);
      this.runWoodenBackgroundExitsAnimation$(0, 150);
      this.runPopupExitsAnimation$();
      this.stopBulbsFlashingAnimation$();
      this.coinBar$?.revertDepth();
    }
    // Entrances animations
    runPopupEntrancesAnimation$() {
      const bannerHeightOffset = AdsUtils_default.getBannerHeight() / 2;
      const popupShowUpAnimation = this.scene.tweens.add({
        ...ShowUp_default,
        targets: [this.popup$],
        duration: 400,
        props: {
          ...ShowUp_default.props,
          y: { from: 350 - bannerHeightOffset, to: -bannerHeightOffset },
          alpha: { start: 0, from: 0, to: 1 },
          scale: { start: 0, from: 0, to: 1 }
        }
      });
      AnimUtils.runTween(popupShowUpAnimation);
    }
    runPopupContentEntrancesAnimation$() {
      const wheelSpinIntoPlaceAnimation = this.scene.tweens.add({
        targets: [this.wheel$],
        duration: 800,
        props: {
          angle: { from: -180, to: 0 }
        },
        ease: Phaser.Math.Easing.Sine.Out
      });
      AnimUtils.runTween(wheelSpinIntoPlaceAnimation);
    }
    runWoodenBackgroundEntrancesAnimation$(delay, duration) {
      AnimUtils.runTween(
        this.scene.tweens.add({
          ...FadeIn_default,
          targets: [this.woodenBackground$],
          delay,
          duration
        })
      );
    }
    // Exits animations
    runPopupExitsAnimation$() {
      const bannerHeightOffset = AdsUtils_default.getBannerHeight() / 2;
      const popupFadeOutAnimation = this.scene.tweens.add({
        ...FadeOut_default,
        targets: [this.popup$],
        duration: 200,
        props: {
          ...FadeOut_default.props,
          y: 250 - bannerHeightOffset,
          scale: 0
        }
      });
      AnimUtils.runTweenAsync(popupFadeOutAnimation).then(() => {
        this.popup$.setY(0);
        ScreenUtils_default.closeScreen(this.name);
      });
    }
    runWoodenBackgroundExitsAnimation$(delay, duration) {
      AnimUtils.runTween(
        this.scene.tweens.add({
          ...FadeOut_default,
          targets: [this.woodenBackground$],
          delay,
          duration
        })
      );
    }
    runSpinAnimation$(from, to, onComplete) {
      this.spinAnimation$?.stop();
      this.spinAnimation$?.remove();
      this.spinAnimation$?.off(Phaser.Tweens.Events.TWEEN_COMPLETE);
      let lastQuotient = Math.floor((from + 22.5) / 45);
      let lastAudioTimeStamp = 0;
      this.spinAnimation$ = this.scene.tweens.add({
        targets: [this.wheel$],
        duration: 6e3,
        props: {
          angle: {
            from,
            to
          }
        },
        ease: Phaser.Math.Easing.Quintic.Out,
        onUpdate: (tween) => {
          const progress = tween.progress;
          const eased = Phaser.Math.Easing.Quintic.Out(progress);
          const curr = Phaser.Math.Linear(from, to, eased);
          const quotient = Math.floor((curr + 22.5) / 45);
          const currTime = Date.now();
          if (quotient !== lastQuotient && currTime - lastAudioTimeStamp > 70) {
            AudioUtils_default.playSound(soundEffects_default.WHEEL_CLICK);
            lastQuotient = quotient;
            lastAudioTimeStamp = currTime;
          }
        }
      });
      AnimUtils.runTweenAsync(this.spinAnimation$).then(onComplete);
    }
    runClaimCoinAnimation$(index, item, onComplete) {
      if (!this.coinBar$) return;
      const itemImage = this.itemImages$[index];
      const itemImageWorldPosition = itemImage.getWorldPosition();
      const barPosition = this.coinBar$.getWorldPosition();
      const coinExplosive = this.requestCoinExplosive$();
      const coinTweens = coinExplosive.explode(
        10,
        itemImageWorldPosition.x,
        itemImageWorldPosition.y,
        barPosition.x,
        barPosition.y
      );
      this.coinBar$?.bringThisToTop();
      const coinBarFadeInTween = this.scene.tweens.add({
        targets: this.coinBar$,
        duration: 300,
        props: {
          alpha: { start: 0, from: 0, to: 1 }
        }
      });
      const coinBarFadeOutTween = this.scene.tweens.add({
        targets: this.coinBar$,
        paused: true,
        duration: 100,
        delay: 200,
        props: {
          alpha: { start: 1, from: 1, to: 0 }
        },
        onComplete: () => {
          this.coinBar$?.setAlpha(1);
          this.coinBar$?.revertDepth();
          onComplete?.();
        }
      });
      AnimUtils.runTween(coinBarFadeInTween);
      let countOfFinishedCoins = 0;
      for (const tween of coinTweens) {
        tween.once(Phaser.Tweens.Events.TWEEN_COMPLETE, () => {
          const rewardCoins = Math.floor(item.amount / 10);
          CoinUtils_default.addCoin(rewardCoins);
          countOfFinishedCoins++;
          if (countOfFinishedCoins === coinTweens.length) {
            AnimUtils.runTween(coinBarFadeOutTween);
          }
        });
      }
    }
    requestCoinExplosive$() {
      const inactiveCoinExplosive = this.coinExplosiveEffects$.find((effect) => !effect.isActive);
      if (inactiveCoinExplosive) {
        return inactiveCoinExplosive;
      }
      const newCoinExplosive = new CoinExplosive_default(this.coinBar$?.scene ?? this.scene);
      this.coinExplosiveEffects$.push(newCoinExplosive);
      return newCoinExplosive;
    }
    runBulbsFlashingAnimation$() {
      if (!this.bulbFlashingAnimation1$) {
        const bulbs = this.bulbs$.map(({ on, off }, index) => index % 2 === 0 ? on : off);
        this.bulbFlashingAnimation1$ = this.scene.tweens.add({
          targets: bulbs,
          repeat: -1,
          repeatDelay: 200,
          hold: 200,
          duration: 200,
          yoyo: true,
          ease: Phaser.Math.Easing.Sine.InOut,
          props: {
            alpha: { from: 0, to: 1 }
          },
          persist: true
        });
      }
      if (!this.bulbFlashingAnimation2$) {
        const bulbs = this.bulbs$.map(({ on, off }, index) => index % 2 === 1 ? on : off);
        this.bulbFlashingAnimation2$ = this.scene.tweens.add({
          targets: bulbs,
          repeat: -1,
          repeatDelay: 200,
          hold: 200,
          duration: 200,
          yoyo: true,
          ease: Phaser.Math.Easing.Sine.InOut,
          props: {
            alpha: { from: 1, to: 0 }
          },
          persist: true
        });
      }
      AnimUtils.runTween(this.bulbFlashingAnimation1$);
      AnimUtils.runTween(this.bulbFlashingAnimation2$);
    }
    stopBulbsFlashingAnimation$() {
      this.bulbFlashingAnimation1$?.stop();
      this.bulbFlashingAnimation2$?.stop();
    }
  };
  var LuckyWheelScreen_default = LuckyWheelScreen;

  // src/game/screens/tournament-detail-screen/TournamentDetailScreen.ts
  init_phaser_custom_min();

  // src/game/screens/tournament-detail-screen/common/TournamentLeaders.ts
  init_phaser_custom_min();

  // src/game/screens/tournament-detail-screen/common/Leader.ts
  init_phaser_custom_min();

  // src/game/animations/special/ShowPopup.ts
  init_phaser_custom_min();
  var defaultConfig = {
    targets: [],
    props: {
      alpha: { start: 0, to: 1, duration: 500, ease: Phaser.Math.Easing.Cubic.Out },
      scale: {
        start: 0.8,
        to: 1,
        duration: 1e3,
        ease: Phaser.Math.Easing.Elastic.Out,
        easeParams: [0.1, 0.45]
      },
      y: { start: 0, to: 0, duration: 500, ease: Phaser.Math.Easing.Back.Out }
    },
    delay: 0
  };
  var ShowPopupAnimation = class {
    config;
    tween;
    scene;
    constructor(config) {
      this.config = { ...defaultConfig, ...config };
      const { scene } = this.config.targets[0];
      if (!scene) return;
      this.scene = scene;
      this.tween = this.scene.tweens.add(this.config);
    }
    play() {
      this.tween.play();
    }
  };
  var ShowPopup_default = ShowPopupAnimation;

  // src/game/screens/tournament-detail-screen/common/Leader.ts
  var { KEY: CHALLENGE_KEY2, FRAME: CHALLENGE_FRAME2 } = sprites_default.CHALLENGE;
  var { KEY: KEY85, FRAME: FRAME87 } = sprites_default.TOURNAMENTS;
  var Leader = class extends Phaser.GameObjects.Container {
    scene;
    popup;
    avatar;
    username;
    score;
    rank;
    rankBackground;
    payload;
    showPopUp;
    constructor(scene) {
      super(scene);
      this.scene = scene;
      this.setSize(320, 56.5);
      this.createAvatar();
      this.createPopup();
      this.createUsername();
      this.createScore();
      this.createRankBackground();
      this.createRank();
    }
    createPopup() {
      const width = 320;
      const height = 56.5;
      this.popup = this.scene.add.container(0, 0);
      this.popup.setSize(width, height);
      const bg = this.scene.make.image({
        key: KEY85,
        frame: FRAME87.ROLL_BAR
      });
      bg.setWorldSize(width, height);
      this.popup.add(bg);
      this.add(this.popup);
      Phaser.Display.Align.In.Center(this.popup, this);
      this.setSize(width, height);
    }
    createAvatar() {
      const size = 33;
      this.avatar = new AvatarFrame_default(this.scene, {
        key: CHALLENGE_KEY2,
        background: CHALLENGE_FRAME2.AVATAR,
        width: size,
        height: size
      });
      this.avatar.background.setWorldSize(size, size);
      this.avatar.loading.setWorldSize(size * 0.5, size * 0.5);
      this.add(this.avatar);
      Phaser.Display.Align.In.LeftCenter(this.avatar, this, -51, -4);
    }
    createUsername() {
      this.username = FontUtils_default.createText(this.scene, "", 15).setOrigin(0, 0.5).setTint(8275998).
      setFontStyle("700");
      FontUtils_default.setTruncateOverflow(this.username, 120);
      this.add(this.username);
      Phaser.Display.Align.In.LeftCenter(this.username, this.popup, -95, -2);
    }
    createClock() {
      const clock = this.scene.make.image({
        key: KEY85,
        frame: FRAME87.ICON_TIME
      });
      clock.setWorldSize(26.5, 28);
      this.add(clock);
      Phaser.Display.Align.In.RightCenter(clock, this.popup, -80, -2);
    }
    createScore() {
      this.score = FontUtils_default.createText(this.scene, "", 15).setTint(15854543).setShadow(0, 3,
      "#846843", 0.5).setFontStyle("700");
      this.add(this.score);
      Phaser.Display.Align.In.RightCenter(this.score, this.popup, -56, -2);
    }
    createRank() {
      this.rank = FontUtils_default.createText(this.scene, "", 17).setTint(16776955).setShadow(0, 3,
      "#896941", 0.5).setFontStyle("700");
      this.add(this.rank);
      Phaser.Display.Align.In.LeftCenter(this.rank, this.popup, -24, -2);
    }
    createRankBackground() {
      this.rankBackground = this.scene.make.image({
        key: KEY85,
        frame: FRAME87.RANK_BACKGROUND
      });
      this.rankBackground.setWorldSize(28.5, 28.5);
      this.add(this.rankBackground);
      Phaser.Display.Align.In.LeftCenter(this.rankBackground, this.popup, -12, -2);
    }
    async updateInfo(payload) {
      this.payload = payload;
      const { name, score, rank, photo, playerId } = payload;
      this.username.setText(name);
      this.score.setText(score.toString());
      this.avatar.loadPhoto(playerId, photo, 40);
      this.updateRank(rank);
    }
    updateRank(rank) {
      if (rank <= 3) {
        this.rank.setVisible(false);
        if (rank === 1) {
          this.rankBackground.setFrame(FRAME87.MEDAL_GOLD);
        } else if (rank === 2) {
          this.rankBackground.setFrame(FRAME87.MEDAL_SILVER);
        } else if (rank === 3) {
          this.rankBackground.setFrame(FRAME87.MEDAL_BRONZE);
        }
      } else {
        this.rank.setVisible(true);
        this.rank.setText(rank.toString());
        this.rankBackground.setFrame(FRAME87.RANK_BACKGROUND);
      }
      this.rankBackground.setWorldSize(28.5, 28.5);
    }
    async runShowPopUpAnimation(delay, duration) {
      this.scene.tweens.killTweensOf(this);
      const currentY = this.y;
      this.showPopUp = new ShowPopup_default({
        targets: [this],
        delay,
        duration,
        props: {
          ...defaultConfig.props,
          y: { ...defaultConfig.props?.y, start: this.y + 70, to: this.y }
        },
        onStop: () => {
          this.y = currentY;
        }
      });
      this.showPopUp.play();
      return new Promise((resolve) => {
        this.scene.time.delayedCall(delay + duration + 500, () => {
          resolve();
        });
      });
    }
    runShowItemAnimation(delay, duration) {
      const targets = this.getItems();
      this.scene.tweens.killTweensOf(targets);
      for (const target of targets) {
        target.setScale(target.type === "Image" ? 0.5 : 1);
      }
      this.scene.tweens.add({
        targets,
        duration,
        delay: this.scene.tweens.stagger(50, { start: delay + 50 }),
        props: {
          alpha: {
            duration: 500,
            value: { start: 0, from: 0, to: 1 },
            ease: Phaser.Math.Easing.Cubic.Out
          },
          scale: {
            duration: 800,
            start: 0.8,
            end: 1,
            value: { start: 0.8, from: 0.8, to: 1 },
            ease: Phaser.Math.Easing.Elastic.Out,
            easeParams: [0.1, 0.45]
          }
        }
      });
    }
    getItems() {
      return [this.rank, this.username, this.score];
    }
    async runShowUpAnimation(index = 0, duration = 300) {
      const delay = index * 100;
      this.runShowItemAnimation(delay, duration);
      await this.runShowPopUpAnimation(delay, duration);
    }
  };
  var Leader_default = Leader;

  // src/game/components/TileLoading.ts
  init_phaser_custom_min();
  var { KEY: LOADING_KEY2, FRAME: LOADING_FRAME2 } = sprites_default.DEFAULT;
  var IconFrames2 = [
    LOADING_FRAME2.LOADING_SCREEN_TILE_ICON_1,
    LOADING_FRAME2.LOADING_SCREEN_TILE_ICON_2,
    LOADING_FRAME2.LOADING_SCREEN_TILE_ICON_3,
    LOADING_FRAME2.LOADING_SCREEN_TILE_ICON_4,
    LOADING_FRAME2.LOADING_SCREEN_TILE_ICON_5
  ];
  var TileLoading = class extends Phaser.GameObjects.Container {
    background;
    icon;
    anim;
    constructor(scene) {
      super(scene, 0, 0);
      this.createBackground();
      this.createIcon();
      this.scene.add.existing(this);
    }
    createBackground() {
      this.background = this.scene.make.image({
        key: LOADING_KEY2,
        frame: LOADING_FRAME2.LOADING_SCREEN_TILE_BG
      });
      this.add(this.background);
    }
    createIcon() {
      this.icon = this.scene.make.image({
        key: LOADING_KEY2,
        frame: LOADING_FRAME2.LOADING_SCREEN_TILE_ICON_1
      });
      this.add(this.icon);
      Phaser.Display.Align.In.Center(this.icon, this.background);
    }
    runAnimation() {
      this.icon.setFrame(IconFrames2[Phaser.Math.Between(0, IconFrames2.length - 1)]);
      this.anim = this.scene.tweens.add({
        targets: [this],
        repeat: -1,
        props: {
          angle: { from: 0, to: 360 }
        },
        duration: 1500,
        ease: Phaser.Math.Easing.Cubic.InOut
      });
    }
    setVisible(visible) {
      super.setVisible(visible);
      if (visible) {
        this.runAnimation();
      } else {
        this.anim.stop();
        this.scene.tweens.remove(this.anim);
      }
      return this;
    }
  };
  var TileLoading_default = TileLoading;

  // src/game/screens/tournament-detail-screen/common/TournamentLeaders.ts
  var TournamentLeaders = class extends Phaser.GameObjects.Container {
    scene;
    loading;
    scroller;
    constructor(scene) {
      super(scene);
      this.scene = scene;
      this.createLoading();
      this.createScroller();
    }
    createLoading() {
      this.loading = new TileLoading_default(this.scene);
      this.add(this.loading);
      Phaser.Display.Align.In.Center(this.loading, this, 0, 30);
    }
    showLoading(visible) {
      this.loading.setVisible(visible);
    }
    createScroller() {
      this.scroller = new ReuseScroller(this.scene, {
        size: {
          width: 335,
          height: 240
        },
        visual: {
          spacing: 2,
          margin: 5
        },
        reuse: {
          ClassType: Leader_default,
          configs: [],
          update: (leader, config) => {
            leader.updateInfo(config);
          }
        }
      });
      this.scroller.setPosition(0, 40);
      this.add(this.scroller);
      this.hideLeaders();
    }
    hideLeaders() {
      this.scroller.setVisible(false);
    }
    async showLeaders() {
      this.scroller.setVisible(true);
      this.scroller.setEnabled(false);
      this.scroller.scrollToTop(true);
      const leaders = this.getLeaders();
      const numberOfLeadersShown = Math.min(leaders.length, 4);
      const duration = 150;
      const leaderPromises = [];
      for (let index = 0; index < numberOfLeadersShown; index++) {
        const leader = leaders[index];
        if (!leader) continue;
        leader.setVisible(true);
        const p = leader.runShowUpAnimation(index, duration);
        leaderPromises.push(p);
      }
      await Promise.all(leaderPromises);
      this.scroller.setEnabled(true);
    }
    getLeaders() {
      return this.scroller.getChildren();
    }
    updateLeaders(data) {
      this.scroller.setConfigs(data.leaders);
    }
  };
  var TournamentLeaders_default = TournamentLeaders;

  // src/game/utils/LeaderboardUtils.ts
  init_phaser_custom_min();
  var { leaderboard: leaderboard4 } = codex;
  var LeaderboardUtils = class _LeaderboardUtils {
    static _instance;
    static get inst() {
      if (!this._instance) {
        this._instance = new _LeaderboardUtils();
      }
      return this._instance;
    }
    static async getAllLeaderboardAsync(id2) {
      if (!leaderboard4) return null;
      const leaderboardName = leaderboard4.getLeaderboardName(id2);
      if (!leaderboardName) return null;
      const res = await leaderboard4.getLeaderboardResponseAsync(id2);
      if (!res) return null;
      await this.requestLeaderboardAsync(leaderboardName, res.amountPlayer);
      return leaderboard4.getLeaderboard(leaderboardName);
    }
    static async requestLeaderboardAsync(name, limit) {
      if (this.isLeaderboardRequesting(name)) {
        await this.waitForLeaderboardFinishAsync(name);
        return;
      }
      await leaderboard4.requestLeaderboardAsync(name, limit);
    }
    static async waitForLeaderboardFinishAsync(name) {
      if (!this.isLeaderboardRequesting(name)) return;
      return new Promise((resolve) => {
        const interval = setInterval(() => {
          if (!this.isLeaderboardRequesting(name)) {
            clearInterval(interval);
            resolve();
          }
        }, 100);
      });
    }
    static isLeaderboardRequesting(name) {
      return leaderboard4.getLeaderboard(name)?.isRequesting || false;
    }
  };
  try {
    new LeaderboardUtils();
  } catch (error) {
    console.error("LeaderboardUtils", error);
  }
  var LeaderboardUtils_default = LeaderboardUtils;

  // src/game/screens/tournament-detail-screen/common/TopLeader.ts
  init_phaser_custom_min();
  var { KEY: CHALLENGE_KEY3, FRAME: CHALLENGE_FRAME3 } = sprites_default.CHALLENGE;
  var { KEY: KEY86, FRAME: FRAME88 } = sprites_default.TOURNAMENTS;
  var TopLeader = class extends Phaser.GameObjects.Container {
    scene;
    glow;
    avatar;
    rank;
    crown;
    showPopUp;
    constructor(scene, index) {
      super(scene);
      this.scene = scene;
      const size = 60;
      this.setSize(size, size);
      if (index === 0) {
        this.createGlow();
        this.createCrown();
      }
      this.createAvatar(size);
      this.createRank(size);
    }
    createGlow() {
      this.glow = this.scene.make.image({
        key: KEY86,
        frame: FRAME88.GLOW
      });
      this.add(this.glow);
      this.scene.tweens.add({
        targets: this.glow,
        props: {
          angle: { from: 0, to: 360 }
        },
        duration: 5e3,
        repeat: -1
      });
    }
    createAvatar(size) {
      this.avatar = new AvatarFrame_default(this.scene, {
        key: CHALLENGE_KEY3,
        background: CHALLENGE_FRAME3.AVATAR,
        width: size,
        height: size
      });
      this.avatar.background.setWorldSize(size, size);
      this.avatar.loading.setWorldSize(size * 0.5, size * 0.5);
      const frame = this.scene.make.image({
        key: KEY86,
        frame: FRAME88.AVATAR_BORDER
      });
      this.add([this.avatar, frame]);
      Phaser.Display.Align.In.Center(this.avatar, this);
      Phaser.Display.Align.In.Center(frame, this);
    }
    createRank(size) {
      this.rank = this.scene.make.image({
        key: KEY86,
        frame: FRAME88.RANK_BACKGROUND
      });
      this.rank.setWorldSize(size * 0.5, size * 0.5);
      this.add(this.rank);
      Phaser.Display.Align.In.BottomCenter(this.rank, this.avatar, 0, 15);
    }
    createCrown() {
      this.crown = this.scene.make.image({
        key: KEY86,
        frame: FRAME88.CROWN
      });
      this.add(this.crown);
      Phaser.Display.Align.In.Center(this.crown, this, 0, -35);
    }
    updateInfo(data) {
      const { rank, photo, playerId } = data;
      this.avatar.loadPhoto(playerId, photo, 60);
      if (rank === 1) {
        this.rank.setFrame(FRAME88.MEDAL_GOLD);
      } else if (rank === 2) {
        this.rank.setFrame(FRAME88.MEDAL_SILVER);
      } else if (rank === 3) {
        this.rank.setFrame(FRAME88.MEDAL_BRONZE);
      }
    }
    async runShowPopUpAnimation(index, duration = 300) {
      this.scene.tweens.killTweensOf(this);
      const delay = index * 100;
      const currentY = this.y;
      this.showPopUp = new ShowPopup_default({
        targets: [this],
        delay,
        duration,
        props: {
          ...defaultConfig.props,
          scale: { ...defaultConfig.props?.scale, to: index === 0 ? 1 : 0.9 },
          y: { ...defaultConfig.props?.y, start: this.y + 10, to: this.y }
        },
        onStop: () => {
          this.y = currentY;
        }
      });
      this.showPopUp.play();
      return new Promise((resolve) => {
        this.scene.time.delayedCall(delay + duration + 500, () => {
          resolve();
        });
      });
    }
  };
  var TopLeader_default = TopLeader;

  // src/utils/TournamentUtils.ts
  init_phaser_custom_min();
  var {
    Utils: { String: S10, Valid: V19, Array: A7 },
    Configs: {
      Mockup: { Leaderboards: LeaderboardsMockupConfig2 }
    }
  } = Ludex;
  var { leaderboard: leaderboard5, player: player26 } = codex;
  var TournamentUtils = class _TournamentUtils {
    static _instance;
    globalTournamentLBData = [];
    playerTournaments = [];
    tournamentData = [];
    maxTimeRefetch = 5e3;
    lastFetchTournamentsData = 0;
    lastFetchGlobalTournament = 0;
    static getInstance() {
      if (!this._instance) {
        this._instance = new _TournamentUtils();
      }
      return this._instance;
    }
    fetchGlobalTournamentLeaderboardAsync = async () => {
      try {
        const now = Date.now();
        if (now - this.lastFetchGlobalTournament > this.maxTimeRefetch) {
          this.globalTournamentLBData = await leaderboard5.requestLeaderboardsAsync({
            limit: 100,
            type: "world_tournament_leaderboard"
          });
          this.globalTournamentLBData.sort((a, b) => {
            const aEndTime = a.expireTime;
            const bEndTime = b.expireTime;
            return aEndTime - bEndTime;
          });
        }
      } catch (error) {
        console.warn("fetchGlobalTournamentLeaderboardAsync", error);
      }
      return this.globalTournamentLBData;
    };
    fetchTournamentsAsync = async () => {
      try {
        const now = Date.now();
        if (now - this.lastFetchTournamentsData > this.maxTimeRefetch) {
          this.playerTournaments = await GameSDK.tournament.getTournamentsAsync();
          this.playerTournaments.sort((a, b) => {
            const aEndTime = a.getEndTime();
            const bEndTime = b.getEndTime();
            return aEndTime - bEndTime;
          });
        }
      } catch (error) {
        console.warn("fetchTournamentsAsync", error);
      }
      return this.playerTournaments;
    };
    // ? Fetch and return all tournament data
    static async requestTournamentDataAsync() {
      const instance = _TournamentUtils.getInstance();
      await Promise.all([instance.fetchTournamentsAsync(), instance.fetchGlobalTournamentLeaderboardAsync()]);
      const playerTournamentData = instance.processPlayerTournamentData();
      const globalTournamentData = instance.processGlobalTournamentLeaderboardData();
      playerTournamentData.sort((a, b) => a.endTime - b.endTime);
      globalTournamentData.sort((a, b) => a.endTime - b.endTime);
      instance.tournamentData = [...globalTournamentData, ...playerTournamentData];
      for (const tournament of instance.tournamentData) {
        const { payload } = tournament;
        const { leaderboardId } = payload;
        if (!leaderboardId) continue;
        if (leaderboard5.isExistLeaderboardId(leaderboardId)) continue;
        leaderboard5.addLeaderboard({
          type: "tournament",
          name: leaderboardId,
          autoSortRank: true,
          leaderboardId
        });
      }
      return instance.tournamentData;
    }
    // ? Return all tournament data without fetching
    static getAllTournamentData() {
      const instance = _TournamentUtils.getInstance();
      return instance.tournamentData;
    }
    static getTournamentDataById(id2) {
      const instance = _TournamentUtils.getInstance();
      return A7.search(instance.tournamentData, (tournament) => tournament.id === id2);
    }
    static getPlayerTournamentData() {
      const instance = _TournamentUtils.getInstance();
      const playerId = player26.getPlayerId();
      return instance.tournamentData.filter((tournament) => {
        const { payload } = tournament;
        return payload.playerId === playerId;
      });
    }
    static getFriendsTournamentData() {
      const instance = _TournamentUtils.getInstance();
      const playerId = player26.getPlayerId();
      return instance.tournamentData.filter((tournament) => {
        const { payload } = tournament;
        return payload.playerId !== playerId && payload.playerId !== "global";
      });
    }
    static getGlobalTournamentData() {
      const instance = _TournamentUtils.getInstance();
      return instance.tournamentData.filter((tournament) => {
        const { payload } = tournament;
        return payload.playerId === "global";
      });
    }
    static validateTournamentExpired(tournamentId) {
      const tournament = _TournamentUtils.getTournamentDataById(tournamentId);
      if (!tournament) return false;
      const { endTime } = tournament;
      const isExpired = endTime < Date.now() / 1e3;
      return isExpired;
    }
    processPlayerTournamentData() {
      const tournaments = [];
      for (const tournament of this.playerTournaments) {
        if (!tournament) continue;
        const tournamentId = `${tournament.getID()}`;
        const contextId = tournament.getContextID();
        const endTime = tournament.getEndTime();
        const payload = this.parseTournamentPayload(tournament.getPayload());
        if (!this.validateGameSDKTournamentPayload(payload)) {
          continue;
        }
        const isExpiredTournament = endTime < Date.now() / 1e3;
        if (isExpiredTournament) continue;
        const tournamentType = tournament.getTournamentType();
        if (tournamentType === "PAGE_HOSTED") continue;
        const playerName = payload.playerName ?? "Player";
        const tournamentData = {
          id: tournamentId,
          title: tournament.getTitle() ?? this.createDefaultTournamentName(playerName),
          endTime,
          contextId,
          payload,
          tournamentType
        };
        tournaments.push(tournamentData);
      }
      return tournaments;
    }
    processGlobalTournamentLeaderboardData() {
      const tournaments = [];
      const { Enabled: LeaderboardMockEnabled } = LeaderboardsMockupConfig2;
      if (LeaderboardMockEnabled) {
        for (const tournament of this.playerTournaments) {
          const tournamentType = tournament.getTournamentType();
          if (tournamentType !== "PAGE_HOSTED") continue;
          const tournamentId = `${tournament.getID()}`;
          const contextId = tournament.getContextID();
          const endTime = tournament.getEndTime();
          const payload = this.parseTournamentPayload(tournament.getPayload());
          const tournamentData = {
            id: tournamentId,
            title: tournament.getTitle() ?? "Global Tournament",
            endTime,
            contextId,
            payload,
            tournamentType
          };
          tournaments.push(tournamentData);
        }
        return tournaments;
      }
      for (const data of this.globalTournamentLBData) {
        let description;
        try {
          description = JSON.parse(data.description);
        } catch (error) {
          continue;
        }
        if (!this.validateExpireTime(data)) continue;
        if (!this.validateGlobalTournamentPayload(description)) continue;
        const title = data.name;
        const tournament = {
          id: description.tournamentId,
          title,
          endTime: this.getTournamentEndTime(data),
          contextId: description.contextId,
          payload: {
            // ? Global tournaments don't have player data
            playerId: "global",
            playerName: "global",
            leaderboardId: data._id
          },
          tournamentType: "PAGE_HOSTED"
        };
        tournaments.push(tournament);
      }
      return tournaments;
    }
    validateGlobalTournamentPayload(payload) {
      const { tournamentId, contextId } = payload;
      if (!V19.isString(tournamentId) || tournamentId === "") {
        return false;
      }
      if (!V19.isString(contextId) || contextId === "") {
        return false;
      }
      return true;
    }
    getTournamentEndTime(data) {
      const createTime = new Date(data.createdAt).getTime();
      const endTime = Math.round((data.expireTime * 1e3 + createTime) / 1e3);
      return endTime;
    }
    validateExpireTime(data) {
      const endTime = this.getTournamentEndTime(data);
      const remainingTimeInMs = endTime * 1e3 - Date.now();
      return remainingTimeInMs > 0;
    }
    validateGameSDKTournamentPayload(payload) {
      if (!V19.isString(payload.playerId) || payload.playerId === "") {
        return false;
      }
      if (!V19.isString(payload.leaderboardId) || payload.leaderboardId === "") {
        return false;
      }
      return true;
    }
    createDefaultTournamentName(name) {
      const shortName = name.substring(0, 7);
      const tournamentName = `${shortName.split(" ")[0] || shortName}'s Tournament`;
      const normalizedName = S10.removeDiacritics(tournamentName);
      return `${normalizedName}`;
    }
    parseTournamentPayload(payload) {
      if (typeof payload !== "string") {
        return {};
      }
      try {
        const parsedPayload = JSON.parse(payload);
        return parsedPayload;
      } catch (error) {
        return {};
      }
    }
  };
  var TournamentUtils_default = TournamentUtils;

  // src/game/effects/StarSparkleExplosive.ts
  init_phaser_custom_min();
  var { KEY: KEY87, FRAME: FRAME89 } = sprites_default.EFFECTS;
  var StarSparkleExplosive = class extends Phaser.GameObjects.Container {
    emitZone;
    emitter;
    constructor(scene) {
      super(scene);
      this.scene = scene;
      this.createEmitZone();
      this.createEmitters();
      this.kill();
    }
    createEmitZone() {
      this.emitZone = new Phaser.Geom.Rectangle();
    }
    createEmitters() {
      this.emitter = this.scene.add.particles(0, 0, KEY87, {
        frame: FRAME89.FX_STAR_YELLOW,
        emitZone: {
          source: this.emitZone,
          type: "random"
        },
        speed: { min: 50, max: 150 },
        scale: { start: 1.2, end: 0, ease: Phaser.Math.Easing.Quartic.Out },
        lifespan: { min: 600, max: 1e3 },
        emitting: true
      });
      this.add(this.emitter);
    }
    explode(count, x, y, width, height) {
      this.revive();
      this.emitZone.setSize(width, height);
      this.emitZone.setPosition(x - width / 2, y - height / 2);
      this.emitter.explode(count);
    }
  };
  var StarSparkleExplosive_default = StarSparkleExplosive;

  // src/game/screens/tournament-detail-screen/TournamentDetailScreen.ts
  var {
    Utils: { Object: O15, String: S11, Array: A8 }
  } = Ludex;
  var { event: event40, player: player27, storage: storage4 } = codex;
  var { KEY: DEFAULT_KEY8, FRAME: DEFAULT_FRAME8 } = sprites_default.DEFAULT;
  var { KEY: CHALLENGE_KEY4, FRAME: CHALLENGE_FRAME4 } = sprites_default.CHALLENGE;
  var { KEY: KEY88, FRAME: FRAME90 } = sprites_default.TOURNAMENTS;
  var TournamentDetailScreen = class extends Screen_default {
    popup;
    tournamentName;
    tournamentTime;
    closeButton;
    playButton;
    replayButton;
    shareButton;
    tournamentLeaders;
    topLeaders;
    emptyLabel;
    tournamentPayload;
    leadersPayload;
    previousLeadersPayload;
    popupShowUpAnimation;
    popupFadeOutAnimation;
    starSparkleUp;
    starSparkleExplosive;
    countdownTimer;
    tempPlayerLeader;
    shineTempPlayerLeader;
    signalController = new Ludex.Utils.Signal.SignalController();
    constructor(scene, name) {
      super(scene, name);
      this.createPopup();
      this.createMiddleBackground();
      this.createTournamentLeaders();
      this.createTopAndBottomBackground();
      this.createRibbon();
      this.createTitle();
      this.createTournamentName();
      this.createTournamentTime();
      this.createCloseButton();
      this.createPlayButton();
      this.createReplayButton();
      this.createShareButton();
      this.createTempPlayerLeader();
      this.createTopLeaders();
      this.createEmptyLabel();
      this.createEffects();
      this.resizePopup();
      this.setDepth(ScreenDepth_default.POPUP);
      this.background.setAlpha(0.8);
      event40.on(GameEvents_default.VIEW_RESIZED, this.resizePopup);
    }
    open(data) {
      super.open(data);
      this.tournamentPayload = data.tournamentPayload;
      const { title, endTime } = this.tournamentPayload;
      this.tournamentName.setText(this.getTournamentName(title));
      if (this.getRemainingTime(endTime) > 0) {
        this.countdownTimer?.remove();
        this.tournamentTime.setText(this.getTournamentTime(endTime));
        this.countdownTimer = this.scene.time.addEvent({
          delay: 1e3,
          callback: () => {
            if (this.getRemainingTime(endTime) <= 0) {
              this.countdownTimer?.remove();
              return;
            }
            this.tournamentTime.setText(this.getTournamentTime(endTime));
          },
          callbackScope: this,
          loop: true
        });
      }
      this.setButtonInteractable(true);
      this.updateLeaders(this.tournamentPayload);
      this.background.setAlpha(0);
      this.animateBackgroundAlpha(0.8, 400);
      this.runPopupEntrancesAnimation();
      if (data.tournamentContext === "tournament_end") {
        this.playButton.setVisible(false);
        this.replayButton.setVisible(true);
        this.shareButton.setVisible(true);
      } else {
        this.playButton.setVisible(true);
        this.replayButton.setVisible(false);
        this.shareButton.setVisible(false);
      }
    }
    close = () => {
      super.close();
      this.countdownTimer?.remove();
      this.signalController.abort();
    };
    async updateLeaders(payload) {
      this.emptyLabel.setVisible(false);
      const { leaderboardId } = payload.payload;
      if (!leaderboardId) return;
      this.tournamentLeaders.hideLeaders();
      this.tournamentLeaders.showLoading(true);
      this.starSparkleUp.stop();
      for (const topLeader of this.topLeaders) {
        topLeader.setVisible(false);
      }
      const signal = this.signalController.renew();
      this.leadersPayload = await this.getLeadersPayload(leaderboardId);
      if (signal.aborted) return;
      this.previousLeadersPayload = this.getPreviousLeadersPayload();
      storage4.setStorageData("Tournament", "showResult", false);
      this.tournamentLeaders.showLoading(false);
      if (this.leadersPayload.leaders.length === 0) {
        this.emptyLabel.setVisible(true);
        return;
      }
      this.tournamentLeaders.updateLeaders(this.previousLeadersPayload ?? this.leadersPayload);
      await this.tournamentLeaders.showLeaders();
      if (signal.aborted) return;
      await new Promise((resolve) => {
        if (!this.leadersPayload.player) resolve();
        if (this.previousLeadersPayload?.player?.rank) {
          this.tournamentLeaders.scroller.setEnabled(false);
          this.tournamentLeaders.scroller.scrollToConfigWithTween(
            this.previousLeadersPayload.player.rank - 2,
            false,
            () => {
              resolve();
            }
          );
        } else if (this.leadersPayload.player) {
          this.tournamentLeaders.scroller.scrollToConfig(this.leadersPayload.player.rank - 1);
          resolve();
        }
      });
      if (signal.aborted) return;
      await this.runRankUpAnimation();
      if (signal.aborted) return;
      this.starSparkleUp.run(1, 0, -150, 60, 60);
      for (let i = 0; i < 3; i++) {
        const topLeader = this.topLeaders[i];
        const leader = this.leadersPayload.leaders[i];
        if (leader) {
          topLeader.setVisible(true);
          topLeader.updateInfo(leader);
          topLeader.runShowPopUpAnimation(i);
        }
      }
    }
    handleClose = () => {
      this.setButtonInteractable(false);
      this.animateBackgroundAlpha(0, 200);
      this.runPopupExitsAnimation();
    };
    createPopup() {
      const width = 354;
      const height = 534;
      this.popup = this.scene.add.container(0, 0);
      this.popup.setSize(width, height);
      this.add(this.popup);
      const bannerHeightOffset = AdsUtils_default.getBannerHeight() / 2;
      Phaser.Display.Align.In.Center(this.popup, this.zone, 0, -bannerHeightOffset);
    }
    createMiddleBackground() {
      const middle = this.scene.make.image({
        key: KEY88,
        frame: FRAME90.LONG_POPUP_MIDDLE
      });
      this.popup.add(middle);
      AlignUtils_default.alignChildCenter(middle, this.popup, 0, 68);
    }
    createTopAndBottomBackground() {
      const top = this.scene.make.image({
        key: KEY88,
        frame: FRAME90.LONG_POPUP_TOP
      });
      const bottom = this.scene.make.image({
        key: KEY88,
        frame: FRAME90.LONG_POPUP_BOTTOM
      });
      this.popup.add([top, bottom]);
      AlignUtils_default.alignChildTopCenter(top, this.popup, 0, 0);
      AlignUtils_default.alignChildBottomCenter(bottom, this.popup, 0, 0);
    }
    createRibbon() {
      const ribbon = this.scene.make.image({
        key: KEY88,
        frame: FRAME90.RIBBON
      });
      this.popup.add(ribbon);
      AlignUtils_default.alignChildTopCenter(ribbon, this.popup, 0, 25);
    }
    createTitle() {
      const title = this.scene.make.image({
        key: KEY88,
        frame: FRAME90.RANKING_TEXT
      });
      this.popup.add(title);
      AlignUtils_default.alignChildTopCenter(title, this.popup, 0, 10);
    }
    createTournamentName() {
      this.tournamentName = FontUtils_default.createShadowText(this.scene, "", 18).setFontStyle("700").
      setTint(16576668);
      FontUtils_default.setTruncateOverflow(this.tournamentName, 230);
      this.popup.add(this.tournamentName);
      AlignUtils_default.alignChildTopCenter(this.tournamentName, this.popup, 0, -30);
    }
    createTournamentTime() {
      const bg = this.scene.make.image({
        key: KEY88,
        frame: FRAME90.PANEL_CLOCK
      });
      this.tournamentTime = FontUtils_default.createText(this.scene, "", 15).setFontStyle("700");
      FontUtils_default.applyYellowStyle(this.tournamentTime);
      const clock = this.scene.make.image({
        key: KEY88,
        frame: FRAME90.ICON_TIME
      });
      this.popup.add(bg);
      this.popup.add(this.tournamentTime);
      this.popup.add(clock);
      AlignUtils_default.alignChildCenter(bg, this.popup, 0, -70);
      Phaser.Display.Align.In.Center(this.tournamentTime, bg, 3, 0);
      Phaser.Display.Align.In.LeftCenter(clock, bg, 13, 0);
    }
    createCloseButton() {
      this.closeButton = new Button_default(this.scene, KEY88, FRAME90.X, 36, 37);
      this.closeButton.setName("Close");
      this.closeButton.onClick = this.handleClose;
      this.closeButton.setButtonHitSoundEffect(soundEffects_default.CLOSE_POPUP_CLICK);
      this.popup.add(this.closeButton);
      AlignUtils_default.alignChildTopRight(this.closeButton, this.popup, -15, -16);
    }
    createPlayButton() {
      this.playButton = new Button_default(this.scene, DEFAULT_KEY8, DEFAULT_FRAME8.BUTTON_GREEN, 139.5,
      45.5);
      this.playButton.setName("Play");
      const label = FontUtils_default.createText(this.scene, "Join", 22).setFontStyle("900");
      FontUtils_default.applyGreenStyle(label);
      const icon = this.scene.make.image({
        key: CHALLENGE_KEY4,
        frame: CHALLENGE_FRAME4.ICON_CONTINUE
      });
      this.playButton.add(label);
      this.playButton.add(icon);
      this.popup.add(this.playButton);
      Phaser.Display.Align.In.Center(label, this.playButton, 13, 0);
      Phaser.Display.Align.In.Center(icon, this.playButton, -30, 0);
      AlignUtils_default.alignChildBottomCenter(this.playButton, this.popup, 0, -23);
      this.playButton.onClick = this.handlePlayButtonClicked;
    }
    createReplayButton() {
      this.replayButton = new Button_default(this.scene, DEFAULT_KEY8, DEFAULT_FRAME8.BUTTON_YELLOW,
      139.5, 45.5);
      this.replayButton.setName("Replay");
      const label = FontUtils_default.createText(this.scene, "Replay", 18).setTint(16777215, 16777215,
      16770463, 16770463).setShadow(0, 3, "#b27f34", 0.5).setStroke("#b27f34", 2).setFontStyle("900");
      const icon = this.scene.make.image({
        key: DEFAULT_KEY8,
        frame: DEFAULT_FRAME8.ICON_REPLAY
      });
      this.replayButton.add(label);
      this.replayButton.add(icon);
      this.popup.add(this.replayButton);
      Phaser.Display.Align.In.Center(label, this.replayButton, 10, 0);
      Phaser.Display.Align.In.Center(icon, this.replayButton, -40, 0);
      AlignUtils_default.alignChildBottomCenter(this.replayButton, this.popup, -80, -23);
      this.replayButton.onClick = this.handleOnReplayButtonClicked;
    }
    createShareButton() {
      this.shareButton = new Button_default(this.scene, DEFAULT_KEY8, DEFAULT_FRAME8.BUTTON_BLUE, 139.5,
      45.5);
      this.shareButton.setName("Share");
      const label = FontUtils_default.createText(this.scene, "Share", 18).setFontStyle("900");
      FontUtils_default.applyBlueStyle(label);
      const icon = this.scene.make.image({
        key: DEFAULT_KEY8,
        frame: DEFAULT_FRAME8.ICON_SHARE
      });
      this.shareButton.add(label);
      this.shareButton.add(icon);
      this.popup.add(this.shareButton);
      Phaser.Display.Align.In.Center(label, this.shareButton, 10, 0);
      Phaser.Display.Align.In.Center(icon, this.shareButton, -40, 0);
      AlignUtils_default.alignChildBottomCenter(this.shareButton, this.popup, 80, -23);
      this.shareButton.onClick = this.handleOnShareButtonClicked;
    }
    createTournamentLeaders() {
      this.tournamentLeaders = new TournamentLeaders_default(this.scene);
      this.popup.add(this.tournamentLeaders);
      AlignUtils_default.alignChildCenter(this.tournamentLeaders, this.popup, 0, 30);
    }
    createTempPlayerLeader() {
      this.tempPlayerLeader = new Leader_default(this.scene);
      this.shineTempPlayerLeader = this.scene.make.image({
        key: KEY88,
        frame: FRAME90.ROLL_BAR
      });
      BlendModeUtils.inst.setBlendModeWithPerf(this.shineTempPlayerLeader, Phaser.BlendModes.ADD);
      this.shineTempPlayerLeader.setAlpha(0);
      this.popup.add(this.tempPlayerLeader);
      this.tempPlayerLeader.add(this.shineTempPlayerLeader);
      AlignUtils_default.alignChildCenter(this.tempPlayerLeader, this.popup, 0, 40);
      this.tempPlayerLeader.setVisible(false);
    }
    createTopLeaders() {
      this.topLeaders = [];
      for (let i = 0; i < 3; i++) {
        const topLeader = new TopLeader_default(this.scene, i);
        this.topLeaders.push(topLeader);
        this.popup.add(topLeader);
      }
      AlignUtils_default.alignChildTopCenter(this.topLeaders[0], this.popup, 0, -90);
      AlignUtils_default.alignChildTopCenter(this.topLeaders[1], this.popup, -90, -100);
      AlignUtils_default.alignChildTopCenter(this.topLeaders[2], this.popup, 90, -100);
      this.topLeaders[1].setScale(0.9);
      this.topLeaders[2].setScale(0.9);
    }
    createEmptyLabel() {
      this.emptyLabel = FontUtils_default.createText(this.scene, "Be the first to join\nthis epic tou\
rnament!", 18).setAlign("center").setTint(16374700).setFontStyle("700");
      this.popup.add(this.emptyLabel);
      AlignUtils_default.alignChildCenter(this.emptyLabel, this.popup, 0, 60);
    }
    createEffects() {
      this.starSparkleUp = new StarSparkle_default(this.scene);
      this.starSparkleExplosive = new StarSparkleExplosive_default(this.scene);
      this.popup.add([this.starSparkleUp, this.starSparkleExplosive]);
    }
    resizePopup = () => {
      const { height } = WorldUtils_default.getWorldSize();
      if (height > 700) {
        this.popup.setScale(1);
        return;
      }
      this.popup.setScale(height / 700);
    };
    getTournamentName(title) {
      const shortName = title.substring(0, 28);
      const normalizedName = S11.removeDiacritics(shortName);
      return normalizedName;
    }
    getTournamentTime(endTime) {
      const remainingTime = endTime * 1e3 - Date.now();
      const endTimeInSeconds = remainingTime / 1e3;
      const days = Math.floor(endTimeInSeconds / 86400);
      const hours = Math.floor(endTimeInSeconds % 86400 / 3600);
      const minutes = Math.floor(endTimeInSeconds % 3600 / 60);
      const secs = Math.floor(endTimeInSeconds % 60);
      return `${days}:${String(hours).padStart(2, "0")}:${String(minutes).padStart(2, "0")}:${String(
      secs).padStart(2, "0")}`;
    }
    getRemainingTime(endTime) {
      return endTime * 1e3 - Date.now();
    }
    handlePlayButtonClicked = async () => {
      await this.processPlayTournament(2, 0);
    };
    handleOnReplayButtonClicked = async () => {
      this.handlePlayButtonClicked();
    };
    handleOnShareButtonClicked = async () => {
      if (!this.leadersPayload.player) {
        ScreenUtils_default.showNotificationScreen("Sorry, unable to share tournament.", 2e3);
        return;
      }
      this.setButtonInteractable(false);
      try {
        await MatchUtils_default.shareTournamentAsync(this.leadersPayload.player.score);
      } catch (error) {
        ScreenUtils_default.showNotificationScreen("Sorry, unable to share tournament.", 2e3);
      }
      this.setButtonInteractable(true);
    };
    async processPlayTournament(level, score) {
      this.setButtonInteractable(false);
      const { id: id2 = "" } = this.tournamentPayload;
      const isTournamentExpired = TournamentUtils_default.validateTournamentExpired(id2);
      if (isTournamentExpired) {
        this.handleClose();
        ScreenUtils_default.showNotificationScreen("Tournament has ended", 2e3);
        return;
      }
      let success = await MatchUtils_default.joinTournamentAsync(id2, level);
      if (success === false) {
        this.setButtonInteractable(true);
        return;
      }
      if (!success) {
        success = await MatchUtils_default.continueTournamentAsync();
      }
      if (!success) {
        this.setButtonInteractable(true);
        ScreenUtils_default.showNotificationScreen("Sorry, unable to get\ntournament data.", 2e3);
        return;
      }
      if (this.leadersPayload.player)
        storage4.setStorageData("Tournament", "previousScore", this.leadersPayload.player.score);
      SceneUtils_default.switchToGameScene({ score });
    }
    async getLeadersPayload(leaderboardId) {
      this.setButtonInteractable(false);
      const leaderboardData = await LeaderboardUtils_default.getAllLeaderboardAsync(leaderboardId);
      this.setButtonInteractable(true);
      if (!leaderboardData)
        return {
          leaders: []
        };
      const leaders = O15.vals(leaderboardData.leaders);
      leaders.sort((a, b) => b.score - a.score);
      return {
        leaders,
        player: leaderboardData.leaders[player27.getPlayerId()]
      };
    }
    getPreviousLeadersPayload() {
      const { previousScore, showResult } = storage4.getStorage("Tournament") ?? {};
      if (previousScore === void 0 || !showResult) return;
      const { player: player33 } = this.leadersPayload;
      if (!player33 || player33.score <= previousScore || player33.rank === void 0) return void 0;
      const previousPlayer = { ...player33 };
      previousPlayer.score = previousScore;
      const previousLeaders = this.leadersPayload.leaders.filter((leader) => leader.playerId !== player33.
      playerId);
      previousLeaders.push(previousPlayer);
      previousLeaders.sort((a, b) => b.score - a.score);
      previousPlayer.rank = A8.searchIndex(previousLeaders, (leader) => leader.playerId === player33.
      playerId) + 2;
      if (player33.rank >= previousPlayer.rank) return void 0;
      return {
        leaders: previousLeaders,
        player: previousPlayer
      };
    }
    runPopupEntrancesAnimation() {
      const scale = this.popup.scale;
      const bannerHeightOffset = AdsUtils_default.getBannerHeight() / 2;
      this.popupShowUpAnimation = this.scene.tweens.add({
        targets: [this.popup],
        duration: 400,
        ease: Phaser.Math.Easing.Back.Out,
        props: {
          y: { from: 250 - bannerHeightOffset, to: -bannerHeightOffset },
          alpha: { start: 0, from: 0, to: 1 },
          scale: { start: scale * 0.8, from: scale * 0.8, to: scale }
        }
      });
      AnimUtils.runTween(this.popupShowUpAnimation);
    }
    runPopupExitsAnimation() {
      const scale = this.popup.scale;
      this.popupFadeOutAnimation = this.scene.tweens.add({
        ...FadeOut_default,
        targets: [this.popup],
        duration: 200,
        props: {
          ...FadeOut_default.props,
          scale: { start: scale, from: scale, to: scale * 0.8 }
        }
      });
      AnimUtils.runTweenAsync(this.popupFadeOutAnimation).then(() => {
        this.popup.setY(0);
        this.popup.setScale(scale);
        ScreenUtils_default.closeScreen(this.name);
      });
    }
    async runRankUpAnimation() {
      if (!this.previousLeadersPayload) return;
      const { player: previousPlayer } = this.previousLeadersPayload;
      const { player: player33 } = this.leadersPayload;
      if (!previousPlayer || !player33) return;
      const leaderHeight = this.tempPlayerLeader.height + 2;
      const tournamentScroller = this.tournamentLeaders.scroller;
      this.tempPlayerLeader.updateInfo(previousPlayer);
      const playerLeader = A8.search(
        tournamentScroller.getChildren(),
        (child) => child.payload.playerId === previousPlayer.playerId
      );
      if (!playerLeader) return;
      this.closeButton.setDisabled(true);
      playerLeader.setVisible(false);
      this.tempPlayerLeader.setVisible(true);
      this.tempPlayerLeader.setPosition(playerLeader.getWorldPosition().x, playerLeader.getWorldPosition().
      y);
      let toY = 70;
      if (player33.rank <= 2) {
        toY = (player33.rank - 1) * leaderHeight - 17;
      } else if (player33.rank === this.leadersPayload.leaders.length - 1) {
        toY = 98;
      }
      await Promise.all([
        new Promise((resolve) => {
          this.scene.add.tween({
            targets: [this.tempPlayerLeader],
            props: {
              scale: { duration: 200, from: 1, to: 1.1 },
              y: { duration: 1e3, from: this.tempPlayerLeader.y, to: toY }
            },
            onUpdate: (tween) => {
              const score = Math.round(
                previousPlayer.score + (player33.score - previousPlayer.score) * tween.progress
              );
              this.tempPlayerLeader.score.setText(score.toString());
              const rank = Math.round(
                previousPlayer.rank + (player33.rank - previousPlayer.rank) * tween.progress
              );
              this.tempPlayerLeader.updateRank(rank);
            },
            onComplete: () => {
              this.tempPlayerLeader.score.setText(player33.score.toString());
              this.tempPlayerLeader.updateRank(player33.rank);
              resolve();
            },
            ease: Phaser.Math.Easing.Quintic.Out
          });
        }),
        new Promise((resolve) => {
          this.tournamentLeaders.scroller.scrollToConfigWithTween(player33.rank - 1, false, () => {
            resolve();
          });
        })
      ]);
      let isExploded = false;
      this.scene.add.tween({
        targets: [this.tempPlayerLeader],
        props: {
          scale: { duration: 300, from: 1.1, to: 1 }
        },
        ease: Phaser.Math.Easing.Back.InOut,
        onUpdate: (tween) => {
          const progress = tween.progress;
          if (progress > 0.5 && !isExploded) {
            isExploded = true;
            this.starSparkleExplosive.explode(
              10,
              this.tempPlayerLeader.x,
              this.tempPlayerLeader.y,
              this.tempPlayerLeader.width,
              this.tempPlayerLeader.height
            );
          }
        }
      });
      this.scene.add.tween({
        targets: [this.shineTempPlayerLeader],
        duration: 200,
        props: {
          alpha: { from: 0, to: 0.3 }
        },
        onComplete: () => {
          this.tempPlayerLeader.setVisible(false);
        },
        yoyo: true
      });
      const belowLeaders = tournamentScroller.getChildren().filter((child) => child.payload.rank > player33.
      rank && child.payload.rank < previousPlayer.rank).slice(0, 4);
      this.scene.add.tween({
        targets: belowLeaders,
        duration: 300,
        props: {
          y: {
            getEnd: (target) => {
              return target.y + leaderHeight;
            }
          }
        },
        ease: Phaser.Math.Easing.Back.Out,
        onComplete: () => {
          tournamentScroller.setEnabled(true);
          this.tournamentLeaders.updateLeaders(this.leadersPayload);
          this.closeButton.setDisabled(false);
        }
      });
    }
    setButtonInteractable(interactable) {
      this.closeButton.setDisabled(!interactable);
      this.playButton.setDisabled(!interactable);
      this.replayButton.setDisabled(!interactable);
      this.shareButton.setDisabled(!interactable);
    }
    preDestroy() {
      this.countdownTimer?.remove();
      super.preDestroy();
    }
  };
  var TournamentDetailScreen_default = TournamentDetailScreen;

  // src/game/screens/tournament-screen/TournamentScreen.ts
  init_phaser_custom_min();

  // src/game/screens/tournament-screen/common/TournamentsBoard.ts
  init_phaser_custom_min();

  // src/game/screens/tournament-screen/common/TournamentBlock.ts
  init_phaser_custom_min();
  var {
    Utils: { Object: O16, String: S12, Time: T12 }
  } = Ludex;
  var { player: player28 } = codex;
  var { KEY: DEFAULT_KEY9, FRAME: DEFAULT_FRAME9 } = sprites_default.DEFAULT;
  var { KEY: KEY89, FRAME: FRAME91 } = sprites_default.TOURNAMENTS;
  var TournamentBlock = class extends Phaser.GameObjects.Container {
    scene;
    popup;
    tournamentBanner;
    tournamentIcon;
    tournamentName;
    tournamentTime;
    tournamentPlayers;
    playButton;
    joinLabel;
    continueLabel;
    blockPayload;
    leadersPayload;
    showPopUp;
    isRequesting;
    constructor(scene) {
      super(scene);
      this.scene = scene;
      this.createPopup();
      this.createTournamentBanner();
      this.createTournamentIcon();
      this.createTournamentName();
      this.createTournamentTime();
      this.createTournamentPlayers();
      this.createPlayButton();
    }
    createPopup() {
      const width = 354;
      const height = 296;
      this.popup = this.scene.add.container(0, 0);
      this.popup.setSize(width, height);
      const board = this.scene.make.image({
        key: KEY89,
        frame: FRAME91.POPUP
      });
      this.popup.add(board);
      this.add(this.popup);
      Phaser.Display.Align.In.Center(this.popup, this);
      this.setSize(width, height);
    }
    createTournamentBanner() {
      this.tournamentBanner = this.scene.make.image({
        key: KEY89,
        frame: FRAME91.FRAME
      });
      this.add(this.tournamentBanner);
      Phaser.Display.Align.In.Center(this.tournamentBanner, this.popup, 0, -15);
    }
    createTournamentIcon() {
      this.tournamentIcon = this.scene.make.image({
        key: KEY89,
        frame: FRAME91.ICON_RANKING
      });
      this.add(this.tournamentIcon);
      Phaser.Display.Align.In.TopLeft(this.tournamentIcon, this.popup, -20, -16);
    }
    createTournamentName() {
      this.tournamentName = FontUtils_default.createShadowText(this.scene, "", 18).setFontStyle("700").
      setTint(16576668);
      FontUtils_default.setTruncateOverflow(this.tournamentName, 230);
      this.add(this.tournamentName);
      Phaser.Display.Align.In.TopCenter(this.tournamentName, this.popup, 0, -22);
    }
    createTournamentTime() {
      const panel = this.scene.make.image({
        key: KEY89,
        frame: FRAME91.PANEL
      });
      const icon = this.scene.make.image({
        key: KEY89,
        frame: FRAME91.ICON_TIME
      });
      this.tournamentTime = FontUtils_default.createText(this.scene, "", 13).setFontStyle("700");
      FontUtils_default.applyYellowStyle(this.tournamentTime);
      this.tournamentTime.setOrigin(0, 0.5);
      this.add([panel, icon, this.tournamentTime]);
      Phaser.Display.Align.In.BottomLeft(panel, this.popup, -25, -22);
      Phaser.Display.Align.In.LeftCenter(icon, panel, 9, 0);
      Phaser.Display.Align.In.LeftCenter(this.tournamentTime, panel, -20, 0);
    }
    createTournamentPlayers() {
      const panel = this.scene.make.image({
        key: KEY89,
        frame: FRAME91.PANEL
      });
      const icon = this.scene.make.image({
        key: KEY89,
        frame: FRAME91.ICON_PEOPLE
      });
      this.tournamentPlayers = FontUtils_default.createText(this.scene, "", 13).setFontStyle("700");
      FontUtils_default.applyYellowStyle(this.tournamentPlayers);
      this.add([panel, icon, this.tournamentPlayers]);
      Phaser.Display.Align.In.BottomLeft(panel, this.popup, -25, -52);
      Phaser.Display.Align.In.LeftCenter(icon, panel, 7, 0);
      Phaser.Display.Align.In.Center(this.tournamentPlayers, panel);
    }
    createPlayButton() {
      const width = 146.5;
      const height = 50.5;
      this.playButton = new Button_default(this.scene, DEFAULT_KEY9, DEFAULT_FRAME9.BUTTON_GREEN, width,
      height);
      this.playButton.setName("Join");
      this.joinLabel = FontUtils_default.createText(this.scene, "Join", 22).setFontStyle("900");
      FontUtils_default.applyGreenStyle(this.joinLabel);
      this.continueLabel = FontUtils_default.createText(this.scene, "Continue", 22).setFontStyle("90\
0");
      FontUtils_default.applyGreenStyle(this.continueLabel);
      this.playButton.add([this.continueLabel, this.joinLabel]);
      this.popup.add(this.playButton);
      Phaser.Display.Align.In.Center(this.joinLabel, this.playButton);
      Phaser.Display.Align.In.Center(this.continueLabel, this.playButton);
      Phaser.Display.Align.In.BottomRight(this.playButton, this.popup, -15, -20);
      this.continueLabel.setVisible(false);
      this.playButton.onClick = this.handlePlayButtonClicked;
    }
    getTournamentName(title) {
      const shortName = title.substring(0, 28);
      const normalizedName = S12.removeDiacritics(shortName);
      return normalizedName;
    }
    getTournamentTime(endTime) {
      const timeString = T12.getRelativeTime(endTime, "en", { style: "short" });
      return `Ends ${timeString}`;
    }
    async updateInfo(data) {
      if (this.isRequesting) return;
      this.setLoading();
      this.blockPayload = data;
      const { title, endTime, payload } = data;
      const { leaderboardId } = payload;
      this.tournamentName.setText(this.getTournamentName(title));
      this.tournamentTime.setText(this.getTournamentTime(endTime));
      this.isRequesting = true;
      if (!leaderboardId) {
        this.isRequesting = false;
        return;
      }
      this.leadersPayload = await this.getLeadersPayload(leaderboardId);
      this.isRequesting = false;
      if (this.leadersPayload.player) {
        this.joinLabel.setVisible(false);
        this.continueLabel.setVisible(true);
      }
      this.tournamentPlayers.setText(`${this.leadersPayload.leaders.length}`);
    }
    async getLeadersPayload(leaderboardId) {
      const leaderboardData = await LeaderboardUtils_default.getAllLeaderboardAsync(leaderboardId);
      if (!leaderboardData)
        return {
          leaders: []
        };
      const leaders = O16.vals(leaderboardData.leaders);
      return {
        leaders,
        player: leaderboardData.leaders[player28.getPlayerId()]
      };
    }
    async runShowPopUpAnimation(delay, duration) {
      this.scene.tweens.killTweensOf(this);
      const currentY = this.y;
      this.showPopUp = new ShowPopup_default({
        targets: [this],
        delay,
        duration,
        props: {
          ...defaultConfig.props,
          y: { ...defaultConfig.props?.y, start: this.y + 70, to: this.y }
        },
        onStop: () => {
          this.y = currentY;
        }
      });
      this.showPopUp.play();
      return new Promise((resolve) => {
        this.scene.time.delayedCall(delay + duration + 500, () => {
          resolve();
        });
      });
    }
    runShowItemAnimation(delay, duration) {
      const targets = this.getItems();
      this.scene.tweens.killTweensOf(targets);
      for (const target of targets) {
        target.setScale(target.type === "Image" ? 0.5 : 1);
      }
      this.scene.tweens.add({
        targets,
        duration,
        delay: this.scene.tweens.stagger(50, { start: delay + 50 }),
        props: {
          alpha: {
            duration: 500,
            value: { start: 0, from: 0, to: 1 },
            ease: Phaser.Math.Easing.Cubic.Out
          },
          scale: {
            duration: 800,
            start: 0.8,
            end: 1,
            value: { start: 0.8, from: 0.8, to: 1 },
            ease: Phaser.Math.Easing.Elastic.Out,
            easeParams: [0.1, 0.45]
          }
        }
      });
    }
    getItems() {
      return [this.tournamentName, this.tournamentPlayers, this.tournamentTime];
    }
    async runShowUpAnimation(index = 0, duration = 300) {
      const delay = index * 100;
      this.runShowItemAnimation(delay, duration);
      await this.runShowPopUpAnimation(delay, duration);
    }
    setLoading() {
      this.tournamentPlayers.setText("Loading...");
    }
    handlePlayButtonClicked = () => {
      this.showTournamentDetailScreen();
    };
    showTournamentDetailScreen = () => {
      if (this.isRequesting) return;
      ScreenUtils_default.openScreen(ScreenKeys_default.TOURNAMENT_DETAIL_SCREEN, {
        tournamentPayload: this.blockPayload,
        tournamentContext: this.leadersPayload.player ? "tournament_end" : "tournament_start"
      });
    };
  };
  var TournamentBlock_default = TournamentBlock;

  // src/game/screens/tournament-screen/common/TournamentsBoard.ts
  var TournamentsBoard = class extends Phaser.GameObjects.Container {
    scene;
    loading;
    scroller;
    constructor(scene) {
      super(scene);
      this.scene = scene;
      this.createLoading();
      this.createScroller();
    }
    showLoading(visible) {
      this.loading.setVisible(visible);
    }
    createLoading() {
      this.loading = new TileLoading_default(this.scene);
      this.loading.setWorldSize(60, 60);
      this.add(this.loading);
      Phaser.Display.Align.In.Center(this.loading, this, 0, -40);
    }
    createScroller() {
      const boardHeight = WorldUtils_default.getWorldSize().height - 200;
      this.scroller = new ReuseScroller(this.scene, {
        size: {
          width: 354 + 10,
          height: boardHeight
        },
        visual: {
          margin: 5,
          mask: true,
          bounds: {
            height: 10,
            tint: 2102028
          }
        },
        reuse: {
          ClassType: TournamentBlock_default,
          configs: [],
          update: (tournament, config) => {
            tournament.updateInfo(config);
          }
        }
      });
      this.scroller.setPosition(0, 0);
      this.setSize(this.scroller.width, this.scroller.height);
      this.add(this.scroller);
      this.hideTournaments();
    }
    hideTournaments() {
      this.scroller.setVisible(false);
    }
    showTournaments() {
      this.scroller.setVisible(true);
      this.scroller.setEnabled(false);
      this.scroller.scrollToTop(true);
      const tournaments = this.getTournaments();
      const numberOfTournamentsShown = Math.min(tournaments.length, 3);
      const duration = 150;
      const tournamentPromises = [];
      for (let index = 0; index < numberOfTournamentsShown; index++) {
        const tournament = tournaments[index];
        if (!tournament) continue;
        tournament.setVisible(true);
        const p = tournament.runShowUpAnimation(index, duration);
        tournamentPromises.push(p);
      }
      if (tournamentPromises.length === 0) return;
      Promise.all(tournamentPromises).then(() => {
        this.scroller.setEnabled(true);
      });
    }
    getTournaments() {
      return this.scroller.getChildren();
    }
    updateTournaments(data) {
      this.scroller.setConfigs(data);
    }
  };
  var TournamentsBoard_default = TournamentsBoard;

  // src/game/screens/tournament-screen/TournamentScreen.ts
  var {
    Events: Events11,
    Utils: { Object: O17, Valid: V20 }
  } = Ludex;
  var { event: event41 } = codex;
  var { KEY: DEFAULT_KEY10, FRAME: DEFAULT_FRAME10 } = sprites_default.DEFAULT;
  var { KEY: KEY90, FRAME: FRAME92 } = sprites_default.TOURNAMENTS;
  var TournamentScreen = class extends Screen_default {
    popup;
    cup;
    ribbon;
    title;
    closeButton;
    tournamentButton;
    tournamentsBoard;
    blockInputZone;
    emptyLabel;
    popupShowUpAnimation;
    popupFadeOutAnimation;
    starSparkleUp;
    constructor(scene, name) {
      super(scene, name);
      this.createPopup();
      this.createCup();
      this.createRibbon();
      this.createTitle();
      this.createEmptyLabel();
      this.createTournamentsBoard();
      this.createBlockInputZone();
      this.createCloseButton();
      this.createTournamentButton();
      this.createEffects();
      this.add(this.popup);
      this.setDepth(ScreenDepth_default.POPUP);
      this.background.setAlpha(0.8);
      event41.on(Events11.OPEN_SCREEN, this.handleOpenScreen);
      event41.on(Events11.CLOSE_SCREEN, this.handleCloseScreen);
    }
    createPopup() {
      this.popup = this.scene.add.container(0, 0);
      this.popup.setWorldSize(375, 667);
    }
    createCup() {
      this.cup = this.scene.make.image({
        key: KEY90,
        frame: FRAME92.CUP
      });
      this.cup.setWorldSize(137, 106);
      Phaser.Display.Align.In.TopCenter(this.cup, this, 0, -24);
      this.popup.add(this.cup);
    }
    createRibbon() {
      this.ribbon = this.scene.make.image({
        key: KEY90,
        frame: FRAME92.RIBBON
      });
      this.ribbon.setWorldSize(245, 63.5);
      Phaser.Display.Align.In.TopCenter(this.ribbon, this, 0, -95);
      this.popup.add(this.ribbon);
    }
    createTitle() {
      this.title = this.scene.make.image({
        key: KEY90,
        frame: FRAME92.TOURNAMENT_TEXT
      });
      this.title.setWorldSize(163.5, 19.5);
      Phaser.Display.Align.In.Center(this.title, this.ribbon, 0, -7);
      this.popup.add(this.title);
    }
    createCloseButton() {
      this.closeButton = new Button_default(this.scene, DEFAULT_KEY10, DEFAULT_FRAME10.BUTTON_CLOSE);
      this.closeButton.setName("Close");
      this.closeButton.onClick = this.handleClose;
      this.closeButton.setButtonHitSoundEffect(soundEffects_default.CLOSE_POPUP_CLICK);
      this.popup.add(this.closeButton);
      Phaser.Display.Align.In.TopCenter(this.closeButton, this, 150, -70);
    }
    createTournamentButton() {
      if (!V20.isDebugger()) return;
      this.tournamentButton = new Button_default(this.scene, KEY90, FRAME92.ICON_RANKING);
      this.tournamentButton.setName("Tournament");
      this.tournamentButton.onClick = this.handleCreateTournament;
      this.tournamentButton.setButtonHitSoundEffect(soundEffects_default.CLOSE_POPUP_CLICK);
      this.popup.add(this.tournamentButton);
      Phaser.Display.Align.In.TopCenter(this.tournamentButton, this, -150, -70);
    }
    createTournamentsBoard() {
      this.tournamentsBoard = new TournamentsBoard_default(this.scene);
      this.popup.add(this.tournamentsBoard);
      Phaser.Display.Align.In.TopCenter(this.tournamentsBoard, this, 0, -150);
    }
    createEmptyLabel() {
      this.emptyLabel = FontUtils_default.createText(this.scene, "", 20).setText(["No tournaments av\
ailable", "Check back later!"]).setTint(16374700).setFontStyle("700").setAlign("center");
      this.emptyLabel.setVisible(false);
      this.popup.add(this.emptyLabel);
      Phaser.Display.Align.In.Center(this.emptyLabel, this.popup, 0, 0);
    }
    createBlockInputZone() {
      this.blockInputZone = this.scene.add.zone(0, 0, 375, 150);
      this.blockInputZone.setInteractive();
      this.popup.add(this.blockInputZone);
      Phaser.Display.Align.In.TopCenter(this.blockInputZone, this, 0, 0);
    }
    createEffects() {
      this.starSparkleUp = new StarSparkle_default(this.scene);
      this.starSparkleUp.run(1.25, 0, this.cup.y - 20, 120, 60);
      this.popup.add(this.starSparkleUp);
    }
    open() {
      super.open();
      this.updateTournaments();
      this.background.setAlpha(0);
      this.animateBackgroundAlpha(0.8, 400);
      this.runPopupEntrancesAnimation();
    }
    handleClose = async () => {
      this.animateBackgroundAlpha(0, 200);
      this.runPopupExitsAnimation();
    };
    handleCreateTournament = async () => {
      try {
        await MatchUtils_default.createTournamentAsync();
      } catch (error) {
        if (!O17.hasOwn(error, "code")) {
          ScreenUtils_default.showNotificationScreen("Sorry, please try again later", 2e3);
          return;
        }
        if (error.code === "USER_INPUT") return;
        if (error.code === "PLAYER_HAS_TOURNAMENT") {
          ScreenUtils_default.showNotificationScreen("You already have a tournament", 2e3);
          return;
        }
        if (error.code === "INVALID_OPERATION") {
          ScreenUtils_default.showNotificationScreen("Sorry, please try again later", 2e3);
          return;
        }
        ScreenUtils_default.showNotificationScreen("Create tournament failed", 2e3);
      } finally {
        this.updateTournaments();
      }
    };
    async updateTournaments() {
      this.tournamentsBoard.hideTournaments();
      this.tournamentsBoard.showLoading(true);
      this.emptyLabel.setVisible(false);
      const tournamentData = await TournamentUtils_default.requestTournamentDataAsync();
      this.tournamentsBoard.updateTournaments(tournamentData);
      this.tournamentsBoard.showLoading(false);
      this.tournamentsBoard.showTournaments();
      if (tournamentData.length === 0) {
        this.emptyLabel.setVisible(true);
      }
    }
    runPopupEntrancesAnimation() {
      this.popupShowUpAnimation = this.scene.tweens.add({
        ...ShowUp_default,
        targets: [this.popup],
        duration: 400,
        props: {
          ...ShowUp_default.props,
          alpha: { start: 0, from: 0, to: 1 },
          scale: { start: 0.8, from: 0.8, to: 1 }
        }
      });
      AnimUtils.runTween(this.popupShowUpAnimation);
    }
    runPopupExitsAnimation() {
      this.popupFadeOutAnimation = this.scene.tweens.add({
        ...FadeOut_default,
        targets: [this.popup],
        duration: 200,
        props: {
          ...FadeOut_default.props,
          scale: 0.8
        }
      });
      AnimUtils.runTweenAsync(this.popupFadeOutAnimation).then(() => {
        this.popup.setY(0);
        ScreenUtils_default.closeScreen(this.name);
      });
    }
    handleOpenScreen = (payload) => {
      if (payload.screenName !== ScreenKeys_default.TOURNAMENT_DETAIL_SCREEN) return;
      this.scene.add.tween({
        targets: [this.popup],
        duration: 100,
        props: {
          alpha: 0
        },
        onComplete: () => {
          this.popup.setVisible(false);
        }
      });
    };
    handleCloseScreen = (payload) => {
      if (payload.screenName !== ScreenKeys_default.TOURNAMENT_DETAIL_SCREEN) return;
      this.popup.setVisible(true);
      this.scene.add.tween({
        targets: [this.popup],
        duration: 100,
        props: {
          alpha: 1
        }
      });
    };
    preDestroy() {
      event41.off(Events11.OPEN_SCREEN, this.handleOpenScreen);
      event41.off(Events11.CLOSE_SCREEN, this.handleCloseScreen);
      super.preDestroy();
    }
  };
  var TournamentScreen_default = TournamentScreen;

  // src/constants/ScreenInstances.ts
  var ScreenInstances = {
    [ScreenKeys_default.PAUSE_SCREEN]: PauseScreen_default,
    [ScreenKeys_default.NOTIFY_SCREEN]: NotifyScreen_default,
    [ScreenKeys_default.RESCUE_SCREEN]: RescueScreen_default,
    [ScreenKeys_default.RESULT_SCREEN]: ResultScreen_default,
    [ScreenKeys_default.CONTINUE_SCREEN]: ContinueScreen_default,
    [ScreenKeys_default.LUCKY_WHEEL_SCREEN]: LuckyWheelScreen_default,
    [ScreenKeys_default.REWARD_ITEM_SCREEN]: RewardItemScreen_default,
    [ScreenKeys_default.REWARD_COINS_SCREEN]: RewardCoinsScreen_default,
    [ScreenKeys_default.TOURNAMENTS_SCREEN]: TournamentScreen_default,
    [ScreenKeys_default.TOURNAMENT_DETAIL_SCREEN]: TournamentDetailScreen_default,
    [ScreenKeys_default.RESULT_CHALLENGE_FRIEND_SCREEN]: ResultChallengeScreen_default,
    [ScreenKeys_default.DAILY_MISSIONS_SCREEN]: DailyMissionsScreen_default,
    [ScreenKeys_default.JOURNEY_SCREEN]: JourneyScreen_default,
    [ScreenKeys_default.LOADING_SCREEN]: LoadingScreen_default
  };
  var ScreenInstances_default = ScreenInstances;

  // src/systems/ScreenManager.ts
  var { event: event42, monitorError: monitorError2 } = codex;
  var {
    Events: Events12,
    Utils: { Valid: V21, Object: O18 }
  } = Ludex;
  var ScreenManager = class {
    screens = {};
    init() {
      this.bindEventHandlers();
      console.info("Screen Manager: Initialized");
    }
    bindEventHandlers() {
      event42.on(Events12.OPEN_SCREEN, this.handleOpenScreen);
      event42.on(Events12.CLOSE_SCREEN, this.handleCloseScreen);
      event42.on(GameEvents_default.DESTROY_SCREENS, this.destroyAllScreens);
    }
    handleOpenScreen = (payload) => {
      this.openScreen(payload.screenName, payload.screenData);
    };
    handleCloseScreen = (payload) => {
      this.closeScreen(payload.screenName, true);
    };
    createScreen(name) {
      const scene = SceneUtils_default.getCurrentScene();
      if (!scene) {
        throw new Error(`Create Screen: Invalid scene ${name}`);
      }
      const { scenes } = this.screens[name];
      const screen2 = scenes[scene.scene.key];
      if (screen2) {
        this.setupScreen(scene, screen2);
        return;
      }
      const Instance = this.getScreenInstance(name);
      if (!Instance) {
        throw new Error(`Create Screen: Invalid screen ${name}`);
      }
      const instance = new Instance(scene, name);
      this.setupScreen(scene, instance);
    }
    setupScreen(scene, screen2) {
      const name = screen2.name;
      this.screens[name].scenes[scene.scene.key] = screen2;
      ScreenUtils_default.addScreen(name, screen2);
      scene.add.existing(screen2);
      if (O18.hasOwn(scene, "gameZone") && V21.isObject(scene.gameZone)) {
        if (scene.gameZone instanceof Phaser.GameObjects.Zone) {
          Phaser.Display.Align.In.Center(screen2, scene.gameZone);
        }
      }
    }
    getScreenInstance(name) {
      const screen2 = ScreenInstances_default[name];
      return screen2 ? screen2 : null;
    }
    prepareScreen(name) {
      this.addScreen(name);
      this.createScreen(name);
    }
    addScreen(name) {
      if (this.screens[name]) return;
      const order = Object.keys(this.screens).length;
      this.screens[name] = {
        name,
        order,
        scenes: {}
      };
    }
    getScreen(name) {
      this.prepareScreen(name);
      const scene = SceneUtils_default.getCurrentScene();
      if (!scene) {
        throw new Error(`ScreenManager: Invalid scene ${name}`);
      }
      const { scenes } = this.screens[name];
      const screen2 = scenes[scene.scene.key];
      if (!screen2) {
        throw new Error(`ScreenManager: Screen ${name} not ready`);
      }
      return screen2;
    }
    validateScreen(screenName) {
      if (!V21.isString(screenName)) {
        throw new Error(`ScreenManager: Invalid screen name ${screenName}`);
      }
    }
    async openScreen(screenName, screenData) {
      this.validateScreen(screenName);
      await new Promise((resolve) => requestAnimationFrame(resolve));
      const screen2 = this.getScreen(screenName);
      if (screen2.active) return;
      console.debug("openScreen", screenName);
      this.showScreen(screen2, screenName, screenData);
    }
    async showScreen(screen2, screenName, screenData) {
      const eventPayload = { screenName, screenData };
      event42.emit(Events12.OPENING_SCREEN, eventPayload);
      screen2.open(screenData);
      this.updateAnalytics(screenName);
      event42.emit(Events12.OPENED_SCREEN, eventPayload);
    }
    async closeScreen(screenName, updateCurrentPage = false) {
      this.validateScreen(screenName);
      await new Promise((resolve) => requestAnimationFrame(resolve));
      const screen2 = this.getScreen(screenName);
      if (!screen2.active) return;
      console.debug("closeScreen", screenName);
      event42.emit(Events12.CLOSING_SCREEN, { screenName });
      screen2.close();
      if (updateCurrentPage) {
        this.updateAnalytics(screenName, false);
      }
      event42.emit(Events12.CLOSED_SCREEN, { screenName });
    }
    updateAnalytics(screenName, isOpening = true) {
      AnalyticsUtils_default.trackCurrentPage(screenName, isOpening);
      if (isOpening) {
        monitorError2?.addMetadata({ currentScreen: screenName });
      } else {
        monitorError2?.removeMetadata("currentScreen");
      }
    }
    closeAllScreens() {
      const logCurrentPage = false;
      for (const screenName in this.screens) {
        this.closeScreen(screenName, logCurrentPage);
      }
    }
    destroyAllScreens = (payload) => {
      const { sceneKey } = payload;
      if (!sceneKey) return;
      for (const screenName in this.screens) {
        const screenEntry = this.screens[screenName];
        if (!screenEntry) continue;
        const screen2 = screenEntry.scenes[sceneKey];
        if (!screen2) continue;
        screen2.destroy();
        delete screenEntry.scenes[sceneKey];
      }
    };
  };
  var ScreenManager_default = ScreenManager;

  // src/systems/StorageManager.ts
  init_phaser_custom_min();
  var { storage: storage5 } = codex;
  var StorageManager = class {
    init() {
      console.info("Storage Manager: Initialized");
    }
    setupDefaultData() {
      this.setupTournamentData();
    }
    setupTournamentData() {
      storage5.addStorage("Tournament", {
        showResult: false,
        previousScore: void 0
      });
    }
  };
  var StorageManager_default = StorageManager;

  // src/systems/LuderSystem.ts
  var {
    Events: Events13,
    Plugins: {
      Analytics: { Events: AnalyticsEvents16 }
    },
    Utils: { Function: F7, Valid: V22 }
  } = Ludex;
  var { context, event: event43, analytics: analytics19, monitorError: monitorError3 } = codex;
  var LuderSystem = class {
    coreManager$ = new CoreManager_default();
    adsManager$ = new AdsManager_default();
    sceneManager$ = new SceneManager_default();
    matchManager$ = new MatchManager_default();
    screenManager$ = new ScreenManager_default();
    playerManager$ = new PlayerManager_default();
    storageManager$ = new StorageManager_default();
    pluginsManager$ = new PluginsManager_default();
    constructor() {
      window.isCustomRequestAnimationFrame = false;
      analytics19.event(AnalyticsEvents16.ENGINE_READY);
      console.groupEnd();
      console.groupCollapsed("\u{1F4E6} Luder System");
      console.info("Luder Initializing...");
      this.initManagers$();
      this.listenEvents$();
      console.groupEnd();
    }
    initManagers$() {
      this.coreManager$.init();
      this.adsManager$.init();
      this.sceneManager$.init();
      this.screenManager$.init();
      this.matchManager$.init();
      this.playerManager$.init();
      this.storageManager$.init();
      this.pluginsManager$.init();
    }
    listenEvents$() {
      this.coreManager$.onCoreBoot(this.handleWhenCoreBoot$);
      this.coreManager$.onCoreStart(this.handleWhenCoreStart$);
      this.coreManager$.onCoreReady(this.handleWhenCoreReady$);
      this.sceneManager$.onSwitchScene(this.handleSwitchScene);
    }
    handleWhenCoreBoot$ = () => {
      this.coreManager$.requestStart();
    };
    handleWhenCoreStart$ = () => {
      this.playerManager$.setupDefaultGameData();
    };
    handleWhenCoreReady$ = async () => {
      await this.playerManager$.syncPlayerData();
      this.matchManager$.setupDefaultMatchData();
      this.storageManager$.setupDefaultData();
      this.initPlugins$();
      console.groupEnd();
      analytics19.event(AnalyticsEvents16.LOAD_START);
      event43.catchUp(Events13.BUNDLE_READY, this.processPreStartGame$);
    };
    processPreStartGame$ = () => {
      event43.catchUp(Events13.SCENE_LAUNCHED, this.processBootSceneLaunched$);
      this.runBootScene$();
    };
    processBootSceneLaunched$ = async () => {
      await event43.waitTo(Events13.SCENE_LAUNCHED);
      if (!window.phaser.isRunning) {
        await this.waitGameResume$();
      }
      this.processStartGame$();
    };
    async waitGameResume$() {
      return new Promise((resolve) => {
        window.phaser.events.once(Phaser.Core.Events.RESUME, resolve);
      });
    }
    runBootScene$() {
      window.phaser.scene.start(SceneKeys_default.BOOT_SCENE);
    }
    async processStartGame$() {
      console.groupEnd();
      analytics19.event(AnalyticsEvents16.LOAD_COMPLETE);
      await this.startGameAsync$();
      event43.catchUp(Events13.PLAYER_INFO_LOADED, this.startProcessContextData$);
    }
    handleSwitchScene = () => {
      console.groupEnd();
    };
    // ? Why call startGameAsync here?
    // * We want to make sure that the game is ready to start, not show
    async startGameAsync$(retries = 0) {
      const startSDKPromise = GameSDK.startGameAsync();
      const [_, error] = await F7.handleAsync(startSDKPromise);
      if (!error) return;
      if (retries <= 3) {
        setTimeout(() => {
          this.startGameAsync$(retries + 1);
        }, 1e3);
        return;
      }
      monitorError3?.sendException(error);
    }
    startProcessContextData$ = async () => {
      analytics19.event(AnalyticsEvents16.APP_READY);
      this.playerManager$.requestConnectedPlayers();
      const processContextDataPromise = context.processContextData();
      const [_, error] = await F7.handleAsync(processContextDataPromise);
      if (error) {
        console.warn("startProcessContextData", error);
        monitorError3?.sendException(error);
      }
      event43.emit(Events13.GAME_READY);
    };
    initPlugins$() {
      this.pluginsManager$.initMissions();
      this.pluginsManager$.initLeaderboards();
      this.pluginsManager$.initDailyRewards();
      this.pluginsManager$.initFrameCapture();
      this.pluginsManager$.initAdaptivePerformance();
    }
  };
  new LuderSystem();
  if (V22.isDebugger()) {
    new EventSource("/esbuild").addEventListener("change", () => location.reload());
  }

  // src/game/index.ts
  init_phaser_custom_min();

  // src/GameObjectExtra.ts
  init_phaser_custom_min();
  var {
    DesignSize: { Resolution: Resolution2 }
  } = GameWorld_default;
  var GameObjectExtra = class {
    addKillRevive() {
      ;
      [
        Phaser.GameObjects.Container,
        Phaser.GameObjects.Image,
        Phaser.GameObjects.Sprite,
        Phaser.GameObjects.Graphics,
        Phaser.GameObjects.Text,
        Phaser.GameObjects.Zone,
        Phaser.GameObjects.Particles.ParticleEmitter,
        Phaser.GameObjects.NineSlice
        //
      ].forEach((object) => {
        object.prototype.kill = this.kill;
        object.prototype.revive = this.revive;
      });
    }
    addKillReviveGroup() {
      Phaser.GameObjects.Group.prototype.killGroup = this.killGroup;
      Phaser.GameObjects.Group.prototype.reviveGroup = this.reviveGroup;
    }
    addSetFrame() {
      ;
      [Phaser.GameObjects.Image, Phaser.GameObjects.Sprite].forEach((object) => {
        object.prototype.oriSetFrame = object.prototype.setFrame;
        object.prototype.setFrame = this.setFrame;
      });
    }
    addSetWorldSize() {
      ;
      [Phaser.GameObjects.Image, Phaser.GameObjects.Sprite, Phaser.GameObjects.Zone].forEach((object) => {
        object.prototype.setWorldSize = this.setWorldSize;
      });
    }
    addSetWorldSizeForNineSlice() {
      ;
      [Phaser.GameObjects.NineSlice].forEach((object) => {
        object.prototype.setWorldSize = this.setWorldSizeForNineSlice;
      });
    }
    addSetWorldSizeForContainer() {
      ;
      [Phaser.GameObjects.Container].forEach((object) => {
        object.prototype.setWorldSize = this.setWorldSizeForContainer;
      });
    }
    addGetWorldPosition() {
      ;
      [
        Phaser.GameObjects.Container,
        Phaser.GameObjects.Image,
        Phaser.GameObjects.Sprite,
        Phaser.GameObjects.Graphics,
        Phaser.GameObjects.Text,
        Phaser.GameObjects.Zone
      ].forEach((object) => {
        object.prototype.getWorldPosition = this.getWorldPosition;
      });
    }
    addDrawDebugBox() {
      ;
      [
        Phaser.GameObjects.Container,
        Phaser.GameObjects.Image,
        Phaser.GameObjects.Sprite,
        Phaser.GameObjects.Graphics,
        Phaser.GameObjects.Text,
        Phaser.GameObjects.Zone
      ].forEach((object) => {
        object.prototype.drawDebugBox = this.drawDebugBox;
      });
    }
    addHighQuality() {
      ;
      [Phaser.GameObjects.Text].forEach((object) => {
        object.prototype.setHighQuality = this.setHighQuality;
      });
    }
    kill() {
      this.setActive(false);
      this.setVisible(false);
    }
    revive() {
      this.setActive(true);
      this.setVisible(true);
    }
    killGroup() {
      const children = this.getChildren();
      for (const child of children) {
        child.setActive(false);
        child.setVisible(false);
      }
    }
    reviveGroup() {
      const children = this.getChildren();
      for (const child of children) {
        child.setActive(true);
        child.setVisible(true);
      }
    }
    setFrame(frame, updateSize = true, updateOrigin = true) {
      this.oriSetFrame(frame, updateSize, updateOrigin);
      this.__width = this.width;
      this.__height = this.height;
      return this;
    }
    setWorldSize(width, height) {
      if (typeof this.__width !== "number") {
        this.__width = this.width;
      }
      if (typeof this.__height !== "number") {
        this.__height = this.height;
      }
      const dpr = WorldUtils_default.getPixelRatio();
      const worldWidth = width ? width : this.__width / dpr;
      const worldHeight = height ? height : this.__height / dpr;
      this.setSize(worldWidth, worldHeight);
      this.setDisplaySize(worldWidth, worldHeight);
    }
    setWorldSizeForContainer(width, height) {
      if (typeof width !== "number" || typeof height !== "number") return;
      this.setSize(width, height);
      this.setDisplaySize(width, height);
    }
    setWorldSizeForNineSlice(width, height) {
      if (!this.__width) {
        this.__width = this.frame.width;
      }
      if (!this.__height) {
        this.__height = this.frame.height;
      }
      const dpr = WorldUtils_default.getPixelRatio();
      const worldWidth = width ? width : this.__width / dpr;
      const worldHeight = height ? height : this.__height / dpr;
      this.leftWidth = this.leftWidth / dpr;
      this.rightWidth = this.rightWidth / dpr;
      this.topHeight = this.topHeight / dpr;
      this.bottomHeight = this.bottomHeight / dpr;
      this.setSize(worldWidth, worldHeight);
      this.setDisplaySize(worldWidth, worldHeight);
    }
    getWorldPosition() {
      const target = this.getWorldTransformMatrix();
      const { translateX, translateY } = target.decomposeMatrix();
      return { x: translateX, y: translateY };
    }
    drawDebugBox(color = 65280, alpha = 0.2) {
      const { width, height, depth, originX, originY } = this;
      if (!width || !height) {
        throw new Error("Width and height are required in drawDebugBox");
      }
      const debugBox = this.scene.add.rectangle(0, 0, width, height, color, alpha);
      debugBox.setName("Debug Box");
      debugBox.setDepth(depth + 1);
      if (this instanceof Phaser.GameObjects.Container) {
        this.add(debugBox);
      }
      if (this.parentContainer) {
        this.parentContainer.add(debugBox);
      }
      debugBox.setOrigin(originX, originY);
      Phaser.Display.Align.In.Center(debugBox, this);
      return debugBox;
    }
    setHighQuality() {
      if (!(this.renderer instanceof Phaser.Renderer.WebGL.WebGLRenderer)) return this;
      return this.setResolution(Resolution2);
    }
  };
  var GameObjectExtra_default = GameObjectExtra;

  // src/game/scenes/BootScene.ts
  init_phaser_custom_min();
  var { event: event44, player: player29 } = codex;
  var { Events: Events14 } = Ludex;
  var BootScene = class extends BaseScene_default {
    create() {
      super.create();
      try {
        event44.catchUp(Events14.GAME_SDK_STARTED, this.processWhenGameSdkStarted);
        SceneUtils_default.switchScene(SceneKeys_default.LOAD_SCENE);
        this.scene.launch(SceneKeys_default.GLOBAL_SCENE);
      } catch (error) {
        console.warn("BootScene", error);
      }
    }
    processWhenGameSdkStarted = () => {
      this.setupGameData();
    };
    setupGameData() {
      const gameData = player29.getGameData();
      if (!gameData) return;
      const { level } = gameData;
      const correctLevel = Math.max(level, 1);
      const correctGameData = {
        level: correctLevel
      };
      player29.setGameData(correctGameData);
      CoinUtils_default.loadCoin();
      MissionUtils_default.addGameMissions();
    }
  };
  var BootScene_default = BootScene;

  // src/game/scenes/dashboard-scene/index.ts
  init_phaser_custom_min();

  // src/game/scenes/dashboard-scene/DashboardScene.ts
  init_phaser_custom_min();

  // src/game/scenes/dashboard-scene/layouts/LayoutManager.ts
  init_phaser_custom_min();

  // src/game/scenes/dashboard-scene/layouts/UIObjects.ts
  init_phaser_custom_min();

  // src/game/scenes/dashboard-scene/containers/HeaderContainer.ts
  init_phaser_custom_min();

  // src/game/scenes/dashboard-scene/components/IconButton.ts
  init_phaser_custom_min();
  var {
    DEFAULT: { KEY: DEFAULT_KEY11, FRAME: DEFAULT_FRAME11 },
    DASHBOARD: { KEY: DASHBOARD_KEY3 }
  } = sprites_default;
  var IconButton = class extends Button_default {
    constructor(scene) {
      super(scene, DEFAULT_KEY11, DEFAULT_FRAME11.BUTTON_YELLOW_CIRCLE);
      this.setName("IconButton");
      this.scene.add.existing(this);
    }
    setIcon(frame) {
      const icon = this.scene.add.image(0, 0, DASHBOARD_KEY3, frame);
      this.add(icon);
    }
  };
  var IconButton_default = IconButton;

  // src/game/scenes/dashboard-scene/containers/HeaderContainer.ts
  var { FRAME: FRAME93 } = sprites_default.DASHBOARD;
  var HeaderContainer = class extends Phaser.GameObjects.Container {
    shopButton;
    settingsButton;
    constructor(scene) {
      super(scene);
      this.updateWorldSize();
      this.createButtons();
      this.scene.add.existing(this);
    }
    createButtons() {
      this.shopButton = new IconButton_default(this.scene);
      this.shopButton.setIcon(FRAME93.ICON_SHOP);
      this.shopButton.kill();
      this.settingsButton = new IconButton_default(this.scene);
      this.settingsButton.setIcon(FRAME93.ICON_SETTINGS);
      this.add([this.shopButton, this.settingsButton]);
    }
    updateWorldSize() {
      const { width } = WorldUtils_default.getWorldSize();
      const maxWidth = Math.min(width, 600);
      this.setWorldSize(maxWidth, 50);
    }
  };
  var HeaderContainer_default = HeaderContainer;

  // src/game/scenes/dashboard-scene/containers/MainContainer.ts
  init_phaser_custom_min();

  // src/game/scenes/dashboard-scene/components/IconMenu.ts
  init_phaser_custom_min();
  var {
    Utils: { Signal: S13 }
  } = Ludex;
  var { KEY: KEY91, FRAME: FRAME94 } = sprites_default.DASHBOARD;
  var IconMenu = class extends Button_default {
    icon;
    label;
    alertContainer;
    alertText;
    alertIcon;
    alertShine;
    alertShineOgScale;
    panelName;
    alertAnimController = new S13.SignalController();
    isAlerting = false;
    constructor(scene) {
      super(scene, KEY91, FRAME94.PANEL_ICON);
      this.setName("IconMenu");
      this.createPanelName();
      this.createAlert();
    }
    setIcon(frame) {
      if (this.icon) {
        this.icon.setFrame(frame);
        return;
      }
      this.icon = this.scene.add.image(0, 0, KEY91, frame);
      this.add(this.icon);
      this.moveBelow(this.icon, this.panelName);
      Phaser.Display.Align.In.Center(this.icon, this, 0, -2);
    }
    setText(text) {
      if (this.label) {
        this.label.setText(text);
        return;
      }
      this.label = FontUtils_default.createText(this.scene, text, 9).setTint(16636332).setShadow(0, 2,
      "#00000075", 0.5).setFontStyle("700");
      this.add(this.label);
      Phaser.Display.Align.In.BottomCenter(this.label, this.button, 0, -3);
    }
    createPanelName() {
      this.panelName = this.scene.add.image(0, 0, KEY91, FRAME94.PANEL_NAME);
      this.add(this.panelName);
      Phaser.Display.Align.In.BottomCenter(this.panelName, this, 0, -1);
    }
    createAlert() {
      this.alertContainer = this.scene.add.container();
      this.add(this.alertContainer);
      this.createAlertIcon();
      this.alertContainer.setSize(this.alertIcon.width, this.alertIcon.height);
      this.createAlertText();
      this.createAlertShine();
      Phaser.Display.Align.In.TopRight(this.alertContainer, this.button, 0, 4);
    }
    createAlertIcon() {
      this.alertIcon = this.scene.add.image(0, 0, KEY91, FRAME94.ICON_INFO_DOT);
      this.alertContainer.add(this.alertIcon);
      this.alertIcon.kill();
    }
    createAlertText() {
      this.alertText = FontUtils_default.createText(this.scene, "1", 12).setFontStyle("700").setOrigin(
      0.5, 0.5).setAlign("center");
      this.alertContainer.add(this.alertText);
      this.alertText.kill();
    }
    createAlertShine() {
      this.alertShine = this.scene.add.image(0, 0, KEY91, FRAME94.ICON_INFO_DOT);
      this.alertShine.setAlpha(0);
      BlendModeUtils.inst.setBlendModeWithPerf(this.alertShine, Phaser.BlendModes.ADD);
      this.alertContainer.add(this.alertShine);
      this.alertShineOgScale = this.alertShine.scale;
      this.alertShine.kill();
    }
    playAlertAnimation() {
      if (this.isAlerting) return;
      this.isAlerting = true;
      const signal = this.alertAnimController.renew();
      this.alertIcon.revive();
      this.alertText.revive();
      this.alertShine.revive();
      AnimUtils.runTween(
        this.scene.tweens.chain({
          paused: true,
          tweens: [
            {
              targets: this.alertContainer,
              props: {
                scale: { from: 0, to: 1 }
              },
              duration: 200,
              ease: Phaser.Math.Easing.Sine.Out
            },
            {
              targets: this.alertShine,
              props: {
                alpha: { from: 0.4, to: 0 },
                scale: { from: this.alertShineOgScale, to: this.alertShineOgScale * 1.7 }
              },
              duration: 1e3,
              ease: Phaser.Math.Easing.Cubic.Out,
              repeat: -1
            }
          ]
        }),
        signal
      );
    }
    stopAlertAnimation() {
      if (!this.isAlerting) return;
      this.isAlerting = false;
      const signal = this.alertAnimController.renew();
      const kill = () => {
        this.alertIcon.kill();
        this.alertText.kill();
        this.alertShine.kill();
      };
      AnimUtils.runTween(
        this.scene.tweens.add({
          targets: this.alertContainer,
          props: {
            scale: { from: 1, to: 0 }
          },
          duration: 200,
          ease: Phaser.Math.Easing.Sine.In,
          paused: true,
          onComplete: kill
        }),
        signal
      );
    }
    setAlertText(text) {
      this.alertText.setText(text);
    }
  };
  var IconMenu_default = IconMenu;

  // src/game/scenes/dashboard-scene/components/JourneyProgress.ts
  init_phaser_custom_min();

  // src/game/components/SimpleProgress.ts
  init_phaser_custom_min();
  var SimpleProgress = class extends Phaser.GameObjects.Container {
    progressBox;
    progressBar;
    constructor(scene, payload) {
      super(scene);
      const { key, boxFrame, barFrames } = payload;
      this.setWorldSize(115, 14);
      this.createProgressBox(key, boxFrame);
      this.createProgressBar(key, barFrames);
      this.alignBar();
      this.scene.add.existing(this);
    }
    setProcess(value) {
      this.progressBar.setWorldSize(this.width * value, this.height);
      this.alignBar();
    }
    alignBar() {
      const [left, middle, right] = this.progressBar.list;
      const { width } = this.progressBar;
      const barWidth = left.width + right.width;
      const calcWidth = width - barWidth;
      const middleWidth = Math.max(calcWidth, -8);
      middle.setWorldSize(middleWidth);
      Phaser.Display.Align.In.Center(this.progressBar, this.progressBox, 1.5, -0.5);
      Phaser.Display.Align.In.LeftCenter(left, this.progressBar);
      Phaser.Display.Align.To.RightCenter(middle, left);
      Phaser.Display.Align.To.RightCenter(right, middle);
      Phaser.Display.Align.In.LeftCenter(this.progressBar, this.progressBox);
    }
    createProgressBox(key, frame) {
      this.progressBox = this.scene.make.image({
        key,
        frame
      });
      this.add(this.progressBox);
    }
    createProgressBar(key, frames) {
      this.progressBar = this.scene.add.container();
      this.progressBar.setWorldSize(this.width, this.height);
      const left = this.scene.make.image({
        key,
        frame: frames.left
      });
      const middle = this.scene.make.image({
        key,
        frame: frames.middle
      });
      const right = this.scene.make.image({
        key,
        frame: frames.right
      });
      this.progressBar.add([left, middle, right]);
      this.add(this.progressBar);
    }
  };
  var SimpleProgress_default = SimpleProgress;

  // src/game/scenes/dashboard-scene/components/JourneyProgress.ts
  var { KEY: KEY92, FRAME: FRAME95 } = sprites_default.DASHBOARD;
  var JourneyProgress = class extends Button_default {
    image;
    country;
    progress;
    constructor(scene) {
      super(scene, KEY92, FRAME95.THEME_FRAME);
      this.setWorldSize(185, 186);
      this.createBoard();
      this.createInfo();
      this.createProgress();
      this.setName("JourneyProgress");
    }
    updateProgress() {
      this.image.setFrame(ThemeUtils.getThemeFrameForDashboardComponent());
      this.country.setText(ThemeUtils.getThemeName());
      this.progress.setProcess(ThemeUtils.getThemeProgress());
    }
    createBoard() {
      this.image = this.scene.make.image({
        key: KEY92,
        frame: ThemeUtils.getThemeFrameForDashboardComponent()
      });
      this.add(this.image);
      Phaser.Display.Align.In.TopCenter(this.image, this.button, 0, -12);
    }
    createInfo() {
      const color = 9060888;
      const currentTarget = FontUtils_default.createText(this.scene, "CURRENT TARGET", 9).setTint(color).
      setAlpha(0.8);
      this.country = FontUtils_default.createText(this.scene, ThemeUtils.getThemeName(), 16).setFontStyle(
      "700").setTint(color).setOrigin(0, 0.5);
      this.add([currentTarget, this.country]);
      Phaser.Display.Align.In.Center(currentTarget, this, -32, 32);
      Phaser.Display.Align.In.BottomLeft(this.country, currentTarget, 0, 19);
    }
    createProgress() {
      this.progress = new SimpleProgress_default(this.scene, {
        key: KEY92,
        boxFrame: FRAME95.BORDER_FULL,
        barFrames: {
          left: FRAME95.PROGRESS_LEFT,
          middle: FRAME95.PROGRESS_MIDDLE,
          right: FRAME95.PROGRESS_RIGHT
        }
      });
      this.progress.setProcess(ThemeUtils.getThemeProgress());
      this.add(this.progress);
      Phaser.Display.Align.In.Center(this.progress, this, -15, 65);
    }
  };
  var JourneyProgress_default = JourneyProgress;

  // src/game/scenes/dashboard-scene/components/icon-menus/DailySpinIconMenu.ts
  init_phaser_custom_min();
  var { Events: Events15 } = Ludex;
  var { player: player30, event: event45 } = codex;
  var { FRAME: FRAME96 } = sprites_default.DASHBOARD;
  var LENGTH_OF_ONE_DAY2 = 1e3 * 60 * 60 * 24;
  var REFRESH_INTERVAL = 1e3 * 30;
  var DailySpinIconMenu = class extends IconMenu_default {
    lastUpdate = 0;
    constructor(scene) {
      super(scene);
      this.setIcon(FRAME96.ICON_DAILY_SPIN);
      this.setText("Daily Spin");
      this.setName("DailySpinIconMenu");
      this.refresh();
    }
    listenToEvents() {
      this.unlistenToEvents();
      this.scene.events.on(Phaser.Scenes.Events.UPDATE, this.update, this);
      event45.on(Events15.OPEN_SCREEN, this.onOpenScreen);
      event45.on(Events15.CLOSE_SCREEN, this.onCloseScreen);
    }
    unlistenToEvents() {
      this.scene.events.off(Phaser.Scenes.Events.UPDATE, this.update, this);
      event45.off(Events15.OPEN_SCREEN, this.onOpenScreen);
      event45.off(Events15.CLOSE_SCREEN, this.onCloseScreen);
    }
    update(time) {
      if (time - this.lastUpdate > REFRESH_INTERVAL) {
        this.lastUpdate = time;
        this.refresh();
      }
    }
    preDestroy() {
      this.unlistenToEvents();
      this.alertAnimController.abort();
      super.preDestroy();
    }
    onOpenScreen = ({ screenName }) => {
      if (screenName !== ScreenKeys_default.LUCKY_WHEEL_SCREEN) return;
      this.refresh();
    };
    onCloseScreen = ({ screenName }) => {
      if (screenName !== ScreenKeys_default.LUCKY_WHEEL_SCREEN) return;
      this.refresh();
    };
    refresh() {
      if (this.hasFreeSpin$()) {
        this.playAlertAnimation();
      } else {
        this.stopAlertAnimation();
      }
    }
    hasFreeSpin$() {
      const { lastDailySpin = 0 } = player30.getGameData() ?? {};
      const startOfLastDailySpinDate = new Date(lastDailySpin);
      startOfLastDailySpinDate.setHours(0, 0, 0, 0);
      const now = Date.now();
      const diff = now - startOfLastDailySpinDate.getTime();
      if (diff > LENGTH_OF_ONE_DAY2) {
        return true;
      }
      return false;
    }
  };

  // src/game/scenes/dashboard-scene/components/icon-menus/DailyRewardsIconMenu.ts
  init_phaser_custom_min();
  var { Events: Events16 } = Ludex;
  var { player: player31, event: event46 } = codex;
  var { FRAME: FRAME97 } = sprites_default.DASHBOARD;
  var REFRESH_INTERVAL2 = 1e3 * 30;
  var DailyRewardsIconMenu = class extends IconMenu_default {
    lastUpdate = 0;
    constructor(scene) {
      super(scene);
      this.setIcon(FRAME97.ICON_REWARDS);
      this.setText("Daily Rewards");
      this.setName("DailyRewardsIconMenu");
      this.refresh();
      this.listenToEvents();
    }
    listenToEvents() {
      this.scene.events.on(Phaser.Scenes.Events.UPDATE, this.update, this);
      event46.on(Events16.OPEN_SCREEN, this.onOpenScreen);
      event46.on(Events16.CLOSE_SCREEN, this.onCloseScreen);
    }
    unlistenToEvents() {
      this.scene.events.off(Phaser.Scenes.Events.UPDATE, this.update, this);
      event46.off(Events16.OPEN_SCREEN, this.onOpenScreen);
      event46.off(Events16.CLOSE_SCREEN, this.onCloseScreen);
    }
    update(time) {
      if (time - this.lastUpdate > REFRESH_INTERVAL2) {
        this.lastUpdate = time;
        this.refresh();
      }
    }
    preDestroy() {
      this.unlistenToEvents();
      this.alertAnimController.abort();
      super.preDestroy();
    }
    onOpenScreen = ({ screenName }) => {
      if (screenName !== ScreenKeys_default.REWARD_COINS_SCREEN) return;
      this.refresh();
    };
    onCloseScreen = ({ screenName }) => {
      if (screenName !== ScreenKeys_default.REWARD_COINS_SCREEN) return;
      this.refresh();
    };
    refresh() {
      if (this.hasDailyRewards$()) {
        this.playAlertAnimation();
      } else {
        this.stopAlertAnimation();
      }
    }
    hasDailyRewards$() {
      const { lastReceiveGift = 0 } = player31.getGameData() || {};
      return !this.isSameDay(lastReceiveGift, Date.now());
    }
    isSameDay(date1, date2) {
      const firstDate = new Date(date1);
      const secondDate = new Date(date2);
      return firstDate.toDateString() === secondDate.toDateString();
    }
  };

  // src/game/scenes/dashboard-scene/components/icon-menus/DailyMissionsIconMenu.ts
  init_phaser_custom_min();
  var { FRAME: FRAME98 } = sprites_default.DASHBOARD;
  var DailyMissionsIconMenu = class extends DailySpinIconMenu {
    constructor(scene) {
      super(scene);
      this.setIcon(FRAME98.ICON_DAILY_MISSIONS);
      this.setText("Daily Missions");
      this.setName("DailyMissionsIconMenu");
      this.setAlertText("");
    }
    onOpenScreen = ({ screenName }) => {
      if (screenName !== ScreenKeys_default.DAILY_MISSIONS_SCREEN) return;
      this.refresh();
    };
    onCloseScreen = ({ screenName }) => {
      if (screenName !== ScreenKeys_default.DAILY_MISSIONS_SCREEN) return;
      this.refresh();
    };
    refresh() {
      const claimableMissions = MissionUtils_default.checkForClaimableMissions();
      if (claimableMissions > 0) {
        this.setAlertText(`${claimableMissions}`);
        this.playAlertAnimation();
      } else {
        this.setAlertText("");
        this.stopAlertAnimation();
      }
    }
  };
  var DailyMissionsIconMenu_default = DailyMissionsIconMenu;

  // src/game/scenes/dashboard-scene/containers/MainContainer.ts
  var { KEY: KEY93, FRAME: FRAME99 } = sprites_default.DASHBOARD;
  var MainContainer = class extends Phaser.GameObjects.Container {
    logo;
    dailySpin;
    dailyRewards;
    inviteFriends;
    dailyMissions;
    tournament;
    playButton;
    playButtonFrame;
    progressBar;
    constructor(scene) {
      super(scene);
      this.updateWorldSize();
      this.createLogo();
      this.createFrame();
      this.createPlayButton();
      this.createMenuButtons();
      this.createProgressBar();
      this.scene.add.existing(this);
    }
    createLogo() {
      this.logo = this.scene.add.image(0, 0, KEY93, FRAME99.TITLE);
      this.add(this.logo);
    }
    createFrame() {
      this.playButtonFrame = this.scene.add.image(0, 0, KEY93, FRAME99.BUTTON_FRAME);
      Phaser.Display.Align.In.BottomCenter(this.playButtonFrame, this, 0, -40);
      this.add(this.playButtonFrame);
    }
    createPlayButton() {
      this.playButton = new PlayButton_default(this.scene);
      Phaser.Display.Align.In.BottomCenter(this.playButton, this, 0, -40);
      this.add(this.playButton);
    }
    createMenuButtons() {
      const dailySpin = new DailySpinIconMenu(this.scene);
      dailySpin.listenToEvents();
      const inviteFriends = new IconMenu_default(this.scene);
      inviteFriends.setIcon(FRAME99.ICON_INVITE_FRIENDS);
      inviteFriends.setText("With Friends");
      const dailyRewards = new DailyRewardsIconMenu(this.scene);
      const dailyMissions = new DailyMissionsIconMenu_default(this.scene);
      dailyMissions.listenToEvents();
      const tournament = new IconMenu_default(this.scene);
      tournament.setIcon(FRAME99.ICON_CUP);
      tournament.setText("Tournaments");
      this.dailySpin = dailySpin;
      this.tournament = tournament;
      this.dailyRewards = dailyRewards;
      this.dailyMissions = dailyMissions;
      this.inviteFriends = inviteFriends;
      this.add([dailySpin, inviteFriends, dailyRewards, dailyMissions, tournament]);
    }
    createProgressBar() {
      this.progressBar = new JourneyProgress_default(this.scene);
      this.add(this.progressBar);
    }
    updateWorldSize() {
      const { width, height } = WorldUtils_default.getWorldSize();
      const maxWidth = Math.min(width, 600);
      const maxHeight = Math.min(height, 420);
      this.setWorldSize(maxWidth, maxHeight);
    }
  };
  var MainContainer_default = MainContainer;

  // src/game/scenes/dashboard-scene/containers/FooterContainer.ts
  init_phaser_custom_min();
  var FooterContainer = class extends Phaser.GameObjects.Container {
    constructor(scene) {
      super(scene);
      this.updateWorldSize();
      this.scene.add.existing(this);
    }
    updateWorldSize() {
      const { width } = WorldUtils_default.getWorldSize();
      const height = AdsUtils_default.getBannerHeight();
      this.setWorldSize(width, height);
    }
  };
  var FooterContainer_default = FooterContainer;

  // src/game/scenes/dashboard-scene/layouts/UIObjects.ts
  var UIObjects2 = class extends BaseUIObjects_default {
    scene;
    // * Containers
    header;
    main;
    footer;
    coinBar;
    constructor(scene) {
      super(scene);
      this.scene = scene;
      this.createObjects();
    }
    createObjects() {
      this.createHeader();
      this.createMain();
      this.createFooter();
      this.createCoinBar();
    }
    createHeader() {
      this.header = new HeaderContainer_default(this.scene);
      this.group.add(this.header);
    }
    createMain() {
      this.main = new MainContainer_default(this.scene);
      this.group.add(this.main);
    }
    createFooter() {
      this.footer = new FooterContainer_default(this.scene);
      this.group.add(this.footer);
    }
    createCoinBar() {
      this.coinBar = new CoinsBar_default(this.scene);
      this.group.add(this.coinBar);
    }
  };
  var UIObjects_default2 = UIObjects2;

  // src/game/scenes/dashboard-scene/layouts/LandscapeLayout.ts
  init_phaser_custom_min();

  // src/game/scenes/dashboard-scene/layouts/PortraitLayout.ts
  init_phaser_custom_min();
  var PortraitLayout2 = class extends BaseLayout_default {
    objects;
    constructor(scene) {
      super(scene);
      this.objects = null;
    }
    alignUI() {
      if (!this.objects) return;
      const { gameZone } = this.scene;
      const { header, main, footer, coinBar } = this.objects;
      header.updateWorldSize();
      main.updateWorldSize();
      footer.updateWorldSize();
      const pad = 10;
      const space = 90;
      const playButtonPadY = 40;
      AlignUtils_default.alignChildTopRight(header.shopButton, header, -pad - 50, -pad);
      AlignUtils_default.alignChildTopRight(header.settingsButton, header, -pad, -pad);
      AlignUtils_default.alignChildTopCenter(main.logo, main);
      AlignUtils_default.alignChildCenter(main.progressBar, main);
      AlignUtils_default.alignChildTopLeft(main.tournament, main, -pad, -10);
      AlignUtils_default.alignChildTopRight(main.dailySpin, main, -pad, -10);
      AlignUtils_default.alignChildTopLeft(main.inviteFriends, main, -pad, -space);
      AlignUtils_default.alignChildTopRight(main.dailyRewards, main, -pad, -space);
      AlignUtils_default.alignChildTopLeft(main.dailyMissions, main, -pad, -space * 2);
      AlignUtils_default.alignChildBottomCenter(main.playButton, main, 0, -playButtonPadY);
      AlignUtils_default.alignChildBottomCenter(main.playButtonFrame, main, 0, -playButtonPadY);
      Phaser.Display.Align.In.TopCenter(header, gameZone);
      Phaser.Display.Align.In.TopLeft(coinBar, header, -pad, -pad);
      Phaser.Display.Align.To.BottomCenter(main, header);
      Phaser.Display.Align.In.BottomCenter(footer, gameZone);
    }
    alignItems() {
    }
  };
  var PortraitLayout_default2 = PortraitLayout2;

  // src/game/scenes/dashboard-scene/layouts/LandscapeLayout.ts
  var LandscapeLayout2 = class extends PortraitLayout_default2 {
    objects;
    constructor(scene) {
      super(scene);
      this.objects = null;
    }
    alignUI() {
      if (this.objects === null) return;
      super.alignUI();
      const { header, main } = this.objects;
      Phaser.Display.Align.To.BottomCenter(main, header, 0, -10);
      main.progressBar.setScale(0.8);
      main.progressBar.setTargetScaleUp(0.8);
      main.progressBar.setTargetScaleDown(0.78);
      Phaser.Display.Align.To.BottomCenter(main.progressBar, main.logo);
      Phaser.Display.Align.To.BottomCenter(main.playButton, main.progressBar);
      Phaser.Display.Align.In.Center(main.playButtonFrame, main.playButton);
    }
    alignItems() {
    }
  };
  var LandscapeLayout_default2 = LandscapeLayout2;

  // src/game/scenes/dashboard-scene/layouts/LayoutManager.ts
  var { event: event47 } = codex;
  var {
    Utils: { Time: T13 }
  } = Ludex;
  var LayoutManager2 = class extends BaseLayoutManager_default {
    scene;
    constructor(scene) {
      super(scene);
      this.scene = scene;
      this.registerEvents();
    }
    createObjects() {
      this.objects = new UIObjects_default2(this.scene);
    }
    registerEvents() {
      event47.on(GameEvents_default.VIEW_RESIZED, this.handleResize);
      event47.on(GameEvents_default.LAYOUT_CHANGED, this.handleLayoutChange);
    }
    /**
     * If the device is in landscape mode, use the LandscapeLayout, otherwise use the PortraitLayout
     */
    createLayouts() {
      if (WorldUtils_default.isLandscape()) {
        this.layout = new LandscapeLayout_default2(this.scene);
      } else {
        this.layout = new PortraitLayout_default2(this.scene);
      }
      this.layout.setUIObjects(this.objects);
    }
    // * If have more logic, you can create a new class to handle it (UIManager)
    initUILogic() {
      const { header, main, coinBar } = this.objects;
      header.shopButton.onClick = () => {
      };
      header.settingsButton.onClick = () => {
        ScreenUtils_default.openScreen(ScreenKeys_default.PAUSE_SCREEN);
      };
      main.tournament.onClick = () => {
        ScreenUtils_default.openScreen(ScreenKeys_default.TOURNAMENTS_SCREEN);
      };
      main.dailySpin.onClick = () => {
        ScreenUtils_default.openScreen(ScreenKeys_default.LUCKY_WHEEL_SCREEN, { coinBar });
      };
      main.inviteFriends.onClick = this.handleInviteFriends;
      main.dailyMissions.onClick = () => {
        ScreenUtils_default.openScreen(ScreenKeys_default.DAILY_MISSIONS_SCREEN, { coinBar });
      };
      main.dailyRewards.onClick = () => {
        ScreenUtils_default.openScreen(ScreenKeys_default.REWARD_COINS_SCREEN, { coinBar });
      };
      main.playButton.onClick = this.handlePlay;
      main.progressBar.onClick = () => {
        ScreenUtils_default.openScreen(ScreenKeys_default.JOURNEY_SCREEN);
      };
      T13.sleepAsync(100).then(() => {
      });
    }
    handlePlay = async () => {
      const success = await MatchUtils_default.startSingleModeAsync();
      if (!success) return;
      SceneUtils_default.switchToGameScene();
    };
    handleInviteFriends = async () => {
      const success = await MatchUtils_default.startChallengeChooseOpponentAsync();
      if (!success) return;
      SceneUtils_default.switchToGameScene();
    };
    // * If have more state, you can create a new class to handle it (UIManager)
    updateUIState() {
      this.objects.main.progressBar.updateProgress();
    }
  };
  var LayoutManager_default2 = LayoutManager2;

  // src/game/scenes/dashboard-scene/DashboardScene.ts
  var { player: player32, storage: storage6 } = codex;
  var {
    Utils: { Valid: V23, Array: A9, Time: T14 }
  } = Ludex;
  var DashboardScene = class extends BaseScene_default {
    layoutManager;
    run = async () => {
      this.layoutManager.init();
      this.initEvents();
      this.updatePlayButton();
      this.updateCoinBar();
      this.updateDailyMissionsIconMenu();
      this.layoutManager.start();
      AudioUtils_default.playMusic();
      AudioUtils_default.setDefaultVolumeMusic();
      this.tryShowTournamentResult();
    };
    initEvents() {
      const { event: event49 } = codex;
      event49.off(GameEvents_default.COINS_CHANGED, this.updateCoinBar);
      event49.on(GameEvents_default.COINS_CHANGED, this.updateCoinBar);
    }
    updatePlayButton() {
      const { level } = player32.getGameData() ?? {};
      if (!V23.isNumber(level)) return;
      const { main } = this.layoutManager.objects;
      main.playButton.setLevel(level);
      main.playButton.playShineAnimation();
    }
    updateDailyMissionsIconMenu = () => {
      const { main } = this.layoutManager.objects;
      main.dailyMissions.refresh();
    };
    updateCoinBar = () => {
      const { coinBar } = this.layoutManager.objects;
      coinBar.updatePlayerCoin();
    };
    preload() {
      this.events.on("wake", this.run);
      this.events.on("resume", this.run);
      this.events.on("create", this.run);
    }
    create() {
      super.create();
      this.createBackground(images_default.BACKGROUND.KEY);
      this.createManagers();
    }
    createManagers() {
      this.layoutManager = new LayoutManager_default2(this);
    }
    async tryShowTournamentResult() {
      await T14.sleepAsync(0);
      try {
        const tournamentStorage = storage6.getStorage("Tournament");
        const { showResult } = tournamentStorage;
        if (!showResult) return;
        ScreenUtils_default.showLoadingScreen();
        const tournamentData = await TournamentUtils_default.requestTournamentDataAsync();
        ScreenUtils_default.closeLoadingScreen();
        const { tournamentId } = MatchUtils_default.getMatchState().customData;
        if (!tournamentId) throw new Error("Tournament ID not found");
        const tournament = A9.search(tournamentData, (tournament2) => tournament2.id === tournamentId);
        if (!tournament) throw new Error("Tournament not found");
        ScreenUtils_default.openScreen(ScreenKeys_default.TOURNAMENT_DETAIL_SCREEN, {
          tournamentPayload: tournament,
          tournamentContext: "tournament_end"
        });
      } catch (error) {
        console.error(error);
      }
    }
  };
  var DashboardScene_default = DashboardScene;

  // src/game/scenes/dashboard-scene/index.ts
  var dashboard_scene_default = DashboardScene_default;

  // src/game/index.ts
  var MagicGame = class extends Phaser.Game {
    async boot() {
      super.boot();
      this.addExtraGameObjectMethods();
      this.addPlugins();
      this.addScenes();
      this.initWorld();
      this.initUtils();
    }
    addExtraGameObjectMethods() {
      const extra = new GameObjectExtra_default();
      extra.addKillRevive();
      extra.addKillReviveGroup();
      extra.addDrawDebugBox();
      extra.addSetFrame();
      extra.addSetWorldSize();
      extra.addSetWorldSizeForContainer();
      extra.addGetWorldPosition();
      extra.addHighQuality();
      extra.addSetWorldSizeForNineSlice();
    }
    addPlugins() {
      if (window.SpinePlugin) {
        this.plugins.installScenePlugin("SpinePlugin", SpinePlugin, "spine");
      }
    }
    addScenes() {
      this.scene.add(SceneKeys_default.BOOT_SCENE, BootScene_default, false);
      this.scene.add(SceneKeys_default.LOAD_SCENE, LoadScene_default, false);
      this.scene.add(SceneKeys_default.GAME_SCENE, game_scene_default, false);
      this.scene.add(SceneKeys_default.DASHBOARD_SCENE, dashboard_scene_default, false);
      this.scene.add(SceneKeys_default.GLOBAL_SCENE, global_scene_default, false);
    }
    initWorld() {
      WorldUtils_default.init(this);
    }
    initUtils() {
      this.removeUnusedPipelines();
    }
    removeUnusedPipelines() {
      const renderer = this.renderer;
      if (!(renderer instanceof Phaser.Renderer.WebGL.WebGLRenderer)) {
        return;
      }
      const { pipelines: manager } = renderer;
      const pipelines = Phaser.Renderer.WebGL.Pipelines;
      const list = [
        pipelines.ROPE_PIPELINE,
        pipelines.LIGHT_PIPELINE,
        pipelines.POSTFX_PIPELINE,
        pipelines.POINTLIGHT_PIPELINE,
        pipelines.BITMAPMASK_PIPELINE
      ];
      for (const pipelineName of list) {
        manager.get(pipelineName)?.destroy();
        manager.remove(pipelineName);
      }
    }
  };
  var game_default2 = MagicGame;

  // src/game/configs/PhaserConfig.ts
  init_phaser_custom_min();
  var PhaserConfig = {
    parent: "GameDiv",
    // type: Phaser.WEBGL,
    scale: {
      autoRound: true
    },
    dom: {
      createContainer: false
    },
    fps: {
      target: 60,
      smoothStep: true
    },
    // backgroundColor: '#333',
    loader: {
      maxParallelDownloads: 6,
      crossOrigin: "no-cros"
    },
    input: {
      gamepad: false,
      touch: {
        capture: true
        // set 'true' for smooth touch move
      },
      smoothFactor: 1,
      // smooth position when drag, 1 is not smooth: 0 -> 1
      activePointers: 1,
      windowEvents: false
      // set 'true' for fix dragMove outsize of window
    },
    disableContextMenu: true,
    render: {
      pixelArt: false,
      antialias: true,
      transparent: false,
      // some devices can't working, ex: crash and white scene on J2
      desynchronized: true,
      // set 'false' to fix some dropdown fps
      powerPreference: "low-power",
      clearBeforeRender: false,
      // set 'true' when use for some feature need a transparent background
      roundPixels: false,
      // NEAREST             : use less cpu/gpu, output like pixel
      // LINEAR_MIPMAP_LINEAR: use more cpu/gpu, smooth and more ram
      mipmapFilter: "LINEAR_MIPMAP_LINEAR"
    },
    plugins: {
      global: []
    }
  };
  var PhaserConfig_default = PhaserConfig;

  // src/index.ts
  var { event: event48 } = codex;
  var { Events: Events17 } = Ludex;
  var initGame = () => {
    try {
      window.phaser = new game_default2(PhaserConfig_default);
      event48.emit(Events17.BUNDLE_READY);
    } catch (error) {
      console.error("Init Game Error", error);
    }
  };
  initGame();
})();
//! wait for handle pointer down in guide complete
//! removeTile first then setTileToMap, do not sort
