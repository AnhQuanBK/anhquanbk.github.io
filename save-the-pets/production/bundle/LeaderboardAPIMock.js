System.register(["./core.js","../GameCore.js","./monitor-error.js"],function(w,j){"use strict";var L,D;return{setters:[l=>{L=l.G},l=>{D=l.D},null],execute:function(){const{Configs:l,Utils:R}=L,{MinScore:m,MaxScore:B,NumOfLeaders:f,ErrorRate:S,DefaultLimit:k,RandomDelayMs:M}=l.Mockup.Leaderboards,{Valid:u,Browser:y,Time:P,Object:h,Number:E}=R,g="LeadersMockKey",p="LeaderboardsMockKey";class O{async getPlayers(e,r){if(await this.awaitRandomDelay(),this.randomResponseError("Get players error"))return{data:[]};const{playerIds:a}=r,t=[];if(a&&a.length>0){const n=this.getLeadersData(e);for(const s of a){const o=n[s];o&&t.push(o)}}return{data:t}}async getLeaders(e,r){if(await this.awaitRandomDelay(),this.randomResponseError("Get leaders error"))return{data:[]};const{limit:a,offset:t}=r,n=this.getLeadersData(e),s=h.vals(n);this.sortLeadersRank(s);const o=[],d=t,i=a===0?k:t+a;for(let c=d;c<i;c++){const b=s[c];b&&o.push(b)}return this.sortLeadersRank(o),{data:o}}async getLeaderboardAsync(e){if(await this.awaitRandomDelay(),this.randomResponseError("Get leaderboard error"))return null;const r=this.getLeaderBoard(e);return r||null}async getLeaderboardsAsync(e){if(await this.awaitRandomDelay(),this.randomResponseError("Get leaderboards error"))return[];const{limit:r=9999,type:a}=e;if(r<=0)return[];const t=this.getLeaderBoardsData(),n=h.vals(t);return a===void 0?n.slice(0,r):n.filter(o=>o.type===a).slice(0,r)}getLeadersData(e){const r=this.getPlayersData(),a=Object.keys(r[e]),t={};for(const n of a){const s=r[e][n];u.isObject(s)&&(t[n]=s)}return t}sortLeadersRank(e){e.sort((r,a)=>parseInt(a.score,10)-parseInt(r.score,10)),e.forEach((r,a)=>{r.rank=a+1})}async setScoreAsync(e,r,a){if(await this.awaitRandomDelay(),this.randomResponseError("Set score error"))return null;const t={success:!1},n=this.getLeaderBoard(e);if(!n)return t;const s=this.getPlayersData();let o=s[e][r];o||(o=this.createPlayerData(r),n.amountPlayer+=1,n.numberOfLeaders+=1,this.writeLeaderBoard(e,n)),o.score=a.toString(),s[e][r]=o;const d=h.vals(s[e]);return this.sortLeadersRank(d),d.forEach((i,c)=>{s[e][i.playerId]=i}),this.writePlayersData(e,s),t.success=!0,t}async createLeaderboard(e){if(await this.awaitRandomDelay(),this.randomResponseError("Create leaderboard error"))return null;const{_id:r}=e,a=this.getLeaderBoardsData();if(a[r])return a[r];let{numberOfLeaders:t}=e;return t=t??E.random(f.Max-f.Min)+f.Min,this.createPlayersData(e,t),this.createLeaderboardData(e,t)}createLeaderboardData(e,r){const{_id:a}=e,t={...D,...e,createdAt:new Date().toISOString(),createdBy:"mock",numberOfLeaders:r,amountPlayer:r};return this.writeLeaderBoard(a,t),t}createPlayersData(e,r){const{_id:a,name:t}=e,n=t==="friends-leaderboard-key",s={[a]:{}},o=[];for(let d=0;d<r;d++){const i=n?`connected-player-${d}`:d.toString(),c=this.createPlayerData(i);o.push(c)}return this.sortLeadersRank(o),o.forEach((d,i)=>{s[a][d.playerId]=d}),this.writePlayersData(a,s),s}createPlayerData(e){return{playerId:e,score:this.randomScore(),rank:0}}randomScore(){return Math.floor(Math.random()*(B-m)+m).toString()}getLeaderBoardsData(){const e=y.getLocalStorage(p);return u.isObject(e)?e:{}}writeLeaderBoardsData(e){u.isObject(e)&&y.writeLocalStorage(p,e)}getLeaderBoard(e){const r=this.getLeaderBoardsData();return r[e]?r[e]:null}writeLeaderBoard(e,r){const a=this.getLeaderBoardsData();a[e]=r,this.writeLeaderBoardsData(a)}getPlayersData(){const e=y.getLocalStorage(g);return u.isObject(e)?e:{}}writePlayersData(e,r){const a=this.getPlayersData();a[e]||(a[e]={}),h.assign(a[e],r[e]),y.writeLocalStorage(g,a)}randomResponseError(e){return Math.random()*100<S}async awaitRandomDelay(){await P.sleepAsync(Math.random()*M)}}w("default",O)}}});
